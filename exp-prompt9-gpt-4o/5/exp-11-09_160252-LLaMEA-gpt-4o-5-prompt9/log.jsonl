{"id": "1cf5eba6-e695-4d63-b51c-d6b151a780f2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that balances exploration and exploitation for diverse optimization landscapes.", "configspace": "", "generation": 0, "fitness": 0.23904448578252446, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6500069855246592, 0.6060337756938221, 0.6233421122426634, 0.6316107564698771, 0.6332708779587499, 0.6291001036841739, 0.6087737019400907, 0.6026774154914875, 0.611504735052484, 0.19673963529600902, 0.24648761893791504, 0.2064646457872178, 0.2594643301555617, 0.1441487166498877, 0.23245159371191426, 0.27245924396047105, 0.1960659019637494, 0.13807426991109517, 0.08067776169553598, 0.11277507920911578, 0.0799257568128855, 0.1275982007103328, 0.11594366172043757, 0.1017181712915044, 0.13335168000271136, 0.10622653554767603, 0.133401776735961, 0.1168548192788379, 0.09913208590624178, 0.09579313703470049, 0.120402625119987, 0.13350731769352764, 0.12217205906783746, 0.1079014909649435, 0.10962073019329688, 0.1304532230413079, 0.9713703826500297, 0.970818951273674, 0.9719118196957579, 0.9531701220568181, 0.9545636506011537, 0.9576084447839871, 0.9643098033187619, 0.9544584857797563, 0.9610071523001282, 0.3602286752624204, 0.34476444422409036, 0.277844188074026, 0.20511063935787033, 0.3325255104939663, 0.3381149721222316, 0.29375864245827654, 0.1773758134924932, 0.2860791712933475, 0.22914115946884117, 0.25693768485370694, 0.3239290071438262, 0.2583194578962379, 0.26213562492746556, 0.2442616833904775, 0.24525228757735107, 0.22738480506460323, 0.32111477387041243, 0.16220551411512185, 0.18452544645641022, 0.1965787478720421, 0.11587241984661889, 0.14166225993198545, 0.11853231121561025, 0.22314876758963742, 0.1430134518080074, 0.1468819084725148, 0.18321875708882784, 0.052508272136707834, 0.12089711101098677, 0.18380465276342406, 0.15817763588819378, 0.15725727714629778, 0.1495277261553567, 0.07652157547933369, 0.11147638918328617, 0.036851874213869595, 0.04172896403978288, 0.009386690223202598, 0.013921109042484336, 0.02061336496881594, 0.0400135779528038, 0.05837277519763029, 0.0375419872627657, 0.032055222444309805, 0.14499098405940236, 0.1401775203165283, 0.10556413305847978, 0.12233883654727484, 0.09693240499098643, 0.1258155934320735, 0.12501651463840024, 0.17214408105300194, 0.14433286660039668, 0.033749359134021883, 0.03860156587645358, 0.08051357915993818, 0.04315716895480359, 0.04874451090476306, 0.04736561724381083, 0.05773952656092474, 0.09135293693765945, 0.04445094220935675, 0.0831713689064465, 0.08935165533996847, 0.15326389349567493, 0.0587231569057578, 0.08308596865515805, 0.08692769432924452, 0.08870239866912033, 0.07799597163517247, 0.09005247356975865, 0.484350107070307, 0.4357495098226387, 0.43535902587306874, 0.4407932875830749, 0.4495354936360062, 0.43612172612508293, 0.46944610357909156, 0.4634275839579425, 0.46326899388959697, 0.08423400212078869, 0.09102282784845506, 0.07556588461815539, 0.08308609702987979, 0.09240583276685665, 0.11814856317935685, 0.13778826565565228, 0.10751928396132426, 0.10876825871825568, 0.1658276641208506, 0.1796664400750163, 0.16418205892551574, 0.2182707867594298, 0.23208770353482655, 0.18745822041211668, 0.1871354193975101, 0.21059265390548276, 0.1961411641633085, 0.3545466130004422, 0.24688738848291136, 0.3344762208643338, 0.22560239115268754, 0.3030177891204917, 0.3138783576622046, 0.2387310082322972, 0.363974262281639, 0.27940542364320764, 0.16499332117015908, 0.2469769545068805, 0.22336511351071542, 0.20944880977502023, 0.21803590449502153, 0.24981980097700518, 0.18772992714262915, 0.2747086491834235, 0.28911508968632393, 0.22305187946319616, 0.18491391410529778, 0.20399704082258485, 0.18065855270288322, 0.19859941809910386, 0.18698829616854018, 0.2024215444128743, 0.1946574491663441, 0.19798630895219937, 0.18901231342477598, 0.19955260580326661, 0.20042563977844996, 0.236851425345872, 0.26572047646415986, 0.20259014908570794, 0.1956986024927666, 0.1757916038316636, 0.21398960518768906, 0.765313261285564, 0.4002397478060643, 0.17674408474928882, 0.1960882799827779, 0.19762425178067466, 0.19568641505675854, 0.1740804759016954, 0.16683630137736705, 0.598631892699675, 0.5153926167902261, 0.20649070730004082, 0.15953917798097517, 0.20666752320641468, 0.21495859270096207, 0.17200617130548435, 0.19106492751772808, 0.5990254216436917, 0.4565791559361607, 0.1854299643569559, 0.19606682080091786, 0.1826262875408161, 0.20059463815158463, 0.17788172394260382, 0.1890076880313567, 0.1812945966385311, 0.1737644280251146, 0.17891451015737803, 0.08790276296742938, 0.08814387068245544, 0.07877313661376006, 0.07310981412894957, 0.09749349817917641, 0.05878566409621888, 0.08048733588820611, 0.07822408717482865, 0.08637788912210231]}, "mutation_prompt": null}
{"id": "ca604f4b-eb98-48c6-ac13-6eb69c25ef9a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that balances exploration and exploitation for diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1cf5eba6-e695-4d63-b51c-d6b151a780f2", "metadata": {"aucs": [0.6500069855246592, 0.6060337756938221, 0.6233421122426634, 0.6316107564698771, 0.6332708779587499, 0.6291001036841739, 0.6087737019400907, 0.6026774154914875, 0.611504735052484, 0.19673963529600902, 0.24648761893791504, 0.2064646457872178, 0.2594643301555617, 0.1441487166498877, 0.23245159371191426, 0.27245924396047105, 0.1960659019637494, 0.13807426991109517, 0.08067776169553598, 0.11277507920911578, 0.0799257568128855, 0.1275982007103328, 0.11594366172043757, 0.1017181712915044, 0.13335168000271136, 0.10622653554767603, 0.133401776735961, 0.1168548192788379, 0.09913208590624178, 0.09579313703470049, 0.120402625119987, 0.13350731769352764, 0.12217205906783746, 0.1079014909649435, 0.10962073019329688, 0.1304532230413079, 0.9713703826500297, 0.970818951273674, 0.9719118196957579, 0.9531701220568181, 0.9545636506011537, 0.9576084447839871, 0.9643098033187619, 0.9544584857797563, 0.9610071523001282, 0.3602286752624204, 0.34476444422409036, 0.277844188074026, 0.20511063935787033, 0.3325255104939663, 0.3381149721222316, 0.29375864245827654, 0.1773758134924932, 0.2860791712933475, 0.22914115946884117, 0.25693768485370694, 0.3239290071438262, 0.2583194578962379, 0.26213562492746556, 0.2442616833904775, 0.24525228757735107, 0.22738480506460323, 0.32111477387041243, 0.16220551411512185, 0.18452544645641022, 0.1965787478720421, 0.11587241984661889, 0.14166225993198545, 0.11853231121561025, 0.22314876758963742, 0.1430134518080074, 0.1468819084725148, 0.18321875708882784, 0.052508272136707834, 0.12089711101098677, 0.18380465276342406, 0.15817763588819378, 0.15725727714629778, 0.1495277261553567, 0.07652157547933369, 0.11147638918328617, 0.036851874213869595, 0.04172896403978288, 0.009386690223202598, 0.013921109042484336, 0.02061336496881594, 0.0400135779528038, 0.05837277519763029, 0.0375419872627657, 0.032055222444309805, 0.14499098405940236, 0.1401775203165283, 0.10556413305847978, 0.12233883654727484, 0.09693240499098643, 0.1258155934320735, 0.12501651463840024, 0.17214408105300194, 0.14433286660039668, 0.033749359134021883, 0.03860156587645358, 0.08051357915993818, 0.04315716895480359, 0.04874451090476306, 0.04736561724381083, 0.05773952656092474, 0.09135293693765945, 0.04445094220935675, 0.0831713689064465, 0.08935165533996847, 0.15326389349567493, 0.0587231569057578, 0.08308596865515805, 0.08692769432924452, 0.08870239866912033, 0.07799597163517247, 0.09005247356975865, 0.484350107070307, 0.4357495098226387, 0.43535902587306874, 0.4407932875830749, 0.4495354936360062, 0.43612172612508293, 0.46944610357909156, 0.4634275839579425, 0.46326899388959697, 0.08423400212078869, 0.09102282784845506, 0.07556588461815539, 0.08308609702987979, 0.09240583276685665, 0.11814856317935685, 0.13778826565565228, 0.10751928396132426, 0.10876825871825568, 0.1658276641208506, 0.1796664400750163, 0.16418205892551574, 0.2182707867594298, 0.23208770353482655, 0.18745822041211668, 0.1871354193975101, 0.21059265390548276, 0.1961411641633085, 0.3545466130004422, 0.24688738848291136, 0.3344762208643338, 0.22560239115268754, 0.3030177891204917, 0.3138783576622046, 0.2387310082322972, 0.363974262281639, 0.27940542364320764, 0.16499332117015908, 0.2469769545068805, 0.22336511351071542, 0.20944880977502023, 0.21803590449502153, 0.24981980097700518, 0.18772992714262915, 0.2747086491834235, 0.28911508968632393, 0.22305187946319616, 0.18491391410529778, 0.20399704082258485, 0.18065855270288322, 0.19859941809910386, 0.18698829616854018, 0.2024215444128743, 0.1946574491663441, 0.19798630895219937, 0.18901231342477598, 0.19955260580326661, 0.20042563977844996, 0.236851425345872, 0.26572047646415986, 0.20259014908570794, 0.1956986024927666, 0.1757916038316636, 0.21398960518768906, 0.765313261285564, 0.4002397478060643, 0.17674408474928882, 0.1960882799827779, 0.19762425178067466, 0.19568641505675854, 0.1740804759016954, 0.16683630137736705, 0.598631892699675, 0.5153926167902261, 0.20649070730004082, 0.15953917798097517, 0.20666752320641468, 0.21495859270096207, 0.17200617130548435, 0.19106492751772808, 0.5990254216436917, 0.4565791559361607, 0.1854299643569559, 0.19606682080091786, 0.1826262875408161, 0.20059463815158463, 0.17788172394260382, 0.1890076880313567, 0.1812945966385311, 0.1737644280251146, 0.17891451015737803, 0.08790276296742938, 0.08814387068245544, 0.07877313661376006, 0.07310981412894957, 0.09749349817917641, 0.05878566409621888, 0.08048733588820611, 0.07822408717482865, 0.08637788912210231]}, "mutation_prompt": null}
{"id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": 0.2574144852734073, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "1cf5eba6-e695-4d63-b51c-d6b151a780f2", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "41f6adc3-5ac2-4f31-ac79-189a377dc556", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02\n        self.levy_factor = 0.1  # Levy flight factor for exploration\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 0.1, self.dim)\n        v = np.random.normal(0, 1.0, self.dim)\n        step = u / np.abs(v)**(1/L)\n        return self.levy_factor * step\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n            self.mutation_factor = max(0.5, self.mutation_factor - self.adaptive_factor * 0.1)\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]) +\n                                  self.levy_flight())\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introducing a Levy flight mechanism and dynamic mutation factor adaptation to enhance exploration and convergence speed.", "configspace": "", "generation": 3, "fitness": 0.2337656493220657, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.5035038857763472, 0.5132615955031412, 0.5121719353229637, 0.5127796937000052, 0.5105207518916539, 0.5185223042433846, 0.493087767842748, 0.5165269756541597, 0.5005167146904754, 0.17046518552434686, 0.19914912204110646, 0.20598239440683963, 0.1934694234295289, 0.18864689586071837, 0.18366151541051146, 0.2045115983833664, 0.19604033573487845, 0.1831239157631639, 0.11306944883412129, 0.11520704463621823, 0.10521172073912133, 0.0880929130275796, 0.11003169655749112, 0.11950441873765572, 0.10367721931291507, 0.11107584832939355, 0.12279828756041389, 0.09256956445171016, 0.10209680974050694, 0.09246438764532705, 0.1298161308915322, 0.12051080936489111, 0.088173469522, 0.11869425949165602, 0.10617375596860001, 0.09778389558605816, 0.9633484913242792, 0.9705278100144547, 0.9759934286204144, 0.9545542623813484, 0.9619878968196551, 0.9850964907710937, 0.9622680325113864, 0.9686944189531064, 0.9545342935986962, 0.29145147486754597, 0.2923559269196411, 0.22831848192121407, 0.28317991175930635, 0.28212219102216296, 0.22874803011108358, 0.27249420431502436, 0.24696544657942876, 0.2659191033177848, 0.361497127164798, 0.33231774585868323, 0.2733371691459271, 0.31216858161541927, 0.29069888188658666, 0.29166255084232584, 0.3128471426041336, 0.2522728986325926, 0.3002132311671185, 0.19811622300701015, 0.1511450807800958, 0.14128856390143774, 0.136334596223195, 0.15000493116470937, 0.13192967393534416, 0.16252499279516575, 0.1277318682535784, 0.14747724261092698, 0.16290511309745703, 0.1478752080803215, 0.1522474017621147, 0.1442263505128072, 0.20574740814254833, 0.1704935626043742, 0.18654107148174448, 0.12473606235831303, 0.1417018589883997, 0.0646035456705707, 0.03791623685837697, 0.041058571988768944, 0.031270635326357654, 0.035323973578784695, 0.03389533482993867, 0.050497041425868305, 0.05286873238916978, 0.044662444472844065, 0.15176402530983035, 0.1519618391217893, 0.19809861533032747, 0.13820879020508914, 0.14368425855189615, 0.13150119327410925, 0.18824892854747666, 0.15265887937199607, 0.17607368683424374, 9.999999999998899e-05, 0.004950459935403662, 0.022865186116312164, 0.018914806415801788, 0.0021419805742151077, 0.014183046688850842, 0.014229329517717826, 0.010718452325977346, 0.00717899834175495, 0.13073086385625488, 0.08772880183986453, 0.12591638216574297, 0.1054560321319199, 0.10847710159958246, 0.12851782301182124, 0.09805028411109928, 0.13530722584155142, 0.10637376991005387, 0.43068069352869875, 0.44281249897899855, 0.42579024124788933, 0.4309027859465877, 0.4133304568816004, 0.42635209188704404, 0.4475416571641253, 0.42729848268835646, 0.4435695564467962, 0.10086606007199461, 0.08777842635724609, 0.1004407305078765, 0.12056915578200955, 0.10183373625234149, 0.0891024397837138, 0.08555732268527005, 0.1413815946544591, 0.09897592031739477, 0.18070291850050435, 0.14875874054399862, 0.1947802826870566, 0.24109355589075354, 0.27694640767225254, 0.22133335296955636, 0.34029392199628294, 0.1741448369006714, 0.19302483845911544, 0.25768946373029233, 0.2804612599759374, 0.31143197948773316, 0.24325166491121286, 0.22051075150223587, 0.2436367661179737, 0.29885870284525407, 0.3052320696731413, 0.31031267423544184, 0.20156973777227316, 0.20137830876532414, 0.20944651154609284, 0.21059320222035993, 0.18962531193455667, 0.23022918495280775, 0.23546475257030008, 0.25362299891057705, 0.2580990460581908, 0.17270460731353, 0.19413810141041354, 0.18943278888766613, 0.19315349746798482, 0.19781685615703226, 0.1939765237129918, 0.22022069225981822, 0.1887699303157736, 0.19070465717616547, 0.20307608531048238, 0.2324575901315039, 0.23378444795237907, 0.20885633728592334, 0.209276468284598, 0.19497241457683, 0.21130332209339286, 0.1941991467830788, 0.20095353224559476, 0.6286012574646156, 0.3138410256239621, 0.16487717198293428, 0.640349283115444, 0.19902279256977096, 0.20158367259391918, 0.1898743966285994, 0.18018030155390974, 0.3242894286094412, 0.5266544036678438, 0.20716276380943932, 0.2619227712711739, 0.3553486888853923, 0.22967872350666052, 0.1684629429477451, 0.20473069186965287, 0.26605954626368444, 0.3732261248943135, 0.19307955224275275, 0.18644896451648385, 0.19662624787521832, 0.19293506623382095, 0.1892936057664767, 0.18790521338218913, 0.17764578074596016, 0.18976320938907776, 0.17438668575927752, 0.0841299852430577, 0.08072339444870835, 0.08234373294527708, 0.08552731848818329, 0.08280039699828923, 0.07216750780342829, 0.08036512499136494, 0.07241006019595952, 0.06425492243205677]}, "mutation_prompt": null}
{"id": "ced0d1c6-b81b-4d75-8214-af0fc0260050", "solution": "import numpy as np\n\nclass HybridPSODE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = self.chaotic_init(self.swarm_size, dim)\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = self.chaotic_init(self.de_size, dim)\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.7  # Adjusted cognitive factor\n        self.c2 = 1.5\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02\n\n    def chaotic_init(self, size, dim):\n        chaotic_seq = np.random.rand(size) * 4  # Chaotic sequence scaling\n        return np.array([np.sin(chaotic_seq * (i + 1)) * 5 for i in range(dim)]).T\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n            if self.evaluations > self.budget * 0.5:  # Dynamic adjustment\n                self.inertia_weight = max(0.3, self.inertia_weight * 0.95)\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE_Chaotic", "description": "An adaptive HybridPSODE variant introducing chaotic initialization and dynamic inertia weights for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.22761052768619947, "feedback": "The algorithm HybridPSODE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.6136277615341308, 0.6133376913876936, 0.576538755968514, 0.6402437812359846, 0.6212540213990222, 0.6177469231114938, 0.5687123928283648, 0.6389703623084944, 0.5579374907325823, 0.2957274089830152, 0.28750644622942845, 0.13669591431130812, 0.2974248101294025, 0.2659067264051761, 0.27831608170881295, 0.33484182101811244, 0.13398236718476086, 0.28178167789565756, 0.0995560037870209, 0.11059041807618175, 0.1337008284188974, 0.13171551402593173, 0.09855221048807328, 0.14530688457112517, 0.09824142200179398, 0.1059625332207852, 0.1060587986348912, 0.11741872107837192, 0.09765859487013573, 0.10778663178892711, 0.09511006024866342, 0.10679553486600801, 0.1284791599806545, 0.09812091819413071, 0.08658421559823404, 0.09139420564341871, 0.9634952824770228, 0.962800409495208, 0.9539749563867056, 0.9726592539356174, 0.9840660723439707, 0.9812705359631849, 0.9685278505461639, 0.9604605824766729, 0.9708416718355328, 0.24341041999831836, 0.2787519687996588, 0.29955562556178816, 0.2763707248394558, 0.16624848742045195, 0.22041434120766412, 0.2779089613662832, 0.19551641598895508, 0.19062000642077526, 0.2380891995905211, 0.24014768191549685, 0.25842087060389574, 0.2538550225266668, 0.268583489925852, 0.24988120799926494, 0.23635284822092018, 0.24199455910479561, 0.2372421514433536, 0.1428876469191891, 0.13068668828849928, 0.18512597654519936, 0.15525134961298082, 0.12317185042604073, 0.11323928674168071, 0.1017660349779248, 0.12129225267612032, 0.1795685923684487, 0.13443583089862965, 0.24541589216128556, 0.1653547016540906, 0.13997167565495494, 0.18036033087719205, 0.19118729093088072, 0.11426625520060407, 0.1993826149257515, 0.17376303126883774, 0.018488420814649187, 0.035957043035938496, 0.016394539201807112, 0.008472347444665296, 0.012896396017224254, 0.009659765619275618, 0.046559899711660524, 0.008865086221422236, 0.05228768400995509, 0.10953120338724565, 0.1096404855896439, 0.1246177738491211, 0.11874060185226987, 0.12235113485964466, 0.10927871426524272, 0.13968450562242996, 0.14841553995917312, 0.1705170543294784, 0.09337112049943697, 0.020854065429077084, 0.025880483920053154, 0.04956486866580434, 0.0634947878235993, 0.06036747886244431, 0.06028887075879352, 0.0678847923890582, 0.061037708741474295, 0.05931768930407466, 0.0986844169513501, 0.06873943725663012, 0.12498910136626906, 0.18881937657308312, 0.07743171616169964, 0.08092428402616025, 0.07519036207007335, 0.09877667814448154, 0.3890370246624979, 0.41426908336958057, 0.4106940075923853, 0.4030792741601177, 0.4298696644685037, 0.4468830941058304, 0.43166705197729005, 0.42248465205329844, 0.44768110897903646, 0.0846138459558522, 0.07287719270485937, 0.11582458344183688, 0.0952261527048095, 0.08004272736721685, 0.10959819881335808, 0.09171062466988933, 0.09512458067781004, 0.10395694971099823, 0.17158342323855902, 0.16341131129721376, 0.14344402631017616, 0.32181365076994795, 0.13817885014927578, 0.16321688582570004, 0.15356294991850294, 0.2478823619843885, 0.1628826404755116, 0.2260439756655257, 0.2485755432289357, 0.22393067015225032, 0.26325092647198034, 0.30356610718583266, 0.2676181273022713, 0.3359841508218655, 0.3375786884926989, 0.35624825691698625, 0.22576077295479813, 0.14995700737407747, 0.2183001090796186, 0.20328631718425016, 0.1937316600444795, 0.2202895298647678, 0.16206086794043517, 0.20863198844020048, 0.21510318017805607, 0.18894881766223426, 0.2363860916377194, 0.23101668031368117, 0.1751616364909152, 0.23640264497329666, 0.2237728072068299, 0.23059559027461551, 0.202996971450624, 0.21834156208962718, 0.17383057381245748, 0.19259185605044582, 0.2651295507759447, 0.18958843938925451, 0.18633517106542563, 0.19750861137962505, 0.1977740419897417, 0.19506870597447756, 0.1888785791556694, 0.2680076865975256, 0.24531688136407925, 0.1582592948543533, 0.2501794051739903, 0.17189940439645202, 0.17691910356544926, 0.23466864531744458, 0.15516427663573107, 0.250185949149177, 0.21685490246225803, 0.154956342091212, 0.2323694900529425, 0.1842691801585975, 0.15666821417855736, 0.19519100188044713, 0.2988128323929733, 0.4826175283042038, 0.20848146784217148, 0.18114749109529316, 0.18416773074236126, 0.17181643627210763, 0.18725033222516485, 0.17062079308357714, 0.20335793252880907, 0.1881124005737429, 0.19496649775631247, 0.20953479555120513, 0.0736132434568002, 0.07313895959100192, 0.07240571315076738, 0.06642066593945906, 0.07865325989057781, 0.07328785811649463, 0.08057535226804069, 0.08937356843954936, 0.077598789622076]}, "mutation_prompt": null}
{"id": "bf17e763-2b06-41ad-823b-2e443ff98f8c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "bc8222de-6841-408f-8b65-ef9978fd3505", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "dd5df49a-ba84-4b3f-9f7b-e75e4c44f92e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "457b74b1-8318-4bb1-b05d-e969670d8b6a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "b9554485-a5cf-43d0-b8a7-145bbd523458", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "1faa813f-bd38-4c38-a211-ea854afd8c38", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50\n        self.de_size = 50\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # New adaptive factor for parameter tuning\n\n    def adapt_parameters(self):\n        # Slightly adjust parameters over time for better adaptation\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters over iterations\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "An enhanced HybridPSODE algorithm utilizing adaptive parameters to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.721952649240603, 0.6805553159496056, 0.6878227422648076, 0.7122328262032873, 0.6868170066386847, 0.6936256679008916, 0.6899267501345479, 0.681366631322041, 0.6917465754580443, 0.3612818665612971, 0.3801130013805528, 0.41272243105058193, 0.42970651980180996, 0.14651806882732377, 0.41001031948689526, 0.14493511821380722, 0.41544147102214235, 0.19345926481907583, 0.11620777237836277, 0.13452121402591344, 0.1602064839940922, 0.14722019210493165, 0.11626025394250061, 0.1274979749661077, 0.10208530930140136, 0.1111770811042716, 0.1644912125347009, 0.118888138885206, 0.10724496199858624, 0.12453514811279598, 0.14486750050886, 0.10691443703029524, 0.11602495518151468, 0.12123078227824113, 0.09406812994786107, 0.1188985441485716, 0.9716486211819898, 0.9708623658553622, 0.9719018582950407, 0.9529572856540549, 0.9545867364381911, 0.9575968565704095, 0.9689594994567303, 0.9544956558867856, 0.9634956708854538, 0.31531807873860496, 0.1664245825992342, 0.36773327503873854, 0.28673874330886906, 0.30768684740587904, 0.37052121132543614, 0.11742785725818017, 0.17770550860371803, 0.31467964599529874, 0.22181760561959052, 0.25115618376728166, 0.23083352750562258, 0.25465310328080093, 0.2326333139343849, 0.7007536541777617, 0.25933648139020193, 0.22865874885914295, 0.25232171845216156, 0.15813141214627646, 0.14481745241455046, 0.16111502719507498, 0.16170047637770624, 0.1530771745522166, 0.137653318172676, 0.25097601149693305, 0.1464269267758147, 0.309780702829736, 0.17487821705317563, 0.09574754086186965, 0.20510845962317426, 0.14622633702352572, 0.17035253508572712, 0.13111754714712065, 0.1705174968858959, 0.12026766474522099, 0.16352715500913217, 0.022575275257267102, 0.04172896403978288, 0.009386690223202598, 0.013917883028367939, 0.02061336496881594, 0.0400135779528038, 0.028806711312457267, 0.0375419872627657, 0.02372337244766043, 0.11760985365708077, 0.1393735915119294, 0.10516129654545803, 0.1521035780197637, 0.09689099849591909, 0.12670495343578603, 0.13141244451289225, 0.17380696458157252, 0.14535386839285114, 0.21531984357458167, 0.002553382159924511, 0.05409150956554243, 0.05978431235716175, 0.06561660766119126, 0.0577317014562454, 0.07591665907672884, 0.13579485438101146, 0.05313955265050185, 0.12464978375944957, 0.11732581674403608, 0.07312617915711761, 0.07449259070274328, 0.12307247364014362, 0.09656666718647067, 0.09030645831409234, 0.10058347018179992, 0.09213863084464813, 0.4447614010508014, 0.4998821454735949, 0.4598474684952194, 0.45668312360934993, 0.4471665615860605, 0.4783158012834804, 0.47758452817074526, 0.4185819697169342, 0.4667989986764485, 0.07617803587504457, 0.14164076285495342, 0.07306623819871072, 0.1308851329398769, 0.13386066323963464, 0.10853477606386952, 0.14489816008810963, 0.12564776749177786, 0.12749950456392345, 0.2081628075372921, 0.263292369874253, 0.173238908525417, 0.23949583016071396, 0.3406994791639655, 0.2565866893461334, 0.3086947125158275, 0.1693374004760675, 0.2040735864216584, 0.28025357833215414, 0.3829628752553612, 0.35430241378053207, 0.23706085526341092, 0.2662375579394676, 0.3255966050876411, 0.30602974399021177, 0.30253869263906097, 0.24606085325589733, 0.1692375282698888, 0.21155984629343727, 0.3486673251654675, 0.1803472607781863, 0.16749482981082164, 0.18953263900081974, 0.26393661379727595, 0.19198048996316552, 0.2798121908190079, 0.2000529070685153, 0.17334048636360744, 0.19653374579291694, 0.2057058976096281, 0.18729996239940205, 0.19497677186611806, 0.19756207701078154, 0.18403554345677664, 0.18757343210266686, 0.19064090647567156, 0.37016808167783577, 0.21477682066196724, 0.3092413230088118, 0.19385346992692454, 0.2253228759720307, 0.18623890717109914, 0.19418560690055653, 0.1832528889756312, 0.7541476362585686, 0.3997723285918351, 0.17993540480701398, 0.6844978949820533, 0.19618759577316025, 0.19622618284340343, 0.1751232759673398, 0.16689169818707472, 0.7332737456454839, 0.433981790703277, 0.20586830304890913, 0.15953917798097517, 0.4725759685391052, 0.2148873019419869, 0.17741548032954702, 0.1927646138468675, 0.2756455966069241, 0.5346125267051218, 0.19272898723729626, 0.1798889573387643, 0.18709908759494298, 0.1962448452734349, 0.1768251279620081, 0.1826519376273995, 0.1729409368721304, 0.18455836808448312, 0.1962626231040625, 0.07938839029628542, 0.08568201286154742, 0.0874215517211363, 0.08444702747015909, 0.09402474140034067, 0.09034543305408638, 0.08550744745697736, 0.0722636914839091, 0.09027642151503046]}, "mutation_prompt": null}
{"id": "e02fcde6-c961-4a1e-8aea-d697354ac6f8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(50, max(10, int(0.1 * dim)))  # Dynamic swarm size\n        self.de_size = min(50, max(10, int(0.1 * dim)))     # Dynamic DE population size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "A slightly enhanced HybridPSODE algorithm with dynamic swarm and population sizes for improved convergence speed.", "configspace": "", "generation": 11, "fitness": 0.3211613444413185, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "5ac04a1c-4425-4d8f-ae50-d7e2f07cc8ff", "metadata": {"aucs": [0.9087052365136331, 0.9103793967888646, 0.926925709031133, 0.8570911864604025, 0.8403920231665977, 0.8589627863173779, 0.9261304031507478, 0.8980397137174683, 0.9235360343267278, 0.7883845939950347, 0.7740117547712877, 0.7654504271207287, 0.8103013957289685, 0.7875958737620448, 0.7695617126539582, 0.7777644964219799, 0.8321410195373189, 0.8235649661167449, 0.15457652658198262, 0.12062961412360929, 0.16834413762799527, 0.1411039240634434, 0.10865979264938941, 0.14108684780751368, 0.177771491299337, 0.5489772680930525, 0.18542928238598277, 0.11524615533667548, 0.16154216008256628, 0.16626757327499853, 0.11932325352878503, 0.13047185138900697, 0.09665168501413612, 0.09587376082001031, 0.124010012480813, 0.09438205274240097, 0.9907497456653358, 0.9849278259127775, 0.9905115088025394, 0.9847907509643491, 0.9886880585771338, 0.9829536574380595, 0.9796895570014237, 0.9901550843322482, 0.979887062027867, 0.680205263007617, 0.06136947596073228, 0.6752342359057153, 0.48206431662494653, 0.1521588892940079, 0.665083594345464, 0.517192628037242, 0.08616236274471756, 0.6209672011237033, 0.2508537298345672, 0.29898777841474133, 0.7716635277205305, 0.8495445618676416, 0.19484523719673608, 0.19120428417179314, 0.23950993112079555, 0.23130231473163188, 0.21771590267742913, 0.34729148675574384, 0.5634451799147568, 0.16860183109907412, 0.1297340846245092, 9.999999999998899e-05, 0.4111262823369334, 0.20445492053443903, 0.16704390141992187, 0.6260866614719374, 0.22530432633188102, 0.32383152238447144, 0.17867092289255537, 0.18013085828545794, 0.157508893670659, 0.18678225036814733, 0.18757918340205515, 0.03453377388750123, 0.18706681906286182, 9.999999999998899e-05, 0.10734752772975698, 0.03658508613884426, 0.044793738698727936, 0.06956067803661903, 0.024116093941431216, 0.09532129404841505, 0.01719171860985247, 0.04370665800476947, 0.05928456806875182, 0.03818048290019982, 0.09890058363535614, 0.05786753182074067, 0.045336402209903315, 0.10515172818533536, 0.13448999720571497, 0.05066792253786223, 0.22257794185134272, 0.3189517231143719, 0.21898113007112807, 0.07026867374774648, 0.09380112010455355, 0.12634709923443244, 0.18012227294318706, 0.16212014114907958, 0.10254679711279313, 0.1290896699535713, 0.27794939157330856, 0.2721092301736867, 0.27499190140393115, 0.03850541047582534, 0.32935295287893573, 0.03779850487780745, 0.16673621418908802, 0.08382532322982772, 0.20104263156821567, 0.655999390784678, 0.5357125357893011, 0.5372445312605281, 0.5485442016371209, 0.20939098953237456, 0.5283526769193305, 0.586556961439517, 0.6925635242952, 0.6142583744602219, 0.11635921987564546, 0.06187239818817669, 0.09815809282204024, 0.1410983043608971, 0.13746756950173988, 0.11740242720878868, 0.06628354457429109, 0.12172065630991658, 0.14342063696158602, 0.22315234747770996, 0.26377014202020754, 0.21668641691049828, 0.3849126310738914, 0.16358214638431923, 0.23014926646971012, 0.240460356517742, 0.17825838911105807, 0.23198460047119696, 0.4163934582363319, 0.3273855039061181, 0.47465558781169215, 0.3630207489593783, 0.20780941606911196, 0.543183023973059, 0.2767518827731513, 0.47675227279547194, 0.45452355622117635, 0.21673255320631024, 0.32439305007175967, 0.26288897252193966, 0.2979942210291321, 0.34523923508957377, 0.32286955903698733, 0.22855194979230264, 0.20167860570451235, 0.25092692988884213, 0.242084050227532, 0.18850578694977616, 0.20973491669638367, 0.21609592186639726, 0.17756875741189848, 0.225044963649344, 0.23619503224555338, 0.20389532507598118, 0.22218226642798677, 0.21017244273697966, 0.21532557627039628, 0.2522371956856686, 0.20575675089048295, 0.2211424497530563, 0.2185469435175028, 0.22073739839532525, 0.22175896669663353, 0.22807236947776033, 0.18816730801665738, 0.9025496632503206, 0.911016408149673, 0.1727370573167225, 0.20104069956330617, 0.16762023233652856, 0.12884787996514968, 0.19839407349156468, 0.17191786516649699, 0.4383277530619908, 0.11280799150984677, 0.7536344491056153, 0.41167877956109045, 0.27346655144985954, 0.2092834133146665, 0.15323895065152193, 0.15698219138973823, 0.5250175008495238, 0.19226284408856276, 0.19565089933173263, 0.20108075564077288, 0.18527927584970538, 0.18759706937964427, 0.18115595141858887, 0.1860990959355634, 0.2138203570489725, 0.2079995013965149, 0.07018897844348282, 0.07936131455280648, 0.08336357552743501, 0.12246540028279229, 0.11875795383740984, 0.08935983666920078, 0.1473634574146543, 0.08612079732733002, 0.09130694935767336]}, "mutation_prompt": null}
{"id": "8f8f3f73-da7e-4814-a5bb-9a0d45568f08", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(50, max(10, int(0.1 * dim)))  # Dynamic swarm size\n        self.de_size = min(50, max(10, int(0.1 * dim)))     # Dynamic DE population size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.02\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.0, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.0, self.c2 * (1 + self.adaptive_factor))\n            self.mutation_factor = self.mutation_factor * (1.0 + 0.5 * self.adaptive_factor)\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "Introduced dynamic adaptation of mutation factor and inertia weight based on convergence progress for improved optimization convergence speed.", "configspace": "", "generation": 12, "fitness": 0.2593049146376777, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "e02fcde6-c961-4a1e-8aea-d697354ac6f8", "metadata": {"aucs": [0.9087048275600302, 0.9103793967888646, 0.926925709031133, 0.44093313706867143, 0.2939966500183365, 0.36995359204424316, 0.9261299711668128, 0.8982333625237383, 0.9235360343267278, 0.7873088719444129, 0.0421823897410728, 0.059197519543167765, 0.8038757749501032, 0.7875958737620448, 0.6562691752742928, 0.06263510206359535, 0.8321410195373189, 0.8235649661167449, 0.14364987127676287, 0.10769378828005138, 0.15727308051119904, 0.14087237956815113, 0.09043283581701511, 0.11545067947773602, 0.15756574264552292, 0.07463411512274487, 0.18542928238598277, 0.11047061596806595, 0.16028787582803816, 0.12903085973166617, 0.08422974210586487, 0.05100142830329457, 0.11353952222473451, 0.09587376082001031, 0.1129575906081205, 0.1356128344126558, 0.9907497323946067, 0.984933972212129, 0.9905115088025394, 0.9847907091271693, 0.9887093395334094, 0.9829536574380595, 0.9825186473118207, 0.9901550843322482, 0.979887062027867, 0.1494091991188332, 0.059872217318858056, 0.6752342359057153, 0.3762770621574828, 0.1521588892940079, 0.15321750144693091, 0.173010813405567, 0.08590352750941443, 0.1424518882560164, 0.26553086454323915, 0.196148591618027, 0.2268623023084012, 0.29277981968433153, 0.19928093048616724, 0.19152372193189215, 0.23831948382568424, 0.21038527652952077, 0.22562819522247923, 0.19998485005369426, 0.17570758946482656, 0.1670007953617887, 0.11396263365859394, 9.999999999998899e-05, 0.1341541042327986, 0.19248299773381872, 0.16704390141992187, 0.1858064322618168, 0.22530432633188102, 0.08299939061961703, 0.13466448998718894, 0.15481732786605495, 0.1319207591097442, 0.16489503792222238, 0.17295318595798548, 0.11200354983719629, 0.13676407169315552, 9.999999999998899e-05, 0.005305589352055939, 0.03658508613884426, 9.999999999998899e-05, 0.07757272237593715, 0.024116093941431216, 9.999999999998899e-05, 9.999999999998899e-05, 0.04368865160285329, 0.12711480723336532, 0.035351403511741264, 0.10841491852131513, 0.05423748966239217, 0.07731292066017814, 0.08225778536201711, 0.13371690770144773, 0.07893018741327373, 0.11292835317951755, 0.3189517231143719, 9.999999999998899e-05, 0.05156650344183711, 0.08331702678896724, 0.09180495015180601, 0.12665855000026327, 0.07612761173332305, 0.10254679711279313, 0.07535548304042461, 0.03320040179846839, 0.045291153032011255, 0.08500176144558969, 0.1082159137422195, 0.012590141676187105, 0.03779850487780745, 0.08254241320802524, 0.08382532322982772, 0.08476872476581543, 0.5332803046915521, 0.5357125357893011, 0.5331639749641714, 0.355043329186544, 0.3722428678634153, 0.48648510861827843, 0.540835781203852, 0.5139196636098371, 0.5358226585712709, 0.08170018536696644, 0.061820451269559595, 0.08561125552300641, 0.14113406470388123, 0.10116285119793644, 0.11740242720878868, 0.0918472827439406, 0.12152571910649823, 0.11594928468302135, 0.22221546913330403, 0.26378512149033784, 0.21668641691049828, 0.3849126310738914, 0.23533985392285395, 0.21108806057807628, 0.24027959916289976, 0.16544395673352008, 0.23198460047119696, 0.2062981558543836, 0.2601700791500994, 0.3823707241021942, 0.24870574063990158, 0.21068394810561264, 0.31531536999303156, 0.2526120875619654, 0.22771117001760854, 0.2409718231464768, 0.18825973002613283, 0.32446198716607677, 0.18948115925924192, 0.2979942210291321, 0.20070186291265446, 0.24157201950053175, 0.19571010693870028, 0.18121349027639944, 0.1560838574335478, 0.24249454275878046, 0.18888338900278756, 0.20701305930887826, 0.21609592186639726, 0.1420027376203763, 0.2251011238037478, 0.23612774848953588, 0.20393094780494447, 0.22218226642798677, 0.20910518338463335, 0.20044686660913158, 0.25189145991973594, 0.18168213594035698, 0.19088564667291708, 0.19213780222150778, 0.20373092808344928, 0.18336843777714074, 0.2126300974137585, 0.1958185582762101, 0.9023418480512762, 0.9109862629995946, 0.17271873782262614, 0.20104069956330617, 0.1651273818570106, 0.15300863651087748, 0.1957953463286577, 0.17364384674384414, 0.4374816035487059, 0.26081833862965575, 0.7536344491056153, 0.41167877956109045, 0.2733201962743642, 0.20850011944241276, 0.14570116114089104, 0.1569906945881172, 0.5237399930044387, 0.1835842286715509, 0.2010127090051863, 0.198143389744317, 0.1855986928143556, 0.1887937939025185, 0.17430574037050706, 0.19177759755465418, 0.21524758312942482, 0.2081180899814613, 0.06700718640878311, 0.057986143615865515, 0.08172655479049773, 0.12246540028279229, 0.11865524483444645, 0.08876989717853945, 0.1469430046719299, 0.06071446235727196, 0.09130694935767336]}, "mutation_prompt": null}
{"id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))  # Slightly increased dynamic swarm size\n        self.de_size = self.swarm_size  # Keeping DE size equal to swarm size for balance\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))  # Reduced initial velocity range\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  # Slightly adjusted cognitive component\n        self.c2 = 1.4  # Slightly adjusted social component\n        self.inertia_weight = 0.6  # Decreased initial inertia weight\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_probability = 0.85  # Slightly reduced crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.025  # Increased adaptive factor for faster adaptation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))  # Allow more aggressive exploration\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced swarm dynamics and adaptive parameter tuning to improve convergence speed.", "configspace": "", "generation": 13, "fitness": 0.3556100443882054, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "e02fcde6-c961-4a1e-8aea-d697354ac6f8", "metadata": {"aucs": [0.874091168323061, 0.8118298892985372, 0.8887931835474435, 0.891725103145723, 0.8290208667858076, 0.899904649385632, 0.907093607773934, 0.8721862422489721, 0.8862039534298759, 0.6617594373711467, 0.6987551966162856, 0.7492228841618169, 0.6838693511091348, 0.6665472983159035, 9.999999999998899e-05, 0.7925930894552156, 0.7210923334281609, 0.6853249993399928, 0.3809190102149681, 0.17073007063135115, 0.1277969659906001, 0.1612700862881491, 0.1321853019463629, 0.1527967312078481, 0.1198280045205492, 0.13729548017700655, 0.151192876486816, 0.22769684382467037, 0.16940328025453277, 0.13018387090858563, 0.13030971299500738, 0.13524695637835193, 0.1487444933915678, 0.11154246056319628, 0.15519885039097647, 0.1624849684469053, 0.988329441251037, 0.9773166238685124, 0.9871715936001026, 0.9935326942002457, 0.982364870633989, 0.984640141065334, 0.9739015852386521, 0.9860898409254094, 0.9865429207533563, 0.5576980236783928, 0.48997991627059145, 0.5297530914954633, 0.5595662918583988, 0.15239191317829337, 0.5610721772253748, 0.08891784765493682, 0.6202632754913482, 0.5845623682726189, 0.6263837787371094, 0.7764494858214281, 0.7465617887408613, 0.7970899267775711, 0.15842573193745835, 0.7082462388986972, 0.6674003696824783, 0.7289314443311867, 0.19961767929206342, 0.44523324264571296, 0.5793257403009082, 0.3990041336387724, 0.27166700824736423, 0.25217715230345306, 0.3979452041926498, 0.3436417644905815, 0.2750964126526494, 0.49405498611137044, 0.14577206720627822, 0.36451132702037314, 0.3399790626656122, 0.25779017696658835, 0.3250651046592482, 0.40609753395719694, 0.2548569895783498, 0.3139337981944713, 0.5039235046862085, 9.999999999998899e-05, 0.1162461429653997, 0.14656830366526408, 0.026324071685547623, 0.06321981637058494, 0.11599158719386815, 0.16004840568604395, 0.20903369775640346, 0.13116141697284822, 0.058072517272613866, 0.13818193958723946, 0.30529110460347497, 0.14551749714537165, 0.3238167335855775, 0.10673439527053774, 0.0909668154428167, 0.09631939788662436, 0.17400721017065568, 0.336794803093342, 0.06994432798806938, 0.10524630967143489, 0.15889254650750995, 0.09380106355614992, 0.19073790291806902, 0.14145307884507197, 0.5117395058356646, 0.12609581833671568, 0.26646777424679724, 0.2177796960905778, 0.2564276977089065, 0.31208841406726373, 0.2965400534035504, 0.28261192715574657, 0.1781644778053948, 0.19770159675171028, 0.2668386415662848, 0.6774553432950192, 0.6344128277410163, 0.6350984448931887, 0.6290497320131965, 0.6968562116629757, 0.5217730728047547, 0.6548966164801069, 0.5533613894195446, 0.7287670024055094, 0.06398884915233816, 0.09294242348354487, 0.11715370536976644, 0.16115355735599457, 0.11747718828196974, 0.1577950402911643, 0.0866069826310355, 0.10739984347459541, 0.09180634060965476, 0.22581925804994873, 0.2032914017672589, 0.16100204033690502, 0.2604454326441551, 0.32101521230098373, 0.33609402320246784, 0.2480076334576755, 0.17010500915415827, 0.22468092370613535, 0.35244643496045736, 0.25819677528678886, 0.2924328734686732, 0.4176896342627927, 0.3178725280515253, 0.4549060709633902, 0.44280700409072693, 0.4057061757061561, 0.43799662057533517, 0.31731503060114696, 0.2606810230521359, 0.3098254278676902, 0.3542899159737771, 0.34205532490206947, 0.35059683734173785, 0.3005199211995522, 0.2935901485468193, 0.28355096268058355, 0.18760105821105644, 0.20789766555342937, 0.18475608824034018, 0.19534857021566365, 0.1877197893267557, 0.24831034648676542, 0.23866499938849806, 0.20283466796167948, 0.18323028187251855, 0.4830745097189858, 0.2222723478208689, 0.4505441441264887, 0.20230945253056198, 0.24451146720135808, 0.2328516517528214, 0.23324119101311147, 0.22302755724728196, 0.19632343655614248, 0.8791924754920558, 0.2045486365185073, 0.8799081266004204, 0.1708662508935953, 0.786020558120854, 0.8483738712187625, 0.1825178795045821, 0.17064594579371117, 0.8272524194173889, 0.16583751722149354, 0.21038522400369397, 0.16834140281523324, 0.5815952068012952, 0.20848314229960518, 0.20863171190268504, 0.21790865814277072, 0.1978876094738774, 0.33933990888867416, 0.21560566290652305, 0.18113771413272828, 0.24483978136852624, 0.19368532255505366, 0.19717453762104364, 0.19728440480289233, 0.20415723809805286, 0.19754118268398035, 0.1875247129156965, 0.07852619192488652, 0.07764203958886429, 0.0796267514259198, 0.07798398094394399, 0.07902900859310735, 0.08885334496395403, 0.07567660887947092, 0.09062014169132293, 0.07652879934451973]}, "mutation_prompt": null}
{"id": "b103a5b2-c059-40c5-9f41-b25647c1f987", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.velocity_scale = 0.9  # New velocity scaling factor\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.velocity_scale = max(0.5, self.velocity_scale * (1 - 0.01))  # Decrease scale slightly over time\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i])) * self.velocity_scale\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Integrating adaptive velocity scaling in PSO to enhance convergence speed while maintaining a balance with DE.", "configspace": "", "generation": 14, "fitness": 0.3469934810158198, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.8564138147960143, 0.8095025567331535, 0.8690234781470129, 0.8617247273819765, 0.8292308925532128, 0.8975650845970493, 0.8801830554469768, 0.8765173250981975, 0.843173941694089, 0.6617594373711467, 0.6973984447535289, 0.745554377295327, 0.6822706729587962, 0.6648016077502852, 9.999999999998899e-05, 0.6851103292006406, 0.7039385752145223, 0.6877544790428507, 0.37106800101981086, 0.2904484597348168, 0.07078049508933304, 0.11819893572860396, 0.06286959267798975, 0.1475105093534519, 0.11298397114640668, 0.13221204156923783, 0.15093298226877105, 0.20025413963090277, 0.16025696682382728, 0.13065655731671943, 0.11636187489815308, 0.13522092828766508, 0.14692994208649746, 0.11655630965790664, 0.14970081278231495, 0.15337100208751653, 0.9791285723160847, 0.9529430771778024, 0.9823914910404296, 0.9935246222518412, 0.9232248294942508, 0.9798683719081985, 0.9688205579435345, 0.9412595512625954, 0.9847182225617134, 0.5592872797146156, 0.4900797120018955, 0.5297660708181258, 0.5638210019177948, 0.14847144447597804, 0.5655940796899687, 0.11407023027981145, 0.6202566814368118, 0.5788482913959279, 0.631639333171232, 0.7767694806728913, 0.752884254890006, 0.7965592842818201, 0.1584300014318396, 0.7097480289046946, 0.668328612978667, 0.7244221235078491, 0.16189052592148223, 0.38894566621911975, 0.5833029289540796, 0.39333265522062366, 0.2830457025303228, 0.2561013155473464, 0.4006391565663776, 0.36183530730278024, 0.27931764430186334, 0.47787597574006446, 0.15204366572027717, 0.3640815615510098, 0.36539032211187306, 0.2532212550151026, 0.31049775148559144, 0.4085204427265735, 0.15824347863792176, 0.3139337981944713, 0.5021856959915864, 9.999999999998899e-05, 0.1162461429653997, 0.14656830366526408, 0.026324071685547623, 0.06321981637058494, 0.11599158719386815, 0.16004840568604395, 0.20903369775640346, 0.13116141697284822, 0.07865655007644168, 0.14209652624680402, 0.30534040258873363, 0.14692157924812876, 0.3238205464548153, 0.10630568114310246, 0.13262596148799788, 0.09636039087862336, 0.16069872961927578, 0.3276205356617332, 0.06430446640736864, 0.08799985163557489, 0.1372076358856521, 0.15449271367172424, 0.17847988857003327, 0.127485605512483, 0.07490182929247235, 0.12977651885717878, 0.2700089762923402, 0.20790359472296593, 0.25731010265973386, 0.31322155686595177, 0.3537686225657217, 0.28312741664272145, 0.2021846153702549, 0.19327505209216855, 0.26711446387389115, 0.6626418061882466, 0.636398375773565, 0.6548646016468995, 0.6210132786717147, 0.6973037602020563, 0.5389478043649564, 0.649001393541642, 0.5610584939621173, 0.7296561857886404, 0.07286263008043403, 0.10533017462792227, 0.12473692059405461, 0.09701585366775345, 0.10906077930000524, 0.12153751434957116, 0.0919112596015661, 0.1112932515444407, 0.0934121345154052, 0.22233129871730029, 0.20223375804169652, 0.40940715906135927, 0.23318727051677968, 0.2225360116547791, 0.1649257455512152, 0.15535257660935253, 0.1797659273585407, 0.15038111381723607, 0.32643560120765547, 0.3206696886617263, 0.2871162194592569, 0.43334246829485035, 0.31810206194150636, 0.4566176992253569, 0.4331809241466612, 0.4029249750248246, 0.43791823537187435, 0.3104241835556856, 0.27703302439630706, 0.2799043833606887, 0.36213184839381085, 0.34189166592004694, 0.2605340062202245, 0.29431219506615147, 0.27012823267455377, 0.2835895371170668, 0.22105165378202263, 0.2295228757788026, 0.20086409068841105, 0.1962785181527963, 0.1877110730849243, 0.1839425681631226, 0.2050996463669097, 0.20222867415386736, 0.2069693417737456, 0.4703756487580234, 0.2207958970487477, 0.4541452866844965, 0.1885111940752503, 0.19979328016259557, 0.2225192317404181, 0.20892146887847718, 0.1906938029398395, 0.17694168877674432, 0.8320158708862666, 0.2045486365185073, 0.8800212189822816, 0.25674994281302366, 0.20204160423452067, 0.8942746075988961, 0.18295841688037173, 0.17064806137706656, 0.8267825576648393, 0.2623653992256676, 0.2208767500064518, 0.3514435054107282, 0.5985105596243554, 0.2311521226257769, 0.212426923328506, 0.21805666930200407, 0.1969168666733535, 0.18780841554253702, 0.18824383001939304, 0.20273161590608157, 0.19566789516754934, 0.17025247457899517, 0.2053473143505229, 0.18494654767139507, 0.1827072097142104, 0.1803397746861437, 0.18243953676364522, 0.07465574257139163, 0.08414501133204377, 0.07496363845177345, 0.07998565416749648, 0.10678415860637502, 0.09829263286549395, 0.12938699253817143, 0.08078633334691243, 0.09922780110823792]}, "mutation_prompt": null}
{"id": "235b57a4-a601-4a2b-9951-42e37b0d4c2a", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))  \n        self.de_size = self.swarm_size  \n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))  \n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  \n        self.c2 = 1.4  \n        self.inertia_weight = 0.6  \n        self.mutation_factor = 0.85  \n        self.crossover_probability = 0.85  \n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.perturbation_strength = 0.1  # New perturbation strength for local search\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.perturbation_strength = max(0.01, self.perturbation_strength * (1 - self.adaptive_factor))  # Adapt perturbation\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n            # Local search with perturbation\n            perturbation = np.random.normal(scale=self.perturbation_strength, size=self.dim)\n            candidate = np.clip(self.particles[i] + perturbation, -5, 5)\n            candidate_score = func(candidate)\n            self.evaluations += 1\n            if candidate_score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = candidate_score\n                self.personal_best_positions[i] = candidate\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Hybrid optimization with enhanced local search using Voronoi perturbation and adaptive diversity maintenance.", "configspace": "", "generation": 15, "fitness": 0.31042892049511295, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.8447204278012033, 0.8282552094387852, 0.8049842090997588, 0.8638072703231416, 0.8183809581210021, 0.8114688630481438, 0.8495097287545114, 0.818594821735531, 0.8151899115707838, 0.6774090913073659, 0.5296965450648481, 0.5880828253373586, 0.6559690231011734, 0.5797965610149041, 0.5511160374206638, 0.6302812745613053, 0.6467310840065192, 0.6521132359715851, 0.11480232853495997, 0.1619836744457842, 0.14121624388927978, 0.1555251075406201, 0.2698858540123952, 0.13613642610360044, 0.14543447085921302, 0.1369309460402066, 0.12559643931839837, 0.13154137657134002, 0.13278402835209668, 0.10056411037006185, 0.1216297984149336, 0.1267739275027161, 0.11486002446998356, 0.1146192858838786, 0.08344420472168146, 0.1946200049519088, 0.9809892318232822, 0.9541378097932346, 0.9788839240507644, 0.9863843102239495, 0.9651217616087882, 0.9775840722410313, 0.9374447606368402, 0.9786108219317186, 0.9539833837065766, 0.39512570197749586, 0.3356741855185146, 0.44125820459954834, 0.4645957857113101, 0.4177220688414641, 0.3886779778168551, 0.4471521345145826, 0.3896048747905194, 0.3303793444542009, 0.36201676196615185, 0.5517100091203736, 0.3525527340570813, 0.2133377984225433, 0.6445279346147289, 0.24189428721640283, 0.6706836653213855, 0.7139006490194417, 0.5974185091351627, 0.2869143475322631, 0.228707695687559, 0.21398851125088358, 0.1740145253519031, 0.2759861032240527, 0.19322992972713005, 0.1966698158832304, 0.23546821671466245, 0.19972119960967394, 0.19684185664100062, 0.27809021073430307, 0.2650526828329667, 0.2122746745117582, 0.2562549798111321, 0.2541268644397966, 0.25579360230347825, 0.2655727949087495, 0.12434194819143363, 0.04743425649217048, 0.11402022899831776, 0.16758592419283536, 0.062282884688436235, 0.026121670434927857, 0.020925609675553236, 0.007168691243269687, 0.06654116263102328, 0.03810334731740295, 0.10425968047701395, 0.3721216328610506, 0.33466942588824367, 0.12204503985848536, 0.1079695302164595, 0.10355133231542513, 0.11478939447995196, 0.11714797496262452, 0.07926067494230216, 0.08197706400378701, 0.0452937845622442, 0.09558187432360721, 0.16488422633385458, 0.10876470651582426, 0.10015252171395472, 0.10047634520524296, 0.21997970480570117, 0.067037078138661, 0.19676687129253345, 0.18051529074882255, 0.22146558577703612, 0.21797323952686742, 0.2510126104924866, 0.2084587722094079, 0.2297383210347269, 0.1777042883023725, 0.08991598029601866, 0.5412312164485581, 0.6497185216474648, 0.5780249494807882, 0.5411311644807457, 0.5327091597846544, 0.6003435291987775, 0.5993840369356793, 0.5626805564203639, 0.5867522389426795, 0.10302316040805748, 0.12267176081527764, 0.12228078700646894, 0.10443087255633765, 0.11094486435065287, 0.11189719753617755, 0.13727303486996478, 0.1074310860819866, 0.08248327301121716, 0.22457693615449636, 0.2342580318340467, 0.23187651257700959, 0.28816414407850144, 0.19948906008627998, 0.13281751933776653, 0.3610123714799748, 0.3060640252073654, 0.22915820416663513, 0.2660712833947344, 0.3240114880851266, 0.3161108267071582, 0.3674015052014311, 0.31163154187892894, 0.3343189589077563, 0.3214245635000429, 0.35948237032305763, 0.2841743200734429, 0.21443963264304866, 0.27385541125831736, 0.22228895936440607, 0.22646525078648927, 0.22349408466453025, 0.1889027691052778, 0.26206098014358514, 0.26005906521848987, 0.24230703959350197, 0.2236628468771149, 0.20027037080336774, 0.191503036182338, 0.23770862226376877, 0.16960991557080074, 0.19939746079834064, 0.1925231877674276, 0.19281403540260134, 0.19501724206309967, 0.21838547563430233, 0.19863718158924226, 0.22314729087631358, 0.4104481743865449, 0.19880633069224374, 0.20391529808821374, 0.2169534201577622, 0.1869326622265719, 0.21036410208292833, 0.1943432943276966, 0.8941330548952844, 0.16706183250856232, 0.6781283706070567, 0.20899342625190998, 0.15979647273645237, 0.18248888278563047, 0.1642796985946996, 0.16284353898780557, 0.6669317660929592, 0.6829451016242177, 0.5674053276247957, 0.4393603390043611, 0.2106435228031428, 0.21006219677647164, 0.10867703578816834, 0.34824787955509107, 0.12617844903931086, 0.2381448679978324, 0.18541689975576703, 0.18056772361466933, 0.18771295189024195, 0.18131338533901953, 0.192505689603648, 0.2152467175812488, 0.19755992995645388, 0.21688484338560332, 0.09111876023083076, 0.08368842773326501, 0.09006072388718422, 0.08250114270109266, 0.07795189875947695, 0.09199482713046359, 0.10911981928184689, 0.07927324876886255, 0.08606514102282237]}, "mutation_prompt": null}
{"id": "b093aa35-47f4-4c1c-b093-501ae84446db", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))  # Slightly increased dynamic swarm size\n        self.de_size = self.swarm_size  # Keeping DE size equal to swarm size for balance\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))  # Reduced initial velocity range\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  # Slightly adjusted cognitive component\n        self.c2 = 1.4  # Slightly adjusted social component\n        self.inertia_weight = 0.6  # Decreased initial inertia weight\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_probability = 0.85  # Slightly reduced crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.025  # Increased adaptive factor for faster adaptation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))  # Allow more aggressive exploration\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced swarm dynamics and adaptive parameter tuning to improve convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.874091168323061, 0.8118298892985372, 0.8887931835474435, 0.891725103145723, 0.8290208667858076, 0.899904649385632, 0.907093607773934, 0.8721862422489721, 0.8862039534298759, 0.6617594373711467, 0.6987551966162856, 0.7492228841618169, 0.6838693511091348, 0.6665472983159035, 9.999999999998899e-05, 0.7925930894552156, 0.7210923334281609, 0.6853249993399928, 0.3809190102149681, 0.17073007063135115, 0.1277969659906001, 0.1612700862881491, 0.1321853019463629, 0.1527967312078481, 0.1198280045205492, 0.13729548017700655, 0.151192876486816, 0.22769684382467037, 0.16940328025453277, 0.13018387090858563, 0.13030971299500738, 0.13524695637835193, 0.1487444933915678, 0.11154246056319628, 0.15519885039097647, 0.1624849684469053, 0.988329441251037, 0.9773166238685124, 0.9871715936001026, 0.9935326942002457, 0.982364870633989, 0.984640141065334, 0.9739015852386521, 0.9860898409254094, 0.9865429207533563, 0.5576980236783928, 0.48997991627059145, 0.5297530914954633, 0.5595662918583988, 0.15239191317829337, 0.5610721772253748, 0.08891784765493682, 0.6202632754913482, 0.5845623682726189, 0.6263837787371094, 0.7764494858214281, 0.7465617887408613, 0.7970899267775711, 0.15842573193745835, 0.7082462388986972, 0.6674003696824783, 0.7289314443311867, 0.19961767929206342, 0.44523324264571296, 0.5793257403009082, 0.3990041336387724, 0.27166700824736423, 0.25217715230345306, 0.3979452041926498, 0.3436417644905815, 0.2750964126526494, 0.49405498611137044, 0.14577206720627822, 0.36451132702037314, 0.3399790626656122, 0.25779017696658835, 0.3250651046592482, 0.40609753395719694, 0.2548569895783498, 0.3139337981944713, 0.5039235046862085, 9.999999999998899e-05, 0.1162461429653997, 0.14656830366526408, 0.026324071685547623, 0.06321981637058494, 0.11599158719386815, 0.16004840568604395, 0.20903369775640346, 0.13116141697284822, 0.058072517272613866, 0.13818193958723946, 0.30529110460347497, 0.14551749714537165, 0.3238167335855775, 0.10673439527053774, 0.0909668154428167, 0.09631939788662436, 0.17400721017065568, 0.336794803093342, 0.06994432798806938, 0.10524630967143489, 0.15889254650750995, 0.09380106355614992, 0.19073790291806902, 0.14145307884507197, 0.5117395058356646, 0.12609581833671568, 0.26646777424679724, 0.2177796960905778, 0.2564276977089065, 0.31208841406726373, 0.2965400534035504, 0.28261192715574657, 0.1781644778053948, 0.19770159675171028, 0.2668386415662848, 0.6774553432950192, 0.6344128277410163, 0.6350984448931887, 0.6290497320131965, 0.6968562116629757, 0.5217730728047547, 0.6548966164801069, 0.5533613894195446, 0.7287670024055094, 0.06398884915233816, 0.09294242348354487, 0.11715370536976644, 0.16115355735599457, 0.11747718828196974, 0.1577950402911643, 0.0866069826310355, 0.10739984347459541, 0.09180634060965476, 0.22581925804994873, 0.2032914017672589, 0.16100204033690502, 0.2604454326441551, 0.32101521230098373, 0.33609402320246784, 0.2480076334576755, 0.17010500915415827, 0.22468092370613535, 0.35244643496045736, 0.25819677528678886, 0.2924328734686732, 0.4176896342627927, 0.3178725280515253, 0.4549060709633902, 0.44280700409072693, 0.4057061757061561, 0.43799662057533517, 0.31731503060114696, 0.2606810230521359, 0.3098254278676902, 0.3542899159737771, 0.34205532490206947, 0.35059683734173785, 0.3005199211995522, 0.2935901485468193, 0.28355096268058355, 0.18760105821105644, 0.20789766555342937, 0.18475608824034018, 0.19534857021566365, 0.1877197893267557, 0.24831034648676542, 0.23866499938849806, 0.20283466796167948, 0.18323028187251855, 0.4830745097189858, 0.2222723478208689, 0.4505441441264887, 0.20230945253056198, 0.24451146720135808, 0.2328516517528214, 0.23324119101311147, 0.22302755724728196, 0.19632343655614248, 0.8791924754920558, 0.2045486365185073, 0.8799081266004204, 0.1708662508935953, 0.786020558120854, 0.8483738712187625, 0.1825178795045821, 0.17064594579371117, 0.8272524194173889, 0.16583751722149354, 0.21038522400369397, 0.16834140281523324, 0.5815952068012952, 0.20848314229960518, 0.20863171190268504, 0.21790865814277072, 0.1978876094738774, 0.33933990888867416, 0.21560566290652305, 0.18113771413272828, 0.24483978136852624, 0.19368532255505366, 0.19717453762104364, 0.19728440480289233, 0.20415723809805286, 0.19754118268398035, 0.1875247129156965, 0.07852619192488652, 0.07764203958886429, 0.0796267514259198, 0.07798398094394399, 0.07902900859310735, 0.08885334496395403, 0.07567660887947092, 0.09062014169132293, 0.07652879934451973]}, "mutation_prompt": null}
{"id": "fed3b00b-3e80-454f-903c-a1d1e7fc741b", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.initial_inertia = self.inertia_weight\n        self.final_inertia = 0.3\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            # Dynamic inertia weight decay\n            self.inertia_weight = (self.initial_inertia - self.final_inertia) * ((self.budget - self.evaluations) / self.budget) + self.final_inertia\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            # Adaptive mutation adjustment\n            self.mutation_factor = max(0.4, self.mutation_factor * (1 - self.adaptive_factor * 0.5))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Incorporate a dynamic inertia weight decay and adaptive mutation adjustment for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.288175822023422, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.771798440258662, 0.804351163987523, 0.8557175054355062, 0.8713513919540522, 0.2793228397997335, 0.8133835834455496, 0.8354182076305738, 0.8059525619778057, 0.8114471657636495, 0.5893306298442293, 0.20354701335576098, 0.6398797994667704, 0.5376648832528033, 0.34557661011165297, 9.999999999998899e-05, 0.5410246171169107, 0.2945099915063112, 0.018969402723311046, 0.16020891397363812, 0.17054327239217515, 0.1406456073171306, 0.14763595648593641, 0.1570862914223602, 0.1728771241548489, 0.1284623903772668, 0.2237810276654577, 0.15629649220151132, 0.12995508671339906, 0.1292024235611039, 0.1479362381769992, 0.14983524381954394, 0.13191247052270993, 0.14129460478644373, 0.15467772188881534, 0.13560934315291928, 0.13113976643455294, 0.9883367286435382, 0.9797788038071438, 0.9886223444122899, 0.9893641431615345, 0.9842285077874078, 0.9858304743908288, 0.9767272844067725, 0.9864385931682732, 0.9879684061432399, 0.3489174418349147, 0.41204476442078664, 0.3873911654168153, 0.15280150545152205, 0.15363336993597165, 0.14856023527238305, 0.08903555209685032, 0.11501849941543096, 0.3574824155019989, 0.6626295598060452, 0.3500977601390267, 0.23366972353761373, 0.2717827171662458, 0.8577833231707412, 0.8699822664608756, 0.19268562194573902, 0.3402677708045684, 0.22518804159189476, 0.27864813727490867, 0.18992444318278945, 0.15610269058736448, 0.1255784648870878, 0.17067862424020552, 0.12570520787998762, 0.1644695330370891, 0.21481698616261902, 0.17851407328845237, 0.1754098927070088, 0.13370699388472662, 0.34441570146061473, 0.14244819761022043, 0.18143475011813182, 0.15863933254923646, 0.1381741096847129, 0.15825407083887255, 0.2071608601889655, 9.999999999998899e-05, 0.06783187992875317, 0.0019106253454378441, 0.023865213539983943, 0.008377580958852326, 0.015776312571177398, 0.005852709556060098, 0.04272928673238763, 0.036359318952600916, 0.06347381174253441, 0.15830619182074446, 0.0909992391146377, 0.09909345579773632, 0.16827536013201294, 0.3163456416826421, 0.062274886991957046, 0.0459464507445162, 0.1107548437552458, 0.21858212719060088, 0.07396910893455733, 0.13947210185835013, 0.1011634747739969, 0.09583095636860817, 0.1959437909529268, 0.14473764639970377, 0.29258995539706845, 0.06923591757339986, 0.20181763744541414, 0.2955297306977922, 0.20451882317752346, 0.23867660383932365, 0.03724870245715717, 0.08071675703780934, 0.14196889699021176, 0.4228375813165274, 0.29051445423720035, 0.4779515595953241, 0.5616957850347049, 0.46509997789610247, 0.5267692932143304, 0.4628023295456716, 0.5160809535235051, 0.5283543968798208, 0.6563304119963242, 0.5524308240754451, 0.07861332608039007, 0.13548759230570318, 0.1415764291354028, 0.12292707093299882, 0.11808618464366283, 0.11057573794017694, 0.10259756243123264, 0.08957592299116279, 0.08289080673356397, 0.28872972394496677, 0.244254940462862, 0.19282447323543284, 0.22681483780696077, 0.2570504987275466, 0.1950904729885118, 0.3156153498197528, 0.16719601545307616, 0.15803757037279897, 0.4359330049974507, 0.356603096352602, 0.4354150476546298, 0.40886737620658087, 0.3590635651023911, 0.4300970509729767, 0.3620766055188587, 0.40091019505828696, 0.2992784243063267, 0.2682589172372727, 0.26942406260073615, 0.29561572347408405, 0.285722507727474, 0.3191733277916421, 0.4569772127204861, 0.16109371860915267, 0.34974767849280686, 0.29112376472033297, 0.22782506187297724, 0.20564001373690266, 0.21251110260692496, 0.22409775096270157, 0.18536012135670066, 0.22387525506249817, 0.21249042741968627, 0.20640205184087013, 0.2128607872313666, 0.23992188711045037, 0.22336909004272998, 0.2163151408985695, 0.2146060109168736, 0.20630037056779005, 0.20952613074547022, 0.2484405884984473, 0.24967097774404268, 0.1976958212079386, 0.7702222395292455, 0.3189705826941732, 0.8831858108230133, 0.13132913042051475, 0.2005921155477398, 0.35830322900843314, 0.18056110847001383, 0.17026555518731823, 0.9129828251339231, 0.15517428888364626, 0.20987094629288405, 0.16820251444302992, 0.2008274831984791, 0.21070176584982236, 0.21052794435253874, 0.6435454631260779, 0.16883512582103033, 0.34108839755789744, 0.19118887054068812, 0.20706477849275207, 0.18940330033810238, 0.19128719042158648, 0.21384324827855494, 0.1763139557255219, 0.1877266558727344, 0.20913954255396872, 0.19777478832173312, 0.08052106694245409, 0.08640401915301932, 0.08596865116939667, 0.08206820291327166, 0.08712476649797396, 0.09131737316863386, 0.09137647191767795, 0.10094560696778332, 0.09115067614253536]}, "mutation_prompt": null}
{"id": "8711e013-4241-497c-a2d4-1fdb47b07535", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))  # Slightly increased dynamic swarm size\n        self.de_size = self.swarm_size  # Keeping DE size equal to swarm size for balance\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))  # Reduced initial velocity range\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  # Slightly adjusted cognitive component\n        self.c2 = 1.4  # Slightly adjusted social component\n        self.inertia_weight = 0.6  # Decreased initial inertia weight\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_probability = 0.85  # Slightly reduced crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.025  # Increased adaptive factor for faster adaptation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))  # Allow more aggressive exploration\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced swarm dynamics and adaptive parameter tuning to improve convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.874091168323061, 0.8118298892985372, 0.8887931835474435, 0.891725103145723, 0.8290208667858076, 0.899904649385632, 0.907093607773934, 0.8721862422489721, 0.8862039534298759, 0.6617594373711467, 0.6987551966162856, 0.7492228841618169, 0.6838693511091348, 0.6665472983159035, 9.999999999998899e-05, 0.7925930894552156, 0.7210923334281609, 0.6853249993399928, 0.3809190102149681, 0.17073007063135115, 0.1277969659906001, 0.1612700862881491, 0.1321853019463629, 0.1527967312078481, 0.1198280045205492, 0.13729548017700655, 0.151192876486816, 0.22769684382467037, 0.16940328025453277, 0.13018387090858563, 0.13030971299500738, 0.13524695637835193, 0.1487444933915678, 0.11154246056319628, 0.15519885039097647, 0.1624849684469053, 0.988329441251037, 0.9773166238685124, 0.9871715936001026, 0.9935326942002457, 0.982364870633989, 0.984640141065334, 0.9739015852386521, 0.9860898409254094, 0.9865429207533563, 0.5576980236783928, 0.48997991627059145, 0.5297530914954633, 0.5595662918583988, 0.15239191317829337, 0.5610721772253748, 0.08891784765493682, 0.6202632754913482, 0.5845623682726189, 0.6263837787371094, 0.7764494858214281, 0.7465617887408613, 0.7970899267775711, 0.15842573193745835, 0.7082462388986972, 0.6674003696824783, 0.7289314443311867, 0.19961767929206342, 0.44523324264571296, 0.5793257403009082, 0.3990041336387724, 0.27166700824736423, 0.25217715230345306, 0.3979452041926498, 0.3436417644905815, 0.2750964126526494, 0.49405498611137044, 0.14577206720627822, 0.36451132702037314, 0.3399790626656122, 0.25779017696658835, 0.3250651046592482, 0.40609753395719694, 0.2548569895783498, 0.3139337981944713, 0.5039235046862085, 9.999999999998899e-05, 0.1162461429653997, 0.14656830366526408, 0.026324071685547623, 0.06321981637058494, 0.11599158719386815, 0.16004840568604395, 0.20903369775640346, 0.13116141697284822, 0.058072517272613866, 0.13818193958723946, 0.30529110460347497, 0.14551749714537165, 0.3238167335855775, 0.10673439527053774, 0.0909668154428167, 0.09631939788662436, 0.17400721017065568, 0.336794803093342, 0.06994432798806938, 0.10524630967143489, 0.15889254650750995, 0.09380106355614992, 0.19073790291806902, 0.14145307884507197, 0.5117395058356646, 0.12609581833671568, 0.26646777424679724, 0.2177796960905778, 0.2564276977089065, 0.31208841406726373, 0.2965400534035504, 0.28261192715574657, 0.1781644778053948, 0.19770159675171028, 0.2668386415662848, 0.6774553432950192, 0.6344128277410163, 0.6350984448931887, 0.6290497320131965, 0.6968562116629757, 0.5217730728047547, 0.6548966164801069, 0.5533613894195446, 0.7287670024055094, 0.06398884915233816, 0.09294242348354487, 0.11715370536976644, 0.16115355735599457, 0.11747718828196974, 0.1577950402911643, 0.0866069826310355, 0.10739984347459541, 0.09180634060965476, 0.22581925804994873, 0.2032914017672589, 0.16100204033690502, 0.2604454326441551, 0.32101521230098373, 0.33609402320246784, 0.2480076334576755, 0.17010500915415827, 0.22468092370613535, 0.35244643496045736, 0.25819677528678886, 0.2924328734686732, 0.4176896342627927, 0.3178725280515253, 0.4549060709633902, 0.44280700409072693, 0.4057061757061561, 0.43799662057533517, 0.31731503060114696, 0.2606810230521359, 0.3098254278676902, 0.3542899159737771, 0.34205532490206947, 0.35059683734173785, 0.3005199211995522, 0.2935901485468193, 0.28355096268058355, 0.18760105821105644, 0.20789766555342937, 0.18475608824034018, 0.19534857021566365, 0.1877197893267557, 0.24831034648676542, 0.23866499938849806, 0.20283466796167948, 0.18323028187251855, 0.4830745097189858, 0.2222723478208689, 0.4505441441264887, 0.20230945253056198, 0.24451146720135808, 0.2328516517528214, 0.23324119101311147, 0.22302755724728196, 0.19632343655614248, 0.8791924754920558, 0.2045486365185073, 0.8799081266004204, 0.1708662508935953, 0.786020558120854, 0.8483738712187625, 0.1825178795045821, 0.17064594579371117, 0.8272524194173889, 0.16583751722149354, 0.21038522400369397, 0.16834140281523324, 0.5815952068012952, 0.20848314229960518, 0.20863171190268504, 0.21790865814277072, 0.1978876094738774, 0.33933990888867416, 0.21560566290652305, 0.18113771413272828, 0.24483978136852624, 0.19368532255505366, 0.19717453762104364, 0.19728440480289233, 0.20415723809805286, 0.19754118268398035, 0.1875247129156965, 0.07852619192488652, 0.07764203958886429, 0.0796267514259198, 0.07798398094394399, 0.07902900859310735, 0.08885334496395403, 0.07567660887947092, 0.09062014169132293, 0.07652879934451973]}, "mutation_prompt": null}
{"id": "185451d1-a3c7-4c7b-99be-c39c6f939fbb", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))  # Slightly increased dynamic swarm size\n        self.de_size = self.swarm_size  # Keeping DE size equal to swarm size for balance\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))  # Reduced initial velocity range\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  # Slightly adjusted cognitive component\n        self.c2 = 1.4  # Slightly adjusted social component\n        self.inertia_weight = 0.6  # Decreased initial inertia weight\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_probability = 0.85  # Slightly reduced crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.025  # Increased adaptive factor for faster adaptation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))  # Allow more aggressive exploration\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced swarm dynamics and adaptive parameter tuning to improve convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.874091168323061, 0.8118298892985372, 0.8887931835474435, 0.891725103145723, 0.8290208667858076, 0.899904649385632, 0.907093607773934, 0.8721862422489721, 0.8862039534298759, 0.6617594373711467, 0.6987551966162856, 0.7492228841618169, 0.6838693511091348, 0.6665472983159035, 9.999999999998899e-05, 0.7925930894552156, 0.7210923334281609, 0.6853249993399928, 0.3809190102149681, 0.17073007063135115, 0.1277969659906001, 0.1612700862881491, 0.1321853019463629, 0.1527967312078481, 0.1198280045205492, 0.13729548017700655, 0.151192876486816, 0.22769684382467037, 0.16940328025453277, 0.13018387090858563, 0.13030971299500738, 0.13524695637835193, 0.1487444933915678, 0.11154246056319628, 0.15519885039097647, 0.1624849684469053, 0.988329441251037, 0.9773166238685124, 0.9871715936001026, 0.9935326942002457, 0.982364870633989, 0.984640141065334, 0.9739015852386521, 0.9860898409254094, 0.9865429207533563, 0.5576980236783928, 0.48997991627059145, 0.5297530914954633, 0.5595662918583988, 0.15239191317829337, 0.5610721772253748, 0.08891784765493682, 0.6202632754913482, 0.5845623682726189, 0.6263837787371094, 0.7764494858214281, 0.7465617887408613, 0.7970899267775711, 0.15842573193745835, 0.7082462388986972, 0.6674003696824783, 0.7289314443311867, 0.19961767929206342, 0.44523324264571296, 0.5793257403009082, 0.3990041336387724, 0.27166700824736423, 0.25217715230345306, 0.3979452041926498, 0.3436417644905815, 0.2750964126526494, 0.49405498611137044, 0.14577206720627822, 0.36451132702037314, 0.3399790626656122, 0.25779017696658835, 0.3250651046592482, 0.40609753395719694, 0.2548569895783498, 0.3139337981944713, 0.5039235046862085, 9.999999999998899e-05, 0.1162461429653997, 0.14656830366526408, 0.026324071685547623, 0.06321981637058494, 0.11599158719386815, 0.16004840568604395, 0.20903369775640346, 0.13116141697284822, 0.058072517272613866, 0.13818193958723946, 0.30529110460347497, 0.14551749714537165, 0.3238167335855775, 0.10673439527053774, 0.0909668154428167, 0.09631939788662436, 0.17400721017065568, 0.336794803093342, 0.06994432798806938, 0.10524630967143489, 0.15889254650750995, 0.09380106355614992, 0.19073790291806902, 0.14145307884507197, 0.5117395058356646, 0.12609581833671568, 0.26646777424679724, 0.2177796960905778, 0.2564276977089065, 0.31208841406726373, 0.2965400534035504, 0.28261192715574657, 0.1781644778053948, 0.19770159675171028, 0.2668386415662848, 0.6774553432950192, 0.6344128277410163, 0.6350984448931887, 0.6290497320131965, 0.6968562116629757, 0.5217730728047547, 0.6548966164801069, 0.5533613894195446, 0.7287670024055094, 0.06398884915233816, 0.09294242348354487, 0.11715370536976644, 0.16115355735599457, 0.11747718828196974, 0.1577950402911643, 0.0866069826310355, 0.10739984347459541, 0.09180634060965476, 0.22581925804994873, 0.2032914017672589, 0.16100204033690502, 0.2604454326441551, 0.32101521230098373, 0.33609402320246784, 0.2480076334576755, 0.17010500915415827, 0.22468092370613535, 0.35244643496045736, 0.25819677528678886, 0.2924328734686732, 0.4176896342627927, 0.3178725280515253, 0.4549060709633902, 0.44280700409072693, 0.4057061757061561, 0.43799662057533517, 0.31731503060114696, 0.2606810230521359, 0.3098254278676902, 0.3542899159737771, 0.34205532490206947, 0.35059683734173785, 0.3005199211995522, 0.2935901485468193, 0.28355096268058355, 0.18760105821105644, 0.20789766555342937, 0.18475608824034018, 0.19534857021566365, 0.1877197893267557, 0.24831034648676542, 0.23866499938849806, 0.20283466796167948, 0.18323028187251855, 0.4830745097189858, 0.2222723478208689, 0.4505441441264887, 0.20230945253056198, 0.24451146720135808, 0.2328516517528214, 0.23324119101311147, 0.22302755724728196, 0.19632343655614248, 0.8791924754920558, 0.2045486365185073, 0.8799081266004204, 0.1708662508935953, 0.786020558120854, 0.8483738712187625, 0.1825178795045821, 0.17064594579371117, 0.8272524194173889, 0.16583751722149354, 0.21038522400369397, 0.16834140281523324, 0.5815952068012952, 0.20848314229960518, 0.20863171190268504, 0.21790865814277072, 0.1978876094738774, 0.33933990888867416, 0.21560566290652305, 0.18113771413272828, 0.24483978136852624, 0.19368532255505366, 0.19717453762104364, 0.19728440480289233, 0.20415723809805286, 0.19754118268398035, 0.1875247129156965, 0.07852619192488652, 0.07764203958886429, 0.0796267514259198, 0.07798398094394399, 0.07902900859310735, 0.08885334496395403, 0.07567660887947092, 0.09062014169132293, 0.07652879934451973]}, "mutation_prompt": null}
{"id": "408de54d-fae8-4758-903e-f192888e7ec1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Increased adaptive factor for faster adaptation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            # Adaptive mutation factor based on progress\n            diversity = np.std(self.particles, axis=0).mean()\n            self.mutation_factor = 0.5 + (0.4 * diversity / 5.0)\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced swarm dynamics with diversity injection and adaptive mutation to improve convergence speed.", "configspace": "", "generation": 20, "fitness": 0.30216643593130105, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.9177227100469483, 0.8452495249371098, 0.8975618879817119, 0.8664676784447514, 0.3827465247084062, 0.8671600648334021, 0.9141966665430763, 0.8882735529560771, 0.8880115486145722, 0.6183570663443902, 0.7508759124516482, 0.8439932588080274, 0.8068084942557823, 0.7288877655794914, 9.999999999998899e-05, 0.7870586335272302, 0.06009702106361381, 0.09567084864878994, 0.16514405154676826, 0.10731508898146025, 0.13653386998536787, 0.26031321122723017, 0.5226898377432325, 0.20149718106047143, 0.15057117208791737, 0.15534205654118471, 0.32501901942435174, 0.1413170030561196, 0.1407256552532945, 0.14047646480041054, 0.13878569007874608, 0.17172062677157518, 0.11982185797901779, 0.12651270584776264, 0.13390232262840196, 0.1380776110817694, 0.9883281530207199, 0.9758120747204325, 0.987160786529134, 0.9870804084838413, 0.9823408335354267, 0.9845947700323398, 0.9687680805778548, 0.9860891918303508, 0.9864980989063887, 0.4392192835055567, 0.10182557630879385, 0.4484723484636779, 0.32177683541349156, 0.25042527356068134, 0.15175421061398398, 0.45294753701244295, 0.12762424899664515, 0.44332159472652355, 0.3449853640523797, 0.22846731054228198, 0.36824107454105337, 0.2766450850206592, 0.2041879548871952, 0.11800717707172348, 0.8218339539852404, 0.2361392049689831, 0.8922006033175343, 0.31165482066791894, 0.2082948129851312, 0.18684957955423442, 0.16559453153744086, 0.1489379888581257, 0.15718767387292232, 0.219972546925026, 0.3851117533236941, 0.18434066878657474, 0.25740617024407164, 0.12689780305162535, 0.14588436696509177, 0.2004960284972992, 0.24375546048840346, 0.20498765846887113, 0.241178083322659, 0.13962503221458356, 0.21587893051269125, 0.013096677909604892, 9.999999999998899e-05, 0.02510448908490326, 0.06092815379185068, 0.006468276073100632, 0.040862368312980624, 0.08610528417671992, 9.999999999998899e-05, 0.10969413909120163, 0.026597392612664028, 0.11967985703133632, 0.2043417033413394, 0.05945425384397918, 0.07779566546567385, 0.19752410438908086, 0.06803590495411793, 0.032348734831115666, 0.15183433388801237, 0.23629958396130446, 0.07138890914144591, 0.03940057549128828, 0.21295825759409892, 0.08775087008944815, 0.19255790825556185, 0.10175979062462626, 0.1714992358224806, 0.07431548370024144, 0.043909929581350426, 0.1359002816566246, 0.3370329953537623, 0.12762604235377673, 0.13767780180093792, 0.34416921737647044, 0.08366444485025637, 0.14514431835493868, 0.08380091399607204, 0.549344344141611, 0.5191609701983727, 0.6275544414938999, 0.5595711325759156, 0.5191447984966223, 0.5060411232587028, 0.5342358441656633, 0.6842909678502761, 0.5906340994368142, 0.08634546070265547, 0.10779344300030402, 0.12797767963549544, 0.16079934916042238, 0.10370027454872777, 0.1024386801367615, 0.07333226640576307, 0.08949464846801658, 0.1165269384514086, 0.2291772153127376, 0.32742879806500935, 0.18746440778561313, 0.18953029405807942, 0.2038625575638482, 0.19976621899595415, 0.1466359505890905, 0.24959123819820384, 0.2977237875254203, 0.5332517618302495, 0.3841057449635098, 0.43462213017794826, 0.5487079218463857, 0.40128848895544156, 0.45193731861977926, 0.4427053723738068, 0.41893017976126434, 0.40231046550526095, 0.28381663909186994, 0.26043475436174734, 0.3125943849070272, 0.2649154755345766, 0.31335742812120926, 0.38229611901934923, 0.22036151463738107, 0.29685744316427076, 0.40625561164639135, 0.21444221436205968, 0.21435303347909318, 0.19304710762516808, 0.1938285346864277, 0.21184881466375594, 0.20701021521039287, 0.21601463913778762, 0.21015700975022766, 0.21399264528666007, 0.7162293020001387, 0.2457878305918313, 0.21886684390656164, 0.24401078651175612, 0.21775009294628345, 0.1953715848664742, 0.24158124468037856, 0.19600846038744124, 0.20215016810749853, 0.8759729704336467, 0.20830775912579236, 0.33539969197177566, 0.1713521153960219, 0.6942231254997424, 0.2468989226868631, 0.18572186882357977, 0.14664088620658366, 0.5316794230061193, 0.2079771366508245, 0.2124250220558579, 0.21040822109739898, 0.16204148425760834, 0.21078568927365993, 0.20987800066665274, 0.1651585374669825, 0.16897500458662162, 0.428029144523671, 0.18680377853413588, 0.18512228821393906, 0.1910839250333165, 0.1883665713008148, 0.19852496232309436, 0.18563389511541295, 0.17891733594717174, 0.19842008017550972, 0.19737376781527505, 0.09769764424686855, 0.0881062701869747, 0.08602153167943538, 0.09596603083777955, 0.07828769059010066, 0.09693551906058617, 0.09369472320415351, 0.10531747391293123, 0.08230202677114795]}, "mutation_prompt": null}
{"id": "56798996-7ac2-44a5-addd-f11a805147e1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.dynamic_adjustment_threshold = 0.1  # New parameter for dynamic adjustment\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n        # Added dynamic adjustment based on score improvement\n        if self.evaluations > self.budget * self.dynamic_adjustment_threshold:\n            self.inertia_weight *= 0.9\n            self.mutation_factor *= 1.05\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n            # Hybrid selection: consider neighboring solutions\n            if i > 0 and score < self.population_scores[i-1]:\n                self.de_population[i-1] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic adaptive parameters and a hybrid selection strategy for improved convergence.", "configspace": "", "generation": 21, "fitness": 0.2663672874612629, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.8442488960428491, 0.8427666846505308, 0.8715674787683652, 0.8945468588133936, 0.5073933523636291, 0.888089224197674, 0.9144987286013534, 0.8727806508490159, 0.874522950059816, 9.999999999998899e-05, 0.04390897134610294, 0.7319633352301353, 0.28744823536526776, 0.28708859093949746, 0.021735455232028134, 0.808690416956624, 0.7216353428385436, 0.019277679023824046, 0.5862365206189837, 0.49458860056212506, 0.13072091337686853, 0.1614453776301118, 0.15291565334913937, 0.1107088938829669, 0.15072988970255774, 0.1380834274907098, 0.13410933553025228, 0.1263181929903694, 0.1348992424849612, 0.08138525878016967, 0.14162850252940917, 0.11462789738749712, 0.12938332324782842, 0.1091223717430283, 0.12811211892762275, 0.13787736181967736, 0.988329441251037, 0.9773766718810717, 0.9871715936001026, 0.9939275937931503, 0.982364870633989, 0.9846341196234816, 0.9879147025000301, 0.9860898409254094, 0.9865625978596069, 0.36520649796629245, 0.059909512507238416, 0.48665476775628413, 0.16064969692634368, 0.20151088023676644, 0.22707682277189956, 0.08912637855484895, 0.08790292238694997, 0.35859694906867845, 0.2778043497342604, 0.22377189440055523, 0.22242758088142378, 0.2749323521387317, 0.14270098720594737, 0.23520489276078915, 0.2330070610263799, 0.2719139599187853, 0.2338693209111613, 0.3278237315434088, 0.1862690993132431, 0.25527209220593594, 0.18860793645631635, 0.17259103828186584, 0.08817694472995952, 0.18401670214150156, 0.2155084752635522, 0.21046317239927115, 0.14121531402543364, 0.1108314390845444, 0.19246901291425655, 0.18766048827516424, 0.22418604199898506, 0.16129376565486786, 0.25454845232009127, 0.24595068279691434, 0.2240210310228753, 0.0414312637782408, 9.999999999998899e-05, 0.04910880313093313, 0.007479787827720075, 0.007818219666958615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015299732387006215, 0.08635314051605236, 0.06631272445805114, 0.08918853196958731, 0.07679171420289344, 0.10466448114815918, 0.1364628955046151, 0.06362440869160146, 0.0461866386828611, 0.12152357909623246, 0.33692678263052, 0.036241523824430466, 0.10854082933952247, 0.0918057346998532, 0.07621302964910359, 0.12218650311200141, 0.07478651945965953, 0.4372655363570018, 0.07679940197998547, 0.07434773323039334, 0.1281339020003177, 0.12872190942188155, 0.13272897251429072, 0.17924447855492132, 0.13727634698546787, 0.12069171126597267, 0.1786134741413412, 0.12451280415758315, 0.5008317006551402, 0.5167115896370357, 0.48067326026708557, 0.503451270831423, 0.4862054365873515, 0.4963425724481906, 0.5215886482150152, 0.5077931301029281, 0.4785654969559726, 0.055590462843596145, 0.08717905582457519, 0.08393986233807083, 0.16145505354351986, 0.10859257489286278, 0.15831978226484067, 0.07519344264930317, 0.0672065028178529, 0.14471587129894814, 0.2427634249939742, 0.20447954935731227, 0.1674270578822601, 0.2287671963437995, 0.26314819512097054, 0.32694251062597446, 0.31400714502315197, 0.17921218348754897, 0.1958488839904723, 0.31822395550079974, 0.2352794323338493, 0.3089738746397299, 0.2780043255607325, 0.2414505686660141, 0.3321787641500259, 0.4248914952575573, 0.26538041398521517, 0.20575938142116523, 0.18009931517668898, 0.23718167391531986, 0.22056871662007638, 0.36696042746425417, 0.24404262355314177, 0.27882330437789904, 0.224381742158698, 0.2627340513995793, 0.11415033715012235, 0.19022524500025928, 0.18724964811278855, 0.1840059135329194, 0.18317795909067258, 0.18580331149705587, 0.2102196128344298, 0.2319602062014996, 0.17550538703967233, 0.1840153759806582, 0.21943846934371192, 0.20393318118627723, 0.23742207095083812, 0.20825070276840585, 0.20943332553292304, 0.198038966178941, 0.22714598031151234, 0.22359317346286312, 0.20169650003044248, 0.8700075948624879, 0.18758335754240596, 0.4584325353744374, 0.1721584470099371, 0.7903877500932251, 0.42652760754533114, 0.5837000362934218, 0.11523207151478532, 0.16271354090005208, 0.155106211999972, 0.2104023058439174, 0.18094145773154557, 0.11202682361618921, 0.19739576240297518, 0.2104033133188381, 0.10503549481191443, 0.16912400088468715, 0.33844485907168254, 0.2068294398274524, 0.1840612114705671, 0.24612224206096323, 0.17929122766569106, 0.198927481011961, 0.1714305617025177, 0.18804294153450074, 0.18698919052283325, 0.18737500637510074, 0.0829752689486708, 0.07891428479688878, 0.0753160814191498, 0.08644193772858721, 0.0817950975315993, 0.07890076824398162, 0.07459752113819629, 0.08082495890559438, 0.0733418791773216]}, "mutation_prompt": null}
{"id": "dcc097a0-01e9-432a-8a2a-145d797ec714", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))  # Slightly increased dynamic swarm size\n        self.de_size = self.swarm_size  # Keeping DE size equal to swarm size for balance\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))  # Reduced initial velocity range\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  # Slightly adjusted cognitive component\n        self.c2 = 1.4  # Slightly adjusted social component\n        self.inertia_weight = 0.6  # Decreased initial inertia weight\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_probability = 0.85  # Slightly reduced crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.025  # Increased adaptive factor for faster adaptation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))  # Allow more aggressive exploration\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced swarm dynamics and adaptive parameter tuning to improve convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.874091168323061, 0.8118298892985372, 0.8887931835474435, 0.891725103145723, 0.8290208667858076, 0.899904649385632, 0.907093607773934, 0.8721862422489721, 0.8862039534298759, 0.6617594373711467, 0.6987551966162856, 0.7492228841618169, 0.6838693511091348, 0.6665472983159035, 9.999999999998899e-05, 0.7925930894552156, 0.7210923334281609, 0.6853249993399928, 0.3809190102149681, 0.17073007063135115, 0.1277969659906001, 0.1612700862881491, 0.1321853019463629, 0.1527967312078481, 0.1198280045205492, 0.13729548017700655, 0.151192876486816, 0.22769684382467037, 0.16940328025453277, 0.13018387090858563, 0.13030971299500738, 0.13524695637835193, 0.1487444933915678, 0.11154246056319628, 0.15519885039097647, 0.1624849684469053, 0.988329441251037, 0.9773166238685124, 0.9871715936001026, 0.9935326942002457, 0.982364870633989, 0.984640141065334, 0.9739015852386521, 0.9860898409254094, 0.9865429207533563, 0.5576980236783928, 0.48997991627059145, 0.5297530914954633, 0.5595662918583988, 0.15239191317829337, 0.5610721772253748, 0.08891784765493682, 0.6202632754913482, 0.5845623682726189, 0.6263837787371094, 0.7764494858214281, 0.7465617887408613, 0.7970899267775711, 0.15842573193745835, 0.7082462388986972, 0.6674003696824783, 0.7289314443311867, 0.19961767929206342, 0.44523324264571296, 0.5793257403009082, 0.3990041336387724, 0.27166700824736423, 0.25217715230345306, 0.3979452041926498, 0.3436417644905815, 0.2750964126526494, 0.49405498611137044, 0.14577206720627822, 0.36451132702037314, 0.3399790626656122, 0.25779017696658835, 0.3250651046592482, 0.40609753395719694, 0.2548569895783498, 0.3139337981944713, 0.5039235046862085, 9.999999999998899e-05, 0.1162461429653997, 0.14656830366526408, 0.026324071685547623, 0.06321981637058494, 0.11599158719386815, 0.16004840568604395, 0.20903369775640346, 0.13116141697284822, 0.058072517272613866, 0.13818193958723946, 0.30529110460347497, 0.14551749714537165, 0.3238167335855775, 0.10673439527053774, 0.0909668154428167, 0.09631939788662436, 0.17400721017065568, 0.336794803093342, 0.06994432798806938, 0.10524630967143489, 0.15889254650750995, 0.09380106355614992, 0.19073790291806902, 0.14145307884507197, 0.5117395058356646, 0.12609581833671568, 0.26646777424679724, 0.2177796960905778, 0.2564276977089065, 0.31208841406726373, 0.2965400534035504, 0.28261192715574657, 0.1781644778053948, 0.19770159675171028, 0.2668386415662848, 0.6774553432950192, 0.6344128277410163, 0.6350984448931887, 0.6290497320131965, 0.6968562116629757, 0.5217730728047547, 0.6548966164801069, 0.5533613894195446, 0.7287670024055094, 0.06398884915233816, 0.09294242348354487, 0.11715370536976644, 0.16115355735599457, 0.11747718828196974, 0.1577950402911643, 0.0866069826310355, 0.10739984347459541, 0.09180634060965476, 0.22581925804994873, 0.2032914017672589, 0.16100204033690502, 0.2604454326441551, 0.32101521230098373, 0.33609402320246784, 0.2480076334576755, 0.17010500915415827, 0.22468092370613535, 0.35244643496045736, 0.25819677528678886, 0.2924328734686732, 0.4176896342627927, 0.3178725280515253, 0.4549060709633902, 0.44280700409072693, 0.4057061757061561, 0.43799662057533517, 0.31731503060114696, 0.2606810230521359, 0.3098254278676902, 0.3542899159737771, 0.34205532490206947, 0.35059683734173785, 0.3005199211995522, 0.2935901485468193, 0.28355096268058355, 0.18760105821105644, 0.20789766555342937, 0.18475608824034018, 0.19534857021566365, 0.1877197893267557, 0.24831034648676542, 0.23866499938849806, 0.20283466796167948, 0.18323028187251855, 0.4830745097189858, 0.2222723478208689, 0.4505441441264887, 0.20230945253056198, 0.24451146720135808, 0.2328516517528214, 0.23324119101311147, 0.22302755724728196, 0.19632343655614248, 0.8791924754920558, 0.2045486365185073, 0.8799081266004204, 0.1708662508935953, 0.786020558120854, 0.8483738712187625, 0.1825178795045821, 0.17064594579371117, 0.8272524194173889, 0.16583751722149354, 0.21038522400369397, 0.16834140281523324, 0.5815952068012952, 0.20848314229960518, 0.20863171190268504, 0.21790865814277072, 0.1978876094738774, 0.33933990888867416, 0.21560566290652305, 0.18113771413272828, 0.24483978136852624, 0.19368532255505366, 0.19717453762104364, 0.19728440480289233, 0.20415723809805286, 0.19754118268398035, 0.1875247129156965, 0.07852619192488652, 0.07764203958886429, 0.0796267514259198, 0.07798398094394399, 0.07902900859310735, 0.08885334496395403, 0.07567660887947092, 0.09062014169132293, 0.07652879934451973]}, "mutation_prompt": null}
{"id": "536842c6-f130-4e3d-8609-67936eb8562e", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim))) \n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6  \n        self.c2 = 1.4  \n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.9  # Increased crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Slightly increased adaptive factor\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor * 0.5))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor * 0.5))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor * 0.5))\n            self.crossover_probability = max(0.6, self.crossover_probability * (1 - self.adaptive_factor * 0.5))\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        for i in range(self.de_size):\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic inertia and crossover adaptation for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.3175859826874618, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.8909185571938152, 0.8447593868410264, 0.886251825725802, 0.8906094662575699, 0.8475840832777896, 0.8383413426589233, 0.8978889502100011, 0.8462876623412658, 0.8586989230380971, 0.7873430218864115, 0.6604218464003415, 0.7889968419113491, 0.7821489095561024, 0.8040183820659658, 0.6225205003771872, 0.059280544769327204, 0.7110373186974475, 0.7591308680962053, 0.4990649833205236, 0.5861375112347038, 0.453236754242043, 0.46353062885538043, 0.15446842630440805, 0.1609948028668412, 0.16993763190903155, 0.17592884290465283, 0.1359339047376541, 0.167157375541102, 0.4514983673720666, 0.49726957573501973, 0.17690549707280567, 0.17029355810612723, 0.43956173970888723, 0.4656026166690044, 0.1623068965631972, 0.48229063858067733, 0.988330500816735, 0.984214421983647, 0.9873110367115149, 0.98660343158171, 0.9824248656238393, 0.98577832763794, 0.9900109008050717, 0.9862853954322086, 0.9865554003412647, 0.4049527309588009, 0.34970052183984357, 0.30093109637843385, 0.39895460323020504, 0.42510735034268676, 0.3897673602586843, 0.12228353206877995, 0.30963716622735726, 0.3794834539257743, 0.40144492171974244, 0.328532186201121, 0.27883596634490415, 0.2120170277577631, 0.1959165828677647, 0.4341860600892734, 0.5486540346918982, 0.6027148462819478, 0.48451503812740604, 0.3786086628727974, 0.2095365615381588, 0.24073576682412445, 0.21619437942062814, 0.2858824234273136, 0.21565658579981506, 0.18188077506680134, 0.20604050554759856, 0.2687689671514518, 0.18791714372603718, 0.17532635031710564, 0.24038897149444138, 0.17503438849308628, 0.21457506229691736, 0.20010232899787672, 0.21442889669991572, 0.23216468629315468, 0.22695535537989941, 0.042474926482007125, 0.014486892842533794, 0.039592118693408174, 0.019391486461598606, 0.007574398392978909, 9.999999999998899e-05, 0.0024167875112841575, 0.035264829155980615, 0.04951939458271826, 0.09144609648763002, 0.12967216081351252, 0.10052317080559792, 0.07384745382746827, 0.14174866961702082, 0.04974861592012947, 0.11876393888398384, 0.08492687875159755, 0.19726346489918378, 0.5147779479221888, 0.036538348847705904, 0.10296804324330333, 0.09120057778705382, 0.08207051689810019, 0.19080615746102358, 0.0756961794228409, 0.32024870621293144, 0.07384865011209762, 0.1448173962903886, 0.14859874572258536, 0.1434914971762704, 0.14411175766898465, 0.14414736538443518, 0.16560761402856694, 0.1523178706211904, 0.1478241736452104, 0.12274774458089688, 0.5301447940965119, 0.5249376410208664, 0.5414982545447549, 0.5655382381442742, 0.5514747855737552, 0.5456121903014761, 0.5227822390165269, 0.5307823705806834, 0.5172444435034105, 0.17481851258274894, 0.08945415057596096, 0.09064479922105273, 0.11304930572099858, 0.11099976802068867, 0.09945681411819862, 0.09499001087310277, 0.13922409706484706, 0.11340437282078342, 0.2745158112086209, 0.2531234553252357, 0.21404845544695306, 0.24820554691735108, 0.26688784220795325, 0.22893990185454727, 0.31273710097545215, 0.15560655281829627, 0.1714063693090787, 0.34537222839121007, 0.3298532053399428, 0.3274005753390692, 0.25905147170130227, 0.3650353642401851, 0.3176841842175885, 0.3720329189433752, 0.38247807569731107, 0.4056806482319518, 0.19902096590722584, 0.2616632945511266, 0.19315484917757164, 0.2830552249376186, 0.18639962011115463, 0.24715205724274458, 0.19280487689600068, 0.24303560555493664, 0.2276471531537515, 0.1987295361672542, 0.19107981987067257, 0.21344942187300409, 0.20842442764256353, 0.18213835508733578, 0.2008488112739254, 0.2115420378816587, 0.19673026235165225, 0.23335349327460964, 0.3692127542198106, 0.6535539730073421, 0.3468011002122632, 0.2341148490009185, 0.2325235492164499, 0.33588243230184045, 0.2868740440424352, 0.21157618566840597, 0.22155523587493686, 0.9286040023065054, 0.1959240569328451, 0.25403729312934353, 0.16484599506247777, 0.2003535072688737, 0.3331315084612553, 0.1673664263533574, 0.16965558457225582, 0.5447220860069751, 0.43287745519510346, 0.21034057895521396, 0.1607297539213498, 0.2055778799541872, 0.20882128730988792, 0.21155931840974795, 0.1285434236236579, 0.21105682939325188, 0.3963528665721877, 0.2023976719629672, 0.1822456601183361, 0.2022708900284068, 0.19209361070504904, 0.18813516599712066, 0.17905476716221924, 0.19714110150512965, 0.1806012345631256, 0.20257405746094326, 0.09436375475310088, 0.09755703449332265, 0.08514506277816913, 0.08826122556483862, 0.08411440118522062, 0.10413167822863745, 0.08576293028510917, 0.08165293659706763, 0.07384345945263104]}, "mutation_prompt": null}
{"id": "1c3e8296-cb76-4f1b-be4c-4598d5cf7690", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5  # Probability for stochastic ranking\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with stochastic ranking for improved convergence by balancing exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.36609045412556684, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "7321faec-bbfc-4d30-8343-4a669f02de8b", "metadata": {"aucs": [0.8888363859559293, 0.8733034637949212, 0.8632359566774858, 0.8856547092762034, 0.8777132203335103, 0.8688938606565586, 0.8878565386758405, 0.8145915458558046, 0.8667947538047439, 0.755709960997816, 0.6794033705363127, 0.7996646253519967, 0.762889933624071, 0.6322505419572649, 0.6945959471952123, 0.6725589660864729, 0.7860588776397937, 0.7701312835857097, 0.1489530827637363, 0.15283958989685875, 0.16933635479208664, 0.26565452008795987, 0.16929341171401469, 0.41022446062144047, 0.16946428980723727, 0.1442400760492647, 0.3537407855675484, 0.13101660937737236, 0.13683035295469415, 0.12120885683748239, 0.1228800695402571, 0.2300382035322618, 0.3535833354971938, 0.25290485275126406, 0.12522436823257466, 0.13891543104240278, 0.983395330556801, 0.9783953056074015, 0.9901495447165682, 0.9799152441866861, 0.9840211188373312, 0.983138149699145, 0.9785832712122704, 0.9824592682475938, 0.9872213712312529, 0.10757328895091212, 0.061584072726914574, 0.059005560584050376, 0.45809969801493866, 0.4885935924578829, 0.537331564425801, 0.45326544772182487, 0.525519413451393, 0.6166582771344102, 0.786173668870968, 0.3281500618893659, 0.7195342722707923, 0.7273512597947103, 0.7553969017307094, 0.629243846761553, 0.8148371243471731, 0.6038107351349795, 0.7418795027263856, 0.35772130041928296, 0.3041274750385269, 0.2453063792661333, 0.37239119802430154, 0.3818051921511867, 0.3329458884027501, 0.31546181482418456, 0.3179282805260959, 0.39173665427935767, 0.34474875156187834, 0.416661889931946, 0.1674789759332056, 0.26012689639211983, 0.3961407175389512, 0.3566692619047872, 0.2676257472971333, 0.32274203764678755, 0.1776517003702871, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.05455700243036321, 0.1178810278593726, 0.25497622816403465, 0.18229159578732979, 0.018722883886652886, 0.3436944295322203, 0.18427356213769153, 0.34528434501901206, 0.14162949212791232, 0.15426616305205576, 0.06463296479864389, 0.36425679471925343, 0.43310199539381133, 0.24453364748753903, 0.08510851293623145, 0.16076785030370122, 0.16338808106794567, 0.23915366881669975, 0.15534998713508508, 0.15058328965354628, 0.1265782697996809, 0.20764620721200777, 0.07523566613905608, 0.29960617215726515, 0.055456830889839104, 0.06821994845807278, 0.33559581149904016, 0.26643873975385546, 0.286895070345368, 0.3040109622231184, 0.3019822466643465, 0.26834029914224855, 0.5992023671861628, 0.6385055972964424, 0.6600681787811262, 0.5584680656341955, 0.6068832690582617, 0.639997815041778, 0.708018724781061, 0.6066943211944054, 0.5641959444256188, 0.12307687393962352, 0.10758225095369256, 0.10358793847141001, 0.10511941303666994, 0.10929078148902605, 0.1323985845712392, 0.08352594150796944, 0.18849655367256324, 0.08473314961310496, 0.14734952021577497, 0.22854348688885395, 0.21603776017370901, 0.2573927848230535, 0.2693998727472524, 0.21687603165152902, 0.1790266255001003, 0.15351962705979205, 0.14811317474227237, 0.443092741127349, 0.4153019085858365, 0.3059004007809851, 0.38918401421049775, 0.3626229314041921, 0.3843956378767438, 0.4442454174692413, 0.46940644292803435, 0.40537405024123185, 0.3038544259654359, 0.33115298421392114, 0.3140443916161587, 0.31508685062065644, 0.22426678126804278, 0.3121829996691544, 0.3373118695000661, 0.348895080661521, 0.2860576981336269, 0.21278594228882375, 0.1874294161524348, 0.21674380023741602, 0.23472326565025436, 0.21564263348403223, 0.19161960403002176, 0.20172847620097678, 0.197728951972015, 0.21638482559135275, 0.20389326271873376, 0.614957900107868, 0.6280133424582094, 0.24415955728011163, 0.20662232991719265, 0.21645872313493542, 0.4934383886557302, 0.24577246739833958, 0.2108782126887251, 0.1674532764303871, 0.8571069617510607, 0.15423145794141546, 0.7904959662888871, 0.20187983544123766, 0.20161810791110923, 0.16432179604061747, 0.1926052343687381, 0.7909306884173217, 0.7235947292290601, 0.20667255194215572, 0.3174165602798136, 0.7146549458301344, 0.20688892000248804, 0.6995289240018168, 0.7945759005570198, 0.5700803048576903, 0.30025191310202703, 0.19013091894200396, 0.18277265685596544, 0.1938886778591028, 0.1873473107648419, 0.18466562835342792, 0.18045347061603967, 0.18401207725301671, 0.17895800042795185, 0.2167777913330401, 0.09593158170970784, 0.08199198632966542, 0.08246058198039741, 0.08548445412938233, 0.08600773683896168, 0.0797460300583549, 0.07023120050864695, 0.08548478163236117, 0.07636862119023913]}, "mutation_prompt": null}
{"id": "45f929ae-7b8d-4540-ab3a-afe01a010230", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5  # Probability for stochastic ranking\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with stochastic ranking for improved convergence by balancing exploration and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1c3e8296-cb76-4f1b-be4c-4598d5cf7690", "metadata": {"aucs": [0.8888363859559293, 0.8733034637949212, 0.8632359566774858, 0.8856547092762034, 0.8777132203335103, 0.8688938606565586, 0.8878565386758405, 0.8145915458558046, 0.8667947538047439, 0.755709960997816, 0.6794033705363127, 0.7996646253519967, 0.762889933624071, 0.6322505419572649, 0.6945959471952123, 0.6725589660864729, 0.7860588776397937, 0.7701312835857097, 0.1489530827637363, 0.15283958989685875, 0.16933635479208664, 0.26565452008795987, 0.16929341171401469, 0.41022446062144047, 0.16946428980723727, 0.1442400760492647, 0.3537407855675484, 0.13101660937737236, 0.13683035295469415, 0.12120885683748239, 0.1228800695402571, 0.2300382035322618, 0.3535833354971938, 0.25290485275126406, 0.12522436823257466, 0.13891543104240278, 0.983395330556801, 0.9783953056074015, 0.9901495447165682, 0.9799152441866861, 0.9840211188373312, 0.983138149699145, 0.9785832712122704, 0.9824592682475938, 0.9872213712312529, 0.10757328895091212, 0.061584072726914574, 0.059005560584050376, 0.45809969801493866, 0.4885935924578829, 0.537331564425801, 0.45326544772182487, 0.525519413451393, 0.6166582771344102, 0.786173668870968, 0.3281500618893659, 0.7195342722707923, 0.7273512597947103, 0.7553969017307094, 0.629243846761553, 0.8148371243471731, 0.6038107351349795, 0.7418795027263856, 0.35772130041928296, 0.3041274750385269, 0.2453063792661333, 0.37239119802430154, 0.3818051921511867, 0.3329458884027501, 0.31546181482418456, 0.3179282805260959, 0.39173665427935767, 0.34474875156187834, 0.416661889931946, 0.1674789759332056, 0.26012689639211983, 0.3961407175389512, 0.3566692619047872, 0.2676257472971333, 0.32274203764678755, 0.1776517003702871, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.05455700243036321, 0.1178810278593726, 0.25497622816403465, 0.18229159578732979, 0.018722883886652886, 0.3436944295322203, 0.18427356213769153, 0.34528434501901206, 0.14162949212791232, 0.15426616305205576, 0.06463296479864389, 0.36425679471925343, 0.43310199539381133, 0.24453364748753903, 0.08510851293623145, 0.16076785030370122, 0.16338808106794567, 0.23915366881669975, 0.15534998713508508, 0.15058328965354628, 0.1265782697996809, 0.20764620721200777, 0.07523566613905608, 0.29960617215726515, 0.055456830889839104, 0.06821994845807278, 0.33559581149904016, 0.26643873975385546, 0.286895070345368, 0.3040109622231184, 0.3019822466643465, 0.26834029914224855, 0.5992023671861628, 0.6385055972964424, 0.6600681787811262, 0.5584680656341955, 0.6068832690582617, 0.639997815041778, 0.708018724781061, 0.6066943211944054, 0.5641959444256188, 0.12307687393962352, 0.10758225095369256, 0.10358793847141001, 0.10511941303666994, 0.10929078148902605, 0.1323985845712392, 0.08352594150796944, 0.18849655367256324, 0.08473314961310496, 0.14734952021577497, 0.22854348688885395, 0.21603776017370901, 0.2573927848230535, 0.2693998727472524, 0.21687603165152902, 0.1790266255001003, 0.15351962705979205, 0.14811317474227237, 0.443092741127349, 0.4153019085858365, 0.3059004007809851, 0.38918401421049775, 0.3626229314041921, 0.3843956378767438, 0.4442454174692413, 0.46940644292803435, 0.40537405024123185, 0.3038544259654359, 0.33115298421392114, 0.3140443916161587, 0.31508685062065644, 0.22426678126804278, 0.3121829996691544, 0.3373118695000661, 0.348895080661521, 0.2860576981336269, 0.21278594228882375, 0.1874294161524348, 0.21674380023741602, 0.23472326565025436, 0.21564263348403223, 0.19161960403002176, 0.20172847620097678, 0.197728951972015, 0.21638482559135275, 0.20389326271873376, 0.614957900107868, 0.6280133424582094, 0.24415955728011163, 0.20662232991719265, 0.21645872313493542, 0.4934383886557302, 0.24577246739833958, 0.2108782126887251, 0.1674532764303871, 0.8571069617510607, 0.15423145794141546, 0.7904959662888871, 0.20187983544123766, 0.20161810791110923, 0.16432179604061747, 0.1926052343687381, 0.7909306884173217, 0.7235947292290601, 0.20667255194215572, 0.3174165602798136, 0.7146549458301344, 0.20688892000248804, 0.6995289240018168, 0.7945759005570198, 0.5700803048576903, 0.30025191310202703, 0.19013091894200396, 0.18277265685596544, 0.1938886778591028, 0.1873473107648419, 0.18466562835342792, 0.18045347061603967, 0.18401207725301671, 0.17895800042795185, 0.2167777913330401, 0.09593158170970784, 0.08199198632966542, 0.08246058198039741, 0.08548445412938233, 0.08600773683896168, 0.0797460300583549, 0.07023120050864695, 0.08548478163236117, 0.07636862119023913]}, "mutation_prompt": null}
{"id": "0686d08a-a11f-4fb2-bc46-3f16efc2b695", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.elitism_rate = 0.05\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n    \n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        elite_count = int(self.elitism_rate * self.de_size)\n        for i in ranks[:-elite_count]:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with integrated dynamic inertia adjustment and elitism for improved convergence speed.", "configspace": "", "generation": 26, "fitness": 0.26687963027608613, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.28.", "error": "", "parent_id": "1c3e8296-cb76-4f1b-be4c-4598d5cf7690", "metadata": {"aucs": [0.9550943766769135, 0.9450966073172666, 0.936185840689379, 0.9344102498573656, 0.9480964901207968, 0.9415700083831361, 0.9418224978118455, 0.9499781218393915, 0.9497373338181496, 0.8601159457155649, 0.044810737895154884, 0.08127471882347836, 0.8891095884031294, 0.8888007646197372, 9.999999999998899e-05, 0.8801579656820392, 0.8564612844153516, 0.8997884881737472, 0.15937404321829451, 0.1526764796055604, 0.12852917091378335, 0.12120896393764269, 0.15021429875243086, 0.13126287660575175, 0.07589424350652785, 0.051840412835130745, 0.16705411315920116, 0.14255002566024977, 0.15406764695635522, 0.14794911582492531, 0.15856846022238702, 0.12713207245094038, 0.15218447514401523, 0.14776425019371653, 0.11936067132632322, 0.12050481059161411, 0.9936229550686255, 0.983732584385569, 0.9936412591145584, 0.99233713255124, 0.9902683175515549, 0.992785063704181, 0.9865143191352883, 0.9929914224844584, 0.9909257164257061, 0.5226582929044962, 0.060234652298919666, 0.059958480517708246, 0.15287008647226552, 0.15430972967345336, 0.15487550305865494, 0.1280586770690747, 0.08899184002419647, 0.6243719612570254, 0.22211810587297054, 0.21126055517665177, 0.23192949284651154, 0.19585399524987923, 0.1924747803100555, 0.11783852249113547, 0.1814027597018636, 0.17940870314294222, 0.201994909259114, 0.13425708764790922, 0.18993023582635904, 0.22207155383976473, 0.18155729230367468, 0.11069169330285678, 9.999999999998899e-05, 0.1928473695003312, 0.2053070059479215, 0.18809291935202632, 0.1348502233990716, 0.1255332571013027, 0.24801649243319757, 0.17850544826534476, 0.2063837671491494, 0.17583805000967712, 0.2457320521375268, 9.999999999998899e-05, 0.2269230960603179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05082696344762194, 0.0031597167121126812, 0.00010104111605901966, 0.014790786680621726, 0.030602371682417417, 0.05820425753806957, 0.07296813378710554, 0.07553898062284337, 0.011359552196393286, 0.03911497402792341, 0.09753135332094265, 0.019307613403035218, 0.13503141339218072, 0.04993065792554641, 0.05213594400713051, 0.06356620898357557, 0.08458057778799799, 0.20193508363827783, 0.08508725162215702, 0.07946202402142621, 0.10679560699700485, 0.08151776170125302, 0.06730525180337521, 0.0450754245053504, 0.13782720523862868, 0.2619405195994293, 0.0074685837926533605, 0.1984989159487618, 0.14615066210890748, 0.16443083815920723, 0.0863675134742844, 0.521089527474017, 0.613766318366781, 0.5260308052649945, 0.5098297662385687, 0.5556830695017856, 0.20910970499523385, 0.5453768725711152, 0.5836456707217191, 0.5585495653438797, 0.13124381864648837, 0.08894373819703305, 0.06796051815233728, 0.1177877061096042, 0.08356544613546923, 0.1237675950591729, 0.07188815141628713, 0.09361377742667187, 0.07633238391129471, 0.2442445216981708, 0.29448763698249103, 0.17749286663000474, 0.3669546754311802, 0.2611592990030579, 0.29490770524645216, 0.2384516048985481, 0.23172719873171066, 0.21429587139141937, 0.3807716305275636, 0.24200575307704097, 0.27369543309687017, 0.34055485184206746, 0.21153086323132175, 0.29768546236817206, 0.2780456006419074, 0.21423197474692857, 0.2814567720043044, 0.12676755768471326, 0.3102487347869767, 0.1236290032770967, 0.34102883045222576, 0.15221802846580523, 0.19323346476344472, 0.2127484298609822, 0.28817447225234916, 0.06559977353931112, 0.18339201532918858, 0.1774974812018867, 0.19408086785922118, 0.20681338905261104, 0.14603903388564798, 0.18684963536831933, 0.21876023768970954, 0.22836159213927953, 0.258701231675877, 0.2528103399350705, 0.21663799103550152, 0.2412113910657524, 0.2513335227235096, 0.20725910963738547, 0.2209998220269047, 0.20639341325062877, 0.857153093386296, 0.6653549333916188, 0.12005364914857419, 0.11465560306468581, 0.1130243104461548, 0.13001973366886888, 0.2023142340338271, 0.11701295221730978, 0.9353068624794362, 0.11535296188768951, 0.1686476470305357, 0.15468766142037982, 0.21281815212208843, 0.12773019880322956, 0.20982687770961284, 0.15631054656498833, 0.2143309907231633, 0.10542727498927107, 0.1571187275071354, 0.18494097018073685, 0.19227770648353304, 0.2129553674484287, 0.20551396818492718, 0.20495317373891708, 0.18389873085384023, 0.18639072040476934, 0.1971734140948006, 0.19234159566000675, 0.2032248068406275, 0.0956904454057731, 0.08937669277112437, 0.0995100453923935, 0.07432189666843969, 0.1256609470403235, 0.1056033277131917, 0.10297698768819208, 0.08192678751457005, 0.09341491649997369]}, "mutation_prompt": null}
{"id": "c2cf7109-f886-4242-b02d-57db725cae0f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introducing adaptive stochastic ranking probability and velocity clamping in EnhancedHybridPSODE for enhanced convergence speed.", "configspace": "", "generation": 27, "fitness": 0.3739099644274046, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "1c3e8296-cb76-4f1b-be4c-4598d5cf7690", "metadata": {"aucs": [0.9173853810325824, 0.892431679261712, 0.8755740410235016, 0.8491863834331638, 0.8555107880184224, 0.8625104246484685, 0.8936620016916879, 0.8934280401714725, 0.8771815498902144, 0.8019962627610567, 0.6845635139737232, 0.7736346297883878, 0.7712138266449617, 0.6099826247915159, 0.7595861099294839, 0.7078053811888845, 0.7702532780986272, 0.7150900118607251, 0.14295295907862327, 0.14991422588236436, 0.16201654431345902, 0.2656270458244979, 0.14265702826712057, 0.4141699896444634, 0.15390293705630897, 0.1419602616486536, 0.3537188836369354, 0.11841619783298596, 0.13055230226642378, 0.11556780187820137, 0.11992004913055387, 0.22208724621208653, 0.3538129563406094, 0.15499458665541965, 0.11129676182443893, 0.1401393711642368, 0.981668369738709, 0.9774178583678946, 0.9674244706543568, 0.9686587120279522, 0.9503661567601707, 0.9743240469176847, 0.9779036328365425, 0.9521854149086963, 0.9872213712312529, 0.5512605475115883, 0.44987319040319584, 0.42107123201053276, 0.48632159604854297, 0.5039620575291587, 0.5507366360937378, 0.5478830697968604, 0.52594939388747, 0.598902030957924, 0.7848652317912296, 0.32622464167454424, 0.7207168115702565, 0.744496054469701, 0.7520199751737361, 0.6266520231640627, 0.8135425012337508, 0.6029008091253916, 0.7436418282010534, 0.36962207711940365, 0.29110232882877995, 0.24268133529830638, 0.3664812407832927, 0.4584841221875129, 0.3224926625743204, 0.3698358917500756, 0.31512901740448207, 0.3826274459279252, 0.3463041535942315, 0.4144515810519187, 0.19373029683848697, 0.26286052611903776, 0.3961107467563193, 0.35802198413144115, 0.27927698041385307, 0.40910110620315887, 0.21222778669621856, 0.06189885408254481, 0.06817786905241852, 0.11695403019683204, 0.14552719367337663, 0.05492300909008829, 0.1178810278593726, 0.25747797378683634, 0.18229159578732979, 0.005181282718090929, 0.3474769957050656, 0.1840984489529952, 0.34449196504330326, 0.1434598810619665, 0.15390127430372247, 0.06403943084692021, 0.36591438233921925, 0.43333261519494015, 0.2361067033337526, 0.30234343061374824, 0.1892846574633511, 0.17325924808666748, 0.2684394955205329, 0.15803028152872556, 0.1570495062111209, 0.13347393237148042, 0.23370364797502186, 0.07429833954412846, 0.2982037567306175, 0.10203235731516092, 0.15253369012873808, 0.3263232269799683, 0.3031903796794799, 0.30233116715059327, 0.3017496104703211, 0.2926004519642482, 0.2663286402521782, 0.5967742354693961, 0.648308591177264, 0.6558842231397259, 0.5456511115474698, 0.6000478430272604, 0.6279969970510884, 0.7012357549657218, 0.6044880363409597, 0.575379656160688, 0.12013906580760192, 0.10100040007648536, 0.10097629324424795, 0.11147532334713728, 0.11045619651123362, 0.1132168309121917, 0.08435341131716978, 0.11637239590156756, 0.11246822064539286, 0.3803151921634417, 0.24368775760534112, 0.18971454003750055, 0.19600379469540696, 0.2652719064236718, 0.19309012552437965, 0.20022456423826884, 0.18344551206902437, 0.1816448972257042, 0.43211700662396146, 0.36928001622678575, 0.3040522772927239, 0.37202796474975275, 0.3159786684907123, 0.3639144032612518, 0.43940481398305087, 0.4690641762183234, 0.3694501174749326, 0.2963057895654485, 0.3167651381957409, 0.29900763242903017, 0.20802911216340636, 0.272373586771417, 0.28853871878004234, 0.3345781518324974, 0.30200625898136946, 0.2799820380692539, 0.2232324125396874, 0.19196405213516665, 0.20554236515327307, 0.22389383880314861, 0.23948272193615472, 0.1951441184994177, 0.21629666047632923, 0.18926408837440045, 0.18862988049630214, 0.1985350767708819, 0.6108117246956724, 0.22002710979968065, 0.23938157696774887, 0.1999878573079955, 0.2073156914818277, 0.48305395941906726, 0.24712633507572246, 0.21619355348619673, 0.18647086232119514, 0.8994961373467739, 0.15414711860753993, 0.9345997738387527, 0.20079358349780252, 0.1941992557119694, 0.16777242186566133, 0.19394478884011424, 0.7902448782160524, 0.7665889803320141, 0.20414015642819572, 0.6066442285815755, 0.7136839189655825, 0.21015303158635357, 0.6960950619329301, 0.7945759005570198, 0.2041344925411135, 0.47006796983627075, 0.20065964523751445, 0.2297194106858952, 0.19348907738014431, 0.20164502664287887, 0.23239261536358968, 0.1808498030029898, 0.18515578573583402, 0.20151359852881756, 0.19000260849186346, 0.09262468241235489, 0.08159436400115627, 0.0779056241717111, 0.0863688250250827, 0.09010977024595745, 0.08120618043938799, 0.06868235527557409, 0.09398418155404542, 0.09877005231836389]}, "mutation_prompt": null}
{"id": "8aad2565-6100-4c36-937e-a75ed614efe8", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.9  # Starting with a higher inertia weight\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))  # Dynamic inertia adjustment\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = max(0.7, min(0.9, self.crossover_probability * (1 + self.adaptive_factor)))  # Adaptive crossover probability\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Incorporating dynamic inertia weight adjustment and adaptive crossover probability for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.3541758091413164, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.9094547677628243, 0.8888237938349175, 0.9015964222407381, 0.8724589224946474, 0.8804570938152123, 0.8778525930272532, 0.9004931032378679, 0.883795503147583, 0.8988241182172212, 0.7312873066607016, 0.699240186823312, 0.7244913689751598, 0.727760200152706, 0.7392286957282581, 0.7141167475427298, 0.7590076627323789, 0.766115367306121, 0.7267156592675551, 0.12758553144545948, 0.15090776762887037, 0.12241974180045467, 0.12397238644744957, 0.11934747591222872, 0.1505097822319642, 0.12742323209634177, 0.15865872446827944, 0.2807177926643224, 0.1536535096872349, 0.10992113264083869, 0.12142750472297414, 0.10797929782795945, 0.12329372160059826, 0.09757898866081338, 0.11910164683466629, 0.11038667402434965, 0.121376985165219, 0.9580156548068487, 0.9727315111487134, 0.9389965551185478, 0.9644900357241846, 0.9829923386240651, 0.9689574502159294, 0.9202351593529453, 0.9280200480872176, 0.9859727464001602, 0.5717602645628248, 0.564054681451673, 0.4878175250476786, 0.6032428522515305, 0.5967522285666899, 0.5760099632458208, 0.6098646382096502, 0.5753589735460718, 0.5213730178211775, 0.2551563603172704, 0.6551557034391788, 0.20726394854681085, 0.2572802179994442, 0.8647669833027111, 0.3504574877057618, 0.1367215543347975, 0.7838473837700428, 0.21719563213582704, 0.351610420478071, 0.4965419041481838, 0.21031264064928246, 0.4199159768221825, 0.24235404457576537, 0.4928348263135952, 0.16001158148926864, 0.1965420921085237, 0.37471650688525593, 0.36008713042635565, 0.32157065829312304, 0.19808895113385638, 0.47303631331758755, 0.4124955774686254, 0.5477788566678126, 0.3326454359635743, 0.4761598409231905, 0.5298465103374495, 0.09184351994628137, 0.12104920900691485, 0.121995850637721, 0.07124971841951733, 0.09243075085385166, 0.16215659075506905, 0.0711482648496109, 0.19151337120915624, 0.1069806135812128, 0.15202876692004808, 0.1521892160523075, 0.3297351206741004, 0.10086966789913276, 0.2105833694619983, 0.0559897636618214, 0.1585336857096239, 0.46755111083253587, 0.2318389175032235, 0.21801600087020778, 0.19056888935627658, 0.11991803789196398, 0.20746447781304556, 0.23668979046394334, 0.19111077796768383, 0.11345020349853419, 0.24960984753461313, 0.07456158619417852, 0.25251013800835076, 0.27960604329399497, 0.2697811497915896, 0.3431823695775874, 0.32482054433997176, 0.1610440153853333, 0.3244373201142515, 0.27717337041621826, 0.23179999495308934, 0.69749133677967, 0.574782201945436, 0.6341009853785784, 0.4851601778382636, 0.5548613655108644, 0.6431410188842364, 0.5885125432496972, 0.6078850646305118, 0.6213408288781077, 0.08047872194529138, 0.09284090478575557, 0.08561271812869509, 0.1435196187490686, 0.10438661452417186, 0.09519280977375477, 0.12767085210400597, 0.12785370733156265, 0.15243001173772686, 0.21385846654904472, 0.27911298281191865, 0.2446842065167638, 0.1988829828912515, 0.18978171799558263, 0.14419943442708194, 0.2428109093041544, 0.14406257312068815, 0.2734039883914269, 0.46431209661361383, 0.4677264723102392, 0.34180340746561744, 0.3694399583007636, 0.45484573743140677, 0.34947210311366983, 0.46796485758285844, 0.363510973138955, 0.301470150070552, 0.2621066988440104, 0.3256178464372589, 0.21782310981312236, 0.20891049415613427, 0.30319978800830627, 0.3284023093085481, 0.2749422812406148, 0.26044553927882774, 0.2628657542447074, 0.24665212269334702, 0.2345736423035396, 0.20689813909731625, 0.1905318876502089, 0.22217653176139762, 0.22745210844571095, 0.2303551619848646, 0.20813694446095266, 0.2031127618628047, 0.5006621284673067, 0.19780717388673597, 0.5085163560083747, 0.38100278120465814, 0.19661724057229646, 0.2209937580237018, 0.38079006772511637, 0.25424949720663803, 0.20212433036782362, 0.19661265161762576, 0.18770316123325959, 0.1481411228744438, 0.924327005540329, 0.2011538480086731, 0.836985371204263, 0.16818881622823134, 0.19412021401560542, 0.1928344433072281, 0.6491824789651559, 0.16649403437554755, 0.8080800411484614, 0.21026298707737046, 0.2110412025590257, 0.7478129596081027, 0.40924706670707633, 0.16757725224403164, 0.4239414095204498, 0.18434210928623673, 0.1941842666431115, 0.193652681949806, 0.1958015106100024, 0.18450707905972608, 0.19772276750572482, 0.21056331353684887, 0.19162521886189787, 0.19133690668900827, 0.07801558104567552, 0.07387582372151158, 0.08471629589172713, 0.08793087275697231, 0.07059986006107588, 0.07204042652889708, 0.07984994966519987, 0.07852991693294442, 0.06894951427033325]}, "mutation_prompt": null}
{"id": "5c9bb017-51ad-4a8b-9e5d-141fbb0b02b1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            # Adaptive mutation factor and dynamic swarm size\n            self.mutation_factor = max(0.5, self.mutation_factor * (1 + self.adaptive_factor * (self.global_best_score / np.max(self.personal_best_scores))))\n            self.swarm_size = max(12, int(self.swarm_size * (1 + self.adaptive_factor * (self.global_best_score / np.max(self.personal_best_scores)))))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation factor and dynamic swarm size adjustment for improved diversification and convergence.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {}, "mutation_prompt": null}
{"id": "9a41a547-d1c0-4e56-aae0-2c64fb65434f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.02  # Slightly decreased adaptive factor\n        self.rank_probability = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight - self.adaptive_factor * 0.1)  # Dynamic inertia reduction\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.mutation_factor = max(0.4, self.mutation_factor * (1 + self.adaptive_factor * 0.5))  # Adaptive mutation adjustment\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced convergence by introducing dynamic inertia reduction and adaptive mutation factor adjustment in EnhancedHybridPSODE.", "configspace": "", "generation": 30, "fitness": 0.25918912737726924, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.74327020713515, 0.7322364783508609, 0.7536411763588895, 0.7268187097769923, 0.7297860315318466, 0.7512133931779675, 0.7428814362854179, 0.7390148296591159, 0.7294545678580584, 0.5042677745241175, 0.41450953724551387, 0.47171817207831057, 0.4622913344771661, 0.034416662221200545, 0.4638161634953297, 0.4932329136934517, 0.5281402374846971, 0.4709208672023366, 0.09062908054631647, 0.149629066726078, 0.0668491699417848, 0.10626260918546904, 0.10757326534732825, 0.1393032841172004, 0.09889514946481737, 0.06906798427456251, 0.09355932931266375, 0.08383869144140554, 0.08492984582500818, 0.09490546190128768, 0.10846705105976051, 0.04924877608810818, 0.04167941742347525, 0.10968119519206265, 0.0580990175548588, 0.06861281615085313, 0.9752908005020811, 0.9761131766920805, 0.9761133572126942, 0.9684876204943864, 0.9665131742413571, 0.9787028412332143, 0.9683069273083699, 0.9539242014801026, 0.9854029417598833, 0.46690153828828906, 0.43173112893148813, 0.46123382436025295, 0.4490863826111269, 0.4138421263740897, 0.4700979852845425, 0.4605185061726623, 0.39358749401975424, 0.42404769804405973, 0.38801535845786306, 0.16908761206519107, 0.168188570526822, 0.27660320203028566, 0.21294722134262833, 0.27415561243450903, 0.21203411658675397, 0.5263240998011671, 0.17830399253350293, 0.1936426667399882, 0.18409714976686276, 0.14985567248773424, 0.17962293308676436, 0.206310935997026, 0.1359337605677865, 0.16830217799535463, 0.1325016765036242, 0.17332978247787323, 0.17870255218431352, 0.18762968817645165, 0.1292356288062083, 0.1590395881260228, 0.13091369382582763, 0.17429318982996156, 0.19218450235441742, 0.130549321013547, 0.21773851110062648, 9.999999999998899e-05, 0.0027656827245288174, 9.999999999998899e-05, 9.999999999998899e-05, 0.03592995844351954, 0.045262570275914404, 0.00011006894675225087, 9.999999999998899e-05, 0.002100859532975896, 0.10378851720715554, 0.06679789425467864, 0.12577711372061862, 0.06359168844993979, 0.04130966748594889, 0.03834948973531849, 0.09371559732471235, 0.06543170061678083, 0.06445170788517118, 0.13079912497038926, 0.1294851303445681, 0.07889125097902983, 0.06426583386596807, 0.07335781939707264, 0.06299029642059817, 0.08637075056082377, 0.15537213406765782, 0.05919581726468315, 0.18081342366418873, 0.10626017639485985, 0.16963622339642404, 0.10962083768537545, 0.17371967309094694, 0.22005610979060197, 0.07671535722277534, 0.2016190421947336, 0.07936835015274335, 0.5300093190152677, 0.5077063969312716, 0.49123992312279596, 0.5383005727997594, 0.49460844063737786, 0.47562171510026563, 0.5104332469977044, 0.46146627351710756, 0.47260927829200194, 0.056073632708793175, 0.0886178732587316, 0.07771906418556096, 0.11545951046067804, 0.0790773138571873, 0.12020960501567535, 0.08586314108456716, 0.07655276196638683, 0.0769377352187739, 0.20033720637371666, 0.19199592638025076, 0.21073866991710077, 0.1809972278363683, 0.25686040795324416, 0.2448548523504036, 0.23997485085993453, 0.30814841116632874, 0.1959425620563543, 0.18610427736626012, 0.2103677883429267, 0.18782754764435616, 0.3522726412466832, 0.2858594533856398, 0.19515463221778062, 0.22665131341188016, 0.38200509312995656, 0.18703095060002917, 0.25540314469126546, 0.2510420440582398, 0.14087151410412702, 0.23132827132624634, 0.16100621146198302, 0.30369812963036, 0.13052391084580905, 0.24225546484571991, 0.11749776861442807, 0.2359837442435344, 0.22562602609844584, 0.2091713353005189, 0.20479801822540145, 0.2059397365712522, 0.23536590113132416, 0.24570808052164228, 0.22880842013198233, 0.21731135318472283, 0.1969560945327028, 0.17074194180127145, 0.19776180033264068, 0.17425616686713252, 0.1904989578625681, 0.17912390692139146, 0.1764640121426292, 0.19718322145825207, 0.19640980547792464, 0.1874624526329871, 0.18743821505340352, 0.17147998463972924, 0.8448957835086226, 0.19996732361739067, 0.15491614751983562, 0.16786222307216414, 0.1652136389688561, 0.15687074819588975, 0.520870542809531, 0.16653622031477044, 0.5997062955387235, 0.20852500839832666, 0.18047880920316617, 0.539075414256332, 0.15945459792881644, 0.16681212138744728, 0.50101476192083, 0.1933637349019296, 0.1959985986412972, 0.1905568032318814, 0.20567925140529653, 0.1859720783652551, 0.20358054520299707, 0.22267181580817919, 0.20707336627528805, 0.19059778634665048, 0.08692318806607635, 0.07443615546833282, 0.07708931868493096, 0.0669630802869966, 0.07651291484466272, 0.09648813522222122, 0.06445577957642112, 0.07472545139723863, 0.0991921079985747]}, "mutation_prompt": null}
{"id": "467d72fa-9af8-452f-bc47-b3c241408d1c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.velocity_clamp_factor = 1.0\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.velocity_clamp_factor = max(0.3, self.velocity_clamp_factor * (1 - 0.005))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -0.5 * self.velocity_clamp_factor, 0.5 * self.velocity_clamp_factor)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            adaptive_mutation = self.mutation_factor * (1 + np.random.randn() * 0.02)\n            mutant = np.clip(a + adaptive_mutation * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic velocity clamping and reinforced diversity through adaptive mutation rate.", "configspace": "", "generation": 31, "fitness": 0.3582507337769169, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.9066196463216308, 0.8990725725902676, 0.9175119088645242, 0.8420252165514895, 0.870737283725441, 0.8848631842703001, 0.8500110212853063, 0.8799502559155176, 0.8744369470478319, 0.7462034426428859, 0.7329116115334118, 0.6909166188360361, 0.7475665109799428, 0.7436874686604337, 0.7622446540855473, 0.7688693592043582, 0.7414998062804428, 0.6859652444491346, 0.13474376720887904, 0.14726671554242587, 0.11221535542984507, 0.1522052951226105, 0.12986954047795007, 0.12942406565032993, 0.06557467742534917, 0.3805081462619484, 0.16068215749202464, 0.1292558331239021, 0.10604583262932665, 0.1380856463961342, 0.17266525775771735, 0.14982710247743758, 0.10726922801846772, 0.13697642931827336, 0.2712862989790811, 0.1127627070685725, 0.9714941566055189, 0.9622520222331303, 0.9610609029136636, 0.9550295963117506, 0.9689905516390698, 0.9675492028700777, 0.9570150133020997, 0.9522997742236258, 0.9806276499980959, 0.5928091929586351, 0.5666466575632123, 0.5319777670160909, 0.5484801137223643, 0.5411334693535037, 0.6024778360799582, 0.5522708730727595, 0.5227132841210593, 0.4976001983992605, 0.6847583204316878, 0.6913223016651785, 0.7025495184182986, 0.7634454290775232, 0.33838318207503326, 0.333940269303995, 0.7813882358150914, 0.6157014262072724, 0.7916940926734641, 0.37536278051611116, 0.23296954936793013, 0.23375051688549298, 0.21872635868523516, 0.3801052942893782, 0.18670084230322892, 0.5532841904949801, 0.36540580196447703, 0.3435590387004661, 0.29014159409046025, 0.35563336511439325, 0.3662810263283848, 0.33278874904145495, 0.33984782945179937, 0.2795368757936817, 0.2676169403848787, 0.337158475148405, 0.4375302811983991, 9.999999999998899e-05, 0.11870447281583274, 0.06780517052826396, 0.058992765297489314, 0.14551360542954694, 0.14835094011540717, 0.3086556973836566, 0.0945445717420409, 0.33069372004590547, 0.272885759834413, 0.19452663305122264, 0.21321897770668907, 0.22507232336688843, 0.12416686704541058, 0.04519551417206824, 0.12097226161918484, 0.12530658517172966, 0.48072752078030967, 0.17196445027631613, 0.26168475030123084, 0.5173944290624491, 0.156009284044893, 0.2748916065386897, 0.16796098365145973, 0.24787221623429745, 0.23507621285237934, 0.1405705286929937, 0.22899788785252362, 0.1731427204133179, 0.3061325592020345, 0.18511997589654672, 0.28066852090314054, 0.26066672256278733, 0.29752863275995745, 0.26505543062395676, 0.2318255950293321, 0.6577687157774426, 0.6278177320004199, 0.619674270127202, 0.5972192211315664, 0.5972416406560841, 0.6642535416075842, 0.6982512357524266, 0.5790079499241307, 0.5704802245407539, 0.09779520892412896, 0.10607524868711882, 0.10451490702478428, 0.10111555339876122, 0.10134271323710564, 0.09985556844513299, 0.0940376599741628, 0.1512471741931518, 0.10400329249329476, 0.20432195818338683, 0.22180781257206217, 0.24857442216620973, 0.3314429072540237, 0.3431529731632743, 0.18327646732391167, 0.21620334516973017, 0.1725963108751244, 0.33036839137984664, 0.31126785315944316, 0.41649640159358736, 0.3757729359191714, 0.4158786828680089, 0.35474114882673613, 0.40010231051151346, 0.4144254046680459, 0.40385392899324, 0.4327806192743283, 0.25902421766687356, 0.28885752621696004, 0.25064247500324033, 0.2031627730285127, 0.2873041522895756, 0.24453108267950296, 0.3053679894542213, 0.31461146936911677, 0.25667851367657135, 0.23703570830446996, 0.22421803077693425, 0.22741155856956352, 0.2526355996827535, 0.23407811361682973, 0.18369001913253935, 0.2276945845877819, 0.2202989023649632, 0.21547299598707237, 0.1770638978528981, 0.19404965680780217, 0.1895895053015112, 0.20275852043289966, 0.23493277875139607, 0.6106416232887328, 0.20879066988309203, 0.3018873266683175, 0.1988108409371775, 0.1872501785940801, 0.17704447734712525, 0.8522313079398727, 0.9242937035471813, 0.2003411401842945, 0.16382421739291697, 0.16784679805237868, 0.18850796403154202, 0.1529575021416213, 0.6560001817830003, 0.2054827644071886, 0.5701775024994136, 0.20315178944402246, 0.20835677709410627, 0.2082634436694054, 0.12647840444511982, 0.16654159365252075, 0.3931171137035855, 0.19092725214054473, 0.20054751201396792, 0.19955997704251338, 0.20556677886304808, 0.17917030240530907, 0.1941476887883442, 0.19203685707017915, 0.21070005269110348, 0.19357972677068513, 0.07790305845986167, 0.07541483151355644, 0.07909391665877552, 0.07153455600572067, 0.08102358454299718, 0.1298435930744839, 0.0782875982993857, 0.09799554418947531, 0.08118929078680726]}, "mutation_prompt": null}
{"id": "2e32a707-7238-4608-9164-f00e42ffecd2", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Slightly increased adaptive factor\n        self.rank_probability = 0.55  # Modified rank probability\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Enhanced adaptive factor and rank probability tuning to improve convergence speed.", "configspace": "", "generation": 32, "fitness": 0.3556015843410421, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.9116655670667696, 0.8835150649651357, 0.9051596538383745, 0.8656265530469441, 0.8650988608200312, 0.8807915992731585, 0.8793080347815543, 0.8818584104048078, 0.8684251378188497, 0.803830525842352, 0.7227124807338734, 0.6983839566984004, 0.7535968651413814, 0.7370900513052359, 0.7654971769189141, 0.7630918859258101, 0.7391030316419946, 0.6887601177639027, 0.13709698444887564, 0.2640787693089479, 0.13356155021805538, 0.563058232502893, 0.40848023459890026, 0.17964939019460058, 0.06814397959774399, 0.1423356219248233, 0.07125611101449958, 0.12458389299232864, 0.3668764640668394, 0.15876778520683288, 0.09613052656531729, 0.12736576461185178, 0.10532328996662943, 0.1503445731539379, 0.1298207255582553, 0.1302961529097707, 0.9792348658772275, 0.8077560232597503, 0.9766045644076262, 0.9632523535980692, 0.9635058894232534, 0.9891522713669594, 0.9570610680897143, 0.9653775520429289, 0.986953280220646, 0.5792128391486211, 0.522694772642466, 0.4947612644303583, 0.500738533928814, 0.5457865372527011, 0.5733033697086563, 0.5491293432118891, 0.4133735166247031, 0.5457287794422214, 0.23091644263212885, 0.6435793737747556, 0.16584523380665028, 0.7699374564578705, 0.2009010734073311, 0.729856041049453, 0.6733639588553133, 0.6428023415312155, 0.6058459601853254, 0.22945671512358168, 0.32030847687092356, 0.3422691730272268, 0.1622195818169817, 0.38332233424944484, 0.3312923757597489, 0.42439053424417716, 0.2908671382103637, 0.2483150531464, 0.33379327652971946, 0.3076998656504828, 0.28628093010748157, 0.37443354991182043, 0.29091660971453426, 0.31205403365851303, 0.3130432376737764, 0.46758287329093384, 0.32321471481947806, 0.015811411553454113, 0.0888650584253119, 0.11188726770823632, 0.03921963061453093, 0.16152400110845178, 0.04981120079720425, 0.1688053260793264, 9.999999999998899e-05, 0.07483340893651125, 0.2105392724547238, 0.29151810680137646, 0.3309705047533341, 0.2308584998089751, 0.1292036954435234, 0.10693195672670097, 0.1738648280976247, 0.13600868724972082, 0.3636128415122938, 0.18599801740877508, 0.09925624197191296, 0.1784833449348605, 0.17674241030174198, 0.14103471584027016, 0.14916652877066827, 0.11906489682068278, 0.18793478151172538, 0.1801379795589626, 0.21598003456125892, 0.26808627289759845, 0.27765241883014247, 0.29627523975528924, 0.29975296711214416, 0.33652657326865243, 0.0765044890956117, 0.2112812321902633, 0.19362995901776225, 0.6094230784401707, 0.5912762297854945, 0.7272493462899173, 0.4805000634424311, 0.5817345117341519, 0.6278247380134574, 0.557370320112483, 0.6316453334511762, 0.5663981724927758, 0.12079824500573655, 0.12560727655352022, 0.3149191147762076, 0.1115879081522767, 0.0879996643055927, 0.11739848240278694, 0.10146960695593132, 0.13056941421756196, 0.0859486962421635, 0.24577306238216257, 0.2820868756402809, 0.4642474983964797, 0.2088584501709082, 0.30821747403122957, 0.14825672160944792, 0.19844559483250834, 0.2405398787208245, 0.20552332575315946, 0.3511670627092176, 0.3831527400770991, 0.30599030655589476, 0.33290582814188574, 0.5302123610157456, 0.3793961576164294, 0.3685088601135864, 0.3829400631390184, 0.40359494722277256, 0.1673669026922444, 0.25503462039941727, 0.22943440869538545, 0.2164859060711365, 0.3359560175125329, 0.29473441891495467, 0.255435063007479, 0.29692816961234725, 0.2663527373660156, 0.2548137724607007, 0.19351451017151144, 0.2056625551493546, 0.19433339404019845, 0.17834019375779275, 0.21604884007742575, 0.2391641228121948, 0.2148315503498498, 0.22328646386994844, 0.44681405208012137, 0.23612067896035682, 0.21142007736838941, 0.5231701088355566, 0.22004912189704828, 0.2336702192293686, 0.23841771094291864, 0.344786885064607, 0.17883148669034543, 0.21086510889437904, 0.8492747261074933, 0.7865504810207133, 0.9347656521677509, 0.20086017247947163, 0.7494518250615956, 0.1691547208877342, 0.19362946137818904, 0.16966181025707827, 0.5584129512893534, 0.20751070801519456, 0.7342118068585317, 0.20513375557825964, 0.2097819855709817, 0.20863529069087983, 0.1530115271182123, 0.16196023856228547, 0.4596208336673536, 0.17944586711448451, 0.21939098231204968, 0.18129034687662737, 0.20613704931816523, 0.1938529893540356, 0.21207464430826184, 0.17901961525415921, 0.20028501298296375, 0.17356500926086504, 0.0665544464372062, 0.06934157314777134, 0.07022040681707586, 0.08746437782136274, 0.08888516508080924, 0.13653587468610262, 0.0635885159095082, 0.09755367220903388, 0.07500820970701061]}, "mutation_prompt": null}
{"id": "2675fa7f-bc26-4c21-b3b8-fb21c5fc4162", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.7, self.mutation_factor * (1 - self.adaptive_factor / 2))  # Adaptive mutation\n            self.crossover_probability = min(0.95, self.crossover_probability * (1 + self.adaptive_factor / 2))  # Dynamic crossover\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and dynamic crossover for improved convergence.", "configspace": "", "generation": 33, "fitness": 0.3170128440572461, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.9173853810325824, 0.8930498438113282, 0.8755740410235016, 0.8470931826928646, 0.8576893297149598, 0.8787670914819902, 0.8943169422821468, 0.8949308218509124, 0.875352757377681, 0.8016208088941452, 0.7577755879164376, 0.7736346297883878, 0.7631415793073606, 0.6018223912068827, 0.7623449586384361, 0.7065859242770052, 0.7688444679920328, 0.7503998609733947, 0.1459983156094219, 0.1448741825296045, 0.10082940992947564, 0.12213509441436277, 0.0938728117440305, 0.10995053651582964, 0.07741721989834716, 0.10955955120140315, 0.5972184819585242, 0.10693861232789226, 0.11683857190248581, 0.09682692276751315, 0.0860063770415258, 0.10107203258119513, 0.0660297637627616, 0.08929872426566032, 0.118280625338268, 0.1048665044187661, 0.9528843179412408, 0.9546278472666393, 0.9535042695045786, 0.8806836551024798, 0.9307605059233202, 0.9415218598474057, 0.8023445986059062, 0.9582147690219769, 0.9728456497385971, 0.5513228955675615, 0.4541885603110525, 0.42143436284261804, 0.45756483166875983, 0.35527604749487984, 0.4641231010913349, 0.5240939461208401, 0.41198825089471114, 0.34699395236782127, 0.17753661687229083, 0.381386532562792, 0.3775407933302669, 0.3666575090612112, 0.27025109050042206, 0.2173972892117082, 0.8673685873982222, 0.8124674224359567, 0.8903779450095932, 0.2126368295817681, 0.15794754458634652, 0.17888971545103816, 0.17694955698103199, 0.3659780632500125, 0.151195489748854, 0.30180241313484346, 0.1588883753698085, 0.17518407415816017, 0.2024735673467417, 0.1932776937059969, 0.19373029683848697, 0.24718010257490808, 0.19042292939699812, 0.16154693739171866, 0.215293273083076, 0.34231019578207067, 0.21222778669621856, 0.1425308521979115, 0.057616097725938786, 0.08398197884498981, 0.08670868729173165, 0.07306405631061152, 0.07602089405333734, 0.07036674595398984, 0.0038973502484624944, 0.14248555850152111, 0.16830789597688067, 0.14131051827803054, 0.13338916312612314, 0.17445627282088494, 0.10660366570271018, 0.17619156930597468, 0.2212902025230281, 0.2572686867543439, 0.317565099417936, 0.305178957096338, 0.11916040316106769, 0.17325924808666748, 0.1763405864404236, 0.11678643653081833, 0.14459997151684334, 0.11957851738742997, 0.1962345756637861, 0.07429833954412846, 0.30618328227045466, 0.10527543558644159, 0.15276795514341934, 0.18737486462324326, 0.2570339447609584, 0.23665199306702855, 0.1362969023264028, 0.23173669511524064, 0.08136403961059036, 0.5520510831235428, 0.5424283645653263, 0.6593968215155306, 0.4838478187798314, 0.5654760377571219, 0.4798454720610913, 0.5449629882274277, 0.5820465042328544, 0.539847450083436, 0.08368159428740796, 0.06774571843399013, 0.09889650914017889, 0.12980628713183018, 0.12207216158574752, 0.09369760508603309, 0.0829801191570132, 0.09284281494431612, 0.12350778814218266, 0.38042292589027416, 0.2387960989559651, 0.19616860823348814, 0.19038054506052482, 0.2652719064236718, 0.19514519985884904, 0.20020493473928502, 0.18019326958415893, 0.19231690315635175, 0.2531968835930464, 0.461407557743996, 0.43401109184706277, 0.26747280720921496, 0.43972113536178126, 0.2517530893532537, 0.33042193414318966, 0.32004463477924305, 0.2992779040748219, 0.2957249487860696, 0.23946291438622314, 0.3074471461152861, 0.1902365657812134, 0.3176348897456607, 0.18141025998063287, 0.18962673779261763, 0.36280265339408246, 0.21037753450880015, 0.2283119051276319, 0.19239162585572567, 0.2018462387486536, 0.24827263445680492, 0.23973239730527407, 0.19519649130441363, 0.22555069495413393, 0.19267202189625887, 0.18506325125606493, 0.1974766846125392, 0.18783828790092305, 0.2114947109212879, 0.20013605820392677, 0.20582854938765227, 0.2199194796960231, 0.21755030150258314, 0.222291629264585, 0.19651110915493275, 0.18656886415403307, 0.9002703783521249, 0.15374030984852294, 0.9345567576819507, 0.20079358349780252, 0.16535462286924718, 0.17166971380201412, 0.16922019466408234, 0.1577461654983956, 0.5113461187264601, 0.20972944613081967, 0.6059962987765763, 0.20711387316205787, 0.26737801576908315, 0.2095525545382566, 0.11184084656418558, 0.15180410428811209, 0.4700482946797815, 0.2088697603156524, 0.22972958642826957, 0.19106492798781094, 0.20190942104956988, 0.23245369387299653, 0.17365412490106624, 0.18524477210405643, 0.2015248730453465, 0.1829473355177813, 0.09262468241235489, 0.0849477532030305, 0.07675900366656951, 0.08640660168570158, 0.09081627637010337, 0.08315762783855041, 0.07641179563743483, 0.09401864003629778, 0.09854217277894695]}, "mutation_prompt": null}
{"id": "f3937721-2fb9-45de-96c9-4f89a3823f4a", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.penalty_factor = 0.1  # Adding a penalty factor\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.penalty_factor *= 0.95  # Decreasing penalty over time\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c) + np.random.uniform(-self.penalty_factor, self.penalty_factor, self.dim), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introducing an adaptive penalty term to broaden exploration and enhance convergence efficiency in EnhancedHybridPSODE.", "configspace": "", "generation": 34, "fitness": 0.37048331388394506, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.9029690717530546, 0.9132805371351517, 0.9174501393233399, 0.8114745393515772, 0.8887346356080501, 0.8913606190858717, 0.8928836033862597, 0.831211257648746, 0.8505802782537342, 0.8150801508279337, 0.7776190521538991, 0.7055950034150573, 0.7716669670121084, 0.7168940559626416, 0.7743361699848694, 0.8070185239896459, 0.7758515526094055, 0.749114204383023, 0.14278512904326002, 0.13489262788172818, 0.4075656952202734, 0.13808997032991188, 0.16333917989567803, 0.4650597746328331, 0.07778829552858801, 0.20527887544919776, 0.053886266039831154, 0.1429370295051785, 0.137329979727016, 0.11851712158974659, 0.15666105346373715, 0.12423573334383586, 0.14088700547937894, 0.12670582426584098, 0.23291022020290764, 0.15333410154019766, 0.9530704525313356, 0.9048625951680174, 0.9479532208976358, 0.989533495077156, 0.936841990348202, 0.9413622157869841, 0.8983671176370748, 0.8882610151370797, 0.9005673312720675, 0.5935026528950592, 0.4931439521635712, 0.5303401886172929, 0.5887817372547495, 0.5520477258312433, 0.5686292800741172, 0.5785976510024112, 0.5759032821878087, 0.4943765493028963, 0.6264945940711408, 0.1133589729168436, 0.5766850021352654, 0.21053777731353762, 0.803796932213255, 0.26836455001861614, 0.6531673566679805, 0.7756600970480146, 0.17285102627464743, 0.37975813992230023, 0.6096009775271252, 0.44781026136366886, 0.5006012681728358, 0.468182788984156, 0.1616479229584442, 0.4590188606200639, 0.49704624228920424, 0.5721029377868085, 0.18123805270165316, 0.15667646672930058, 0.31933055325989534, 0.28415392773707004, 0.482235691906612, 0.30083593080920945, 0.3327723250792758, 0.2490550129512008, 0.2409328834890152, 0.172570529213938, 0.06433488299882117, 0.09765163418772549, 0.04262715022440078, 0.3645466586516064, 0.28189823452575735, 0.12611257177556068, 0.18563611895437193, 0.08689905490383676, 0.31258923304877284, 0.2412780744268498, 0.11033833480789634, 0.3637637816082322, 0.35112634668458753, 0.134679078361304, 0.3282024112053916, 0.12104772347002546, 0.4525945839936809, 0.2521607342656753, 0.3429731040591263, 0.258272674966327, 0.16246446190002717, 0.2443412104262822, 0.14539242584593737, 0.17632461671364652, 0.18304503874964917, 0.1153786474294779, 0.22000570437494427, 0.2950898043845658, 0.22295194753937708, 0.29875077562527097, 0.35779832611476603, 0.2997621872923024, 0.239543421983628, 0.39226288781514584, 0.24931581713008777, 0.6860424211093136, 0.6156296181690587, 0.5991015484089233, 0.6062658288556286, 0.6446951058354897, 0.6662133298089081, 0.6966843058657095, 0.6026151284426079, 0.5874307674899093, 0.09145548262213599, 0.10560658209818174, 0.09169358863696775, 0.09931046799292509, 0.07838757837211674, 0.10540523050730477, 0.14666871600181908, 0.08237859958780314, 0.15386694056226147, 0.21825785922832597, 0.2503488062187532, 0.15389400523029506, 0.2719343091821156, 0.36296462118993034, 0.18738504360668262, 0.20272376208092824, 0.23011765158224684, 0.19171834900693252, 0.3604011242930808, 0.4058256667067198, 0.44654287948791116, 0.3209614574945284, 0.33075550750283733, 0.39070418242093075, 0.4128566410191744, 0.41660474843173856, 0.3973738489273725, 0.21500025794913968, 0.18383883173557303, 0.27910465341265067, 0.28775522247817875, 0.2467919169065932, 0.3041965930824748, 0.2436891451253549, 0.29286432286453834, 0.2918128377622484, 0.22306992317095764, 0.2231830764669216, 0.22023667405318126, 0.21712360533870056, 0.21772735424561984, 0.22229323494926434, 0.21648015566274492, 0.21718643253074776, 0.2266514590511396, 0.5979725758932617, 0.5047321055165532, 0.6341597808914627, 0.5117785297855121, 0.3194602778131337, 0.18614630119298758, 0.21592816112709778, 0.2130068776762991, 0.20269961168648964, 0.19769537505080592, 0.18978476463294114, 0.16038725655400465, 0.7494182376967131, 0.20057514812452915, 0.17707104062693524, 0.18356792771154617, 0.16379884983744175, 0.16322538841696965, 0.6488500310689248, 0.6074888556943769, 0.8029303683878163, 0.7761360033417204, 0.20760701120806857, 0.20449441250329092, 0.20424674460099645, 0.8400786307265162, 0.4323090406395337, 0.20808667667502323, 0.18725774427353392, 0.2033326594718462, 0.32411052888867775, 0.21564812417225088, 0.1985622809261014, 0.20252203844551198, 0.2170499510852636, 0.22230830884754194, 0.10711050920178045, 0.08943449736199749, 0.0841782741805106, 0.10632359542176961, 0.07562934239974328, 0.09742109249398523, 0.0951405336483786, 0.08018695393634734, 0.08560253751799518]}, "mutation_prompt": null}
{"id": "bb3df231-f7a5-4f28-aa04-12cd403f4f1d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = self.chaotic_initialization(self.swarm_size, dim)\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = self.chaotic_initialization(self.de_size, dim)\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.learning_rate = 0.1  # New adaptive learning rate\n\n    def chaotic_initialization(self, size, dim):\n        chaotic_values = np.random.rand(size, dim)\n        return -5 + 10 * chaotic_values\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.learning_rate *= (1 - self.adaptive_factor)  # Adjust learning rate\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = 0.5\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.learning_rate * self.velocities[i]  # Apply learning rate\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introducing adaptive learning rate and chaotic initialization to enhance exploration and convergence in EnhancedHybridPSODE.", "configspace": "", "generation": 35, "fitness": 0.33650929049430967, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.8275917061083466, 0.8122854039754608, 0.7737363973035987, 0.8379180814926157, 0.8370405001520844, 0.8221980618305532, 0.785388624319546, 0.8139535640899074, 0.7976363316841927, 0.6874201822216162, 0.6794033705363127, 0.6712631138960151, 0.7080996639136623, 0.6099826247915159, 0.6945959471952123, 0.6725589660864729, 0.690938973978823, 0.679963242969517, 0.13990252774004297, 0.12107496047438782, 0.16196985559140287, 0.25959626005993397, 0.14202306209742988, 0.4082565322234605, 0.15327092606847215, 0.14192238953092762, 0.35360135739323284, 0.11783275469723609, 0.1300566519494596, 0.11461817073317393, 0.11537963318705347, 0.22208122487175375, 0.35298092676404336, 0.15483630812147908, 0.1112786040863255, 0.13819752183622225, 0.9816678624215414, 0.9773760500827183, 0.9674221001758921, 0.9686515118169169, 0.9502173856612296, 0.9743240469176847, 0.9778962104278014, 0.9520618841686861, 0.9872213712312529, 0.10530532690666206, 0.060284056813445175, 0.058529288436650284, 0.4319148169240379, 0.48242944137147725, 0.5328701655785202, 0.4512775265567791, 0.5250873864145498, 0.598902030957924, 0.7808356488505213, 0.32533433233337206, 0.7180375907468172, 0.7210459457538465, 0.7520199751737361, 0.6252989275599978, 0.8134798935515799, 0.6029008091253916, 0.7416979764526712, 0.34103423160906754, 0.28527415133857326, 0.2364887937458704, 0.36198190987561096, 0.37635685706400723, 0.3224926625743204, 0.30135243651045496, 0.3085917683776721, 0.36961865474090205, 0.3363422793425268, 0.4144515810519187, 0.009865986225683576, 0.24616521063668295, 0.39133628544134313, 0.34235559655445547, 0.2531341838194969, 0.32274203764678755, 0.12058489561075525, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.05455700243036321, 0.1178810278593726, 0.2548056643512837, 0.18229159578732979, 0.005181282718090929, 0.3436944295322203, 0.1838797430547826, 0.3423989532613144, 0.14151498486102176, 0.15390127430372247, 0.061986982306929006, 0.3635691255505933, 0.43310199539381133, 0.23368844776939213, 0.06250567677629892, 0.16076785030370122, 0.05333013211716531, 0.22562305168153785, 0.13509063085636697, 0.12919680606183426, 0.1216741247785188, 0.18103041672160214, 9.999999999998899e-05, 0.2982037567306175, 9.999999999998899e-05, 0.04159898115521332, 0.3236979776385721, 0.2652830387402644, 0.286895070345368, 0.3017496104703211, 0.28882479807225814, 0.2641470366072626, 0.5475862886781002, 0.6301815286600431, 0.6370235281765477, 0.539699150179143, 0.579691776266896, 0.6259668525392311, 0.6724374735210523, 0.5857188444981636, 0.5449336928028247, 0.12011780791582183, 0.10100040007648536, 0.10097629324424795, 0.09071153052374248, 0.10747394672495247, 0.11166248743138163, 0.0794851427233434, 0.10676825425945313, 0.08067919720160877, 0.11733700374409328, 0.22903149476095808, 0.18287078470084206, 0.1964903823078069, 0.1770927661859174, 0.10576655827373926, 0.16446157185848898, 0.15336415688855976, 0.13542287032000733, 0.4314669993961747, 0.3640425117974091, 0.30359030993377356, 0.3669810740880395, 0.3049173090993782, 0.36390558236395465, 0.43940481398305087, 0.4689965521960259, 0.3693981076577968, 0.2961367105788649, 0.3161464752092197, 0.2984291292017186, 0.20638715785838835, 0.22218002554413074, 0.28864983315621495, 0.3344918956352081, 0.30088916331156734, 0.2799771205931334, 0.16872415971644628, 0.15973621565277973, 0.19557634475395302, 0.17665350524267254, 0.21301245035172933, 0.17816797758474368, 0.18239851800562934, 0.167860584743443, 0.18807027279255883, 0.1976870188161951, 0.599282014028915, 0.21000706377027023, 0.2261001194111948, 0.18827582449933533, 0.19688526978545373, 0.47808695568789306, 0.24350876177755432, 0.20578964008143252, 0.15983672766555823, 0.14666067822092643, 0.15412839322072702, 0.12995819076371062, 0.12094049886324487, 0.19324196462137777, 0.15924499711187146, 0.19225954714825488, 0.7892785826908542, 0.7235869821703869, 0.20286958378861397, 0.16561116945215526, 0.7051230294129905, 0.20553906862717353, 0.6826064000986449, 0.7945759005570198, 0.20413375354169083, 0.1978694860328689, 0.19299139332238746, 0.20226894578944454, 0.1908172426516498, 0.17775443274625014, 0.18101526149427205, 0.18552276381469746, 0.1771391062673343, 0.19388075322510645, 0.19039745318263335, 0.06565264859827769, 0.0794980697535913, 0.0730536896204721, 0.07864352885057979, 0.07696631315675351, 0.07656318900302883, 0.06040181198762462, 0.0826772136519679, 0.07060301132381397]}, "mutation_prompt": null}
{"id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic velocity clamp adjustment improves convergence by dynamically adapting velocity constraints.", "configspace": "", "generation": 36, "fitness": 0.37524623634370086, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "c2cf7109-f886-4242-b02d-57db725cae0f", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8584338121925901, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6113605606819082, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.7125720180140063, 0.1411027963989001, 0.12993829213589236, 0.1620165661053219, 0.26275494606005845, 0.14356280601529747, 0.42326673941406745, 0.15401863110513692, 0.14292710918636908, 0.3547024676230244, 0.11837630001122523, 0.13119514801303345, 0.11636033082333308, 0.1228625376535547, 0.2220816350413497, 0.3540368341164729, 0.154951740621183, 0.11138460617349832, 0.14079617224654217, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.45565485380186344, 0.5769550403384566, 0.5521475238968264, 0.5936515054926761, 0.5464352975295845, 0.6153065339820311, 0.7849765247621938, 0.32688973948200706, 0.7203638848494625, 0.7291714728505716, 0.7520199751737361, 0.6386134782507928, 0.8135912774278522, 0.6029008091253916, 0.7434713893031137, 0.396753927786463, 0.2981326219235003, 0.24698706275401516, 0.3668009865729318, 0.3891836298884259, 0.3224926625743204, 0.49879768686796755, 0.3151097726146713, 0.3790223741899933, 0.3457818617852588, 0.4144515810519187, 0.1953146121273156, 0.26361509384874116, 0.39707102863890376, 0.3680992611113384, 0.2894379648363916, 0.3458743067580281, 0.18234243756241975, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.07306954827510181, 0.1178810278593726, 0.25805928781142806, 0.18229159578732979, 0.007332194029477601, 0.34791800148099405, 0.1840465963468625, 0.34521137628303644, 0.1448589439023319, 0.1540071845686889, 0.06399695639113778, 0.3661195346562939, 0.4338933453740228, 0.23537200819901394, 0.15218715742806832, 0.1980481626465317, 0.238318145534119, 0.2608464495229328, 0.16206518950000626, 0.17183619299857456, 0.1666013279525398, 0.22460851643935653, 0.07092797631311754, 0.2982037567306175, 0.08685656041890522, 0.2121850033230348, 0.3236979776385721, 0.34712980421901507, 0.29518265509603747, 0.3017496104703211, 0.2888873641038576, 0.2664210665048957, 0.5834145187447821, 0.6478802022586689, 0.6484558471390154, 0.5401845956345237, 0.6034700708968245, 0.630356700609872, 0.6905379133172551, 0.6091048014514051, 0.5838295594779004, 0.1201362536053775, 0.10100040007648536, 0.10097629324424795, 0.097621369698626, 0.10889454837375379, 0.11349696012937383, 0.0828447934659674, 0.10861947637836966, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19996766733352045, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.4317694141508951, 0.3646263928805282, 0.30406834161273855, 0.37007238344698046, 0.35992807598758636, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.3167771224620901, 0.29898454753012116, 0.20941993308843954, 0.23714099793232835, 0.2884634635857768, 0.3345100965481056, 0.3021380210291612, 0.2800130281821859, 0.20662672500122503, 0.1606786004134888, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19138953746551357, 0.19866658360322031, 0.612758206723588, 0.22030573235988538, 0.23918740299763996, 0.20052800699111573, 0.22012094832065043, 0.4822443367120447, 0.2471714273025165, 0.2111708279901644, 0.186343242508759, 0.8725973182680067, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19341900766806486, 0.16763465813931921, 0.19325635126535012, 0.7902370955703986, 0.7725432986676, 0.20683669431754925, 0.5675308973084116, 0.7132111249032875, 0.2107157882226639, 0.6967005941898485, 0.7958285684649093, 0.2041344925411135, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07044253525910793, 0.08182076026617902, 0.07675296820300881, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07186128707562822, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "4220dae5-525d-4a94-9a00-d47f634187bc", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.9  # Slightly increased to enhance mutation step\n        self.crossover_probability = 0.9  # Slightly increased for more exploration\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Increased adaptation rate\n        self.rank_probability = 0.55  # Adjusted for better ranking dynamics\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Improved adaptability and dynamic balance of exploration and exploitation for enhanced convergence speed.", "configspace": "", "generation": 37, "fitness": 0.3480950868670237, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9214593919698604, 0.8851652119850965, 0.8976518509383343, 0.8719967142286682, 0.8282546042393826, 0.8887399387010092, 0.874894990010612, 0.8958012840009765, 0.8805741027811579, 0.7546502106018531, 0.692203437041558, 0.7443599901044705, 0.7169060712579733, 0.7309834655251443, 0.7483542395947004, 0.7194231490912025, 0.7101414652769079, 0.6511877348174688, 0.18809384152076258, 0.14992533190441704, 0.18370449505917819, 0.0829672274031249, 0.42221419320085185, 0.1688570598260718, 0.08316106840647575, 0.12206848801166292, 0.11652221634394333, 0.15023301010222456, 0.13082887096926954, 0.12946359165863797, 0.09539202644600386, 0.12653951870759028, 0.15360830845932016, 0.12102618608697557, 0.11359988549344158, 0.10430671915921597, 0.942676759258772, 0.9501500126885666, 0.8565660576873686, 0.9766286535390982, 0.9688953474758031, 0.9486267903599086, 0.9744948035408363, 0.9300880060316293, 0.9841570062975722, 0.5762655574927688, 0.5171845524608196, 0.5176389180890789, 0.5228429283592231, 0.5082471868526977, 0.4994011311719141, 0.5569638897576341, 0.42592632851643064, 0.5280371089010655, 0.33002478936926616, 0.6771342116082049, 0.6548345530504502, 0.4054037581602924, 0.6683592537468892, 0.17540507928105176, 0.7247041946260586, 0.11519110566467539, 0.23267431832452234, 0.32994259693793526, 0.2728780219006094, 0.3093026284531668, 0.3976452175522087, 0.4234334297219997, 0.3980863952010262, 0.315922583276509, 0.3150073805482497, 0.2525379258427336, 0.2795174401017828, 0.061820996266024664, 0.2028162692436446, 0.4299679129672921, 0.319539765517142, 0.4752212779690953, 0.2195374969561188, 0.4237276991716836, 0.5708406286133962, 0.062155299484235704, 0.0007445800992345042, 0.147284499800435, 0.022484746309593406, 0.1257417969682716, 0.14950234830944586, 0.17364260711513946, 0.3065902147276409, 0.00943785961477861, 0.11315216461027866, 0.19870061083186952, 0.15357952632097271, 0.24497826698613423, 0.09759571399731903, 0.0507273380010167, 0.12535853982480216, 0.25234786915226937, 0.05828986742655762, 0.20709170284469813, 0.14796869645886124, 0.20667281849597385, 0.2576169185862931, 0.30750622813645323, 0.1297843752640372, 0.09401903713711812, 0.1482197618880513, 0.07330979705496243, 0.30771435529677127, 0.23948378652580127, 0.2604012718685724, 0.26965870063190744, 0.28359881738236625, 0.3103578440368383, 0.26021765366365146, 0.2813899602474974, 0.08001292692246476, 0.7174043989333883, 0.5905023926369677, 0.6037529488274564, 0.6697656171802008, 0.5918094825229074, 0.5770493541687227, 0.6469758118096485, 0.5847928936466112, 0.6825054213007535, 0.11168171506018165, 0.11270496069026481, 0.14010071991552264, 0.0848098391625337, 0.09097110323283719, 0.07580525219516276, 0.08673641485490058, 0.11400847605120035, 0.12923698404564643, 0.2144661838297407, 0.27025554514113836, 0.16324004124867608, 0.17588325699387475, 0.2689377217821587, 0.16913886537851608, 0.22359610824128295, 0.18297893960367806, 0.3259625339430885, 0.33545363474798817, 0.3372248423506111, 0.39135335973418783, 0.40837473686796233, 0.3937082755332465, 0.3876724996850276, 0.42086365851295127, 0.20062175090237766, 0.35754383980760973, 0.29412867773844054, 0.3129643883431722, 0.2592013905298701, 0.24836322695757396, 0.26413103728122855, 0.27355266689255764, 0.3466489755681317, 0.2845694737918959, 0.14474456799238122, 0.23495697163832785, 0.19585556185580666, 0.21454686239394272, 0.19032416207131186, 0.2651557786024119, 0.19223563782566255, 0.23085623085176443, 0.23452768547543712, 0.20709301989806883, 0.2214725395259145, 0.21716541849580617, 0.21144691334148946, 0.2088375474286932, 0.20435833522700908, 0.20550473967782745, 0.2130421891725126, 0.24243649066421025, 0.2172812972690885, 0.1871253728007648, 0.8704894210205916, 0.20774367914632974, 0.9263811001336689, 0.20062714478079657, 0.1214230211729993, 0.16834986835686327, 0.19566262453441519, 0.7701723003325989, 0.5796331486784179, 0.20920626858983504, 0.7284641372330163, 0.7630767877347894, 0.2103186904072304, 0.20974821911225705, 0.42720151659851113, 0.7911563158171401, 0.49262255051301795, 0.23709426284716228, 0.19321540362006184, 0.18879218775674012, 0.1855894299083195, 0.1965539288441145, 0.22440886546081862, 0.1875774336992475, 0.19824498518971967, 0.20695690933229527, 0.09584040952248374, 0.087959765624264, 0.08572806520483722, 0.08062419876145144, 0.08620552915872937, 0.07485887550108616, 0.0754347039494544, 0.07316074470568934, 0.09873316867675219]}, "mutation_prompt": null}
{"id": "5ad13210-7586-4fb1-b18d-eef543289949", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = min(0.9, self.mutation_factor * (1 + self.adaptive_factor))\n            self.crossover_probability = max(0.7, self.crossover_probability * (1 - self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and crossover dynamically adjusts DE parameters for faster convergence.", "configspace": "", "generation": 38, "fitness": 0.33477777295042654, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8739258567300793, 0.9109894083093829, 0.8709406738979941, 0.856032270067683, 0.8867826973217162, 0.883311144051581, 0.8972911821846837, 0.8566136088581522, 0.770281674911487, 0.7253794163777201, 0.7656971634144154, 0.8020761142583617, 0.6678310423278282, 0.7894389247518742, 0.7372996525073265, 0.7771172707866275, 0.7248289863066353, 0.549537475957516, 0.1644472060989246, 0.43110669161561277, 0.45513761215447623, 0.4825570510973929, 0.17419601379829674, 0.16763143862365848, 0.43780038741730665, 0.15541315188971438, 0.13996702674284256, 0.1571105437738346, 0.3297457868951732, 0.1662173469647118, 0.44532645863492093, 0.1425607230196747, 0.153280652322077, 0.2479298928163144, 0.2882815793285395, 0.9859371106032812, 0.9400106791289187, 0.9562888606911898, 0.983266696996962, 0.9683672250081042, 0.9800920970574707, 0.950944791531419, 0.9703863510415991, 0.9857676978079359, 0.6872526143668407, 0.5214516675170588, 0.5109717610088091, 0.45698500073523163, 0.5768138262466374, 0.5259817612749609, 0.5890337691323779, 0.4734016671940199, 0.5079719276952611, 0.411837864628365, 0.49205926642128495, 0.35008705496036974, 0.5367770022272585, 0.6274702409757111, 0.27619047163288357, 0.21132194307295815, 0.3340098151235358, 0.5899088028204227, 0.29489608905511067, 0.19505157229517478, 0.24660187983628323, 0.16687577685604138, 0.1933134264904547, 0.18652821831312305, 0.4838817770533904, 0.1999825462669198, 0.2799739423214379, 0.19634497619456748, 0.13401173954791534, 0.20881057178502083, 0.2340718743206185, 0.29217940942973253, 0.24490449428228533, 0.2729154029210664, 0.2325134287188697, 0.192000834242534, 0.054571523288073354, 0.0464938657317614, 0.036679797888996335, 0.04275438628578454, 0.07479186584888198, 0.047019099168765566, 0.06030905251244423, 0.024519232688123505, 0.027042162140591075, 0.12970280067643292, 0.09923677508364104, 0.15590573257166962, 0.2526540617280558, 0.084390476330785, 0.15926437159118212, 0.20974790836429957, 0.14055248499217343, 0.11321033609819875, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17593156275644084, 0.11686870416435136, 0.15874184950653814, 0.16393934130177445, 0.17319220504216915, 0.09596533002039365, 0.12945095180364896, 0.1526217581640631, 0.21188690989400982, 0.1604934685045981, 0.3356479235447454, 0.1873562364435164, 0.1142538708121641, 0.15114515206446177, 0.1691930685099733, 0.5850513481069736, 0.5535288399228299, 0.5358598195326346, 0.5352722368322577, 0.49920736829280077, 0.5269036273212404, 0.542860000539239, 0.604734605123775, 0.5969048558078517, 0.09006832087610839, 0.11092577144437654, 0.08580790180638653, 0.09356669739562418, 0.07730862384651804, 0.09039951521967782, 0.08614234391678188, 0.08683844013098008, 0.11270607160503587, 0.2179490154709206, 0.27408167073423406, 0.19356226868511428, 0.2534794128563953, 0.22020620390886558, 0.1321201924451194, 0.22635612806971206, 0.18982167879122513, 0.16832313656092046, 0.2821384944020434, 0.2593289003897892, 0.2874645664224347, 0.31636601797493513, 0.3548793649075518, 0.29684975510468226, 0.36571057362792103, 0.33922467806744816, 0.356161454337787, 0.22709119543320233, 0.21486648496848837, 0.18892044749087278, 0.24574638283225214, 0.22529115726597004, 0.18475450750636568, 0.22807805903855372, 0.24605267920112195, 0.19668776746186833, 0.20662672500122503, 0.1683972368058212, 0.21329478777631516, 0.24149801451404085, 0.2750962054250973, 0.23250590042002628, 0.23542435291166008, 0.2175068869250838, 0.19987683519538302, 0.3081576105123264, 0.21869528057813303, 0.21802407944022362, 0.49346915817108283, 0.22166533415983225, 0.3769788231061033, 0.2685409124629988, 0.1861236834747385, 0.31312891598187453, 0.18635191419115182, 0.8724978325986188, 0.15311627036671904, 0.917605511140932, 0.20065701392642843, 0.1558965650595261, 0.16762868522787688, 0.1679226803347561, 0.18243854559412997, 0.5911833438454489, 0.20680615101514188, 0.5668520909426724, 0.20682682314447842, 0.4977028692501132, 0.2101589685785783, 0.4709791195331098, 0.20193834959103174, 0.46419582516443403, 0.21167185486259554, 0.20703071607378565, 0.18330899751982, 0.20803478677446885, 0.1959802547495919, 0.19412024215619916, 0.1875835318548622, 0.18783133606989455, 0.18385028177482476, 0.07329757399754122, 0.07448472668809458, 0.07520892478451136, 0.09512621074360117, 0.07287034605523646, 0.0970338757370568, 0.0719624118946176, 0.11054642818540872, 0.10558201605482609]}, "mutation_prompt": null}
{"id": "39c79584-c650-4396-9fd5-4a29c3366c7d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.c3 = 0.5\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            # Find local neighborhood best\n            neighborhood_best_position = self.personal_best_positions[i]\n            neighborhood_range = 2\n            for j in range(1, neighborhood_range + 1):\n                left_index = (i - j) % self.swarm_size\n                right_index = (i + j) % self.swarm_size\n                if self.personal_best_scores[left_index] < self.personal_best_scores[i]:\n                    neighborhood_best_position = self.personal_best_positions[left_index]\n                if self.personal_best_scores[right_index] < self.personal_best_scores[i]:\n                    neighborhood_best_position = self.personal_best_positions[right_index]\n\n            r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]) +\n                                  self.c3 * r3 * (neighborhood_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with local neighborhood best improves convergence by incorporating local neighborhood best positions into velocity updates.", "configspace": "", "generation": 39, "fitness": 0.36358200238278715, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8745665720917207, 0.8379318685093446, 0.8694668684384415, 0.8204799897791771, 0.8685264951953661, 0.8623193142449562, 0.8509803416285933, 0.8427682307368327, 0.8592974251621324, 0.6968463348339785, 0.6706421525052604, 0.5373734363479252, 0.718519830295991, 0.5985520106812532, 0.7232774686182264, 0.7252269649872336, 0.7263791585939947, 0.720418238941734, 0.11917983769379659, 0.14408866161381573, 0.11064778220170823, 0.15982305401143004, 0.2230886307121066, 0.1571146767984275, 0.14353928681007566, 0.28782409095913786, 0.14942569295734542, 0.11141613082661006, 0.13864279714457384, 0.09840641561010666, 0.13852378497123463, 0.11513486219191582, 0.144279493425018, 0.1845434368036285, 0.16126601387309492, 0.4708046842452822, 0.9938121599529164, 0.9757861395263718, 0.9700715519953353, 0.9795662587651267, 0.9681882551433196, 0.9588364959019516, 0.9904001212020658, 0.9758633044849162, 0.9891133006743025, 0.5646497215142836, 0.4300261858296184, 0.39512044970430416, 0.4126677053494282, 0.44083604349980354, 0.5365136289163264, 0.4050058019649381, 0.5300015463184942, 0.5412997679435487, 0.5468327463545832, 0.6855650652896119, 0.7363466846264161, 0.7624778560948329, 0.808727631670388, 0.8912316082090976, 0.23456030890786006, 0.17569286860946287, 0.23465151932046702, 0.4962958549617128, 0.504537941091195, 0.5129646952075821, 0.3908960948051222, 0.5193571925961906, 0.15813076732120912, 0.4868985743762392, 0.3171310648384723, 0.3382724693345456, 0.3359280223838108, 0.193330741060035, 0.17674965041489576, 0.49603049851504166, 0.5496846576103223, 0.35602070698463784, 0.3408592009748471, 0.2806250094881556, 0.3589884069755881, 0.058164087623912564, 0.0808048146330761, 0.11382379596242076, 0.050927223722428194, 0.16852192017285583, 0.07418639607501132, 0.15274754210551733, 0.30143708429064375, 0.10802266265664706, 0.15956490411719493, 0.17733536161833185, 0.25724932464487704, 0.29693961881441056, 0.16701376331216866, 0.15206431239436968, 0.11963234864492389, 0.209095499526316, 0.15729896605867344, 0.22410208211004523, 0.1488608315236366, 0.3121179722169025, 0.15246430295142277, 0.1274434793857525, 0.14152737234069246, 0.2015504325393015, 0.16089298851833134, 0.06783511420405319, 0.262525014989772, 0.29772245715156653, 0.24150630454282973, 0.2722616549140765, 0.3183525819547194, 0.340703707574907, 0.07825375364610188, 0.16380394924325425, 0.28254796363173496, 0.6634551126443236, 0.7062930553203286, 0.713581557594489, 0.6041880262926762, 0.6544245434122972, 0.5365330474705872, 0.6168991412584754, 0.6036105341333335, 0.5433746808382056, 0.10560619738365584, 0.10758418783026702, 0.09703965665340364, 0.09259553739098869, 0.17916071825199376, 0.08997355043453004, 0.08433147379331185, 0.13995962283206898, 0.11968793225982377, 0.3339217097002547, 0.19483664903869002, 0.19136112176809905, 0.2142384064165621, 0.21832543444493724, 0.2061202223388401, 0.24487941613913589, 0.2087044945273786, 0.19732435280703464, 0.38553512268044465, 0.3452500633815493, 0.3883094277922995, 0.3847067347956953, 0.3864848486780216, 0.37010034076890097, 0.1805821548584694, 0.40521722374348956, 0.4245497168836917, 0.20035509478258795, 0.34183292609098204, 0.27869204587754204, 0.2119829698145319, 0.3120900886239366, 0.28610662306622603, 0.22024689894736593, 0.3154935677272912, 0.27534345172000874, 0.24364598247151292, 0.22800792998972963, 0.1714903618228082, 0.2550431060741736, 0.2705720371877999, 0.2870229383485041, 0.22841466653540632, 0.2737199126781844, 0.23098470861710763, 0.21285343654905742, 0.6430705222571467, 0.21940700351484443, 0.2225352652204724, 0.2331306168860411, 0.22911486337340325, 0.5499577123717317, 0.20360602135094674, 0.5929354846985865, 0.18646139547591534, 0.18831112823421503, 0.8459991609322232, 0.7215625612746043, 0.2128254268927271, 0.19091321392849037, 0.1753031965810622, 0.8139926612298265, 0.5470431450850393, 0.5813132130151618, 0.7935303118024101, 0.7464904230252389, 0.20871800029890286, 0.21072158786247985, 0.6926390746023169, 0.11008391082537872, 0.20615176434705795, 0.45263148960135946, 0.19252189229165784, 0.1883247041011208, 0.21575390068461808, 0.19632129681253363, 0.2380879406448091, 0.183388586076339, 0.20678894421894967, 0.20144657609562389, 0.20446343043951176, 0.07905002633426883, 0.06847591072080739, 0.09374726809882616, 0.09087986449612839, 0.06978972281786833, 0.08618168843300777, 0.07861090103199275, 0.08200592685263985, 0.08961011539700159]}, "mutation_prompt": null}
{"id": "b84a9646-6ea3-434e-bff9-b7a5a7427bf9", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.7  # Modified initial inertia weight\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor * 1.5))  # Adjusted adaptive factor\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def stochastic_competitive_selection(self, scores, population):\n        selected = []\n        for _ in range(len(population)):\n            candidates_idx = np.random.choice(len(scores), 2, replace=False)\n            if scores[candidates_idx[0]] < scores[candidates_idx[1]]:\n                selected.append(population[candidates_idx[0]])\n            else:\n                selected.append(population[candidates_idx[1]])\n        return np.array(selected)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.de_population = self.stochastic_competitive_selection(self.population_scores, self.de_population)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with improved local search using adaptive inertia weight scaling and stochastic competitive selection for better exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.2684516984572821, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8886713921309501, 0.8977683257234063, 0.9252611454303403, 0.8660273104453101, 0.8620390649141301, 0.9029580757788724, 0.8566331516793413, 0.8784156172119338, 0.8713037207910561, 0.774813280602984, 0.6930187741448283, 0.6705870740108932, 0.736132472295917, 0.6931207162137327, 0.7726274118012972, 0.7451420072762394, 0.7708663491154857, 0.6927807322686464, 0.07656809698444644, 0.09353168919487276, 0.049570932254676014, 0.08048781890295154, 0.07101348282155362, 0.0978736900507996, 0.07119840110495024, 0.06451625383360715, 0.08337532837328487, 0.11003714150908872, 0.09282329672804446, 0.04821092362235868, 0.09700001629016808, 0.020400032195269868, 0.055149090334420725, 0.02240602644301093, 0.030092626705556125, 0.0605347851263619, 0.8835069217488742, 0.7299562091133952, 0.6892704551768887, 0.970512447612213, 0.9171921017814675, 0.8515524630384264, 0.7424253255749839, 0.8251861092924995, 0.9441245092069017, 0.43871908182453934, 0.42949204428043475, 0.49745415456525743, 0.5621809233943877, 0.47427981005185216, 0.6027027352077308, 0.4732588580048529, 0.4361056852495264, 0.49317685626492, 0.19597535061048232, 0.18296799356895144, 0.12090746091372206, 0.2797312847735498, 0.15865691270494864, 0.17903255948925745, 0.114232055408381, 0.1054497873656377, 0.17541706129169, 0.2405954242848275, 0.1330578752565994, 0.17787996632381797, 0.25158275155383714, 0.1823798803379324, 0.1369628246763286, 0.18703886738426723, 0.13438206874266267, 0.1758121679196909, 0.19773469788693399, 0.0823725970290714, 0.20500005226124174, 0.12828390124865996, 0.24243076565549493, 0.1839143072897308, 0.2302874910385705, 0.23931945673652932, 0.19228690964060047, 0.02255896590734885, 0.01058201396746683, 9.999999999998899e-05, 0.0321427529977002, 0.07273019811748127, 0.0695088209388588, 0.002392887151234535, 9.999999999998899e-05, 0.06252214271109335, 0.09574722859959006, 0.05162942914702473, 0.08129923045217091, 0.07223710387200932, 0.02847537201480954, 0.020210075943733363, 0.10284572447937301, 0.05271781237501272, 0.05665564095546649, 0.1151677395671804, 0.3464461881945926, 0.16656029469660594, 0.12050430084551023, 0.11149916402736382, 0.09807648883973574, 0.26143826012489035, 0.418282670671869, 0.07510416028808231, 0.08948266796818405, 0.174385360799993, 0.0718355892719248, 0.1343318408416011, 0.0841260760652851, 0.1672035519760704, 0.07896388064264814, 0.18914333859259236, 0.08111354076782151, 0.5439414755310736, 0.5548904825807568, 0.5740692680818614, 0.49450107816946975, 0.5100929768641793, 0.473209955987121, 0.5144255238133209, 0.5043880875996722, 0.5510561619552989, 0.04362196619807035, 0.055209082646826, 0.014508351313650358, 0.07495770638314936, 0.07301420931210434, 0.05576343545367568, 0.07778272925844631, 0.1056574848053804, 0.07917031843181344, 0.3372831281342904, 0.23900602781266866, 0.191555458384439, 0.19088744662837243, 0.2098062001212171, 0.22174949424821555, 0.18838704673408346, 0.3987718643304595, 0.2285497462272853, 0.1390475757651375, 0.1792522910178379, 0.17384826961531386, 0.2267236096836387, 0.2123229701960404, 0.20259322401305624, 0.159804162872059, 0.17340673584981814, 0.13927493615729414, 0.07932122054388235, 0.2342575801993524, 0.1275659031585561, 0.18670645535011332, 0.17548174747392675, 0.16709860888772987, 0.09989785130333984, 0.1281178531744025, 0.12912818166808027, 0.26982378635762816, 0.2001322533123312, 0.21843844795928258, 0.2263782208521623, 0.20536620114043425, 0.21321728227217218, 0.2302480534052861, 0.2679164609947775, 0.21695228673654954, 0.19954987875264474, 0.18331040614284122, 0.1818275839561364, 0.1893822152199638, 0.18759775147313618, 0.18836605053722666, 0.1888192115142101, 0.21175076165580253, 0.18159371983831307, 0.1880048900116279, 0.1878674169746256, 0.1241688641069697, 0.9129615510567148, 0.20064128490928101, 0.10132353667971039, 0.20570015269076447, 0.16465832119203316, 0.15221519850691456, 0.8531094910131194, 0.11158938452853695, 0.5916402540030454, 0.20834034349196207, 0.21027955032866863, 0.20674505461815862, 0.17559241697662076, 0.0920543699068328, 0.4052323579516365, 0.2053613545133498, 0.1999180764196381, 0.17888096841465306, 0.20671886073461687, 0.19804786621027537, 0.1872684037247052, 0.20272877999511663, 0.2158326307592474, 0.21503190569761943, 0.10679363734947, 0.06799715600006528, 0.046327925045648644, 0.08529092784403924, 0.09134522931511524, 0.08476074006324874, 0.1034759084585044, 0.07061437757837452, 0.09040529273897613]}, "mutation_prompt": null}
{"id": "7fd59bd8-af02-4576-b44a-2ee5243f575b", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = max(0.7, min(0.9, (self.crossover_probability - 0.05 * self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover probability and refined inertia weight adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.3550203137767341, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8985156610186339, 0.8910762161629922, 0.9026214630539006, 0.8274107134468346, 0.8637480004254467, 0.8815956733858749, 0.8745559822146876, 0.8771189309334227, 0.8655231888079957, 0.7849996634795067, 0.7256664022112933, 0.7699725531055781, 0.7291385756583327, 0.6846793516355781, 0.7510210818195164, 0.7124176328463568, 0.7163714220603259, 0.7594366292035089, 0.1240048869127568, 0.5174020022540372, 0.4221266639440465, 0.4998921405774428, 0.0910335996145546, 0.2796394698674781, 0.33778171072293994, 0.07657931120864703, 0.16833797562261865, 0.13653450580506454, 0.14827177389456814, 0.12419694705119333, 0.4109500251434499, 0.28784025346139996, 0.1483696803210247, 0.363928133752896, 0.15411516306563933, 0.15892417712924056, 0.9816683614409101, 0.962370908616413, 0.9756253233887673, 0.9365828412236186, 0.9620071255726208, 0.9743240469176847, 0.942915599241516, 0.9609708816397348, 0.9872213712312529, 0.5312518180184089, 0.556204712003076, 0.4393316256377642, 0.46514396663375746, 0.6393353832098526, 0.5401950605172279, 0.5147903721788984, 0.4462056554235838, 0.535523561439313, 0.5498638801441815, 0.6388040044000458, 0.7072030035556021, 0.616207052529993, 0.3434328006719114, 0.21713299462170255, 0.6845208816276078, 0.6322363829124992, 0.6458091353009163, 0.2910489277861694, 0.33220839144528447, 0.22639819700974095, 0.28100074821728016, 0.24114237068797684, 0.22677160424646525, 0.38879196172654285, 0.24152327346188462, 0.24865360200178643, 0.20740874445632107, 0.11864989662301739, 0.22369164268834352, 0.22728811403431515, 0.3142152279134979, 0.27767649823623297, 0.2562455336058792, 0.24865978887490992, 0.25136324358643236, 0.05842247157209457, 0.05749793119622504, 0.10743751775023536, 0.052832463693492704, 0.099510705920975, 0.11046956616297521, 0.08576955441851153, 9.999999999998899e-05, 0.10873602872070554, 0.11531096799533624, 0.15190701959126873, 0.18992323019151047, 0.154935779555881, 0.14928136680462745, 0.10935754602060044, 0.34798264076748275, 0.2042965213635738, 0.15240831577295244, 0.17799113979431713, 0.1678190105752303, 0.2241908832513404, 0.18788306095284213, 0.11628812056666904, 0.1922216056112851, 0.15038285118267736, 0.17141509247320696, 0.07332335124055134, 0.19632966308764377, 0.20858749460381976, 0.19917085000214552, 0.42246880407098863, 0.2604494996838751, 0.1965334975789539, 0.16187974109656755, 0.1330103833442876, 0.1555598572573299, 0.5818942064158206, 0.5683536954988578, 0.5606939076482718, 0.5503646274431468, 0.5529474556093475, 0.5507331446081192, 0.5584034743373827, 0.5924835646418016, 0.6038752125293023, 0.0879095661055862, 0.08946370742379839, 0.11508778948782783, 0.10482575108616488, 0.10395953601082841, 0.09071827072118654, 0.09119315437992659, 0.09235306542820687, 0.11267059511423816, 0.19846601709106282, 0.2632963418145915, 0.19372809200986107, 0.2889710263614723, 0.2509126287424198, 0.15715625939247235, 0.21470911450342212, 0.17806246790380142, 0.14789234942979113, 0.31241662843313656, 0.30792793086501535, 0.3114264982412096, 0.3240739752448166, 0.3280991000928316, 0.3073143368064155, 0.41263684303178705, 0.18908643532487113, 0.4018912369706188, 0.21740940620467486, 0.23414434177242804, 0.2360114539895628, 0.21537938969041082, 0.2137206230448928, 0.2544870698148225, 0.2790143411216989, 0.2513498643319233, 0.27669144697678516, 0.20610998378063772, 0.1868733656208561, 0.21976699559629964, 0.24092776458645848, 0.24736687223715415, 0.23019818126691693, 0.2430631051359271, 0.2403034801210987, 0.1818463488340495, 0.19581480531863305, 0.4678996950498926, 0.3342821354374834, 0.34535104794655447, 0.21621572766860608, 0.19175412929012947, 0.40602651960995895, 0.4546597405596935, 0.18224908481149238, 0.18633808530740747, 0.8874933626713007, 0.7838618934208609, 0.9195817651033937, 0.20073266732381112, 0.7509469699721707, 0.1684521621170355, 0.19617374084393058, 0.7577979833957651, 0.5208869960672224, 0.20856888236189086, 0.6728237031526141, 0.5583532277017201, 0.21072249923350905, 0.5319564236406363, 0.44450956337788416, 0.19723187905796113, 0.5090564174407743, 0.21559600156576375, 0.18628239527621415, 0.1903462629198246, 0.1884911496214542, 0.19696326466040437, 0.22890705956531088, 0.2095003380253102, 0.19659431288063134, 0.18090899460553123, 0.10353392133312556, 0.08363969410876582, 0.07386343015330132, 0.09190751944961106, 0.07991745338047207, 0.0959911087421822, 0.06999944158044857, 0.1054260511350491, 0.10901761562092105]}, "mutation_prompt": null}
{"id": "51e9d7ef-8e30-4016-a192-5efb1db38c1d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = max(0.7, min(0.9, self.crossover_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        np.random.shuffle(idx[:2])  # Randomly swap the first two elements for added exploration\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover probability and modified ranking improves exploration and convergence efficiency.", "configspace": "", "generation": 42, "fitness": 0.36335856633837893, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9110924365056393, 0.8868860292235138, 0.9032013372964546, 0.8490945055372212, 0.8667053739336306, 0.8832206898108901, 0.8728543995280544, 0.8910747227973701, 0.8668879639080641, 0.7726824838119403, 0.7338973293700326, 0.7800512466169093, 0.7367893249171871, 0.6039882435369166, 0.6879643378924476, 0.7537438075316423, 0.7327823921957144, 0.6622388952449261, 0.12068561817963108, 0.14799601836973109, 0.14902172948302628, 0.39001105376592204, 0.2651411048345279, 0.15297830856841121, 0.14732059754951699, 0.11646081901125693, 0.17875576535801718, 0.13345508762401093, 0.13429398710854312, 0.15274107947678695, 0.13924543949089707, 0.13535039535021698, 0.13122272452152317, 0.1412045737407841, 0.12478754906548406, 0.13674522206616546, 0.9790365531784242, 0.9556752608339075, 0.9537082145366418, 0.9378627561030145, 0.9524869473729144, 0.9609173060749447, 0.9716133090536796, 0.9346983083737926, 0.9684233901185895, 0.6075489794747102, 0.5579104134769244, 0.5883032711601626, 0.5554661713753002, 0.5681253437479445, 0.549255165502254, 0.5385638806783806, 0.4840453792874041, 0.6045890480069742, 0.2223346242622951, 0.7438512921334595, 0.2234009362951368, 0.822475465281964, 0.7806804657897353, 0.2072111647679732, 0.7364615623290365, 0.17344239619038504, 0.37359762528145823, 0.4609984874328097, 0.1783287169835881, 0.3536267178984708, 0.2282523832551192, 0.3941097961508647, 0.2131411686147513, 0.3130733251112161, 0.3045869218083973, 0.546480554855991, 0.20527933810728982, 0.1545655682417384, 0.1951684787175726, 0.5150632841921772, 0.13457788997056563, 0.4336531210226594, 0.3745827897791165, 0.43612354152531263, 0.40623088942981733, 0.12747198169087515, 0.17366292785300286, 0.06687051153997003, 0.19384463577073086, 0.12375418038947805, 0.05983668628057637, 0.12011686110734898, 0.40144531521391413, 0.41956914705688064, 0.23979743537183584, 0.08719181017451083, 0.23153264254846972, 0.09312315117703307, 0.055991047089250734, 0.08908686039795344, 0.6458415698622648, 0.03688717330036506, 0.1550472243631451, 0.2429289268502267, 0.16215644548907726, 0.2189393567601272, 0.1781146860210996, 0.13230126284710364, 0.1801179121979236, 0.09876933227892204, 0.17648583120061245, 0.09504919441627879, 0.31842810316806536, 0.2855438875598866, 0.20804283150800618, 0.3149583293457038, 0.3655152167263801, 0.3729149337967529, 0.21406744842098824, 0.2795409117988106, 0.2017657239992131, 0.7163839624795981, 0.6106327259523058, 0.6370750862552916, 0.5596570066883866, 0.633659996366769, 0.6356076441757494, 0.6553382918905784, 0.5882250602953435, 0.6042739183699933, 0.06320912108132848, 0.13772131757046358, 0.06831314421047396, 0.12915992884970806, 0.09296218748500962, 0.08551495364712514, 0.1192599780225464, 0.10610829271122002, 0.10816835936302904, 0.29627878169340083, 0.25674592842576016, 0.22645514039971915, 0.1868553888590192, 0.19853151337909014, 0.25434380831088343, 0.19128906375227928, 0.15340793943701103, 0.22208905709524884, 0.4210789648661175, 0.36654643299645107, 0.34668591978702124, 0.426164197570034, 0.3956099345443208, 0.3661672302106782, 0.4137948113493225, 0.14533532274305305, 0.4514595650526617, 0.21506890294258163, 0.28313520539347536, 0.31635450304485657, 0.311102331380678, 0.3270237274014537, 0.2995293069620478, 0.1327386785406165, 0.24819993640748228, 0.23515734270755517, 0.20350173198061683, 0.18050629748555935, 0.21495851520994957, 0.2929941884210999, 0.22512501131906493, 0.21904071762469512, 0.1988982822050237, 0.22703766448591522, 0.2309782296315127, 0.19394248699775052, 0.4946573454697395, 0.22592989020768506, 0.5341569884151336, 0.2321608394460597, 0.4769386243991641, 0.6069376183055291, 0.22219954827427002, 0.2116230220977402, 0.1867328543363841, 0.8707406654458462, 0.25837560367282353, 0.9270964099234803, 0.20076850916661593, 0.7915865777674737, 0.7765931082249891, 0.18256055519631564, 0.17169129993780685, 0.6033799168524169, 0.20578033353458858, 0.44884905614796866, 0.20635291135470202, 0.7753500561276867, 0.20902477517055718, 0.41598031414198555, 0.1667878174001477, 0.5545671562874082, 0.21686532790312463, 0.1883391818049558, 0.19259933923938266, 0.1909366218348506, 0.2039243545938283, 0.20891436559017507, 0.2008913030991626, 0.1791353946235611, 0.18841945903850232, 0.10391563138063609, 0.07926052301379927, 0.0817930519943959, 0.0963363537104629, 0.08788673621887833, 0.1625349020081086, 0.0728054105803605, 0.0957093866420815, 0.09414585989949098]}, "mutation_prompt": null}
{"id": "df42f8bc-b593-4e5e-a053-33a937c3aa35", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = 0.75 + 0.1 * (1 - self.global_best_score / self.global_best_score + 1e-9)\n            \n    def orthogonal_learning_strategy(self, position):\n        best_vector = self.global_best_position\n        direction = best_vector - position\n        for _ in range(3):\n            orthogonal_vector = direction - np.dot(direction, position) / np.dot(position, position) * position\n            if np.linalg.norm(orthogonal_vector) > 1e-9:\n                direction = orthogonal_vector\n                break\n        return position + 0.5 * direction\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            learned_position = self.orthogonal_learning_strategy(self.particles[i])\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (learned_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with orthogonal learning and adaptive mutation enhances convergence by incorporating orthogonal learning and adjusting differential evolution mutation dynamically.", "configspace": "", "generation": 43, "fitness": 0.3250507021235682, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8008235019165411, 0.8561321997477452, 0.8357568678768432, 0.8515210140387445, 0.8589422742716859, 0.2958054582540778, 0.8423882943284293, 0.8538548701813399, 0.8563751625873832, 0.703573431894092, 0.7729273514679648, 9.999999999998899e-05, 0.7432849224032669, 0.7249458709421223, 0.6971206932565335, 0.05184388652338434, 0.740201169421657, 0.7488601732063116, 0.14540594693808784, 0.14715573433035156, 0.13299648569206401, 0.15123642049997998, 0.10622410018472894, 0.1581589831698258, 0.11551615219920208, 0.1355869939985923, 0.1483313418085731, 0.12429845740214551, 0.10774287448651265, 0.13750380540003482, 0.12977248075601733, 0.13369369061119885, 0.09084590049346841, 0.0940877008417974, 0.12752225606947254, 0.13667532683735917, 0.9700940013424555, 0.9561815019391523, 0.9516858333036264, 0.9557869330117332, 0.9424117677093322, 0.9559614067493223, 0.9443973036218599, 0.9503807827868065, 0.97508802031043, 0.4008639236428686, 0.5187891692819085, 0.05914616512469162, 0.5446552872932777, 0.5469979919625492, 0.6333536463684121, 0.18294765452869943, 0.6213022923666529, 0.5267225591216395, 0.7416715064603658, 0.2186515240334025, 0.2320098293919185, 0.8031026684991786, 0.776669653244862, 0.2095150085306936, 0.22639610122538212, 0.7188352972490218, 0.8012343344272865, 0.4951878283508503, 0.13043749614801492, 0.1824753620144175, 0.25034339644500647, 0.12699715075059814, 0.26444448587891833, 0.17542751859353267, 0.2294820950202644, 0.5326638987191993, 0.009911461291028378, 0.2432727478718273, 0.18667598974088506, 0.1952779768481081, 0.3183928368726283, 0.3586086575921328, 0.18167321288583294, 0.23335050288810055, 0.22709692760358824, 0.25030122815230116, 0.3270902866046649, 0.08472904872624676, 0.33057307375072054, 0.07075225232547577, 0.06877939591816196, 0.14594524823354482, 9.999999999998899e-05, 0.3039786001771698, 0.1810188156829271, 0.23553211570690824, 0.11650738608230327, 0.057198172651350965, 0.09990033277091293, 0.16029871167964826, 0.14049627336219106, 0.04929474869262007, 0.06385978989165286, 0.2174401434753902, 0.09375641062445683, 0.17887066099220028, 0.2721658433657288, 0.14744436241892234, 0.07681718261178538, 0.11471350228849786, 0.15935673839192754, 9.999999999998899e-05, 0.2544132348329067, 0.334218006172176, 9.999999999998899e-05, 0.37030860105573815, 0.3476343766010618, 0.3076348811917493, 0.2887250926774674, 0.3110020743685473, 0.23324034212647737, 0.6144795644248373, 0.61993941723247, 0.6144994398398937, 0.5185111194713523, 0.6241485506959912, 0.2063981254114372, 0.7254871242461005, 0.6671184183623698, 0.5555027768506055, 0.1049950298739768, 0.07989728840261012, 0.08290627849427679, 0.0899664333975585, 0.11466322112383387, 0.08909272484434683, 0.088681882618599, 0.13939394096650448, 0.0855729472253004, 0.14201667480412183, 0.23662135450885136, 0.14693726847135513, 0.14851479677420776, 0.16315912573159153, 0.15270300964230843, 0.13932125208163648, 0.1498256387678062, 0.1685637988985249, 0.45917439117295866, 0.4135836367200366, 0.46446315187353826, 0.44350735631991123, 0.4683354175083838, 0.36019944436655027, 0.45981235783345187, 0.4330419537938073, 0.45624761690563365, 0.27686904647286525, 0.16392867489978957, 0.26123602601279594, 0.23157065466946336, 0.28453645208406053, 0.30438323501012277, 0.3490216496345926, 0.3572171448557241, 0.36610822299830925, 0.18643476828424832, 0.17672613517388414, 0.19017775159463668, 0.18170304687565986, 0.17286784882666084, 0.18175411167721423, 0.2030899725090598, 0.19022283084325786, 0.20947278763123267, 0.22592268248276315, 0.18555060268375334, 0.20707409732163296, 0.6056064245096904, 0.6394308026650812, 0.19753151343069253, 0.2242187168600075, 0.22541651816937336, 0.19097482717486414, 0.2562206639574002, 0.18303724744327565, 0.8899462451843272, 0.30005389051030507, 0.1762879437139503, 0.7211632476622448, 0.6912371344694092, 0.19348615084316945, 0.7802924406289351, 0.20853074062763421, 0.20793860586169455, 0.6264771378593557, 0.7006317836857868, 0.12606282374037459, 0.20619590622121275, 0.16730540162833785, 0.15488288994832133, 0.18238598093576397, 0.19419605446811816, 0.19436805975935545, 0.18015808601732042, 0.1916099169874954, 0.1951554394891698, 0.19569816826092024, 0.18809545934470884, 0.1892707854058504, 0.18009574839223152, 0.07345863591285562, 0.07240869822565632, 0.07426471358085496, 0.06872101617072479, 0.06854603902805323, 0.07785046928933737, 0.07262536932951258, 0.06468033980541965, 0.08320291260964263]}, "mutation_prompt": null}
{"id": "da4d3872-ce9f-4d89-88fc-6f5310c31b2c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.4, self.inertia_weight * (1 - self.adaptive_factor * 0.5))  # Adjusted adaptive decay\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = 0.9 - 0.5 * (self.evaluations / self.budget)  # Adaptive crossover\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive inertia weight and dynamic crossover rate adjustment improves convergence by better balancing exploration and exploitation.", "configspace": "", "generation": 44, "fitness": 0.3349172027872496, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8823032048132914, 0.8819569217065822, 0.8824589699997666, 0.8639467362558324, 0.8754671084424686, 0.853504774350668, 0.8623431558658456, 0.8692214129760889, 0.8725107326867491, 0.6864249044952906, 0.0753572855688277, 0.7023165466238297, 0.701991638656664, 0.7179747665083609, 0.7105118565272255, 0.7412783867187841, 0.7194860876903575, 0.7150160123294556, 0.34761443972930817, 0.1505098853834057, 0.14946433538596482, 0.20942892031723048, 0.08215463570529424, 0.4487673956906104, 0.14809673441874616, 0.16707964036965128, 0.1494712974968022, 0.13101728408337132, 0.13754845710485408, 0.4048873157385757, 0.1086117113388062, 0.3606053992003656, 0.15859117280272617, 0.13254570361727624, 0.4629730261297349, 0.3411911874562812, 0.9431282638932404, 0.9606435770222418, 0.9071339130102425, 0.9555904125023247, 0.9362170791991674, 0.9659101352226143, 0.9741281978001033, 0.9376292421619283, 0.9382570410590428, 0.5693454703615144, 0.5095970829302783, 0.5480879780268856, 0.6322364083990029, 0.5073767379700498, 0.5585107856793271, 0.5863924608749119, 0.4705325038955719, 0.5632921409818177, 0.5170846737607387, 0.7484800397637589, 0.6937686298610838, 0.671904229977696, 0.18900015187525343, 0.706750474222593, 0.6818922965738834, 0.7678737780063707, 0.738352007894413, 0.22966238809288209, 0.22569941948036865, 0.17124350981436798, 0.2556043493817465, 0.2169857767482497, 0.26722308881398915, 0.1309084078245738, 0.18573263407879503, 0.2275254597723403, 0.13968904150381745, 0.18678359484768803, 0.19483064269054706, 0.259017176470665, 0.2534172926163003, 0.18003977762921353, 0.2291902571260821, 0.1916790409478314, 0.21828561377922562, 0.07925201431625428, 0.05090877757348411, 0.048037156095330324, 0.007823028844443636, 0.05796943190382697, 0.045171243355854096, 0.026369550850264156, 0.23293751161802356, 0.11675634419000147, 0.10720926717019741, 0.12598142217847508, 0.11376798755350215, 0.22688831591813208, 0.2294528733192598, 0.05389727675837308, 0.17038465077316756, 0.11954634202005887, 0.0747814060824592, 0.18952327642487932, 0.2686739172163808, 0.09223230753343958, 0.1307914907320672, 0.15368786704227455, 0.1157497537288793, 0.10461231054217257, 0.17403575749988176, 0.10636664649082739, 0.20341916295493778, 0.1883927147465163, 0.2275160910568096, 0.2285498122963262, 0.20262597994131804, 0.2295509854826221, 0.1514764844607175, 0.2710416053131599, 0.08229485989053786, 0.5455435846314022, 0.5644357149322075, 0.6207997124009741, 0.5718771973446668, 0.5370170083781723, 0.5132251976044808, 0.5799361102554701, 0.5713217378758365, 0.5505723055135056, 0.09095579967528034, 0.14170490883078635, 0.09282653863041157, 0.08916866072731788, 0.08452866140680582, 0.08093445689696144, 0.09638933550043582, 0.09551967369311665, 0.07005871483430892, 0.27033986026482204, 0.1567615715232794, 0.2677956222980544, 0.23636744586236436, 0.5009062119238092, 0.17928959160011604, 0.3249726076663598, 0.16024906602653877, 0.3017951558679932, 0.21382378353691633, 0.33094432417386765, 0.3065665500753578, 0.3062835926673261, 0.39064209554382223, 0.35888162530346035, 0.3131596313823639, 0.27412878050597755, 0.334908742643784, 0.26206193681421974, 0.27920395355172256, 0.22211326714291568, 0.2182591652789524, 0.21371439039365236, 0.2648096318159495, 0.23192736285639715, 0.3042517666594574, 0.24172746644908671, 0.20400666223967068, 0.1902024451769786, 0.21343577313714002, 0.215119974181897, 0.20231896467441735, 0.2506348917879446, 0.21143386832694755, 0.23997104278426118, 0.19055420260905032, 0.2436920423290051, 0.21071083219339148, 0.2066007137735869, 0.18925459213141183, 0.2109281949569487, 0.20669761095994377, 0.21351737293255424, 0.24010760893077399, 0.20624295799336823, 0.18774922561939056, 0.18774421049389944, 0.1933418518108787, 0.9070547890543337, 0.2010764520360232, 0.15298550752680862, 0.1682235412657126, 0.7359032885387449, 0.1842074679429837, 0.5913977361154277, 0.2100246307003627, 0.7627848487808819, 0.20827672900935845, 0.20989646075152535, 0.5195617998308351, 0.8089069930298877, 0.16676829308602814, 0.5910041400578803, 0.1843198331394379, 0.18652058432063923, 0.1955428262650858, 0.17125946021182115, 0.19599035827425915, 0.21259155021012432, 0.20721239463791774, 0.18347559706339467, 0.21040385269936568, 0.08233863055941182, 0.07663600129228709, 0.07613613527457708, 0.10257929922542408, 0.08394254370376875, 0.10175461400224717, 0.06845101114563246, 0.07098169229351425, 0.08200332939136334]}, "mutation_prompt": null}
{"id": "ccc0277b-c5c8-4db0-86ee-720db5d29c75", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.03\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.2, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.4, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.4, self.c2 * (1 + self.adaptive_factor))\n            self.mutation_factor = max(0.7, self.mutation_factor * (1 - self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "The algorithm is updated with enhanced inertia weight adaptation, dynamic mutation factor, and improved crossover strategy for better convergence.", "configspace": "", "generation": 45, "fitness": 0.34494998843828556, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8611173653137445, 0.8790895901007502, 0.8750974962481135, 0.8491788171647043, 0.8028119782552228, 0.8937594114894835, 0.8613125585105403, 0.8816061172657227, 0.87486308518714, 0.7695872109805021, 0.5073644076203601, 0.7202011963524155, 0.5848801762102502, 0.7441116441264843, 0.7854119391475396, 0.7511744786138982, 0.6981905516286016, 0.7066456979381881, 0.0770365504730175, 0.13660836359531947, 0.14349988313866002, 0.5390281894895241, 0.13363370530988106, 0.13888529139358996, 0.08620544817484754, 0.1415794909588638, 0.17242451408622128, 0.042180191224557184, 0.09982911293697905, 0.11778648233957734, 0.0977208634566108, 0.1356184335071826, 0.136780570305718, 0.10605501406702333, 0.11051840848682737, 0.09213681058770185, 0.8722718608910792, 0.9216413920915549, 0.8695761967444984, 0.8321240446890651, 0.955289267952583, 0.9497659191630813, 0.9291419969730097, 0.9447531457713128, 0.9808463467425816, 0.4843377173495802, 0.4441257231045519, 0.36790056037425534, 0.3839477127550065, 0.5727516145291991, 0.6261384864075767, 0.41215283830897975, 0.4140197092259452, 0.6493390738220435, 0.24738369714436004, 0.20916394672554084, 0.16942169749941072, 0.815692775962062, 0.37004929384071594, 0.8378681222559512, 0.8668454868233955, 0.8018239768959807, 0.3887463662827436, 0.27552961679457655, 0.1774999746302912, 0.18703120724205013, 0.1672540266491791, 0.33312461568433605, 0.4765803881178011, 0.4050954679857841, 0.1631359025211545, 0.19763395974300335, 0.1874749045942814, 0.16239542717236777, 0.2074742884791544, 0.16357019936036465, 0.20733169878270652, 0.2702987338706325, 0.26678885743673497, 0.3198070559999886, 0.18718047490917977, 0.0053509219729860336, 0.1177417918691992, 0.13385741603881596, 0.05393643161731598, 0.08521708489759217, 0.051639740790202504, 0.09308156193177619, 0.28114044778138414, 0.09696576371360388, 0.11113947304419836, 0.20083290791420172, 0.0987254512038489, 0.18493091576512977, 0.14633852353419075, 0.17773363483031668, 0.07671828608856379, 0.25040311072435684, 0.07752640631559848, 0.39341269114501576, 0.2725384099520195, 0.22330913200665392, 0.23218140886824257, 0.42064031211376063, 0.1720960354804938, 0.1520897898952156, 0.21983469975564707, 0.18449982049850155, 0.2395088814031604, 0.0959067799931278, 0.20435291129855127, 0.2606549258970351, 0.36072910801144253, 0.089958100414406, 0.21369180560459466, 0.3437815113262279, 0.3468662109325443, 0.6100149474864296, 0.526943156885586, 0.621700647519347, 0.5624084769153781, 0.556100155483731, 0.6162856242079342, 0.5533634369886233, 0.5552411549648795, 0.6269441452755806, 0.0857076227591258, 0.132275573877346, 0.12511545758104237, 0.11436672644993529, 0.11892408689351264, 0.12246622915802652, 0.07991188224025048, 0.12171451055883897, 0.11131512834783697, 0.3728055221784755, 0.3124424608478862, 0.170251194153912, 0.19767794196424915, 0.32311373246415676, 0.17700678142689663, 0.16126656473066958, 0.17091197000952885, 0.22360507720469391, 0.555227051210603, 0.21612836788152867, 0.564974437758573, 0.40302939209556554, 0.3153661106046366, 0.23994298143197046, 0.3493680037657062, 0.597741216560669, 0.16424056903086837, 0.27894181946289776, 0.26362508831649323, 0.3087761603167565, 0.27192900133531905, 0.42882864108096963, 0.3339872675631854, 0.34601023469501646, 0.2270964836525643, 0.3693450978942665, 0.2921785613976341, 0.1983109545993088, 0.25414151024517495, 0.20070034823167415, 0.28328762865511337, 0.20280971744279308, 0.21671748409148517, 0.22636612044514293, 0.1908804435711452, 0.5285085493654115, 0.575745699802668, 0.1921754510828504, 0.21209374639951806, 0.43112774724527403, 0.1889692137986715, 0.19823783718050858, 0.2199096587662408, 0.21846959989194836, 0.7658727966266897, 0.8229516589283228, 0.1525284503965484, 0.90735587299302, 0.20081568865542276, 0.1435168555364973, 0.17221774488940444, 0.8560835443853501, 0.18513064195843676, 0.5504837922656749, 0.20786226510187766, 0.5077945419190675, 0.20789926067730224, 0.2104186354350236, 0.8171407145879845, 0.44485372101281406, 0.20035371376963063, 0.3770758763964204, 0.20329045013166003, 0.18474229259755792, 0.1857779556291771, 0.19485144828004208, 0.2031663997455091, 0.18522122775895733, 0.19613479745316342, 0.19308898211349756, 0.1928565152511741, 0.09264734238255135, 0.08775430983645716, 0.0716777205844562, 0.07688796598131398, 0.08212355076521505, 0.08505912499174195, 0.078233689709717, 0.080366161047563, 0.07430416681507157]}, "mutation_prompt": null}
{"id": "263d0311-fbf2-49f6-917e-113d823aad29", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.velocity_mutation_prob = 0.1  # New parameter for velocity mutation\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            # New velocity mutation step\n            if np.random.uniform() < self.velocity_mutation_prob:\n                self.velocities[i] += np.random.normal(0, 0.1, self.dim)\n\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive velocity mutation introduces a novel velocity mutation step to improve exploration during early iterations.", "configspace": "", "generation": 46, "fitness": 0.36554813767652544, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8529745268920661, 0.8406040462482023, 0.8334240719059041, 0.8103316367272666, 0.8281329775820939, 0.8599722402187556, 0.8419213759501211, 0.8591768616635211, 0.8339028266063178, 0.7186922784985333, 0.7097633393239668, 0.6991664198013616, 0.6869572468019602, 0.7093976515334918, 0.6755922138226595, 0.658749877255842, 0.7297532369715746, 0.6052366808183774, 0.15004898412348489, 0.1488363016510268, 0.13033054475795647, 0.40177012424735026, 0.34414238098407146, 0.5011575681962162, 0.13777701107939233, 0.12810477331634906, 0.41698115846549955, 0.1409584731894542, 0.12201328685582269, 0.16336734803632336, 0.13733554452270003, 0.1421356736723034, 0.1163074867454279, 0.1472003087659598, 0.19123957163591576, 0.10772229484864204, 0.977405054893623, 0.9638595915221212, 0.9633198513747059, 0.9705232672034602, 0.9372680266519477, 0.9379258093675866, 0.9818957357624531, 0.9604619059087302, 0.95106472460381, 0.5443063090836369, 0.5593398556481118, 0.6214242002348547, 0.5642511994160138, 0.576030524666949, 0.562079912393302, 0.6361443006708667, 0.5304074477290859, 0.540079974798287, 0.371338121769349, 0.7282519699429888, 0.6767824339916451, 0.7450034131937979, 0.7568696637293346, 0.76740584234053, 0.7233109558913142, 0.7293481389445613, 0.6033599567856829, 0.2824767077112895, 0.4822558136454542, 0.3216559505130355, 0.2781442739617008, 0.292369496768318, 0.39320695559171825, 0.41162136581531494, 0.4570996782864618, 0.42547417398827125, 0.18903964202149182, 0.2835836197838808, 0.20772137237067922, 0.4072373468611019, 0.5570622335756578, 0.2861224822076446, 0.27606484779514495, 0.5374081435823519, 0.256244901818369, 0.2803513636184386, 0.09274411039559471, 9.999999999998899e-05, 0.0801928464890509, 0.10653771549496327, 0.04329221538791894, 0.07287580048442865, 0.18916005742391073, 0.027452676077841187, 0.11825619900874085, 0.20780735171489007, 0.13999168175897214, 0.06916745404508151, 0.3337117830032027, 0.14953578187687222, 0.26327968763248055, 0.22266588797622722, 0.37206378177446764, 0.11863858982508513, 0.1234481559480326, 0.15523622701687723, 0.2484624641821107, 0.0655857099526822, 0.09408295034104486, 0.13947273496895707, 0.2252086954449899, 0.09476855222180491, 0.26138599106621774, 0.26355139302604524, 0.22832321772270647, 0.349849999528586, 0.3324933352525703, 0.3110987215742921, 0.2618800169077581, 0.24198503044690978, 0.24354972605703884, 0.5097049726692957, 0.6220730407137688, 0.567403330856677, 0.578815673836236, 0.6428387124856048, 0.6131270318146287, 0.5974274121390071, 0.6109676295130019, 0.6902325697964833, 0.11471075122537955, 0.12408070313863451, 0.05154667972654392, 0.11926214796792445, 0.10276888526977324, 0.10491940930095245, 0.1161246679050808, 0.09663798975408877, 0.11926386148637558, 0.22175367399287393, 0.24834575620441268, 0.38278855767086173, 0.25997916325133985, 0.3336275832041432, 0.148399847226117, 0.20684906557742022, 0.17811983760580952, 0.23639979342265194, 0.3085037215535845, 0.3520562909523285, 0.23103366855267482, 0.32649536961213266, 0.35662856992251324, 0.38199308538976706, 0.3072387709610287, 0.4063836561039541, 0.3883765187948468, 0.27421554800487313, 0.37110610709096425, 0.2727324121800747, 0.2741446967316017, 0.281031507187641, 0.32281729189911224, 0.33601555822609375, 0.3025351372401981, 0.31092197397626353, 0.22767812124206177, 0.20844014759524054, 0.2469019606559707, 0.20270303772088505, 0.20252656227332944, 0.19444092950679115, 0.2442211048470343, 0.19269924306637487, 0.20413978163597601, 0.22378771401906628, 0.21407278997749968, 0.5793271075391617, 0.1845835529979618, 0.2171789714434187, 0.2409973165109507, 0.2160254094493531, 0.6514690131180897, 0.20798193246901675, 0.3462850532841921, 0.8188759557766279, 0.8074842677796892, 0.8838202064076152, 0.21123843777347606, 0.16664565183376912, 0.6933131650952777, 0.16696581400887667, 0.20235957509770364, 0.8451928954970664, 0.20937012472815886, 0.5749957763120608, 0.20786855543806282, 0.1662126277046695, 0.2092531321018355, 0.14914564922841744, 0.16159902042519458, 0.38789413709058906, 0.20012818380092867, 0.18027413933578207, 0.18503456330514267, 0.19796826948211144, 0.1932344587141983, 0.1961063359449412, 0.20310563360912215, 0.22599533725793108, 0.2074259342040533, 0.07862569805423159, 0.07566612398810157, 0.07790996612347445, 0.07924076179660655, 0.10191216475726139, 0.09654525789456458, 0.07698102626833092, 0.08454436356426465, 0.09397270206289632]}, "mutation_prompt": null}
{"id": "0b39f6eb-37e1-4c3f-bcd0-778d8b226c77", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.learning_rate_scale = 0.1\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor * self.learning_rate_scale))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor * self.learning_rate_scale))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = 0.9 - 0.5 * (self.evaluations / self.budget)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive learning rates and dynamic factor scaling improves convergence by fine-tuning exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.32305085229450947, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.856268446577251, 0.7885788546229909, 0.825692759731944, 0.8169396696889399, 0.8165343348304983, 0.8221318873820971, 0.8574991583776574, 0.8484938391104544, 0.2057546162524745, 0.7196948488332556, 0.6865371734619621, 0.6939979527068336, 0.7422191047494593, 0.04693697693315768, 0.7226101998821388, 0.6693641137525381, 0.7166023817174723, 0.7025282605474921, 0.12286064145220565, 0.1735692014339122, 0.15763774736021519, 0.14473604530214956, 0.14412946723693476, 0.14538322713145113, 0.1588615813522556, 0.14699088686841533, 0.13283766240168193, 0.13787616828361882, 0.12283251084218061, 0.11236172487908402, 0.15791392312482455, 0.11016870022745295, 0.10956760364713758, 0.10049993629833665, 0.10589485066441506, 0.13601504386171548, 0.9856712848220068, 0.9645382946683969, 0.9728214658364871, 0.9413156597615304, 0.9673708819926491, 0.9794759398589621, 0.9720719482511969, 0.9721670807456628, 0.9800408515389204, 0.49045192447991837, 0.43562855264254263, 0.05564797009976352, 0.16632300962342184, 0.4272562848980368, 0.43720847814123953, 0.16202464229447666, 0.5524733107540454, 0.11993277394824764, 0.7449805631275701, 0.7495767855150444, 0.7701578670448406, 0.7916262243080208, 0.19928651349437132, 0.7139406533787642, 0.7824651401335974, 0.7064052280545874, 0.7199889234803576, 0.26990294619680166, 0.2991617968709719, 0.2683049959312802, 0.397118204864329, 0.18256436515131613, 0.16079755347441405, 0.3489846956661612, 0.2634791147313271, 0.16753171922834442, 0.14037014376206602, 0.043272438969750304, 0.21612048474380474, 0.240080262375431, 0.2344537515876215, 0.2504454669140189, 0.18130030865699354, 0.20919436422453197, 0.21317383983346627, 0.17823069106697442, 0.08592677369597257, 0.1369262739189704, 0.017846801649269217, 0.16227471455175457, 0.05780873063930447, 0.047524791178365944, 9.999999999998899e-05, 0.16327177350409006, 0.2136934717642356, 0.22424584671963654, 0.18666623489441092, 0.24001389440959542, 0.19297143960749674, 0.049459823416145854, 0.19534660168346574, 0.1619007522584205, 0.10680994052423942, 0.026143131113529172, 0.15903744960376132, 0.11678108732029069, 0.1395363299736051, 0.11820250953193046, 0.08838442953914838, 0.08902454147812766, 0.07941866743129145, 9.999999999998899e-05, 0.1792138490520203, 0.36405922892747455, 0.011141970191792971, 0.2536188170789695, 0.18460285961040945, 0.264688855045507, 0.048820762568178355, 0.045796887817154075, 0.25700688927435744, 0.6878578623310325, 0.6819972762169864, 0.5259293137280643, 0.5609786453149808, 0.5650411677427318, 0.633045120415714, 0.6363255624473383, 0.7118845190698427, 0.5752635343433488, 0.11323208055799527, 0.08232945083958476, 0.07252502373252645, 0.07633423523310723, 0.11390888058138349, 0.08906295744042714, 0.08513693390894661, 0.0963893284135624, 0.1278383600040104, 0.40944493792120407, 0.24053095766428945, 0.20712493439475976, 0.17486961926957667, 0.23041546649477973, 0.1609814493828704, 0.17297086037154263, 0.14126354763175153, 0.1838559111853324, 0.4220712172545247, 0.44009635928732427, 0.4301549395697539, 0.36955717437899704, 0.383093940176086, 0.48842544383942554, 0.4407344710507852, 0.5289159298606215, 0.2027347742679415, 0.3714030152168851, 0.33193557496276294, 0.23554246301176895, 0.3936329975978541, 0.2858215637496605, 0.18070561236378613, 0.39524197769546754, 0.12538371000956272, 0.2570309137338638, 0.28773306704622326, 0.20378570881394753, 0.2766798773958039, 0.22923320491184718, 0.18558298143941387, 0.19696992779624645, 0.21289749867829588, 0.233957101550197, 0.19965664690268836, 0.20854244578266445, 0.237444562244838, 0.19950578091771942, 0.5104225875031854, 0.20710447903152573, 0.5612342292740314, 0.21026332202776554, 0.6204816010631604, 0.2125894442679198, 0.18645419528081586, 0.1916434668207858, 0.2084964464254243, 0.31482765545434843, 0.7398500083493049, 0.16628047643941168, 0.16529347827039031, 0.7693294769235115, 0.16790765347274972, 0.44963672366667473, 0.20745201103507993, 0.4997951869119903, 0.2031933203362839, 0.20305138035084735, 0.7774270127632916, 0.3310186847150871, 0.15016268907285335, 0.19733139174575454, 0.18223806758666095, 0.18939441803525858, 0.2022117500860119, 0.19229341496898877, 0.22807358525863197, 0.19758084936474785, 0.17937797302897474, 0.18896548157373638, 0.2365905625982948, 0.10108119154936535, 0.0781714113815466, 0.09089136213923776, 0.08809140444818964, 0.09166448443386255, 0.09539490884237001, 0.06478574239824497, 0.08221889971998553, 0.07547982020932409]}, "mutation_prompt": null}
{"id": "58c3ef36-515a-490f-a088-6f26e0e2675e", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * 0.99)  # Gradually decrease inertia weight\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Modified EnhancedHybridPSODE using dynamic inertia weight adjustment for improved convergence by balancing exploration and exploitation.", "configspace": "", "generation": 48, "fitness": 0.37485289301279595, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8680999434837029, 0.8730059986794882, 0.8501287408818128, 0.8586125197611942, 0.8642640786335765, 0.8608314423083733, 0.8675493914164398, 0.8635349455616561, 0.8720237013173885, 0.7158020418135642, 0.6794033705363127, 0.6981646269660553, 0.7218806145599401, 0.6779210224604263, 0.7095553530994217, 0.7364220077098746, 0.7091553547571967, 0.6832174005150415, 0.14485856741797964, 0.1244097295200598, 0.16202639079224446, 0.2619159970877547, 0.144324720350556, 0.4222372776981673, 0.15594264636128408, 0.1422477289536791, 0.35402570308088044, 0.11813808936749681, 0.13063141684832935, 0.11546453991098438, 0.1233337825458084, 0.22209049589825658, 0.3536737499799213, 0.15596163429883036, 0.1113981728173421, 0.14008113350537676, 0.9816687823429224, 0.9774146899805567, 0.9674258258391374, 0.9686767443730361, 0.9506360356121049, 0.9743240469176847, 0.9779041596187372, 0.9523752551720555, 0.9872213712312529, 0.5714994080770299, 0.5812621790948922, 0.5534665411158555, 0.522846993888092, 0.48810439692133145, 0.5353066497001908, 0.5505579088124064, 0.5670686647967156, 0.622122524617472, 0.8074643696106434, 0.3281271018257378, 0.7223567484583437, 0.749046568228637, 0.7551715316518531, 0.6391938646455104, 0.8145122491059991, 0.6030670448890362, 0.7429016970953277, 0.36083794003534697, 0.30451347813689156, 0.2400390162331274, 0.369167258567315, 0.3818774239519074, 0.3224926625743204, 0.3131062806662288, 0.3127793462637357, 0.38202944052400245, 0.3430778866386177, 0.42203886636482935, 0.20351898729587414, 0.26646046634310083, 0.39766410675454567, 0.35590330810321136, 0.2764382108297382, 0.3357839351228533, 0.22013218301556026, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.05688856562762068, 0.1178810278593726, 0.2548056643512837, 0.18229159578732979, 0.005181282718090929, 0.34465101961869316, 0.18386716374073475, 0.34414282542679375, 0.14162888087641656, 0.15502598728141492, 0.06540721814239692, 0.36576456613488906, 0.43310344231501563, 0.23545046119181823, 0.29046798300586774, 0.19481908272763826, 0.12001131304367285, 0.23947449482880812, 0.15630979350551022, 0.1430605036072259, 0.12419649887107931, 0.21247127030440605, 0.06760713274999364, 0.30634533252353346, 0.12120505560038364, 0.2938563944968373, 0.3276376748275579, 0.30971438169784804, 0.3102509629006919, 0.30368614564687624, 0.4025055896121694, 0.26707304912475005, 0.5767503069802415, 0.6403137644909478, 0.6494135799259027, 0.5497332867146751, 0.6095007816557422, 0.6366676959066382, 0.6987657286979752, 0.609949819679626, 0.5806001975789343, 0.12017251348140157, 0.12117397990116918, 0.1074732974203716, 0.09517321309046456, 0.11213090764601763, 0.11283106672923227, 0.09150466977606497, 0.1079194018712416, 0.082761740603703, 0.27518880358063147, 0.22832334145368027, 0.4053147894559328, 0.1997976654732594, 0.37625483990268505, 0.23013588652610895, 0.28072603410012864, 0.19429452514299306, 0.266381169225253, 0.4318240571298618, 0.36699976635441056, 0.30487870067052625, 0.37129352022077045, 0.3231817909903074, 0.36407552957611455, 0.43949154029969995, 0.4705690403960472, 0.36940505298537996, 0.2965055997522851, 0.3537896848303751, 0.2991301175093717, 0.2696819820604729, 0.22804411723967, 0.2973529876016128, 0.337943826564435, 0.301454761203659, 0.2799800803250435, 0.22572393465737917, 0.231728698970191, 0.19564296854760388, 0.23089961306502116, 0.2199985316424542, 0.22851288823471883, 0.23278174292053666, 0.23105340774633654, 0.25247906443686563, 0.1996935314462025, 0.6091865020758662, 0.21620435613459477, 0.23567205779816858, 0.20189512778926244, 0.20741934445341248, 0.4845418723572409, 0.24783612687983492, 0.21748777785111417, 0.18758975315052617, 0.18774039950749444, 0.15414611831105918, 0.9287475699563272, 0.20107415905125203, 0.19418805564319508, 0.16819755813773896, 0.1949084756259184, 0.7898606547054652, 0.7760792261510658, 0.2043543739381123, 0.7957019830429529, 0.716294155627635, 0.2105042704698229, 0.7426638109018361, 0.7945759005570198, 0.20467621653824886, 0.5276781863761018, 0.19285427355573215, 0.19915350541594878, 0.2034385688825191, 0.198056113532454, 0.20126087649709645, 0.1892934164771367, 0.25883871022903593, 0.18574666443395704, 0.19834779377086542, 0.08365916626187331, 0.08214785578126504, 0.07288788596900142, 0.0899866070405888, 0.07790668023838931, 0.09137960863520733, 0.1169493716753579, 0.08355561645290654, 0.07192302162128017]}, "mutation_prompt": null}
{"id": "87192328-b10c-419b-b2d5-2d8518293ab6", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.7  # Adjusted for more gradual change\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Slightly increased to enhance adaptation\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.mutation_factor = max(0.5, self.mutation_factor * (1 - self.adaptive_factor * 0.5))  # New adaptation strategy\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive inertia and mutation factors to improve convergence by dynamically adjusting exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.33061772271477746, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9195114100478251, 0.8976062954865867, 0.9128815421815859, 0.8556737613686151, 0.8740203772644949, 0.8891060926698455, 0.8885542009387847, 0.8926567783150937, 0.883528634748091, 0.7643634398092489, 0.7102847357463811, 0.7023938466960513, 0.7459242120578744, 0.7602745092646989, 0.783177889840228, 0.7851441771008546, 0.7567806814031978, 0.6862175681154832, 0.3650672810882588, 0.602059884755341, 0.15251124971840235, 0.08286508649385194, 0.14190199566903705, 0.1558499426784603, 0.11748661246243519, 0.24665645215737753, 0.13184120741650618, 0.10140802885210409, 0.09410674415334974, 0.10955015691611047, 0.14253300078782627, 0.13689919251758165, 0.11381746488762057, 0.10775067457862353, 0.15284340121288298, 0.11008105539368318, 0.98369090121115, 0.9415916671389732, 0.9743088156190262, 0.949364756176253, 0.9619947248163778, 0.988016618554403, 0.9688585199265553, 0.7914073139260502, 0.9862032983662117, 0.5393859785687525, 0.480340345290559, 0.38139364083850413, 0.4475254538161343, 0.4219349151756552, 0.5265992659759802, 0.535542930192817, 0.41227876956865006, 0.558907051913757, 0.8696937310761342, 0.22236155988658224, 0.13915709874950277, 0.37408546835372203, 0.32644311803681025, 0.347820451230042, 0.17368824574425157, 0.17293371733502538, 0.1783498939788848, 0.18726606191939554, 0.18042616573760462, 0.22307533043328642, 0.2432973658850125, 0.20068056446495108, 0.22313454402557398, 0.18195352685343424, 0.14205600746074254, 0.15509114175279481, 0.19845480852523256, 0.04853188262659236, 0.19055619447964778, 0.2740547842315255, 0.14999323220598892, 0.2651424466040351, 0.22619253465185996, 0.17318596979458467, 0.19773778186721702, 9.999999999998899e-05, 0.08674555382967697, 0.0931498358672207, 0.0852532271321994, 0.052638100040969804, 0.06268715353013576, 0.008089623948256519, 0.029497220745299813, 9.999999999998899e-05, 0.08333890170966118, 0.20014421605460497, 0.11744643332461402, 0.13853620491818275, 0.04169738231942266, 0.10635885271353651, 0.2588933491197768, 0.20264035277976, 0.15622563274958956, 0.13474582906740107, 0.1606572351069101, 0.2381020779832148, 0.18140475611082651, 0.32639788902975275, 0.38555077162794826, 0.15936915081852132, 0.2650954622913423, 0.2844740356107396, 0.05660655145027449, 0.07989465854946398, 0.1855943281907062, 0.2776622925932313, 0.2405906170436508, 0.1944156719851282, 0.19472618264237151, 0.1702873946743001, 0.1475001405922619, 0.5742082055463169, 0.5767309322672487, 0.5379685168461279, 0.6089404478123357, 0.5829033107488961, 0.4838923907611111, 0.5060801376784737, 0.5227284570674046, 0.5265189295202799, 0.11873505359288006, 0.07938576359539551, 0.1304255410534244, 0.12266280852965794, 0.0729992050758016, 0.11116025600706214, 0.14304637509245588, 0.1242832456158185, 0.09766280333479882, 0.2587344119305618, 0.17289142349197495, 0.2659561089806127, 0.19468761129782008, 0.1995659432431487, 0.23061191579772422, 0.203201530262056, 0.16134308957440258, 0.17880380503512516, 0.4326908110706763, 0.6083443505756446, 0.44555094874484835, 0.44614310877827745, 0.39821750532922073, 0.2902321517517904, 0.18898490497706577, 0.4944100481307845, 0.43262376181347073, 0.22081904139344943, 0.3183139347673648, 0.41131388493856036, 0.2933967225694216, 0.3058380963087485, 0.3661493170351656, 0.40624936770269593, 0.21844219092677264, 0.38043724611463836, 0.23119653360927273, 0.21624095483274008, 0.2532147657694861, 0.22822647483026515, 0.251530851982804, 0.24225031376142492, 0.23900174075004832, 0.2501351092965838, 0.2627752310907392, 0.19944633845343174, 0.2152429567352525, 0.2212114337069242, 0.20531463398688898, 0.19846903570084606, 0.19558129212633402, 0.22843665380470868, 0.19656478828332236, 0.21554443724692596, 0.7637751837624419, 0.8850867032378843, 0.8461020868490685, 0.9220202586580146, 0.20029612822104836, 0.18743492553932006, 0.16745512124046913, 0.1752962815229725, 0.16826862840138435, 0.6230695821604332, 0.2098535789145124, 0.9091916053081623, 0.20636091109971355, 0.21083580880611474, 0.6209395296676761, 0.15458369887937373, 0.2065807751290969, 0.47003800091961556, 0.19109886086744787, 0.22554165604115528, 0.19373399244135736, 0.19955154435533617, 0.20685389614041239, 0.20425490868920892, 0.20166723771096084, 0.2037148338594249, 0.23697875958991554, 0.09405918046395068, 0.08405024746046874, 0.07881984322954017, 0.12231082541212834, 0.09764074938345513, 0.10320113525570318, 0.08400552581236387, 0.09289304681479693, 0.07653862995990879]}, "mutation_prompt": null}
{"id": "ba90f3e0-f92c-4ccd-b07e-ec54011287d7", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.velocity_momentum = 0.9\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = max(0.6, self.crossover_probability * (1 - self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = (self.inertia_weight * self.velocities[i] +\n                               self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                               self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = self.velocity_momentum * self.velocities[i] + (1 - self.velocity_momentum) * velocity_update\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with an adaptive crossover probability and momentum-like velocity update for improved convergence speed.", "configspace": "", "generation": 50, "fitness": 0.32765855377805525, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8359492275921513, 0.8103244851404209, 0.8286738541182291, 0.8313736539616564, 0.8216016312338884, 0.8461966465182374, 0.8228278780051049, 0.8389024274260021, 0.8365029563836648, 0.6742194939459822, 0.7049583383305391, 0.6418561602262893, 0.6780613510297261, 0.6841884836344081, 0.7074748486219398, 0.6669490118139978, 0.6930025493798166, 0.6748964108307194, 0.49922288721331165, 0.5841294739056446, 0.161180679597684, 0.1368887233241587, 0.09637980878917607, 0.5254942007892918, 0.4610424920994749, 0.5135306337791261, 0.5211204597984678, 0.1541739483607022, 0.34195006391827, 0.4442597992072961, 0.16418826128638342, 0.15342252984337723, 0.11895560648689885, 0.487994621673986, 0.4171487732740159, 0.5699064126865221, 0.9689897511590906, 0.9434491460528261, 0.9763646519632097, 0.9745659256555764, 0.9796332433792849, 0.9896745451306754, 0.9595137480510043, 0.9730871783536216, 0.980489818709236, 0.42667359150929085, 0.46194520420880913, 0.13589465329303074, 0.4338540549085804, 0.4371666961374584, 0.41489069427123104, 0.5339153114783404, 0.42299144288736557, 0.43935098228601377, 0.3074537598691883, 0.6680273726348743, 0.543190892365566, 0.3794104585382746, 0.6408374330458124, 0.6414958976388263, 0.3237133660727972, 0.3723593857168749, 0.4830981392310313, 0.2660933658238428, 0.21558311359743054, 0.24834227160973255, 0.20418983525688195, 0.26063592353421505, 0.20751825335321028, 0.30802595529921895, 0.17565669094978098, 0.18537169033892154, 0.2902036368873847, 0.1279286577065183, 0.17695529339191673, 0.2212512330956815, 0.19490827531657728, 0.22955955019901997, 0.18749851919182237, 0.18787955042508042, 0.23773192059800186, 0.040182802751644875, 0.01944458580556707, 0.002015808625166371, 0.01782666678683109, 0.021256314848915103, 0.03666734059514565, 0.000795033271874801, 0.06205930096991341, 0.0001189434872729267, 0.15910868343320816, 0.0925165533606096, 0.12005195740406183, 0.10250208327560717, 0.05951955281955956, 0.022637357618542464, 0.08601254956432913, 0.10912472710526477, 0.09353012338792466, 0.07146390309539197, 0.11357093315280165, 0.0784548837049368, 0.06907147984898399, 0.07689244385967153, 0.14447082538623401, 0.06646620533167114, 0.11606691949812431, 0.061864452205460996, 0.12350855762414159, 0.1338034198934367, 0.14158217497690873, 0.14947542602840058, 0.15711090780300552, 0.1346636423817319, 0.12445429914267825, 0.18801950970468628, 0.14249152613070437, 0.5279238037965444, 0.5110919995149034, 0.5346003200584099, 0.48829443067773404, 0.4961236410627081, 0.4494084883863182, 0.5581872744690409, 0.5029925274980429, 0.5326212058171653, 0.1177930005206117, 0.1054264076462208, 0.0960670707629, 0.15820628487340982, 0.07684271989271763, 0.15213726798398786, 0.09160539500117337, 0.0846364544741095, 0.0927763778973747, 0.24831592487200127, 0.4209911784774144, 0.29260258171666687, 0.21982725387571111, 0.2706465018813118, 0.16810551160404708, 0.15194183016826224, 0.19319533185598547, 0.21891099872696695, 0.3152977931054205, 0.35396944885172243, 0.25563972265009505, 0.30495285593029897, 0.34622656888678505, 0.2891947008673026, 0.38924085903443617, 0.37675648562987774, 0.35873860213215225, 0.18591176817221744, 0.2821392028733952, 0.18160883512292347, 0.21967049477428924, 0.2168344433135515, 0.16417844904936008, 0.2933919279562728, 0.26345444541986496, 0.2345888081735512, 0.2181302186797126, 0.21043233649578885, 0.2023466752391183, 0.23394287053447183, 0.22095424824641663, 0.193737896597322, 0.22208708350796003, 0.23377289019747372, 0.24431319784319638, 0.3213935677277261, 0.1949717961222659, 0.28828844353075667, 0.25908694662333853, 0.22577735619913686, 0.20472491866885667, 0.37489044409798467, 0.636806362859673, 0.3363504117676872, 0.18692065444332295, 0.18213036483123946, 0.705234331209665, 0.7975581398875694, 0.19934758222818516, 0.8119343675367805, 0.18557848612872707, 0.1751110170451573, 0.17419605286150364, 0.6277622307920914, 0.20365153044941542, 0.5787883063045278, 0.19899609548436614, 0.4411960576356547, 0.5514305500318384, 0.20636135938764477, 0.18938316377285025, 0.37053467546685515, 0.18442543144838142, 0.18546855817382746, 0.19133618503047856, 0.20461656970351794, 0.19425372656413642, 0.19488571983497882, 0.18855509692962702, 0.21690781884144805, 0.18784010196777867, 0.09830300037356066, 0.09526773392989385, 0.08037927406278855, 0.08740977883886225, 0.07516489438969998, 0.12158795366579966, 0.0786154607711187, 0.08356049712928582, 0.07935822828311956]}, "mutation_prompt": null}
{"id": "969efa79-3360-4f09-8423-18fcbfe21b85", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = 0.5 + 0.35 * (1 - self.evaluations / self.budget)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation factor dynamically adjusts search intensification and diversification for improved convergence.", "configspace": "", "generation": 51, "fitness": 0.361304770550498, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740457831127885, 0.9109894083093829, 0.8637319092588174, 0.8599012447742291, 0.8864715245173794, 0.8839979333724417, 0.8975221816976149, 0.8601168784249997, 0.7702746582515572, 0.726518588591289, 0.7680795452488806, 0.8028739063073087, 0.706271102034226, 0.7899805155251516, 0.7373700566359676, 0.7789538384279086, 0.7510380828418277, 0.16942967168137146, 0.5244061477168784, 0.6111101931995849, 0.14412140737247392, 0.13158213439885824, 0.39994910461258637, 0.13888902985699092, 0.140210333926979, 0.16389375935147088, 0.13943357060144024, 0.12057634981403531, 0.14064500100974897, 0.14352442598844772, 0.12798486082328198, 0.11302486122528665, 0.12183252536556788, 0.12747750757443788, 0.12130648460022131, 0.9816674087375358, 0.9773455952481944, 0.9526569161465059, 0.9548193710662201, 0.9707740187166515, 0.9747553912166711, 0.9779038879764631, 0.966014149798678, 0.9872186115812535, 0.6872486641787656, 0.5511202289772571, 0.5114862820706387, 0.43138737568417795, 0.6604869988965374, 0.5606208989924248, 0.6202698599364346, 0.5133817372089637, 0.6345082972143395, 0.3562314762019517, 0.6859611380587232, 0.741255348124364, 0.6283362668437527, 0.687901874320281, 0.27655334853904223, 0.7818510924103563, 0.783151994747733, 0.7607721281650295, 0.39119380326507924, 0.2295125548257294, 0.18148717879155696, 0.16691314510136057, 0.30621503518667437, 0.16768326564803793, 0.4838817770533904, 0.1817087960985473, 0.1771136242902015, 0.19634497619456748, 0.17377434941762804, 0.1953146121273156, 0.1954525168957476, 0.2037291770262406, 0.647473363090618, 0.23582840003145478, 0.2206737800265821, 0.18234243756241975, 0.06977748332293654, 0.0633312233995752, 0.07876137436176955, 0.20734761750102337, 0.21229429311659775, 0.06792375363934533, 0.18529399768296628, 0.04188152562266256, 0.007075344688604823, 0.15751582942898024, 0.3667737011738257, 0.34423159058481156, 0.2898503115857809, 0.19311689056558334, 0.029281748093582194, 0.4302591692622052, 0.16194172122628314, 0.09422822303505218, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.20147680994234551, 0.18678840679615272, 0.2366400771143139, 0.1673114131180179, 0.4158064048518688, 0.07092797631311754, 0.2631752911966784, 0.13617863520086615, 0.3411757321075739, 0.32635464710993733, 0.3764968957700927, 0.28654321075768086, 0.07925732184407752, 0.2139990061945668, 0.21154487083511475, 0.7528797606844075, 0.6512948615723826, 0.6217833980694499, 0.7152301001432464, 0.5215667278856356, 0.6190846692415009, 0.5307784102669035, 0.5555946572786497, 0.6318223969692215, 0.06528666639961123, 0.09742528348705382, 0.11630426618686796, 0.09301218097831876, 0.10955457161375037, 0.09288287270521955, 0.10673195854978657, 0.08705839653779734, 0.11270607160503587, 0.16207838135266606, 0.27408167073423406, 0.19356880300813772, 0.2535730558211471, 0.22241170055140957, 0.1319122327607294, 0.20241160213346077, 0.10784000677490169, 0.17072119746176317, 0.24845543346516308, 0.172816566548887, 0.38191539870129865, 0.5088008646539677, 0.4700937780244472, 0.3771970956859929, 0.4208229037663317, 0.4895872021938992, 0.5402272934519405, 0.20958191332146747, 0.3173584113765594, 0.2881738517340232, 0.3045396551936005, 0.3166598443898392, 0.22490219155964175, 0.3828425327860371, 0.3109876963399776, 0.3691685264071458, 0.21000813929829032, 0.19687724850492894, 0.21434924646359477, 0.2427349407365086, 0.27509636559815076, 0.2323423347024992, 0.23542435291166008, 0.21643728780574256, 0.195456377831578, 0.4505799761075322, 0.19994275757001245, 0.555447514597976, 0.22795673634743385, 0.2015598877053768, 0.2094664673017007, 0.18515076817014808, 0.22555015432200698, 0.4176654305809189, 0.20769260457983862, 0.8727635919564205, 0.18073927139384183, 0.917718114913855, 0.20065701392642843, 0.2027203349784018, 0.177199288368745, 0.16750538307400997, 0.26836158980667046, 0.5911833438454489, 0.20793227042696316, 0.5675370574465796, 0.5266000213025085, 0.21071578828129245, 0.21015896865644013, 0.4679374955284574, 0.1856670176685019, 0.46436833338675343, 0.2116022353165694, 0.21168409126836585, 0.2014936303759043, 0.208470799852567, 0.19488337203536044, 0.19745805284594875, 0.19648405443698824, 0.18805445844793056, 0.18385028177482476, 0.07796342089088826, 0.07755444373026565, 0.0770135907370102, 0.09512621074360117, 0.09264000861585409, 0.09707426194812818, 0.08676267447475128, 0.11054642818540872, 0.10547547046641703]}, "mutation_prompt": null}
{"id": "dac48b1a-860f-4b05-8b96-f0e27faf268b", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.9  # Changed from 0.6 to 0.9\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.9  # Changed from 0.85 to 0.9\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic inertia weight and crossover strategy improves convergence by better exploration and exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.3613935896826116, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8992447879206882, 0.8917843685932608, 0.8849674613200802, 0.8684751361109352, 0.8777258221052417, 0.8901764695330248, 0.8943954453264596, 0.9015755922270179, 0.8982537392980373, 0.7401638371858299, 0.6743748609988918, 0.7155234475983824, 0.7439859356546754, 0.7112891495649567, 0.7059181965435606, 0.7300230695921679, 0.7203338602386409, 0.6903288234930933, 0.14743736304044763, 0.13877018734564595, 0.12199819955578461, 0.11012714892018882, 0.11992180673835551, 0.13894604170135627, 0.30403505731290215, 0.2976380764040404, 0.11818523032325878, 0.12507428009106591, 0.16021181902701342, 0.14097164275768415, 0.11706266264170839, 0.13151465907153503, 0.15308449652558487, 0.1365041754874614, 0.11734872971685295, 0.08217477885605151, 0.9066463375018168, 0.9540604913210207, 0.9355953584781562, 0.950710701955167, 0.9547714383630174, 0.9729283188098906, 0.935475886500289, 0.9490028033861899, 0.9643556895197113, 0.636839516537826, 0.5655408367228068, 0.5672239802273815, 0.5841800905298828, 0.5669013149446573, 0.5558730977325431, 0.551312717842642, 0.4976593369453578, 0.5373819371380779, 0.7802913959008158, 0.7650245950264254, 0.7842168658989979, 0.27892009608809254, 0.21653016300769923, 0.27455242389855705, 0.8100762156110142, 0.815284065653298, 0.7888222050669698, 0.4768339356207295, 0.2947579130746484, 0.31518787202810095, 0.20990824628933147, 0.26596428541391415, 0.1495113998999681, 0.17751508985682973, 0.4570836809431714, 0.42008772994190513, 0.13529002774675647, 0.47368235741179954, 0.19962342555060852, 0.20157236835265235, 0.34025436457462244, 0.4553294988263561, 0.22236432897697367, 0.3973746676734692, 0.2580277298249838, 0.06103065617625547, 0.0994736430279316, 0.0867089022097709, 0.06537968575526698, 0.09248533821618932, 0.08752332317921663, 0.15492925607660657, 0.2285336524936713, 0.10888440308034975, 0.1630960011934256, 0.17123770546532646, 0.12546756038549267, 0.27416577376015516, 0.11266743762247411, 0.13394570667157035, 0.15635215648984357, 0.32643608816317315, 0.2601070218829207, 0.12523554254019653, 0.31333763411583937, 0.24750849488639237, 0.12942249988335153, 0.14260425963797863, 0.21275406285618637, 0.08390782771211658, 0.2551975895754621, 0.19429399605180342, 0.2970966100322774, 0.3233203171196535, 0.3494461871727803, 0.1377313672926852, 0.3636207029507392, 0.36347466931414474, 0.3194201307980761, 0.24356129259255987, 0.2759395464494445, 0.674641385333439, 0.7616686327210208, 0.6753026596481814, 0.5712401212270748, 0.6164437339918227, 0.7039224615779156, 0.6502526503888284, 0.6090756613403612, 0.6691864434604937, 0.061388724913520654, 0.1345736600727916, 0.12601460115431096, 0.07771180846946901, 0.11573848299452316, 0.09036538320441645, 0.09654108531600081, 0.09721347633486943, 0.08692795525804375, 0.30659352912388693, 0.16137190885320418, 0.26304739624864937, 0.3459868228821258, 0.2246175350551527, 0.2482383675403208, 0.1946389472161848, 0.16188937554629323, 0.4928458941465317, 0.385318153913211, 0.4030660978932855, 0.22952717888255325, 0.38249502883878594, 0.36594220629159535, 0.4097455944496581, 0.36682109193175516, 0.385071588776679, 0.4017311540256011, 0.2886224378102966, 0.2778703157468356, 0.2822437864527473, 0.3076464656852056, 0.2460885973781225, 0.303763705045589, 0.3252845809224528, 0.2604106423725834, 0.24662417422945604, 0.19275146263233223, 0.198966386234101, 0.19855126988524863, 0.1844559814517467, 0.23557577880664515, 0.2428385955904485, 0.266524760907219, 0.2535977766342745, 0.24752833475675773, 0.1962086637783419, 0.20377752830658347, 0.23724731830821588, 0.4434436822976643, 0.19733342799428133, 0.20754859325535335, 0.1922888798873178, 0.25428214782115, 0.4800969140528548, 0.8682251279830062, 0.1877624611435873, 0.1860166678055526, 0.9337588704995227, 0.2011048894774231, 0.18274083528939222, 0.17208508641245623, 0.8555946841278351, 0.16988550727661844, 0.6006115096750559, 0.20988530218633406, 0.484365448048966, 0.21042961210967337, 0.21129151980262528, 0.8330390241640024, 0.37576613886599275, 0.20488279812377452, 0.4322939891087899, 0.1915502375815228, 0.2282996888315868, 0.1855075467369145, 0.191565298780633, 0.19052308284268094, 0.19141957559469658, 0.189320244005042, 0.21688945316444952, 0.1915589558975218, 0.08480228618671204, 0.06835871450485353, 0.08308168902180968, 0.08241814907323564, 0.07362722176673797, 0.0837722577629405, 0.0664217851036647, 0.08850612790566215, 0.07853437304811361]}, "mutation_prompt": null}
{"id": "fe646168-a2a8-4777-bb63-ed81ccbb8384", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            # Adaptive mutation factor based on progress\n            self.mutation_factor = max(0.5, min(0.9, 0.85 - (0.5 * (self.evaluations / self.budget))))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation in DE dynamically tunes mutation factor for better exploration-exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.3566723899822248, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8753149514150536, 0.9109894083093829, 0.8610474692946198, 0.8605585427075364, 0.886455020026294, 0.8839799815520734, 0.8974801159179001, 0.8681126486950015, 0.7727210698385165, 0.7310514146632561, 0.7693130790018752, 0.802640895970506, 0.7371403545878565, 0.7894321245870932, 0.7376442859607018, 0.776855238796524, 0.7430378767679509, 0.13489240059269947, 0.1395271299664229, 0.13461932323321724, 0.1398218827908373, 0.17465305817425547, 0.1349940519542786, 0.12707349044819638, 0.15123568486989603, 0.11615653554213823, 0.10974127041575554, 0.11201726125764488, 0.13612082356786048, 0.11802257727615906, 0.1195036422510306, 0.1562341667977658, 0.13469354735308703, 0.2769564274072239, 0.1330313944098176, 0.9816670086082638, 0.9773037740595446, 0.9356675433360605, 0.9657604223026639, 0.9705925029004779, 0.9781907446838325, 0.9779040019914932, 0.9431663886693923, 0.9872174642614624, 0.6872486641787656, 0.5218550813294123, 0.511425726988451, 0.6089832777823114, 0.5746976909263073, 0.5306432518215122, 0.5890337691323779, 0.5007394721851135, 0.5170339479899665, 0.8136804571714389, 0.7820467123410899, 0.764254662090933, 0.7800002631916556, 0.3576075821720799, 0.7730308526765729, 0.8032502250090698, 0.8042059438463087, 0.8232762812504608, 0.2874944131909446, 0.17853849118734266, 0.18138471978684245, 0.28896404848470825, 0.19125915647916336, 0.16357902537221858, 0.4838817770533904, 0.16892685231779614, 0.2046634750330737, 0.3295478951958579, 0.1931228348380123, 0.1953146121273156, 0.25696058467600114, 0.13363338177358797, 0.20995873603327886, 0.23582840003145478, 0.2637866982784529, 0.24683150934708276, 0.0767892987799752, 0.06120281718905496, 0.07850191871698786, 0.047510019155070915, 0.07306954827510181, 0.0739028276169511, 0.04686036611091182, 0.09985083755412927, 0.1522497352170703, 0.3403215505170072, 0.16104919828228192, 0.2991160103472653, 0.3168401643261196, 0.2225404319079588, 0.029281748093582194, 0.13415529563718287, 0.23889935029211595, 0.1370446577781086, 0.1691577041449427, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.211198727910358, 0.18866849037849054, 0.16508389033102555, 0.17319220504216915, 0.07092797631311754, 0.2829451682962292, 0.36585296009438717, 0.21188690989400982, 0.3091994157067909, 0.33635492349564833, 0.27738812352335485, 0.20961947620974164, 0.34601920170420075, 0.1700128374065909, 0.627494767666857, 0.593004228595344, 0.5939724174808243, 0.537720943739411, 0.6573577759538645, 0.5863588622933327, 0.6266144010999625, 0.6015396860583979, 0.6048404566641846, 0.07203472474354189, 0.10341032318121324, 0.09311216178710835, 0.09233315513828133, 0.11651947115989092, 0.10530828709402973, 0.12501821404528712, 0.09957027737226998, 0.11270607160503587, 0.13777534530812952, 0.27408167073423406, 0.1936406236996061, 0.25424221884951326, 0.2196257228399363, 0.14031239032810772, 0.20241011041812218, 0.19545508276873025, 0.16715691820305278, 0.5550555210969674, 0.39514235696233424, 0.3651264135774398, 0.4604435112840718, 0.46747100339433867, 0.4541483238398204, 0.5123871877445743, 0.5326715044914949, 0.45854305018533437, 0.31890061094181554, 0.21924536450654297, 0.3469365758829398, 0.242692812371876, 0.38582826889151767, 0.3226942094649268, 0.3080521783601188, 0.3661581013424643, 0.4042770612575599, 0.20672086070197715, 0.1711132509845611, 0.21329478777631516, 0.24167268071094927, 0.27505233670434215, 0.2326618881186282, 0.23542435291166008, 0.21642040377158178, 0.19461397381852008, 0.2030395912966182, 0.227917875692774, 0.2377669021047173, 0.2229248415798727, 0.1962810996790496, 0.2386519487919827, 0.21576053196710498, 0.4094690699057574, 0.21471302288402716, 0.18634397186737262, 0.8727661636700089, 0.18058151667112177, 0.917718239134767, 0.20065701392642843, 0.1992015647678227, 0.1712750883260643, 0.19290620722363738, 0.16604365110164565, 0.5911833438454489, 0.20922707342288804, 0.5675394532454587, 0.39248668626873173, 0.21071578822220383, 0.21015896858952154, 0.46803375447212126, 0.15190686965886402, 0.4643179646206701, 0.21184692634815405, 0.20696457076711372, 0.19001640098389583, 0.20837529247274944, 0.194946338548455, 0.19440642730891922, 0.1845072572508233, 0.18782435887004445, 0.18385028177482476, 0.07815036902508143, 0.07826438077610531, 0.10904357321878866, 0.09513848841887107, 0.077574414597541, 0.09734875497836926, 0.08389324783189911, 0.11054642818540872, 0.10545857602501707]}, "mutation_prompt": null}
{"id": "d6269561-7a66-4b33-a32d-99d6883ef4a9", "solution": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        diversity = np.mean(np.std(self.particles, axis=0))\n        self.inertia_weight = max(0.3, 0.9 - 0.5 * diversity)\n        self.mutation_factor = max(0.6, 1.0 - 0.3 * diversity)\n        if self.global_best_score < np.inf:\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "ImprovedHybridPSODE", "description": "ImprovedHybridPSODE enhances convergence by dynamically adjusting inertia weight and mutation factor based on population diversity.", "configspace": "", "generation": 54, "fitness": 0.3446455875955728, "feedback": "The algorithm ImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.7390924144519808, 0.7730228475921119, 0.48819590290472614, 0.7755338498104498, 0.8128296813140495, 0.7850894871662664, 0.7837338217770955, 0.8165574624466622, 0.804422408152601, 0.5704433794315479, 0.6423854435850624, 0.6512756919751722, 0.6346159320740287, 0.040342703968202276, 0.6284063890547271, 0.6281876447298426, 0.6621694894683505, 0.6816782163550368, 0.38617731529462773, 0.15784244102009293, 0.16224180599274274, 0.16910436402744433, 0.33112522153689394, 0.15545020118224329, 0.47546836981107643, 0.1625694221342927, 0.34897530232061413, 0.14233249364468537, 0.1416665455659466, 0.15318669247187278, 0.12928550406821726, 0.5225168180793057, 0.13186846784111717, 0.1454091305598031, 0.10650617772268467, 0.13515082615206864, 0.9426687974769512, 0.9529577693870664, 0.9319082908821381, 0.9693422639960735, 0.9441362022541818, 0.9658563567281218, 0.9761021049706666, 0.9597391830874341, 0.981685879410969, 0.4861874283687828, 0.448689481610382, 0.3159950750697873, 0.4280186048125725, 0.45774182344445913, 0.3956048784867783, 0.5273181653578173, 0.4465734297781955, 0.3335566024249834, 0.6976245454105533, 0.6357046947041448, 0.3953960637173455, 0.6808543215998075, 0.7179922909282278, 0.3652753402727855, 0.8373360296424391, 0.6503136428092708, 0.51077117581694, 0.29027153010668394, 0.4027183662066244, 0.31895664650636535, 0.43391471944660975, 0.2937120138943047, 0.16867491793688172, 0.28212706843908864, 0.31984574336220006, 0.42215677023937836, 0.26751432639440664, 0.2878658640452253, 0.2928857935087944, 0.4250595533237488, 0.3079758064142002, 0.2619810019196833, 0.36683449276034275, 0.33290247194140454, 0.2388583434199123, 0.0713630766156017, 0.2060553450014947, 0.08364901358482968, 0.11756708348165357, 0.09790599564118196, 0.09831913715473328, 0.10973767505405052, 0.05611612365963614, 0.1742477074273593, 0.20407247775413584, 0.24384840999182267, 0.17663640685707382, 0.16885502007251685, 0.19450138031045316, 0.0905628311075023, 0.24423956428456595, 0.2632624579014432, 0.27465804890056456, 0.043117797928981405, 0.12100655674943905, 0.04296638872554015, 0.08645986662944338, 0.21864114858495454, 0.09721375337408766, 0.16697003525568543, 0.15289786691646134, 0.140724695060496, 0.21468684666719684, 0.2505527556109569, 0.20034542813217815, 0.1325120666070856, 0.23229490173783973, 0.26778482717192686, 0.20965295153581165, 0.25122809972858307, 0.1890931327926373, 0.5919041797540538, 0.5585598900988813, 0.608756939598537, 0.5551464808362747, 0.581506280967999, 0.4246651770351787, 0.6094046476516977, 0.6387526939514737, 0.6141107724913581, 0.17657636914864927, 0.12795362766129292, 0.14899052752373643, 0.11162483287289526, 0.1418788228368052, 0.08353644267217752, 0.10550513487175273, 0.13040521461880217, 0.11242567231813627, 0.20319469533487566, 0.18344790448940407, 0.3823597822648075, 0.24066354656290612, 0.19818033698575754, 0.1743188441778708, 0.19943788229661685, 0.22120526927027973, 0.21505564038578284, 0.35151887296640005, 0.3220411594586109, 0.3125401797254578, 0.3456020275227849, 0.20093143657847135, 0.31374732751876533, 0.36147564522175146, 0.4685681178660549, 0.3851724320771436, 0.23129657190726616, 0.27270097410222394, 0.22555801244959828, 0.25629017748540894, 0.2695474089429768, 0.22301282437737924, 0.2183779178462345, 0.30501270404234515, 0.2458381125163026, 0.23589712788058737, 0.27062817969794706, 0.21520064482052426, 0.19364561266560754, 0.18898006206809514, 0.22158729461974658, 0.19344288992924952, 0.20957359227248662, 0.20030589557594847, 0.2119848328306333, 0.2258277532776668, 0.4445812496576321, 0.1922130532471955, 0.6835941011416062, 0.3981632368964194, 0.5339234587513209, 0.20052024633053167, 0.237382274310604, 0.17554068543171797, 0.7807752934718264, 0.891435309057723, 0.827413381980776, 0.199774760010887, 0.16821110829567243, 0.17090417097296773, 0.7662385740503053, 0.17285115617704216, 0.7566439248922513, 0.16911059361997482, 0.666746552355751, 0.5682650267451284, 0.2076023534510737, 0.20810870576691098, 0.42215313690573186, 0.19109358185997172, 0.4387335931806897, 0.19188310466208935, 0.18370854715413965, 0.20099446450755754, 0.2004555382422757, 0.1755437960384133, 0.19623954994751025, 0.1860621973117209, 0.18297719872317242, 0.2324087340093911, 0.09017901581734278, 0.12453227434464864, 0.0779888197311942, 0.08222467561044211, 0.08146903058546429, 0.08721307572846437, 0.07384952687799906, 0.0703398498950768, 0.07931198396514971]}, "mutation_prompt": null}
{"id": "e5645a3d-239a-45a4-adc4-94047611a8e8", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = min(0.95, self.crossover_probability + 0.01)  # Adaptive crossover\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover and hybrid inertia dynamics improves convergence by optimizing exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.3410969817542974, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8738615168923861, 0.9109894083093829, 0.8618990140710717, 0.8589104179117892, 0.8864585451459812, 0.8842123498081365, 0.8972375856823058, 0.8554531644760526, 0.7703804348718356, 0.7123083993965295, 0.7670942163488574, 0.8018095551308935, 0.6678509283620386, 0.7911400531506044, 0.7380044988599563, 0.77683300445247, 0.7012968343747603, 0.08794010895702431, 0.16086008911462668, 0.1374452753316857, 0.10045556093366792, 0.09713875869261623, 0.1349940519542786, 0.09816651739666826, 0.07914133476883234, 0.13474894774045365, 0.11049798174883341, 0.1279440793365395, 0.11111233088033856, 0.12194177370411818, 0.13058535278924033, 0.13266687094167662, 0.09369665064010224, 0.1055446429797785, 0.09922392152384907, 0.9726832177515499, 0.9347414116122172, 0.9525160103792693, 0.9442577805699068, 0.8994856346620644, 0.769208386267758, 0.6874626490906157, 0.9655303960556062, 0.9859727464001602, 0.6877311984373717, 0.5356029937727342, 0.5111116829782343, 0.4723335662806676, 0.6082217005561392, 0.6000868480389179, 0.5892404591361187, 0.5854963378412213, 0.5090397675790969, 0.3581511411814292, 0.3655085527957078, 0.2183551115896466, 0.7806346690281789, 0.18841470515637504, 0.27582389594568546, 0.8358643806554209, 0.3795699958859208, 0.21906160203355118, 0.30774417592569236, 0.41333654619989324, 0.18138471978684245, 0.16687577685604138, 0.595889528913365, 0.4720130313502715, 0.4838817770533904, 0.33644212502853255, 0.5220989863898131, 0.19634497619456748, 0.24299939255211656, 0.1953146121273156, 0.6051581474421228, 0.13450001473338125, 0.36672513341679924, 0.4135643028972822, 0.23705580453748754, 0.18244433454086573, 0.4528094187586762, 0.13309393847244844, 0.07501354278040762, 0.07286010704709589, 0.0867617382767859, 0.06190777043553175, 0.2229120084038303, 0.13364935560506364, 0.2645417808287912, 0.14470652339597567, 0.17153069880584426, 0.20595583619804347, 0.20108301768415526, 0.12191903900010037, 0.03234228839059228, 0.1632379738713131, 0.14955677364915498, 0.29080160381117737, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.19790154094463464, 0.16123333261501016, 0.16393934130177445, 0.17319220504216915, 0.09559574776560653, 0.2885763614272363, 0.23089671415823032, 0.30150732532987623, 0.24985063542621955, 0.33695124755216843, 0.16811311750942115, 0.26387598116362554, 0.19287914026891417, 0.24516361186926083, 0.6234849213658907, 0.6402169914667013, 0.6701404411653826, 0.6054314739001929, 0.5565642089080949, 0.5736894122738051, 0.5313399485213358, 0.6068795711168486, 0.5594962864633388, 0.07420890616527287, 0.09189613075201797, 0.0940763857993625, 0.09346723739335394, 0.0845327493898953, 0.1236950598921217, 0.11006121099012922, 0.11512475576749925, 0.11270607160503587, 0.21165071952330694, 0.27408167073423406, 0.19356226868511428, 0.25343873978145315, 0.21960642587531887, 0.1446516269773458, 0.20235575916573845, 0.11525228704696344, 0.1693459254916736, 0.3133064314509867, 0.47022469302245573, 0.33091160472339043, 0.3611633291953682, 0.41040749809391186, 0.42946780326580525, 0.2809509148218968, 0.4202276701708384, 0.44070289854891354, 0.2643365074588062, 0.3076350115071733, 0.23366759470506238, 0.29438252415575494, 0.40377410893216437, 0.3104854361049806, 0.28819271288919146, 0.3253973078070703, 0.206864596853102, 0.20662672500122503, 0.1645124078508814, 0.21329478777631516, 0.24149801451404085, 0.2750557004892201, 0.23232536794731895, 0.23542435291166008, 0.21642040377158178, 0.18633280882245729, 0.18757714442567874, 0.23616470340168827, 0.2239088764319609, 0.1999418842425672, 0.1926894464433343, 0.20811792221653913, 0.17566383134039731, 0.24130224858929972, 0.1846319154052355, 0.18635402881725138, 0.8725990174588198, 0.15316701264427124, 0.917605511140932, 0.20065701392642843, 0.12547532046284837, 0.1713442677786977, 0.19363054824570758, 0.1535999578586441, 0.5911833438454489, 0.20717279046367165, 0.8230371990631888, 0.34504144955127125, 0.2107167377027228, 0.21017376675332866, 0.7915625455440191, 0.1537511182347362, 0.46411478900911185, 0.2118608343445545, 0.20693103404056423, 0.18410581964765804, 0.2086690848906093, 0.1952495921307532, 0.19425067961980835, 0.184353791853899, 0.18612894262888646, 0.1838535405369467, 0.07125846149417825, 0.08274027725954569, 0.07530689282861314, 0.09512621074360117, 0.07959956536990054, 0.09721387724502839, 0.07165752556110638, 0.11054642818540872, 0.10688964184948035]}, "mutation_prompt": null}
{"id": "83e1c87f-dd2a-4191-b413-fec5112d7561", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def adaptive_stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        adjusted_rank_prob = self.rank_probability * (1 + np.tanh(self.evaluations / self.budget - 0.5))\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < adjusted_rank_prob:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp / (1 + 0.5 * self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.adaptive_stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive stochastic ranking and decay-based velocity clamp improves exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 56, "fitness": 0.3722374677801874, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9263945989030788, 0.8755471928586612, 0.9002353328259155, 0.8641826087334057, 0.871357922268573, 0.8971810479990288, 0.8757624256485909, 0.8909757759049923, 0.8736711707891653, 0.7721890916270103, 0.7125333690164524, 0.7182114858275042, 0.7576713573657553, 0.6100144279949915, 0.7365161199198622, 0.744593949340728, 0.7341952669986911, 0.7176724183086982, 0.1417852159037286, 0.13185401213349013, 0.16201661419064972, 0.2627571348684694, 0.14337734603669272, 0.4116235128413368, 0.15453119504502466, 0.14291696566138923, 0.3537322279963988, 0.1187012760002566, 0.1308843992585511, 0.1159961099697423, 0.12194660752455289, 0.22209374788742275, 0.35377279065876377, 0.15499401252307743, 0.11128352170797862, 0.14015806414431986, 0.981668365594562, 0.9774177779630864, 0.9674244706543568, 0.9686587173482456, 0.9503655048035207, 0.9743240469176847, 0.9779036281068234, 0.9521852761814242, 0.9872213712312529, 0.583676983561311, 0.4485400023513989, 0.4812026342332265, 0.6122230779997531, 0.5155737835115485, 0.5402252154789997, 0.5680150003367503, 0.5394215779525716, 0.6052685603613225, 0.7853211485669439, 0.3264213219337825, 0.7208188522944521, 0.7326657465059214, 0.7520199751737361, 0.6258458943531408, 0.8135425012337508, 0.6029008091253916, 0.7436190818179393, 0.3710096471218579, 0.29766546218467116, 0.24158955560227502, 0.3639822995245362, 0.395380209012857, 0.3224926625743204, 0.35819249050353485, 0.3148105079088427, 0.3792172171732916, 0.3449751395517471, 0.4144515810519187, 0.12754942196256835, 0.26189164071315907, 0.3958686787815914, 0.35803237177914793, 0.2778175741078389, 0.3860294842156624, 0.14831767405923124, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.06267448875058312, 0.1178810278593726, 0.2561334673595399, 0.18229159578732979, 0.005181282718090929, 0.3468028720927617, 0.18403148469544894, 0.34524977552849745, 0.14464537793703602, 0.15390127430372247, 0.06308263288645699, 0.36665995397215223, 0.4333427271844511, 0.23451558579276055, 0.13536701085192904, 0.1935690194263634, 0.17210954948779322, 0.2671589837340329, 0.1598562466174912, 0.1623898105653554, 0.12203981406327624, 0.2148994132494194, 0.07496809661148163, 0.2982037567306175, 0.10387499705265169, 0.15582422654353645, 0.3284087819839282, 0.27938126358860205, 0.3107449325904319, 0.3017496104703211, 0.29599570119868934, 0.266620098490992, 0.5779997820136482, 0.6450452492249796, 0.6589662779822392, 0.5468584223372364, 0.6036376576358418, 0.6321361172222697, 0.702397102324695, 0.6176967538649639, 0.5654256796157913, 0.12013452310802009, 0.10100040007648536, 0.10097629324424795, 0.09149399795277968, 0.11045152141725867, 0.11319242555220921, 0.0840118812681101, 0.1124131047002338, 0.11184978372658028, 0.1682828689390874, 0.23707013713146685, 0.20097879092718252, 0.20295710090610652, 0.2700210525512132, 0.19855419444451905, 0.18700209837028214, 0.17287816986365045, 0.1919150101861712, 0.4316850938603167, 0.366831520322498, 0.3040614323261438, 0.3724905311065887, 0.33868206847243554, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36944979634231456, 0.2963032814122788, 0.31671154908287613, 0.29880027434726064, 0.20818899799248203, 0.26302732114391625, 0.2899725436667415, 0.33461940832531145, 0.30228285362940366, 0.27997924380626926, 0.25871203289721234, 0.16414589806436541, 0.22218866132641968, 0.2535437548181202, 0.22726865488506232, 0.21637071909327832, 0.1933173745578718, 0.21578169741535025, 0.21895323584935134, 0.1985509283182787, 0.6141168553679879, 0.22028994325231432, 0.23924585748203875, 0.20087602602117316, 0.20137808189996542, 0.4817291806691666, 0.24826713288261681, 0.2115512130314553, 0.18646302531055126, 0.8827706330879719, 0.15414703551336462, 0.9257728205261085, 0.200827429756401, 0.19397621627477746, 0.16777203976506827, 0.19319957898967477, 0.7902563253304035, 0.7623634446522751, 0.20505045654871246, 0.6688227881017317, 0.714192792411893, 0.21019449703268944, 0.6966310431154318, 0.7945759005570198, 0.2041344925411135, 0.5476163840982082, 0.1863238006238246, 0.17978256821606609, 0.19152053750836306, 0.2006429338079625, 0.18513107528272554, 0.19537825677708587, 0.1838746126708971, 0.1807690016016037, 0.1913118953589763, 0.09719519760251638, 0.08162557365612244, 0.0738809493480801, 0.10453603454717919, 0.08412854000406456, 0.09087638998659708, 0.060488994327174805, 0.08381621334955902, 0.09997229202450197]}, "mutation_prompt": null}
{"id": "e2c17cd6-11e9-41df-8d9a-7f6de4c59b28", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic velocity clamp adjustment improves convergence by dynamically adapting velocity constraints.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8584338121925901, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6113605606819082, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.7125720180140063, 0.1411027963989001, 0.12993829213589236, 0.1620165661053219, 0.26275494606005845, 0.14356280601529747, 0.42326673941406745, 0.15401863110513692, 0.14292710918636908, 0.3547024676230244, 0.11837630001122523, 0.13119514801303345, 0.11636033082333308, 0.1228625376535547, 0.2220816350413497, 0.3540368341164729, 0.154951740621183, 0.11138460617349832, 0.14079617224654217, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.45565485380186344, 0.5769550403384566, 0.5521475238968264, 0.5936515054926761, 0.5464352975295845, 0.6153065339820311, 0.7849765247621938, 0.32688973948200706, 0.7203638848494625, 0.7291714728505716, 0.7520199751737361, 0.6386134782507928, 0.8135912774278522, 0.6029008091253916, 0.7434713893031137, 0.396753927786463, 0.2981326219235003, 0.24698706275401516, 0.3668009865729318, 0.3891836298884259, 0.3224926625743204, 0.49879768686796755, 0.3151097726146713, 0.3790223741899933, 0.3457818617852588, 0.4144515810519187, 0.1953146121273156, 0.26361509384874116, 0.39707102863890376, 0.3680992611113384, 0.2894379648363916, 0.3458743067580281, 0.18234243756241975, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.07306954827510181, 0.1178810278593726, 0.25805928781142806, 0.18229159578732979, 0.007332194029477601, 0.34791800148099405, 0.1840465963468625, 0.34521137628303644, 0.1448589439023319, 0.1540071845686889, 0.06399695639113778, 0.3661195346562939, 0.4338933453740228, 0.23537200819901394, 0.15218715742806832, 0.1980481626465317, 0.238318145534119, 0.2608464495229328, 0.16206518950000626, 0.17183619299857456, 0.1666013279525398, 0.22460851643935653, 0.07092797631311754, 0.2982037567306175, 0.08685656041890522, 0.2121850033230348, 0.3236979776385721, 0.34712980421901507, 0.29518265509603747, 0.3017496104703211, 0.2888873641038576, 0.2664210665048957, 0.5834145187447821, 0.6478802022586689, 0.6484558471390154, 0.5401845956345237, 0.6034700708968245, 0.630356700609872, 0.6905379133172551, 0.6091048014514051, 0.5838295594779004, 0.1201362536053775, 0.10100040007648536, 0.10097629324424795, 0.097621369698626, 0.10889454837375379, 0.11349696012937383, 0.0828447934659674, 0.10861947637836966, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19996766733352045, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.4317694141508951, 0.3646263928805282, 0.30406834161273855, 0.37007238344698046, 0.35992807598758636, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.3167771224620901, 0.29898454753012116, 0.20941993308843954, 0.23714099793232835, 0.2884634635857768, 0.3345100965481056, 0.3021380210291612, 0.2800130281821859, 0.20662672500122503, 0.1606786004134888, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19138953746551357, 0.19866658360322031, 0.612758206723588, 0.22030573235988538, 0.23918740299763996, 0.20052800699111573, 0.22012094832065043, 0.4822443367120447, 0.2471714273025165, 0.2111708279901644, 0.186343242508759, 0.8725973182680067, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19341900766806486, 0.16763465813931921, 0.19325635126535012, 0.7902370955703986, 0.7725432986676, 0.20683669431754925, 0.5675308973084116, 0.7132111249032875, 0.2107157882226639, 0.6967005941898485, 0.7958285684649093, 0.2041344925411135, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07044253525910793, 0.08182076026617902, 0.07675296820300881, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07186128707562822, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "1148e07a-ca22-4202-a6f5-640733fc8581", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic velocity clamp adjustment improves convergence by dynamically adapting velocity constraints.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8584338121925901, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6113605606819082, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.7125720180140063, 0.1411027963989001, 0.12993829213589236, 0.1620165661053219, 0.26275494606005845, 0.14356280601529747, 0.42326673941406745, 0.15401863110513692, 0.14292710918636908, 0.3547024676230244, 0.11837630001122523, 0.13119514801303345, 0.11636033082333308, 0.1228625376535547, 0.2220816350413497, 0.3540368341164729, 0.154951740621183, 0.11138460617349832, 0.14079617224654217, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.45565485380186344, 0.5769550403384566, 0.5521475238968264, 0.5936515054926761, 0.5464352975295845, 0.6153065339820311, 0.7849765247621938, 0.32688973948200706, 0.7203638848494625, 0.7291714728505716, 0.7520199751737361, 0.6386134782507928, 0.8135912774278522, 0.6029008091253916, 0.7434713893031137, 0.396753927786463, 0.2981326219235003, 0.24698706275401516, 0.3668009865729318, 0.3891836298884259, 0.3224926625743204, 0.49879768686796755, 0.3151097726146713, 0.3790223741899933, 0.3457818617852588, 0.4144515810519187, 0.1953146121273156, 0.26361509384874116, 0.39707102863890376, 0.3680992611113384, 0.2894379648363916, 0.3458743067580281, 0.18234243756241975, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.07306954827510181, 0.1178810278593726, 0.25805928781142806, 0.18229159578732979, 0.007332194029477601, 0.34791800148099405, 0.1840465963468625, 0.34521137628303644, 0.1448589439023319, 0.1540071845686889, 0.06399695639113778, 0.3661195346562939, 0.4338933453740228, 0.23537200819901394, 0.15218715742806832, 0.1980481626465317, 0.238318145534119, 0.2608464495229328, 0.16206518950000626, 0.17183619299857456, 0.1666013279525398, 0.22460851643935653, 0.07092797631311754, 0.2982037567306175, 0.08685656041890522, 0.2121850033230348, 0.3236979776385721, 0.34712980421901507, 0.29518265509603747, 0.3017496104703211, 0.2888873641038576, 0.2664210665048957, 0.5834145187447821, 0.6478802022586689, 0.6484558471390154, 0.5401845956345237, 0.6034700708968245, 0.630356700609872, 0.6905379133172551, 0.6091048014514051, 0.5838295594779004, 0.1201362536053775, 0.10100040007648536, 0.10097629324424795, 0.097621369698626, 0.10889454837375379, 0.11349696012937383, 0.0828447934659674, 0.10861947637836966, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19996766733352045, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.4317694141508951, 0.3646263928805282, 0.30406834161273855, 0.37007238344698046, 0.35992807598758636, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.3167771224620901, 0.29898454753012116, 0.20941993308843954, 0.23714099793232835, 0.2884634635857768, 0.3345100965481056, 0.3021380210291612, 0.2800130281821859, 0.20662672500122503, 0.1606786004134888, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19138953746551357, 0.19866658360322031, 0.612758206723588, 0.22030573235988538, 0.23918740299763996, 0.20052800699111573, 0.22012094832065043, 0.4822443367120447, 0.2471714273025165, 0.2111708279901644, 0.186343242508759, 0.8725973182680067, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19341900766806486, 0.16763465813931921, 0.19325635126535012, 0.7902370955703986, 0.7725432986676, 0.20683669431754925, 0.5675308973084116, 0.7132111249032875, 0.2107157882226639, 0.6967005941898485, 0.7958285684649093, 0.2041344925411135, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07044253525910793, 0.08182076026617902, 0.07675296820300881, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07186128707562822, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "debdad8e-addf-4568-9887-7aa8671db70c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        # Adjusted adaptive factors\n        self.mutation_adaptive_factor = 0.02\n        self.crossover_adaptive_factor = 0.02\n        self.evaluations = 0\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.mutation_adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.mutation_adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.mutation_adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.mutation_adaptive_factor)))\n            # Adjust crossover and mutation rates\n            self.mutation_factor = max(0.7, min(0.9, self.mutation_factor * (1 + self.mutation_adaptive_factor)))\n            self.crossover_probability = max(0.8, min(0.9, self.crossover_probability * (1 + self.crossover_adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover and mutation rates improves convergence by dynamically adjusting evolutionary operators.", "configspace": "", "generation": 59, "fitness": 0.34519191287167666, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9073306873079674, 0.895548924762599, 0.8958441198300466, 0.8203919153555468, 0.8460508027444646, 0.8883880314435965, 0.9054275628492501, 0.8957566114426303, 0.8815887713186216, 0.7418490373740756, 0.6938605536496665, 0.7254536626828987, 0.6938301852629527, 0.6584763536833188, 0.7639227241019593, 0.8023117982170062, 0.7507262335850159, 0.6630748139873051, 0.15770269549823768, 0.4447081732148709, 0.38514655664103825, 0.15176698176083792, 0.13428200496041076, 0.11387923746686757, 0.1482946017305503, 0.11441608454546481, 0.11335534303823225, 0.12819683033766816, 0.1514029463997324, 0.11473199467813411, 0.10677540088426907, 0.113854235338535, 0.13094382639735558, 0.12007113480534204, 0.11934336700427572, 0.14829646828123766, 0.9654784303669809, 0.9588727364269862, 0.9694341511323771, 0.9656295317366866, 0.972567515610199, 0.9625654133144896, 0.8665612168830296, 0.9680887149879198, 0.9890298026300084, 0.5631399003567281, 0.46383553286797763, 0.3821890185114346, 0.5021244273405809, 0.5980483142778679, 0.5430315101510368, 0.5145318745061839, 0.5018810647083709, 0.5554945576191191, 0.2211709464634981, 0.35496693808152513, 0.7957123104868759, 0.2646734258288266, 0.7209487011524529, 0.2704411887545698, 0.735466740909964, 0.16860745244811315, 0.6182958918339093, 0.32009409631895747, 0.4798963315451311, 0.3382773537481222, 0.3538180415877966, 0.37982247974859995, 0.15241092443371385, 0.4007136866051244, 0.1359689830413494, 0.4881398544538722, 0.42754970442202445, 0.30199787937998823, 0.42433498227004307, 0.170351397695519, 0.44430484502775247, 0.5004462867109775, 0.22267988727007937, 0.39259368930354155, 0.4121176341184071, 0.23407738553091895, 0.0032658681129996703, 0.04210744000543276, 0.19606267319933646, 0.07591912731832928, 0.059854659032817614, 0.10108116013654111, 0.13827461923628437, 0.17391542518450365, 0.1915807698874491, 0.10180873601650564, 0.10114514683722409, 0.32715723041315037, 0.1161220102973235, 0.02629854571465784, 0.09260456891615432, 0.18851767747716874, 0.09276652577764632, 0.27775372536197096, 0.10808729285668472, 0.1497311528891414, 0.14908698362137862, 0.1615583807586991, 0.17390993108131514, 0.20720576960240822, 0.18274655355129632, 0.1771470513671899, 0.2894480981980425, 0.26476086884126404, 0.23212595555799598, 0.3326006520858128, 0.28096821976547726, 0.3226211342710672, 0.07930922193065437, 0.2768867054690253, 0.1835162034561657, 0.6170863839995633, 0.5817378755408371, 0.6168718920537642, 0.4706614352611135, 0.6870319786526184, 0.7212787149336017, 0.6653787624602954, 0.6985524004683943, 0.69011091310011, 0.0991629107699673, 0.09906051127277371, 0.11838946306674225, 0.11739363094876587, 0.11437956076219491, 0.11918737750607722, 0.1142394335267729, 0.10073986382482103, 0.11522099056853441, 0.38354663528549504, 0.251151732204965, 0.1875202592709163, 0.19942203069815112, 0.21612493951116007, 0.1722133157496637, 0.19937046541551173, 0.2514579833326519, 0.2026516699315143, 0.4312294601059038, 0.3167058315334571, 0.43756065630812047, 0.41421738319543444, 0.3645051168676331, 0.4074308210215368, 0.40392237661489017, 0.320201785922534, 0.3819678048039755, 0.2421768874283281, 0.2919600804663153, 0.23827085623747513, 0.2732464444625775, 0.38146942981798426, 0.23609523556943457, 0.15788939449698425, 0.20450019115786067, 0.16555584645654742, 0.25236053522592716, 0.2746479443450712, 0.24161584988449647, 0.21784225719644024, 0.22419078636739465, 0.217709968455296, 0.1972517820357217, 0.20887694115902877, 0.18966302833860638, 0.23566962793904245, 0.23044068940886597, 0.21321251807721742, 0.2161569990553438, 0.24513033706039156, 0.2234977063572452, 0.19350972124629073, 0.22524488030774303, 0.22026384941458177, 0.18644517030006613, 0.835122743813543, 0.1635391271784694, 0.9325603785355253, 0.2002396130884656, 0.1623816000663062, 0.16773253607417626, 0.16584508206285242, 0.18649735646977827, 0.7095212344746914, 0.20707935329794103, 0.6280737751406733, 0.20774078406076457, 0.21073757552726224, 0.21042079415865522, 0.5470158671857512, 0.14688449695693284, 0.38313206066629524, 0.2105391973078553, 0.17908526885739307, 0.22001002690517213, 0.19415764557226256, 0.19174907411497577, 0.21137670623182503, 0.1871303812384093, 0.2057639558329717, 0.18138014882073883, 0.09181635360592222, 0.08327619431095334, 0.08197709271308262, 0.1190354158150756, 0.09229152447131705, 0.10033193067687063, 0.11051075552941914, 0.0745503328710283, 0.09203796247932972]}, "mutation_prompt": null}
{"id": "eeaa8daa-5656-4240-8627-d870b68c5d60", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.successful_mutations = 0\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            if self.evaluations > 0:\n                success_rate = self.successful_mutations / self.evaluations\n                self.mutation_factor = 0.8 + 0.2 * success_rate\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n                self.successful_mutations += 1\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive DE mutation factor refines exploration by adjusting the mutation factor based on success rates.", "configspace": "", "generation": 60, "fitness": 0.3606542133094212, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8747557269378323, 0.9110352090358134, 0.8647445005034285, 0.8571181684414134, 0.8870482361423796, 0.8841440279045377, 0.8970773030993172, 0.8565395535575286, 0.7706266543817851, 0.7183566729799034, 0.7659368473869578, 0.8036486482770064, 0.716333612587951, 0.7894321245870932, 0.7383782651197961, 0.7778240446757173, 0.7259489468928748, 0.13624226455439437, 0.15489166551795475, 0.10873572132832143, 0.13270566976237275, 0.1669681321552383, 0.14727105381858763, 0.11631506066074904, 0.16346964547132814, 0.14164486602667203, 0.1328744029436102, 0.09560319860411781, 0.38044138508550085, 0.147290349412869, 0.1282535370876161, 0.4767928884582411, 0.13534626766284052, 0.13043942215822868, 0.14504915118955974, 0.9856607371935399, 0.971484056022919, 0.9788904251092869, 0.9483357457380064, 0.9634180318990544, 0.9741080828880992, 0.9653699882334787, 0.9618519505521926, 0.9798943704912549, 0.6916202829664544, 0.5746744138890691, 0.5111458171339269, 0.43244967034787385, 0.6002413177002044, 0.56442285682484, 0.5890715381322664, 0.46882452254759854, 0.5085468973739032, 0.34830489452347646, 0.35149128689936904, 0.6680976295834732, 0.7007200609127469, 0.2067773067242018, 0.27626761552456414, 0.3537641129248643, 0.7406725375043569, 0.21624950696128353, 0.2874944131909446, 0.22018004720290396, 0.24814093740223198, 0.2456273467527723, 0.2367241434384475, 0.30668706219847164, 0.5403215672559271, 0.5334565217224807, 0.2571769024811529, 0.24640756004498066, 0.09305402212323677, 0.1953146121273156, 0.5172625966719365, 0.4920855640991859, 0.29788157190551023, 0.43627532506916633, 0.2207069543524851, 0.23109576643793417, 0.11903611691251903, 0.1867719439801947, 0.06505045325482683, 0.2625478647831362, 0.07875081045159438, 0.06720906336304089, 0.08354434201827576, 0.18965001865695097, 0.2557029792778214, 0.16610387847075125, 0.20852799638890185, 0.16456474067952476, 0.09171613097787923, 0.1452566764672758, 0.12260971593805503, 0.42742374782557124, 0.1745505592631431, 0.12736317628882332, 0.1587547399659941, 0.26201680378406766, 0.238318145534119, 0.2573364562154371, 0.15064848801848452, 0.1635122491096248, 0.16393934130177445, 0.17319220504216915, 0.07092797631311754, 0.23193869105660847, 0.2877364988462575, 0.27907912292753445, 0.06803708873082792, 0.36659121762074987, 0.16811311750942115, 0.08112868553943042, 0.2547659964749257, 0.08156945962082662, 0.6311632623540469, 0.6551050689002411, 0.6797727615051368, 0.5144656235271841, 0.5680063333998289, 0.5879802225456277, 0.6996992708068401, 0.649396527838637, 0.6849042064478307, 0.07615104568092479, 0.12070216000804612, 0.08450476374121119, 0.12376330599077756, 0.11883665093279705, 0.10191416213509819, 0.0845737686510456, 0.0987642605973782, 0.11306370418087774, 0.19071626067734737, 0.27408167073423406, 0.19357032322554124, 0.25343873978145315, 0.21969031864615307, 0.17495083473977213, 0.2025202328941923, 0.14581816189172636, 0.16816747174843172, 0.43044286348635785, 0.37367745931810237, 0.36727036222267295, 0.27281297946600014, 0.40551333409378265, 0.41917907683967326, 0.4328968019477807, 0.464070607318095, 0.4108362842320601, 0.29782023766202914, 0.3199273026597551, 0.24037409883340544, 0.25267339462575467, 0.2771609497909949, 0.2170146682977846, 0.2593293408348043, 0.14393319425468054, 0.3194459368680397, 0.20683635228874975, 0.16786886273188506, 0.22087187139136266, 0.24149801451404085, 0.2750474197365581, 0.23231675619105452, 0.23542435291166008, 0.22166606683562695, 0.20464006057023643, 0.19154009351845902, 0.6002925125440706, 0.2115891595027144, 0.1999418842425672, 0.664629002150267, 0.6516791672616273, 0.2627447389236287, 0.5328520611735323, 0.2075776587374334, 0.20735631850035563, 0.8724126139938813, 0.15170334256295337, 0.917605511140932, 0.20065701392642843, 0.17909469939446865, 0.1676796982902673, 0.8387079688666259, 0.80072069085351, 0.5911833438454489, 0.2083755294597377, 0.7623523417781278, 0.7244956635618687, 0.2107157882239269, 0.2101589685785783, 0.47618090268955926, 0.16291521972532064, 0.4641638147748749, 0.2115802943227133, 0.20693604662844112, 0.18825677742591473, 0.20964925417710212, 0.19707152689563734, 0.19404655427955186, 0.1842873294999402, 0.19364306604308457, 0.18409757118963488, 0.09739143680362594, 0.07621897041253001, 0.07625936983199044, 0.09512621074360117, 0.07142940358445415, 0.0970338757370568, 0.08477874124691576, 0.11054642818540872, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "613dca29-29cd-49f8-9e86-8f7d5e61ddd3", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = 0.9 - 0.4 * (self.evaluations / self.budget)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic inertia and adaptive DE crossover optimizes convergence by tuning inertia and DE strategies based on evaluations.", "configspace": "", "generation": 61, "fitness": 0.34507548138754557, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8742116225948023, 0.9109986092731056, 0.8608418367701329, 0.8569680797550618, 0.886455020026294, 0.8829976206131658, 0.8987327398629932, 0.8578580749861705, 0.7729172342778758, 0.7100110747748871, 0.7658416235065004, 0.8018095551308935, 0.7002557685817203, 0.7894673890692516, 0.7372996525073265, 0.7772871902499094, 0.7231279884343689, 0.14618761465419972, 0.14707692701205066, 0.14651824133316493, 0.15769809956114167, 0.40846209813673595, 0.13499407768389105, 0.11687696605021103, 0.3339267932692125, 0.4052041994009532, 0.35526344144811484, 0.15112557332465515, 0.10747489061900617, 0.10524190361285868, 0.14489301968907842, 0.1541804758293952, 0.14073252565340588, 0.13620553317762674, 0.13280197487258172, 0.9558552573636587, 0.961219544930508, 0.8090925160676943, 0.9680703725032906, 0.9567838157454938, 0.9536592897539302, 0.9703498226682739, 0.9578689072011339, 0.9771821841592747, 0.6872598513020951, 0.5206412866056874, 0.5172829906800567, 0.5124128917352476, 0.574623734624459, 0.537355599857717, 0.589056199562201, 0.46768176646391757, 0.5248327204837325, 0.6817662104562121, 0.7460486655827518, 0.6050897684014436, 0.6587270342599605, 0.1974776565326537, 0.8110352966478224, 0.696448636067677, 0.8060161078741903, 0.6772636424644143, 0.2874944131909446, 0.19622801977094995, 0.23045347852596998, 0.24638688613782345, 0.18327732744819547, 0.2714079674853498, 0.4838817770533904, 0.21806529908755656, 0.19376890308822037, 0.19634497619456748, 0.21856885376074398, 0.1953146121273156, 0.24023636939679605, 0.16910369467636321, 0.2963657944711464, 0.23781793765385606, 0.2606550748496024, 0.2612875436277813, 0.0774436483300156, 0.14164955308361316, 0.0015318332322743489, 0.12204474120988162, 0.0731034046289506, 0.094295502732061, 0.18102152347126088, 0.17043186099598695, 0.06121472145836926, 0.11398690671627265, 0.25687358200457344, 0.111031168588412, 0.2211922510865888, 0.29355032841782236, 0.04255659258996913, 0.15225274403758926, 0.14382897172798148, 0.07820309748684884, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.1120492226084362, 0.15874184950653814, 0.16393934130177445, 0.17319220504216915, 0.07092797631311754, 0.24556935676461644, 0.2566490281749384, 0.2126121224808729, 0.2497664779196136, 0.33565395833257605, 0.21115158494244157, 0.17056194920959167, 0.19679797930711207, 0.15152463809482597, 0.5708084676878473, 0.558281160385466, 0.5550832696207519, 0.5226259661821242, 0.5726477937338385, 0.5209871557517527, 0.5799244508956194, 0.6316158396644269, 0.6000543986721881, 0.10622312600689443, 0.15257293827741614, 0.0999915980795657, 0.0875178720797305, 0.1034395503446407, 0.08574840227516145, 0.11758929629312531, 0.09928568696917628, 0.11270607160503587, 0.135189464518087, 0.27408167073423406, 0.19356226868511428, 0.25351618173148827, 0.21960642587531887, 0.1842299205533432, 0.2024917509499432, 0.18339200660428745, 0.1709221118760088, 0.2321494848879132, 0.3300417993598709, 0.34512167105454783, 0.34803107717601256, 0.34698676033811526, 0.3381309129244421, 0.35543241257851, 0.3925901394924546, 0.4263421281865357, 0.25733139082786394, 0.242177460879484, 0.2749383777096919, 0.22705211339568176, 0.19654705301432962, 0.2731887843269484, 0.16691178499259296, 0.2930002001493385, 0.2942988731931072, 0.20669494995825022, 0.1886543564933263, 0.21329478777631516, 0.24149801451404085, 0.27510438180134444, 0.2324301463185825, 0.23542435291166008, 0.216514646067411, 0.18633280882245729, 0.23466045744710418, 0.22334932968714716, 0.2115891595027144, 0.1999418842425672, 0.48887114458191705, 0.46037306307151804, 0.19469864385715918, 0.21880640729586243, 0.19166994414556304, 0.18633807055359553, 0.8726685856947723, 0.15137611011665397, 0.917605511140932, 0.20065701392642843, 0.16405246187964562, 0.16763921195272524, 0.7838385569817716, 0.18487225768974846, 0.5911833438454489, 0.20892730234055246, 0.5668054282588346, 0.20662550014535797, 0.21071578822220383, 0.2101589685785783, 0.4790749015810438, 0.15171676423082003, 0.4648363646614613, 0.21183358164616362, 0.2074448149083794, 0.1823672300098087, 0.20856596640709013, 0.19481038607812362, 0.1971575888148801, 0.18565297587738983, 0.189666237119396, 0.18385028177482476, 0.07235012105099237, 0.07783248619617877, 0.0754029197926005, 0.09512621074360117, 0.07144405559952305, 0.09865297567285891, 0.07425647325102058, 0.11061903919452432, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "c9331bd6-0f83-4fa8-b757-071bc316a5b5", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability_initial = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.crossover_adapt_rate = 0.99\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        self.crossover_probability = self.crossover_probability_initial * self.crossover_adapt_rate ** (self.evaluations / self.budget)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introduce an adaptive crossover probability and enhance population diversity to improve convergence speed.", "configspace": "", "generation": 62, "fitness": 0.3716765937062359, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8585379251483869, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6213169434274022, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.717602272263379, 0.14215574087203664, 0.17536809682081145, 0.16530239329541907, 0.23441650932859714, 0.13048670078935498, 0.4060471408063676, 0.2608479893791542, 0.14282156162491777, 0.3538847781700528, 0.14845740928182405, 0.12883645008574363, 0.11302487074508627, 0.15083328943531393, 0.1968120773161801, 0.14415062890566133, 0.14590030477011462, 0.10521917812005122, 0.12824445161691111, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.5166897967209976, 0.592104542088445, 0.5379702852089793, 0.5959388932658022, 0.5716463342903606, 0.5796131436578513, 0.7820448829245286, 0.3270515626864009, 0.6134863346178516, 0.7605613110507585, 0.7520199751737361, 0.3031018069543233, 0.7881637146345781, 0.7011442677714305, 0.8183165028197857, 0.42791541818444845, 0.27474941048760504, 0.2990872575517288, 0.3377526654885291, 0.279241321979367, 0.2984619704974253, 0.4852409336553921, 0.32273034575098425, 0.3359116231246905, 0.3583418786762269, 0.26444583050488213, 0.1953146121273156, 0.3390940504232208, 0.18858400107482365, 0.3978390692161644, 0.3303862068801563, 0.2660416645407353, 0.18234243756241975, 0.026267264896412623, 0.06817748370715848, 0.2826716622857698, 0.054139544676245155, 0.10660034096258408, 0.11643932023170855, 0.3656384422356306, 0.2345040186010402, 0.011155480626636405, 0.2915043826721244, 0.177996639819631, 0.3599850302655596, 0.14524427608993706, 0.15034885683407173, 0.15781986094212264, 0.2371822209406882, 0.28281093156435866, 0.34386914541322244, 0.15218715742806832, 0.18481431767668743, 0.238318145534119, 0.28336625418344774, 0.16562185230049709, 0.1637293002817598, 0.1666013279525398, 0.1780185999961943, 0.07092797631311754, 0.2693941904401601, 0.08685656041890522, 0.2121850033230348, 0.2548914217328552, 0.33565469072274146, 0.25983337962793784, 0.3461443403338603, 0.20632674925254568, 0.30835767401544223, 0.5984779358589684, 0.6506143540270655, 0.6547096629415942, 0.6370520239626565, 0.6365284941112709, 0.611689525342106, 0.6340843237835012, 0.6285383352353322, 0.6011397514419807, 0.11972479350125687, 0.1003041042426066, 0.10097401388533667, 0.1200721930689489, 0.11796858467134241, 0.11664107046687333, 0.09382794714633913, 0.07503425238211126, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19977607167431166, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.38404115727143795, 0.3275150133902879, 0.30729239862585267, 0.4184734368308539, 0.3897494728116834, 0.40199271676124515, 0.4813762897633451, 0.47306238945058054, 0.4038269022432027, 0.3112855170889588, 0.2761929141392502, 0.21993180586666927, 0.2099980034959955, 0.22518940504402163, 0.29527903234069164, 0.36004321248976123, 0.2721708956711535, 0.30434772075004113, 0.20662672500122503, 0.17846953426124024, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19099651265370132, 0.20189826617957174, 0.615089912087114, 0.22030512686065318, 0.1999418842425672, 0.19775223684104504, 0.21709636568585589, 0.20811518360743197, 0.24717127904923786, 0.398784763340015, 0.186343242508759, 0.8725973182680067, 0.15414693821968917, 0.9176484995149864, 0.20065701392642843, 0.15991463903094172, 0.16763465813931921, 0.19322469957786825, 0.7839517143527193, 0.7860983442650028, 0.20683669431754925, 0.5675308973084116, 0.7068096631490122, 0.2107157882239138, 0.7159440955332319, 0.8066404099193718, 0.20413300139188362, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07090647221629298, 0.08120082922893201, 0.07660247335174375, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07653750233992795, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "9919f3cd-337e-453c-94d8-2313eeb953e9", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = 0.7 + 0.3 * (self.evaluations / self.budget)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introduce adaptive crossover probability to the differential evolution phase to balance exploration and exploitation dynamically.", "configspace": "", "generation": 63, "fitness": 0.35665250933016557, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740901112403043, 0.9109894083093829, 0.864468327346327, 0.8677807277114818, 0.8866558418892779, 0.8842228179722071, 0.8972067450894523, 0.861505857434551, 0.771339045315795, 0.7247102516478042, 0.766594361186555, 0.8018095551308935, 0.6702924395864585, 0.7894473186147154, 0.7388588415996542, 0.77683300445247, 0.7185163320542609, 0.1497414008979152, 0.3629909008487472, 0.4899392917687113, 0.5290300656788762, 0.29060753234151937, 0.1541375262076461, 0.17438985403831142, 0.6134222421758534, 0.4932160908293759, 0.15679073273610378, 0.1280842131436526, 0.11903400986754276, 0.14278496208523594, 0.14290106027835858, 0.14620389541334788, 0.1358635255318208, 0.1430514032575012, 0.1294441110363621, 0.9606368531789944, 0.9703798304780065, 0.970741493269855, 0.9543009220156508, 0.9753271163142978, 0.9721962691521827, 0.9569559903979917, 0.9741486851912498, 0.9838206950839556, 0.6872623407790541, 0.5305860943286842, 0.5108971579584136, 0.43138737568417795, 0.5746322538104255, 0.5562188012997314, 0.5890337691323779, 0.50592348211103, 0.5741480168377165, 0.3371037021987001, 0.44491471511266734, 0.21492018400617585, 0.6174241755513825, 0.19250009475472452, 0.2762549186646277, 0.5863248563031227, 0.616806083674774, 0.7366799686252588, 0.4179598876579834, 0.2686349602560353, 0.2239497008250888, 0.2212075073879225, 0.3171917267927169, 0.26700363941788774, 0.4907488557266376, 0.283434143172413, 0.24884257785319797, 0.23582316956156946, 0.12201787561163369, 0.1953146121273156, 0.3370084478533406, 0.24622497166263324, 0.27499123347605736, 0.38310531397423886, 0.32003943769944987, 0.26542497585217817, 0.14693998590327595, 0.17069725894973253, 0.0015318332322743489, 0.052888290321735476, 0.10335760852669629, 0.16093872150349076, 0.13728448591244147, 0.17420004426274338, 0.1492638066159725, 0.18205307244512525, 0.22707771064193905, 0.2577455683813953, 0.259335339075913, 0.13190480762498957, 0.14970470025204208, 0.19552510849852178, 0.23398361805414214, 0.20480106041124457, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.11201616813784365, 0.17867841047081368, 0.16453507283817526, 0.18303492269795207, 0.21414281356233877, 0.19134045298888103, 0.23860184571645027, 0.2477507661739493, 0.2193828838714853, 0.36203517450408995, 0.314992669471138, 0.23200195938322987, 0.27357837538496943, 0.22644430199916665, 0.5458408328303544, 0.6095857543410373, 0.6592760996944896, 0.6232991246018786, 0.6832478069913005, 0.5645835619659721, 0.6278916149969902, 0.6185225625602092, 0.6475377947518672, 0.09959369814950281, 0.0857628975042628, 0.10893642460043762, 0.09502250848794591, 0.1020736111563394, 0.09015831840573751, 0.14340635238225752, 0.0958281357250722, 0.11270607160503587, 0.1629112126580945, 0.3394512821938337, 0.19365178348821588, 0.25343873978145315, 0.21960642587531887, 0.1679711965933084, 0.20247680367105458, 0.13442702594937694, 0.16730983530392807, 0.31968425799902866, 0.3539740851921678, 0.35697567564959476, 0.3558029209664546, 0.40574594332029656, 0.348946179777194, 0.4022958253455533, 0.36050984161980815, 0.4346322196900029, 0.2550216286940816, 0.2983249384873333, 0.22746634650405995, 0.21696741737905045, 0.2646032908241349, 0.2450875043379771, 0.25955088112192326, 0.2902535756310285, 0.2778991022556353, 0.20663533784790344, 0.1665316684528827, 0.21329478777631516, 0.24149801451404085, 0.27512758843390106, 0.2324165304414535, 0.23542435291166008, 0.21648538216323, 0.1925794663205216, 0.1910806487293949, 0.48106323636831994, 0.21640353933236622, 0.21978382534479735, 0.39244779711627975, 0.5110395320534116, 0.1975137707764162, 0.4417739904839353, 0.2048911911573701, 0.20417878768861586, 0.8724126139938813, 0.2513924147404616, 0.917605511140932, 0.20065701392642843, 0.1836661027436448, 0.20548893742111962, 0.15422732994598498, 0.16708360511185927, 0.6192167376597957, 0.20716416609213473, 0.5687047499864215, 0.20800743070844718, 0.21071578822220383, 0.6690503214475585, 0.4709832901392671, 0.1907643105852932, 0.464332671428496, 0.2115802943227133, 0.2126757090560416, 0.18384854667828154, 0.20835204259366025, 0.19481534492758634, 0.19532752428688238, 0.18651278583500308, 0.1883686566538405, 0.18385028177482476, 0.07207492571773177, 0.07617711475404254, 0.07519356075805572, 0.09512621074360117, 0.07764663697662166, 0.0970338757370568, 0.07189250803585912, 0.11054642818540872, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "923a96be-3253-421b-8a30-877d43a27075", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        dynamic_mutation = self.mutation_factor * (1 - self.evaluations / self.budget)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + dynamic_mutation * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introduced a dynamic mutation factor for differential evolution based on convergence to enhance exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.35636923300919504, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8756781759214982, 0.9110143479148006, 0.8616906833403266, 0.8700351055987213, 0.8869433005664501, 0.8850295442461052, 0.8979810212609697, 0.8680047651597826, 0.8023326622245138, 0.7092074620427256, 0.7670456900243118, 0.8025207104038834, 0.6901642506874679, 0.7906170207542844, 0.7604624536850264, 0.7813908860784249, 0.7439367862350399, 0.13999653195437045, 0.13136407792102778, 0.12989026106166057, 0.0894152810696649, 0.14636054098180573, 0.1563188829063663, 0.2164686453263701, 0.13543646382743613, 0.15188196681012356, 0.15371421124590234, 0.1180235359596793, 0.12472493278667773, 0.11970391191710428, 0.10691004149470484, 0.13139161062657456, 0.11702832404650798, 0.12106532457064623, 0.13321335370826126, 0.9794800702475985, 0.9631907672270511, 0.9373342311703868, 0.9602455939775878, 0.960389621183646, 0.9507930532437412, 0.9779045791958255, 0.9620369600878618, 0.9872092336975481, 0.6872486641787656, 0.5184925377680776, 0.5112637426405076, 0.43150756625780373, 0.5753928932594585, 0.5265961083181685, 0.589037428038858, 0.46881987966995453, 0.5104168319477107, 0.7979124177876887, 0.8004737389274273, 0.21637535179730705, 0.8152764512060011, 0.8305796883695343, 0.8135019699012469, 0.7364184762654904, 0.34089823933013375, 0.7827702865210144, 0.2874944131909446, 0.17927013588407603, 0.18138643092633844, 0.18469280802757915, 0.2291223406100975, 0.16011374701529635, 0.4838817770533904, 0.14376938388240812, 0.30813222849721245, 0.19634497619456748, 0.26779101344879097, 0.22178816751956387, 0.203801343044546, 0.22438316833302008, 0.23110258560304553, 0.2358284126789626, 0.22161566655023857, 0.20081548312980346, 0.013074959160841337, 0.17601356552401048, 0.06593218057866612, 0.10451371471318238, 0.07306954827510181, 0.06779706003676633, 0.08648570562781788, 0.07960524973272387, 0.2320715725109388, 0.11398690671627265, 0.1333872147479257, 0.1531909831243602, 0.19273829274991772, 0.13377182854491343, 0.029281748093582194, 0.261366463954249, 0.20448274664948185, 0.08665636493549556, 0.25959324418790586, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.2147621619919814, 0.24657754069436877, 0.16607594882599208, 0.19642509813364017, 0.07092797631311754, 0.1609262303268768, 0.28482258685735773, 0.21278124032866252, 0.2525053041092691, 0.3362904359305803, 0.3331976181889921, 0.21626044072566775, 0.11149017332142008, 0.3141085861025932, 0.6772538735865792, 0.5503063187689142, 0.5651549967437309, 0.618748698433077, 0.6156557388027306, 0.5684960777491417, 0.6594241678365405, 0.5973235227535085, 0.5490411650930939, 0.09749423829204751, 0.12642991730254582, 0.043248630645431496, 0.11178986323085194, 0.08600632658237739, 0.1183518652327673, 0.10004483959168176, 0.11594813522473846, 0.11270607160503587, 0.14844629505569795, 0.27408167073423406, 0.2434375087355345, 0.25403840282511103, 0.21960642587531887, 0.15811607895291835, 0.20237225621212185, 0.15577435174766796, 0.1689253585933711, 0.4167823344000702, 0.4923226601836629, 0.32385009651835917, 0.4754227901387128, 0.47448280167907886, 0.39272008884966236, 0.5069696215582946, 0.4409012631384729, 0.4268495895927288, 0.3283030542913774, 0.330045307092822, 0.272164759416727, 0.29666962263291374, 0.26217788164033373, 0.3799715975581507, 0.3766888156298396, 0.2545068219754547, 0.3200608884102367, 0.20663980819238337, 0.19131728421909333, 0.21596446647725487, 0.24275957715555885, 0.27524233633591644, 0.23236918640580428, 0.23542435291166008, 0.2165909769748493, 0.18633280882245729, 0.20231207038726085, 0.2642098094146911, 0.2115891595027144, 0.20124042886850657, 0.48821510974613513, 0.20800203193169575, 0.23567895983784315, 0.6341200500517155, 0.23550045885573434, 0.20793537955299413, 0.87301317141447, 0.8482975569644595, 0.9177185190365387, 0.20065701392642843, 0.16947788680868248, 0.1676344432113117, 0.14917227524601062, 0.16601301538289337, 0.5911833438454489, 0.20870041906882608, 0.5675385238366568, 0.4811245015853485, 0.21071573020632872, 0.2101589743386314, 0.4741630884136082, 0.7047066777716904, 0.46487275362535774, 0.21167846734812779, 0.20693681536634845, 0.1915791382096953, 0.20821841157802023, 0.1963078080882774, 0.19484041782465866, 0.18530629657863873, 0.18683541659353287, 0.18385028177482476, 0.08540968008050676, 0.07456937159173616, 0.07786477245208012, 0.0952776896488805, 0.07940586223108581, 0.09739553217636876, 0.09133378587162821, 0.11054639022396018, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "387a1567-bd70-4f3b-8ca4-1c388b01a055", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.initial_swarm_size = self.swarm_size\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.swarm_size = max(12, int(self.initial_swarm_size * (1 - (self.evaluations / self.budget) * 0.1)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive population size for better exploration-exploitation trade-off.", "configspace": "", "generation": 65, "fitness": 0.37524623634370086, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8584338121925901, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6113605606819082, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.7125720180140063, 0.1411027963989001, 0.12993829213589236, 0.1620165661053219, 0.26275494606005845, 0.14356280601529747, 0.42326673941406745, 0.15401863110513692, 0.14292710918636908, 0.3547024676230244, 0.11837630001122523, 0.13119514801303345, 0.11636033082333308, 0.1228625376535547, 0.2220816350413497, 0.3540368341164729, 0.154951740621183, 0.11138460617349832, 0.14079617224654217, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.45565485380186344, 0.5769550403384566, 0.5521475238968264, 0.5936515054926761, 0.5464352975295845, 0.6153065339820311, 0.7849765247621938, 0.32688973948200706, 0.7203638848494625, 0.7291714728505716, 0.7520199751737361, 0.6386134782507928, 0.8135912774278522, 0.6029008091253916, 0.7434713893031137, 0.396753927786463, 0.2981326219235003, 0.24698706275401516, 0.3668009865729318, 0.3891836298884259, 0.3224926625743204, 0.49879768686796755, 0.3151097726146713, 0.3790223741899933, 0.3457818617852588, 0.4144515810519187, 0.1953146121273156, 0.26361509384874116, 0.39707102863890376, 0.3680992611113384, 0.2894379648363916, 0.3458743067580281, 0.18234243756241975, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.07306954827510181, 0.1178810278593726, 0.25805928781142806, 0.18229159578732979, 0.007332194029477601, 0.34791800148099405, 0.1840465963468625, 0.34521137628303644, 0.1448589439023319, 0.1540071845686889, 0.06399695639113778, 0.3661195346562939, 0.4338933453740228, 0.23537200819901394, 0.15218715742806832, 0.1980481626465317, 0.238318145534119, 0.2608464495229328, 0.16206518950000626, 0.17183619299857456, 0.1666013279525398, 0.22460851643935653, 0.07092797631311754, 0.2982037567306175, 0.08685656041890522, 0.2121850033230348, 0.3236979776385721, 0.34712980421901507, 0.29518265509603747, 0.3017496104703211, 0.2888873641038576, 0.2664210665048957, 0.5834145187447821, 0.6478802022586689, 0.6484558471390154, 0.5401845956345237, 0.6034700708968245, 0.630356700609872, 0.6905379133172551, 0.6091048014514051, 0.5838295594779004, 0.1201362536053775, 0.10100040007648536, 0.10097629324424795, 0.097621369698626, 0.10889454837375379, 0.11349696012937383, 0.0828447934659674, 0.10861947637836966, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19996766733352045, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.4317694141508951, 0.3646263928805282, 0.30406834161273855, 0.37007238344698046, 0.35992807598758636, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.3167771224620901, 0.29898454753012116, 0.20941993308843954, 0.23714099793232835, 0.2884634635857768, 0.3345100965481056, 0.3021380210291612, 0.2800130281821859, 0.20662672500122503, 0.1606786004134888, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19138953746551357, 0.19866658360322031, 0.612758206723588, 0.22030573235988538, 0.23918740299763996, 0.20052800699111573, 0.22012094832065043, 0.4822443367120447, 0.2471714273025165, 0.2111708279901644, 0.186343242508759, 0.8725973182680067, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19341900766806486, 0.16763465813931921, 0.19325635126535012, 0.7902370955703986, 0.7725432986676, 0.20683669431754925, 0.5675308973084116, 0.7132111249032875, 0.2107157882226639, 0.6967005941898485, 0.7958285684649093, 0.2041344925411135, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07044253525910793, 0.08182076026617902, 0.07675296820300881, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07186128707562822, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "1a1b666e-38a8-4bfa-a3f7-3370a7726afe", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic velocity clamp adjustment improves convergence by dynamically adapting velocity constraints.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8584338121925901, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6113605606819082, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.7125720180140063, 0.1411027963989001, 0.12993829213589236, 0.1620165661053219, 0.26275494606005845, 0.14356280601529747, 0.42326673941406745, 0.15401863110513692, 0.14292710918636908, 0.3547024676230244, 0.11837630001122523, 0.13119514801303345, 0.11636033082333308, 0.1228625376535547, 0.2220816350413497, 0.3540368341164729, 0.154951740621183, 0.11138460617349832, 0.14079617224654217, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.45565485380186344, 0.5769550403384566, 0.5521475238968264, 0.5936515054926761, 0.5464352975295845, 0.6153065339820311, 0.7849765247621938, 0.32688973948200706, 0.7203638848494625, 0.7291714728505716, 0.7520199751737361, 0.6386134782507928, 0.8135912774278522, 0.6029008091253916, 0.7434713893031137, 0.396753927786463, 0.2981326219235003, 0.24698706275401516, 0.3668009865729318, 0.3891836298884259, 0.3224926625743204, 0.49879768686796755, 0.3151097726146713, 0.3790223741899933, 0.3457818617852588, 0.4144515810519187, 0.1953146121273156, 0.26361509384874116, 0.39707102863890376, 0.3680992611113384, 0.2894379648363916, 0.3458743067580281, 0.18234243756241975, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.07306954827510181, 0.1178810278593726, 0.25805928781142806, 0.18229159578732979, 0.007332194029477601, 0.34791800148099405, 0.1840465963468625, 0.34521137628303644, 0.1448589439023319, 0.1540071845686889, 0.06399695639113778, 0.3661195346562939, 0.4338933453740228, 0.23537200819901394, 0.15218715742806832, 0.1980481626465317, 0.238318145534119, 0.2608464495229328, 0.16206518950000626, 0.17183619299857456, 0.1666013279525398, 0.22460851643935653, 0.07092797631311754, 0.2982037567306175, 0.08685656041890522, 0.2121850033230348, 0.3236979776385721, 0.34712980421901507, 0.29518265509603747, 0.3017496104703211, 0.2888873641038576, 0.2664210665048957, 0.5834145187447821, 0.6478802022586689, 0.6484558471390154, 0.5401845956345237, 0.6034700708968245, 0.630356700609872, 0.6905379133172551, 0.6091048014514051, 0.5838295594779004, 0.1201362536053775, 0.10100040007648536, 0.10097629324424795, 0.097621369698626, 0.10889454837375379, 0.11349696012937383, 0.0828447934659674, 0.10861947637836966, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19996766733352045, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.4317694141508951, 0.3646263928805282, 0.30406834161273855, 0.37007238344698046, 0.35992807598758636, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.3167771224620901, 0.29898454753012116, 0.20941993308843954, 0.23714099793232835, 0.2884634635857768, 0.3345100965481056, 0.3021380210291612, 0.2800130281821859, 0.20662672500122503, 0.1606786004134888, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19138953746551357, 0.19866658360322031, 0.612758206723588, 0.22030573235988538, 0.23918740299763996, 0.20052800699111573, 0.22012094832065043, 0.4822443367120447, 0.2471714273025165, 0.2111708279901644, 0.186343242508759, 0.8725973182680067, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19341900766806486, 0.16763465813931921, 0.19325635126535012, 0.7902370955703986, 0.7725432986676, 0.20683669431754925, 0.5675308973084116, 0.7132111249032875, 0.2107157882226639, 0.6967005941898485, 0.7958285684649093, 0.2041344925411135, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07044253525910793, 0.08182076026617902, 0.07675296820300881, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07186128707562822, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "0b686f73-e117-4626-aa27-4b4f027e02c1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = 0.9 - 0.6 * (self.evaluations / self.budget)\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic inertia weight adjustment improves exploration-exploitation balance by dynamically adjusting inertia weight based on convergence progress.", "configspace": "", "generation": 67, "fitness": 0.3652304463555421, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8394193592253416, 0.8308900101975103, 0.7967916826215085, 0.8399945421496842, 0.8425349855054476, 0.8325629781676205, 0.8000877208042321, 0.8338006798695758, 0.805801232799725, 0.6874201822216162, 0.6794033705363127, 0.6712631138960151, 0.7080996639136623, 0.6099826247915159, 0.6945959471952123, 0.6725589660864729, 0.690938973978823, 0.679963242969517, 0.14129427946444173, 0.13637925519318161, 0.16202315908957265, 0.26345009475067027, 0.14474881932845873, 0.4136502389261988, 0.15430418463736228, 0.1430904129826771, 0.35361768933177984, 0.11974038946300991, 0.13074779812603177, 0.1175901609769584, 0.12048495291158745, 0.22209815723703552, 0.35338544520995385, 0.15654545013876775, 0.11275982376320903, 0.13993294443136528, 0.9816699952112798, 0.9774146289914041, 0.9674244706543568, 0.9686748366941401, 0.9559632120944539, 0.9743240469176847, 0.977902085071409, 0.9523191493571632, 0.9872213712312529, 0.41182993540234547, 0.43997019063034504, 0.40653576738897124, 0.4626842620573848, 0.514088382456861, 0.5450629661413766, 0.49987852213761785, 0.5360152551117918, 0.6025974162629526, 0.8261668810608879, 0.32801756712945285, 0.7216737094148172, 0.7466169552214768, 0.755639470456712, 0.6270708332028061, 0.8137265343649447, 0.60290376922183, 0.7435538749713608, 0.3517769615916262, 0.3021186435412492, 0.24458268679115025, 0.36921631856037695, 0.3863093061645674, 0.3275878108534723, 0.31324610104497674, 0.3136311219687955, 0.38096150988416866, 0.3468674669863603, 0.4206176584328758, 0.13506345076490145, 0.2631081809945569, 0.39698332752227716, 0.36166333809881257, 0.2772355670839698, 0.33521651529540164, 0.2008720148288181, 0.06782189976498265, 0.06817786905241852, 0.12126942013644004, 0.14604891869239323, 0.05672649827600529, 0.11788657824290827, 0.2548056643512837, 0.18229159578732979, 0.005181282718090929, 0.3437678872284853, 0.18507949140650393, 0.34655984764585, 0.1425115901801346, 0.15390127430372247, 0.06259545621525398, 0.3660123902186785, 0.4334833626249077, 0.2393901990976085, 0.11059447991698124, 0.16076785030370122, 0.1116784721069416, 0.22562305168153785, 0.13509063085636697, 0.12919680606183426, 0.1216741247785188, 0.18103041672160214, 0.04427136122853825, 0.2997167216474329, 0.09123991796831887, 0.17920068620507446, 0.32484655843248134, 0.26730014877338704, 0.28942492926494845, 0.3021589004608115, 0.2902813419869983, 0.26638138713142534, 0.5705668347411063, 0.6444054007530733, 0.644666462779158, 0.5459412650181503, 0.5937939845891429, 0.6295852236046341, 0.6853207925409373, 0.5944340121567641, 0.555013934650337, 0.12011805282081911, 0.12036735823760591, 0.10098538309160698, 0.09296342113302214, 0.10874736291436404, 0.12141258921236164, 0.08070634539975308, 0.11129471791831225, 0.08822265797175621, 0.17167952713927548, 0.24844782292264378, 0.18662695210514568, 0.22992288696839547, 0.3937492007900797, 0.21476620559929394, 0.1770113510710265, 0.19138637206601383, 0.2997575537046422, 0.43157154873496906, 0.38646200224245775, 0.3042763583652366, 0.39006166843720835, 0.3458022068755241, 0.37024106447593663, 0.43940481398305087, 0.4701740966436523, 0.36945178779720766, 0.2963312684276179, 0.3326170433249528, 0.2988840738801992, 0.22741207960802723, 0.227628593253292, 0.2898695685584597, 0.3344785104645591, 0.3016473640725815, 0.28017760684363013, 0.2691016496159656, 0.2079067717243922, 0.23933053134409366, 0.1956233235791125, 0.22184057113181033, 0.22722622314120422, 0.20642294789908033, 0.2553845176472904, 0.19351124959002552, 0.20718379329911873, 0.6097746597354248, 0.21353807905726074, 0.2328091855711053, 0.20560139835566826, 0.2018321054294152, 0.48024439194393664, 0.2475090930786843, 0.2127159927251786, 0.18740205354667505, 0.8228673137305782, 0.15414676320480936, 0.857577146422791, 0.20037764540821545, 0.1939308386963684, 0.1673582956265809, 0.19358382292664722, 0.790285940850236, 0.8026666527952677, 0.20876461010254965, 0.6508328787363011, 0.7140618025484743, 0.20657667429052096, 0.6962390255201716, 0.8041400585128368, 0.20413586345666734, 0.5314760770959628, 0.19653455351141746, 0.21214011068033756, 0.1900208702573113, 0.19375724529157157, 0.1865258928173268, 0.18319017221823286, 0.19520437759199072, 0.1784932285752555, 0.19061497561994634, 0.07220821449255332, 0.08685862786015697, 0.07957329608639052, 0.0789295942577577, 0.08809344814164088, 0.10430672202563818, 0.06987143826995867, 0.08429209824314099, 0.08685065700065675]}, "mutation_prompt": null}
{"id": "b5cef8fd-c12c-4144-92fb-61dc41f32577", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = 0.9 - 0.5 * (self.evaluations / self.budget)  # Adaptive crossover\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        random_indices = np.random.permutation(len(scores))  # Improved randomness\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx[random_indices]  # Shuffle indices for better exploration\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover strategy and improved stochastic ranking for better exploration and convergence.", "configspace": "", "generation": 68, "fitness": 0.35610027037245273, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9169715697876641, 0.8984638748869541, 0.9129776551510987, 0.8263107904998657, 0.846023823976109, 0.8807362975841431, 0.8899325319454446, 0.8858414908200888, 0.8822498227515008, 0.7743581361794107, 0.7206999433108399, 0.7397289907155409, 0.7655927843163848, 0.7038242475723248, 0.7463982160392966, 0.7762327596970866, 0.780970901099344, 0.6936125501703843, 0.411114915875458, 0.10566604766052445, 0.06401647027119217, 0.2539883139691731, 0.1351476549213394, 0.18712466558521867, 0.3883834005027923, 0.14384043461787588, 0.1420542372679885, 0.1512599203365167, 0.30449015599759566, 0.40223651228716695, 0.24609614310271788, 0.1561079277707006, 0.15087286580398562, 0.1577356249826204, 0.44931714889842755, 0.3466814332587854, 0.9876174155088385, 0.9723196272528613, 0.9602162388209355, 0.9704466148488298, 0.9651715549985382, 0.9600397377890819, 0.972065317445592, 0.9316326750424838, 0.9835751557617959, 0.5184388940985619, 0.5176350452280527, 0.49354963978586597, 0.4759208838903065, 0.39779755888544, 0.5552460351772444, 0.5619832490657068, 0.43588206263838203, 0.49062416586941904, 0.2508977230913574, 0.7511443705517589, 0.2043113445020749, 0.7801288675924474, 0.8437848446425017, 0.6277487944664625, 0.6801511292738571, 0.681673590979383, 0.6947269500553064, 0.26633435773111247, 0.1938347846621472, 0.21098966711488243, 0.4135252391917087, 0.1661964213401318, 0.19737273066623306, 0.4618979749290818, 0.23838109701855492, 0.25993896392769045, 0.27278339353441594, 0.22836319344017209, 0.18532713035684578, 0.33789143609050243, 0.38581657064631103, 0.23002251227191373, 0.24398654446975332, 0.23543997081263646, 0.214563805913897, 0.09801144756069802, 0.09285996252875739, 0.06293992749283006, 0.10933532673812274, 0.08616567462229974, 0.09827883595478815, 0.0597186616444908, 0.08017725726920566, 0.08281607034562988, 0.21787526284504188, 0.0769293641505101, 0.17551145393586376, 0.07805850182243412, 0.1697481801708174, 0.04463955298111655, 0.17652100315920194, 0.21229517086990612, 0.2944319658612231, 0.15670784103826296, 0.2097454473366891, 0.298317443484707, 0.15565440502932593, 0.11359408347873212, 0.1048072174480098, 0.13381046642157968, 0.20088264284985458, 0.1048700341360218, 0.20990917648336171, 0.18821284236964497, 0.23090856551662886, 0.19254337622047957, 0.19763307527127882, 0.2056644383440983, 0.1868976719320894, 0.17719106692663822, 0.18051540528143706, 0.5553725907422111, 0.5808090608194798, 0.5775551695419208, 0.5287952593504944, 0.5713890933233547, 0.5155034912098395, 0.601347157524873, 0.5476905113521875, 0.5982260776657371, 0.0973733036467489, 0.07412243389357931, 0.1326173017338773, 0.09386911220907912, 0.10354536080880938, 0.11738961411360926, 0.07758670522077338, 0.08257586623665669, 0.11551444037970082, 0.409409322298821, 0.2523113454907371, 0.2485024459385019, 0.2654790832360734, 0.24593631979351116, 0.1465720890955985, 0.1971078751219919, 0.23317677820654037, 0.20481637095428917, 0.35911900146865605, 0.32405297627467866, 0.37073452867434276, 0.2572764844617079, 0.34174465068608484, 0.3551286316568816, 0.3928445025905738, 0.43865493976315506, 0.4231205955287416, 0.2561232550477297, 0.3514784334400094, 0.267114998185525, 0.2037656560826342, 0.2619610170277641, 0.2361172162671834, 0.27169575319701966, 0.24907381167706777, 0.13988069132006498, 0.21329516207622723, 0.2247482216344331, 0.23286916486482445, 0.20847360788777336, 0.22861977152611357, 0.19469536722300085, 0.2497292275966998, 0.2528925128133682, 0.21560105792981654, 0.2992185318539661, 0.581357836509157, 0.22482803916994032, 0.23308315916037836, 0.6780502760372129, 0.22034527630020107, 0.22614073204802165, 0.5633684041995108, 0.18486020128884506, 0.17648738098715455, 0.874321944151599, 0.8546964334329561, 0.9096183876681493, 0.2010463341401476, 0.827314709207683, 0.19854696241930925, 0.19213693344324012, 0.15100898255827744, 0.718428796486819, 0.20922998467829113, 0.5978570019745353, 0.5698394277457868, 0.2092463669377066, 0.20956536795049185, 0.19609281650432508, 0.1564278985101868, 0.4328297915300091, 0.21243489532651016, 0.1942454537392192, 0.18887731876196334, 0.2344420035450253, 0.21288526966465648, 0.20753800464283056, 0.19005397635846577, 0.20395979172204637, 0.18475377322568898, 0.09705217395707855, 0.09252256108195411, 0.0898254665328645, 0.0931157277551451, 0.07230605183637195, 0.07734813420015474, 0.0764924523536139, 0.09991135283945496, 0.08990623868535952]}, "mutation_prompt": null}
{"id": "4aa34120-88ce-4bfd-9aab-c35120e7b691", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = max(0.6, self.crossover_probability * (1 - self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introducing an adaptive crossover probability in differential evolution to enhance population diversity and convergence speed.", "configspace": "", "generation": 69, "fitness": 0.34181398565912213, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8738078271323645, 0.9109894083093829, 0.8695972734279809, 0.8593978785742313, 0.8876100304348103, 0.8848811778021904, 0.8982841035898466, 0.8592658972598997, 0.7703341728965791, 0.7287747843343573, 0.7660949668932844, 0.8018582447304538, 0.6854253628334424, 0.7900520085800301, 0.737490753626205, 0.776919557207136, 0.7194519078343912, 0.4993570328108725, 0.5820991853686227, 0.16025023261828286, 0.12632771947580856, 0.08380857586265833, 0.5303303720640387, 0.4599549574607851, 0.5143915544312776, 0.5219956049443344, 0.154150965325488, 0.3436077618888327, 0.4443180752998418, 0.1637712260793318, 0.15342060458100715, 0.11947290300064428, 0.4866957425724582, 0.41674590873717865, 0.5702303313009714, 0.9689899868603628, 0.9434706436482003, 0.9763630223253246, 0.9745689743901693, 0.9795199785062847, 0.9896745451306754, 0.959520239810296, 0.9730118294549561, 0.980489818709236, 0.6872486641787656, 0.524722905981021, 0.5108949544689414, 0.4377733419041214, 0.574623734624459, 0.5259828386466443, 0.5890341596462674, 0.4753094164355428, 0.5087836986518703, 0.3113358650801086, 0.6679130443929022, 0.5361228686997029, 0.40063685206317556, 0.6358749142921241, 0.6510946136399897, 0.32265624578209673, 0.37114461087870054, 0.48290549597670374, 0.2876376094295665, 0.21772926235236878, 0.2533251753705946, 0.20469402322905983, 0.1797966284037943, 0.20751825335321028, 0.4838817770533904, 0.178045398292625, 0.18639467162456969, 0.22663448164419508, 0.09356340985809497, 0.1953146121273156, 0.22850266215118797, 0.19367365671952952, 0.23518173297369327, 0.23687713355936213, 0.23013617899563132, 0.2322711769167315, 0.040182802751644875, 0.01944458580556707, 0.002336371376232438, 0.04275438628578454, 0.07306954827510181, 0.05188483848048164, 0.04686036611091182, 0.06205930096991341, 0.007075344688604823, 0.17035521217759653, 0.08927296462324197, 0.1217985492563759, 0.10625417451606822, 0.04682889008139224, 0.029281748093582194, 0.09184929790277441, 0.13948482276454366, 0.10090024626013505, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.11201616813784365, 0.15874184950653814, 0.16393934130177445, 0.17319220504216915, 0.07092797631311754, 0.10522663239579855, 0.1413448436698791, 0.21195389624749172, 0.13381885134915206, 0.33567452766171724, 0.17352080232801326, 0.12463949576162081, 0.12863378204823128, 0.1433201333221774, 0.5479446717714955, 0.5328355815951941, 0.5315425251588859, 0.4988670539778741, 0.499464021562147, 0.4744077583783044, 0.5550554701787342, 0.5196974428620805, 0.5714596349946997, 0.10667746490886998, 0.09914683126818358, 0.095961839888702, 0.10277803773418914, 0.08114834346066835, 0.09004373203658633, 0.09234946446468784, 0.08599578657114271, 0.11270607160503587, 0.14310993687620188, 0.27408167073423406, 0.20543752023550665, 0.2537182012043607, 0.22011183691356495, 0.1502080454464465, 0.2023951369832968, 0.13020877467790903, 0.1670003066293102, 0.31518473984425943, 0.3240051922439109, 0.25454296939391663, 0.2990269924022513, 0.38811609712266393, 0.2851214883037049, 0.3888932528833067, 0.34346604453776863, 0.3589661053576003, 0.17837923325337213, 0.19240975266574312, 0.18542765774491943, 0.18587941189369883, 0.2245039123147604, 0.16246048884768993, 0.29096501910999384, 0.2558028674616293, 0.23410577759299767, 0.20662672500122503, 0.17490320740965404, 0.21329478777631516, 0.24149801451404085, 0.27533510882581325, 0.2323296850988299, 0.23568791125386324, 0.21648538216323, 0.1865878164236644, 0.3186180944703375, 0.20008403522369433, 0.2949223643451051, 0.2632701624757682, 0.22963075299278113, 0.21388345229304373, 0.3700939301004075, 0.6308301362985559, 0.336436713086386, 0.186438938137501, 0.8728737208607664, 0.7042833286352927, 0.917605511140932, 0.20065701392642843, 0.17184728106348324, 0.18832466068910547, 0.17509997652957465, 0.16342176159310495, 0.5911833438454489, 0.20907620735157062, 0.5672905626012217, 0.2072547108933367, 0.4471739268114705, 0.21017166591244418, 0.46937812949407287, 0.18925632779328483, 0.4657068370738279, 0.21203784841745899, 0.20701823424643917, 0.18707829572026136, 0.21246376285534552, 0.19573799562338168, 0.19430844251682167, 0.1908403493350952, 0.18658868784263272, 0.18672941134084442, 0.09583381614993736, 0.09329554147005492, 0.07991467361384696, 0.09512621074360117, 0.07778636633755465, 0.0970338757370568, 0.07880895135346311, 0.11054642818540872, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "f1a3d2ea-33de-43ad-9e33-d62250049cba", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = min(0.9, self.mutation_factor * (1 + 0.5 * self.adaptive_factor))\n            self.crossover_probability = max(0.75, self.crossover_probability * (1 - 0.5 * self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and crossover factors in DE improves exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 70, "fitness": 0.35059911346758177, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8739849454493274, 0.9109894083093829, 0.8623004908416418, 0.859912242050586, 0.886695668848229, 0.8835694182446365, 0.8978947331566653, 0.8583281717308564, 0.7702746582515572, 0.7092074620427256, 0.7656437563385815, 0.8018827962234691, 0.6655410248468479, 0.7894321245870932, 0.7372996525073265, 0.7768988013925368, 0.6993585234846458, 0.40627454500359983, 0.12744701854329432, 0.12884622002411195, 0.15498985799223608, 0.3199507009217667, 0.17649398119569726, 0.168133785195426, 0.5252970792182381, 0.155526804951855, 0.23309499509879794, 0.2985919353567721, 0.41303734946580173, 0.15924516734054106, 0.2976976231203148, 0.38577855524014404, 0.24761688280218652, 0.13521202160246193, 0.46771935534674536, 0.9753754774718311, 0.9706924100690572, 0.9614836811324423, 0.9782245935898864, 0.976861622420645, 0.9850979856724693, 0.967614098672714, 0.9701367747616043, 0.9819920740766248, 0.6872486641787656, 0.5174386078443267, 0.511105796326442, 0.43554109853385137, 0.5747106400112143, 0.5260340150512679, 0.5890337691323779, 0.48485541047668956, 0.5084715804498816, 0.5867592003173385, 0.6426394588608068, 0.6260090470685662, 0.553012992931045, 0.3256068008106926, 0.4749727312819815, 0.5856186859101632, 0.6699983751388467, 0.646008188794353, 0.3186675485514755, 0.24629731461634252, 0.4395357583682038, 0.27872407385948683, 0.3056327475961915, 0.2712782353124169, 0.4838817770533904, 0.30915469372518856, 0.24002616790017184, 0.19634497619456748, 0.23149035647158078, 0.19534016063890092, 0.23405281650651455, 0.24248093398821513, 0.27070440016554653, 0.32704173335685405, 0.25127846567445666, 0.18234243756241975, 0.07276001097024232, 0.14931336962919306, 0.06549806304765426, 0.04275438628578454, 0.08207988555379708, 0.09512280435816278, 0.09531025278730942, 0.08537887094302732, 0.1023825729103397, 0.11398690671627265, 0.208603021102573, 0.12286376974706914, 0.13296001930235812, 0.1536128891752776, 0.06260624987516517, 0.2703347091673982, 0.28929144764188197, 0.1504140605025397, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.182195389753947, 0.13396292454019898, 0.15874184950653814, 0.16393934130177445, 0.1760187373332157, 0.07092797631311754, 0.16454571283581076, 0.23999276039620976, 0.22594840225562818, 0.2266963526837631, 0.3356479235447454, 0.2058090213397823, 0.19064984706759902, 0.18071941567800043, 0.081391785836187, 0.581283075064714, 0.5996452446630594, 0.5946805984661394, 0.5423275744728216, 0.568619567514706, 0.513526230846763, 0.5487327907167258, 0.5598648109471864, 0.58684743992929, 0.06708632883941446, 0.08842694239578064, 0.08304770284261598, 0.09222780551894905, 0.11052678478544442, 0.07961879881778844, 0.0816355337511715, 0.0900102261843736, 0.12225426263196404, 0.16156881923600142, 0.27408167073423406, 0.19356226868511428, 0.2562099157695146, 0.21960642587531887, 0.24229005312102625, 0.20239686262038126, 0.14835739718270546, 0.17825559026093774, 0.3518095330237283, 0.3029304543923812, 0.3242287185340448, 0.35574664778636866, 0.3586297570798975, 0.28890761678534016, 0.3444603268282994, 0.2617032425620529, 0.1963661930684243, 0.20975251496846958, 0.2176784821046821, 0.20004703733184348, 0.2645321602807128, 0.21735394759236792, 0.20924235299079197, 0.2302439076704802, 0.2532807420953216, 0.1561087153815084, 0.20717770282664982, 0.16472600483702593, 0.2177408883237416, 0.24149801451404085, 0.275045459480304, 0.23230983832817043, 0.23543029693357176, 0.21646052752592881, 0.1865234331608192, 0.22441146704680248, 0.4933252870900059, 0.3914780375574324, 0.33755828203368843, 0.193532498387741, 0.30639689107092827, 0.20204511974438433, 0.1918529169061911, 0.1885268659487016, 0.1863496840462231, 0.8729484456675507, 0.6661083736716719, 0.9176521213576134, 0.20506000953434667, 0.17130607803092734, 0.16766269546030999, 0.20175258051161604, 0.18260364168079812, 0.5911833438454489, 0.20788252572749988, 0.5671323356849926, 0.2066485972651536, 0.5530155785844371, 0.5138615935510857, 0.4737783420500076, 0.19910180578002168, 0.46411478900911185, 0.21240055815405334, 0.20696542388691797, 0.1943263616383365, 0.20813916848272251, 0.2008363013183425, 0.19635772664238338, 0.18459499377390765, 0.1867821789352141, 0.18970848266427653, 0.070364866015864, 0.07455904318287265, 0.07749000946091733, 0.09512621074360117, 0.08408686908731033, 0.09703393875647215, 0.07123009328239804, 0.11054642818540872, 0.10545560520185249]}, "mutation_prompt": null}
{"id": "317d3ff0-460b-4517-a502-49a373cfcf61", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.dynamic_mutation = lambda f, i: f * (1.0 - 0.5 * (i / self.de_size))\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            dynamic_mutation_factor = self.dynamic_mutation(self.mutation_factor, i)\n            mutant = np.clip(a + dynamic_mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic DE mutation strategies adapts mutation factor for improved exploration capabilities.", "configspace": "", "generation": 71, "fitness": 0.36712228379972234, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9104807058560515, 0.881135239517572, 0.9109894083093829, 0.8838522005223464, 0.877492273300431, 0.8888715329204969, 0.8845094250178172, 0.8986876112095435, 0.8802022802492251, 0.7704182895815065, 0.7092074620427256, 0.7668198602310098, 0.8037537510424999, 0.8026003077142971, 0.7921636537031715, 0.7629296737501396, 0.7779012631963687, 0.8028864800125117, 0.16165906259617846, 0.11685423734259093, 0.17589650204228668, 0.3052747298907591, 0.12821136696324176, 0.15234697708641942, 0.12267330208262195, 0.11178559044119396, 0.16448266287916335, 0.1580166657383918, 0.13464984367535504, 0.1490544382848089, 0.46211439236817964, 0.11000257856402818, 0.14039011856718775, 0.13332835841642277, 0.13472226715925495, 0.13263130768940978, 0.9727501642307372, 0.935136450046004, 0.9421884150889739, 0.9461703900015342, 0.9655663117900636, 0.9566631495134773, 0.9805201732663598, 0.9564028861438489, 0.9773427518855309, 0.6872486641787656, 0.5172245403848156, 0.5108949544689414, 0.6138175124880394, 0.5749119169497507, 0.5263633055293522, 0.5890337691323779, 0.4678840202422141, 0.5096045973847575, 0.22220364952758886, 0.8311766721399045, 0.20851736899451567, 0.27255361696400493, 0.8845139444439096, 0.8722035566779527, 0.850124885296941, 0.777783457875372, 0.40787525458514384, 0.2874944131909446, 0.17424446293642382, 0.6295220011889828, 0.1824555092300607, 0.1799813184328004, 0.2813461437025607, 0.4838817770533904, 0.17652228320260632, 0.37457941095990355, 0.19634497619456748, 0.17993552836300386, 0.2016545859278952, 0.20334536333556497, 0.18567606563726569, 0.2099820835248113, 0.23582840003145478, 0.22167959832380835, 0.18234243756241975, 0.07167076748544354, 0.000309152416303915, 0.0068090969079774855, 0.16834182326903213, 0.07306954827510181, 0.14267311897374424, 0.09345553447256993, 0.025614020620742473, 0.14791498048884333, 0.11398690671627265, 0.06445558114642969, 0.10406428881647312, 0.1286413622623126, 0.2417602061756412, 0.30602269156716266, 0.2539417383026217, 0.15189253794755897, 0.17808953453982213, 0.16503042270830315, 0.15914902579803125, 0.3578680777639148, 0.1855858438454453, 0.21601316293098927, 0.15874184950653814, 0.1701496922111142, 0.35284360227722855, 0.20255447533105853, 0.24772682499216625, 0.17536600374319655, 0.21377877441898874, 0.3306939892216194, 0.37262823536332745, 0.16811311750942115, 0.07730900211866176, 0.22490331546485154, 0.08137357102057463, 0.5418084504436198, 0.5889959593147645, 0.5963545089735849, 0.547221709021469, 0.6769971320874161, 0.7185901622987818, 0.5441221807464127, 0.5578307735568103, 0.5727822865296817, 0.15079434323500351, 0.09041109964874616, 0.08989720663254597, 0.10644510607530633, 0.07897107026510897, 0.14376713033933453, 0.10900097886878646, 0.1324983894081535, 0.1225477319863385, 0.324486926770555, 0.27408167073423406, 0.19349316747964196, 0.30795961441640385, 0.2234466040228068, 0.19509251763417068, 0.20268021473142006, 0.20866058727779746, 0.3109652848233443, 0.5632453399418451, 0.3206934380169286, 0.5599700637003212, 0.49524124442506234, 0.5549645459871186, 0.4791388760089137, 0.5242023090147957, 0.5811237744281486, 0.5359530953266946, 0.3212676591612349, 0.23556334552262936, 0.24775859717037374, 0.330674547173474, 0.19052662929694653, 0.16399401464259367, 0.33468129823459547, 0.37311104297428754, 0.49302768410307507, 0.20815569142555257, 0.21062678300094817, 0.21329478777631516, 0.24149801451404085, 0.2752684604371046, 0.23234636482906446, 0.23542435291166008, 0.21792775483218296, 0.186986245225092, 0.6870520442339872, 0.6204611576342951, 0.5871248399765133, 0.2426959338524054, 0.21066853594874946, 0.22130013291167538, 0.2286323155037674, 0.5496897264363225, 0.2062263152912508, 0.18637253861819703, 0.8725365527973481, 0.17647596627882034, 0.917605511140932, 0.20065701392642843, 0.8685320779515546, 0.17192585374527225, 0.5173293702037041, 0.18274774838574492, 0.591228263863328, 0.20866582501124542, 0.5676145947722393, 0.20683220639685873, 0.21085314933162957, 0.26071704033186816, 0.8452804444800263, 0.10387249402911347, 0.4641454256658458, 0.2122235155950617, 0.2069306572690397, 0.18235710114221948, 0.20895792428366788, 0.2021303490074331, 0.194507071823254, 0.1989716961529212, 0.18933415394883124, 0.1867693445636851, 0.07371115741122225, 0.07446464656089469, 0.08335149051665391, 0.09512727845278934, 0.07861195334290205, 0.0970338757370568, 0.0789966269249005, 0.11061723692401304, 0.10547494035769578]}, "mutation_prompt": null}
{"id": "ffac1bcb-5426-4b84-acbd-d6509de7cd73", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.elite_fraction = 0.1  # Added elite fraction\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        elite_count = int(self.elite_fraction * self.de_size)  # Calculate number of elites\n        elites = ranks[:elite_count]  # Select elites\n        for i in elites:  # Prioritize elites in mutation\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic sub-population prioritization for accelerated convergence by integrating elitism.", "configspace": "", "generation": 72, "fitness": 0.2984711346010044, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9508258675030523, 0.9322415169225812, 0.9509476032017481, 0.905493803593922, 0.9297073519109013, 0.9498408819073626, 0.9399427439140771, 0.9510617172706092, 0.9454955210951349, 0.8653949329808647, 0.8304385628777342, 0.7825344123632458, 0.850172941241293, 0.8563989178054843, 0.8431336618636742, 0.8609368002611208, 0.8646388292327075, 0.8402063033456577, 0.08691501236433252, 0.1656428563724821, 0.05930724534633569, 0.08414633573896824, 0.10205039756348522, 0.12800713725161583, 0.0841934544717311, 0.0978377927627857, 0.050131199073136345, 0.08312951620733078, 0.05028733718779477, 0.0639704169546148, 0.09891266472483762, 0.02544813201744056, 0.04553052682398795, 0.08517238989463294, 0.0636919183683452, 0.06309793750657444, 0.9243289578008516, 0.8673467146892181, 0.921764068088948, 0.8909191572438032, 0.892781667478313, 0.9119804905038857, 0.8838681836245286, 0.8619067581552646, 0.8314917022582549, 0.7359978455759046, 0.7150771026119231, 0.6308593631279933, 0.65372828983443, 0.6932716766818349, 0.7692511252489648, 0.752333470318236, 0.7080396581365891, 0.7099018753114666, 0.7247021267036233, 0.11363117137546908, 0.12513345277387633, 0.21387582018507934, 0.16742186474779608, 0.2126302140871127, 0.1418895892650568, 0.07174355885140726, 0.216060649316152, 0.22168332859705786, 0.1344120577652499, 0.19562460348005994, 0.19955333114008345, 0.27593680413331556, 0.22414919420115986, 0.22743323164644447, 0.24186975986504222, 0.1952638731090407, 0.2238487682196525, 0.1889734246555862, 0.22797029631705723, 0.20479562185995748, 0.3515082524467973, 0.20626084867140926, 0.24434936763541404, 0.22792987451363733, 0.2419942792559736, 0.15716928539677721, 9.999999999998899e-05, 0.11673683110770794, 0.07872847481063405, 0.014446606376210314, 0.0414501787683188, 0.010692883877350012, 9.999999999998899e-05, 0.06094657259187719, 0.11224624212773937, 0.08202091710077397, 0.0909755787057116, 0.07424646998368789, 0.0031076190997225694, 0.045646877742734016, 0.10822637148759806, 0.044708134568129054, 0.07402414821987224, 0.3105229558363658, 0.1983628415847929, 0.24372597994650058, 0.13606833896112125, 0.1417119573940976, 0.0927850118641963, 0.140786399798705, 0.1851506028651263, 0.07905300542070381, 0.15284166982468472, 0.48958259785745717, 0.14395156253792463, 0.14530063236598156, 0.13727990705227366, 0.0846259207838379, 0.08289999241167567, 0.30010202580267864, 0.08520195492509575, 0.5728660589831328, 0.5341702639768657, 0.548013699798708, 0.5666975112703728, 0.5839465311626191, 0.5125738416364567, 0.5532550899090417, 0.6166957405185232, 0.607307188352482, 0.05110145739075456, 0.029690320079398758, 0.025268841141034004, 0.07883778176362799, 0.0652208457786192, 0.07913667781815659, 0.07797919524100616, 0.06678239090134686, 0.07921185986092683, 0.2185576682612146, 0.27531674999434463, 0.3250432105044446, 0.26669359787433733, 0.25803549438550244, 0.17435445415356132, 0.22402735903979587, 0.2525382159546399, 0.26902684672630506, 0.1389642785356202, 0.18196179491715814, 0.16806731055314594, 0.17514727222695126, 0.53135565221034, 0.20588258741610244, 0.1418187516331917, 0.19405705753810076, 0.15730363187010332, 0.10218213629962625, 0.14692906724687105, 0.09885487012649574, 0.1932894049315933, 0.23991117862094313, 0.10033988345708222, 0.10114633252975525, 0.11861356173684234, 0.12542105992917219, 0.20851656289630005, 0.23472249665323697, 0.2669080096405151, 0.2869045638538681, 0.1976953785225507, 0.23914864838691152, 0.22253208623461518, 0.25839561000026345, 0.24277786496307496, 0.17652796095574563, 0.1945220337294511, 0.17699923201889145, 0.18573932876515808, 0.19985828261579974, 0.18032736801755112, 0.18041392009521517, 0.20173067279702173, 0.1805991387506023, 0.18870922490065245, 0.17692847248788113, 0.13220502604905837, 0.17354604418965225, 0.2015302030728876, 0.1672412721236347, 0.16873479664623825, 0.1665111232292169, 0.15352674468897454, 0.9211987681001363, 0.2040223679669132, 0.7058395434421136, 0.21015610174907284, 0.21245538837037325, 0.21257977080608648, 0.10848994403925594, 0.16811484112130148, 0.5347262446199286, 0.18316925075814383, 0.19658582193881224, 0.2387036736368784, 0.2162560367979347, 0.19749536125807776, 0.24070621428971506, 0.2272275792858356, 0.19558094506469748, 0.19993001657929943, 0.09568535593718319, 0.07540763265120953, 0.07251705834116529, 0.07102010533764846, 0.08610618395448877, 0.12365285048846364, 0.05675324854595165, 0.08980508436721435, 0.10082823319916223]}, "mutation_prompt": null}
{"id": "60420260-ad12-4eec-825f-e1de31b007c1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic velocity clamp adjustment improves convergence by dynamically adapting velocity constraints.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8740046942903668, 0.9109894083093829, 0.8648218009179481, 0.8601339668157705, 0.886455020026294, 0.8847062569419125, 0.8974782562661854, 0.8584338121925901, 0.7725435287731667, 0.7212377508475416, 0.7655172887041541, 0.8036174253779342, 0.6113605606819082, 0.7898465971363742, 0.7373128056694894, 0.7780799801214721, 0.7125720180140063, 0.1411027963989001, 0.12993829213589236, 0.1620165661053219, 0.26275494606005845, 0.14356280601529747, 0.42326673941406745, 0.15401863110513692, 0.14292710918636908, 0.3547024676230244, 0.11837630001122523, 0.13119514801303345, 0.11636033082333308, 0.1228625376535547, 0.2220816350413497, 0.3540368341164729, 0.154951740621183, 0.11138460617349832, 0.14079617224654217, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.6872486641787656, 0.5170933430113053, 0.5114089422083266, 0.45565485380186344, 0.5769550403384566, 0.5521475238968264, 0.5936515054926761, 0.5464352975295845, 0.6153065339820311, 0.7849765247621938, 0.32688973948200706, 0.7203638848494625, 0.7291714728505716, 0.7520199751737361, 0.6386134782507928, 0.8135912774278522, 0.6029008091253916, 0.7434713893031137, 0.396753927786463, 0.2981326219235003, 0.24698706275401516, 0.3668009865729318, 0.3891836298884259, 0.3224926625743204, 0.49879768686796755, 0.3151097726146713, 0.3790223741899933, 0.3457818617852588, 0.4144515810519187, 0.1953146121273156, 0.26361509384874116, 0.39707102863890376, 0.3680992611113384, 0.2894379648363916, 0.3458743067580281, 0.18234243756241975, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14535889814541691, 0.07306954827510181, 0.1178810278593726, 0.25805928781142806, 0.18229159578732979, 0.007332194029477601, 0.34791800148099405, 0.1840465963468625, 0.34521137628303644, 0.1448589439023319, 0.1540071845686889, 0.06399695639113778, 0.3661195346562939, 0.4338933453740228, 0.23537200819901394, 0.15218715742806832, 0.1980481626465317, 0.238318145534119, 0.2608464495229328, 0.16206518950000626, 0.17183619299857456, 0.1666013279525398, 0.22460851643935653, 0.07092797631311754, 0.2982037567306175, 0.08685656041890522, 0.2121850033230348, 0.3236979776385721, 0.34712980421901507, 0.29518265509603747, 0.3017496104703211, 0.2888873641038576, 0.2664210665048957, 0.5834145187447821, 0.6478802022586689, 0.6484558471390154, 0.5401845956345237, 0.6034700708968245, 0.630356700609872, 0.6905379133172551, 0.6091048014514051, 0.5838295594779004, 0.1201362536053775, 0.10100040007648536, 0.10097629324424795, 0.097621369698626, 0.10889454837375379, 0.11349696012937383, 0.0828447934659674, 0.10861947637836966, 0.11270607160503587, 0.13337941089377214, 0.27408167073423406, 0.19996766733352045, 0.2537471842919642, 0.21960642587531887, 0.1319122327607294, 0.2023951369832968, 0.1533226992096861, 0.16738637265627987, 0.4317694141508951, 0.3646263928805282, 0.30406834161273855, 0.37007238344698046, 0.35992807598758636, 0.3639078647394782, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.3167771224620901, 0.29898454753012116, 0.20941993308843954, 0.23714099793232835, 0.2884634635857768, 0.3345100965481056, 0.3021380210291612, 0.2800130281821859, 0.20662672500122503, 0.1606786004134888, 0.21755832096129124, 0.24149801451404085, 0.27544249798814613, 0.23245083063301808, 0.23542435291166008, 0.21642040377158178, 0.19138953746551357, 0.19866658360322031, 0.612758206723588, 0.22030573235988538, 0.23918740299763996, 0.20052800699111573, 0.22012094832065043, 0.4822443367120447, 0.2471714273025165, 0.2111708279901644, 0.186343242508759, 0.8725973182680067, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19341900766806486, 0.16763465813931921, 0.19325635126535012, 0.7902370955703986, 0.7725432986676, 0.20683669431754925, 0.5675308973084116, 0.7132111249032875, 0.2107157882226639, 0.6967005941898485, 0.7958285684649093, 0.2041344925411135, 0.4652995023423234, 0.2118608343445545, 0.20714267266619668, 0.19236350326538654, 0.20804040097583598, 0.1949250534432383, 0.19440222877992097, 0.1877584587622696, 0.18683607907242428, 0.19264028139894163, 0.07044253525910793, 0.08182076026617902, 0.07675296820300881, 0.09513556845109994, 0.07865772190544118, 0.09712928884255179, 0.07186128707562822, 0.11054642818540872, 0.10558965591028102]}, "mutation_prompt": null}
{"id": "cad36bde-d733-4721-8d75-3f98024863a3", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.randomness_factor = 0.1  # Added randomness factor\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.randomness_factor = min(0.2, self.randomness_factor * 1.05)  # Gradually increase randomness\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            random_factor = self.randomness_factor * np.random.randn(self.dim)  # Introduce randomness\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]) +\n                                  random_factor)\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Hybrid PSODE with stochastic velocity adaptation improves convergence by introducing randomness in velocity adjustment.", "configspace": "", "generation": 74, "fitness": 0.32786673839667974, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.7924278713967836, 0.8403224144472106, 0.8233911282847647, 0.8457965922390451, 0.8180806636866468, 0.8213328231100402, 0.8238797402155085, 0.8158842342190222, 0.4185878537092034, 0.7114913252407793, 0.7117155240117788, 0.08855055964861835, 0.06321810017956775, 0.6858382528168591, 9.999999999998899e-05, 0.6749538299421876, 0.6357375695915517, 0.6664017353985114, 0.2392417630247633, 0.11779528264877004, 0.11538721143497055, 0.5922452776452412, 0.11472252762789581, 0.09491523213969089, 0.32022499647564395, 0.3996356013715101, 0.3828860562311648, 0.13174813229542415, 0.1556514651420744, 0.13039942502488555, 0.21149264042286098, 0.14360008607902075, 0.14167239527342868, 0.13114173073863966, 0.12348017121484356, 0.1336924235805349, 0.9754288771854993, 0.9789712840799524, 0.9633625032300249, 0.9805269503403153, 0.9812807730059203, 0.9801141480766046, 0.9755222665593065, 0.962604527196605, 0.9566452255660461, 0.5184066194776774, 0.2825996933529581, 0.36246274318783667, 0.4736628767379163, 0.5139148768695049, 0.49995505746966673, 0.555823856850048, 0.28135689758328675, 0.554072894370816, 0.22906901345763586, 0.6543217754411217, 0.7071518574334149, 0.4081589427378173, 0.7506420502586229, 0.7796068781422812, 0.22530914026370996, 0.6961341509840357, 0.7713474596337744, 0.26805157053386863, 0.16470544089710604, 0.19994534397970576, 0.2243969934973783, 0.32464131096465565, 0.27325063827446905, 0.32500547609041786, 0.4269815712941568, 0.3490668102148553, 0.15143727758531078, 0.06312078982545666, 0.12876675904223434, 0.4081293040673575, 0.2310263161489574, 0.23879858070070092, 0.29827827566959786, 0.20568797081700507, 0.37580731781223664, 0.0643020963767551, 0.09672639490884172, 0.08445358534176217, 0.04967565374904148, 0.0847561338204279, 0.1107876281129847, 0.0030976644645915874, 0.19677266067194932, 0.0773442295147273, 0.10279003428064626, 0.21681298229812063, 0.13036720598432416, 0.210167707248482, 0.4107014751843465, 0.23382318398379298, 0.12543496916325259, 0.20657640819055345, 0.2778474597394185, 0.045483796862447745, 0.10550506976024299, 0.04758801212166508, 0.007547814603389824, 0.08280875731495418, 0.2112519139534086, 0.09355105237276806, 0.09585954088681514, 0.07703167698741231, 0.23493803457797102, 0.24086404911511616, 0.1858767001065449, 0.34955122825461205, 0.2834487920361711, 0.25591207309513964, 0.08078573199534045, 0.2305402378024206, 0.23718057858073094, 0.6659713218519643, 0.5590495096184147, 0.6323056978276038, 0.6197380051279662, 0.4080024067027068, 0.7237753056202801, 0.6283252882394033, 0.6269923276157896, 0.6465620625631758, 0.09464278274711757, 0.09655225224480202, 0.08398257297511391, 0.11498047452012394, 0.08434095189947532, 0.13350685778392157, 0.1346053212901459, 0.09467293070582805, 0.08182101989752444, 0.2529974744065058, 0.22810299652206212, 0.23583210234590624, 0.22974701803507247, 0.2872802981432113, 0.2565807984452718, 0.17541488190456844, 0.25567286895132224, 0.194756224277839, 0.35953309934151956, 0.34689655473756065, 0.37528243176735043, 0.36808724132924076, 0.33263137855590896, 0.4332982749170118, 0.3515792756151199, 0.4131113775683388, 0.45287956408680285, 0.3209196700063931, 0.23897448549804068, 0.25990243666022783, 0.2917082832914062, 0.3063605662103359, 0.25599668500985107, 0.3028362085702161, 0.29712977458102996, 0.3086698429717666, 0.2338796961782924, 0.18772118509067814, 0.19010213284188127, 0.22152437811925774, 0.22526341077130263, 0.2146267204447878, 0.25104257641527816, 0.1906022166512037, 0.20070312933333312, 0.21605559400197138, 0.21108274945498728, 0.2047519346946589, 0.20103819686374969, 0.2249262408963445, 0.2690767514832435, 0.23868803336824562, 0.30124712747046656, 0.2120333499686028, 0.187134097158712, 0.8051904322567749, 0.8112872357475647, 0.7982478061399196, 0.1991661604571875, 0.18223862145186198, 0.1676952234515664, 0.18184144230193378, 0.19475506217648308, 0.712050429779812, 0.16262236622015913, 0.5508853537622527, 0.2049561234414612, 0.21076684012719948, 0.716413347042532, 0.15316422715441635, 0.14872135831855593, 0.3299736256475775, 0.1824891928545923, 0.17889427670615898, 0.17910107880707726, 0.1778136161269569, 0.19705788592827922, 0.20109768574667053, 0.17626956810819405, 0.18168097973277064, 0.19634521230748303, 0.08817834758463194, 0.07362631772233219, 0.07805204580036151, 0.0956736004707045, 0.07910649139664205, 0.08087578594936862, 0.08288119178188025, 0.07331210922123133, 0.08191977089350899]}, "mutation_prompt": null}
{"id": "d4aed91c-607b-41a7-85d0-d89f2482865e", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n            # Adaptive crossover probability based on population diversity\n            diversity = np.mean(np.std(self.de_population, axis=0))\n            self.crossover_probability = max(0.6, min(0.9, 1 - diversity))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover probability boosts convergence by dynamically adjusting crossover rates based on population diversity.", "configspace": "", "generation": 75, "fitness": 0.3527918042640713, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8737313805343454, 0.9109894083093829, 0.8638040006183463, 0.8591356102051412, 0.886455020026294, 0.8840146615671642, 0.8979836623064831, 0.8554055792678635, 0.7702746582515572, 0.7174757302326606, 0.7653743312116386, 0.8018095551308935, 0.7141692850140653, 0.7894321245870932, 0.7372996525073265, 0.778279139966336, 0.7030812899770766, 0.1460143929361517, 0.3613184127986112, 0.17194956730943578, 0.16669899553881096, 0.15996540892674316, 0.17506614940278176, 0.5248129743071983, 0.1641482220298942, 0.4453165607026641, 0.3477026250738773, 0.15438834674394453, 0.15827073901206057, 0.4449040796546755, 0.14111551262439082, 0.443880971015153, 0.15472337994213192, 0.14763214115843315, 0.1488524985727261, 0.9832944353068135, 0.9565888628501564, 0.9747904359188787, 0.9706079148890002, 0.9822897450619816, 0.9733735213987234, 0.9770457062712858, 0.9827075224636237, 0.9734084614531017, 0.6886393502680501, 0.516295789973105, 0.5109867602177689, 0.5251710766577353, 0.5746438646732559, 0.5815639091285496, 0.5890337691323779, 0.5052450484997577, 0.5796157009856573, 0.49701834707386683, 0.32277433555868984, 0.2145308135475198, 0.7327821787518864, 0.5134931017196671, 0.5147058924165162, 0.34408927466129435, 0.323750266406851, 0.2742596617422831, 0.4260206252646882, 0.26782743254509567, 0.33910053861836764, 0.4002543397646062, 0.3468439939269917, 0.2552884504320275, 0.5988989602938203, 0.23902662782482242, 0.16791477030777857, 0.20128267426847002, 0.07069035238335442, 0.23133089071110413, 0.32107944724644355, 0.4607866883156816, 0.3553238018524577, 0.26931645343597177, 0.42456987430465754, 0.23875144358214462, 0.005056754127885532, 0.0020293787978249433, 0.004276868873012374, 0.04275438628578454, 0.07306954827510181, 0.047019099168765566, 0.05277545916923487, 0.014611908508615268, 0.02964931399235682, 0.12083636657332442, 0.10514649505289542, 0.114478107235786, 0.12042175051630655, 0.06982769278819523, 0.029281748093582194, 0.139011897236076, 0.16772891081102004, 0.07453281108625998, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.15861839047069992, 0.15874184950653814, 0.16400486698944117, 0.17319220504216915, 0.18174763162566054, 0.2459563880863178, 0.21353772187572162, 0.23670827990994658, 0.26865377008521185, 0.39618996878305524, 0.2842595531152605, 0.14056111240784797, 0.17191577450215167, 0.08137357102057463, 0.6437411480672507, 0.7237751281565553, 0.7110991534359967, 0.49023429061541157, 0.680688147673814, 0.551130792882159, 0.6844520328700678, 0.6217236400456465, 0.6504639466928315, 0.09101692869495981, 0.09819835714325109, 0.09965163637107066, 0.09624057739361347, 0.09501579389743797, 0.10495706084280487, 0.07460990472580031, 0.08142698682686167, 0.11270607160503587, 0.1425547130758268, 0.27408167073423406, 0.19356226868511428, 0.2536678496829382, 0.21960642587531887, 0.17757935933049085, 0.20266066861089826, 0.12784217838715473, 0.1763947042919637, 0.31744017907459743, 0.29666416455827793, 0.31582181152998823, 0.28736581012940543, 0.39580403456023605, 0.3340358152993086, 0.38732210161895597, 0.4115776315553541, 0.4198305776228618, 0.19115693584614102, 0.191229554625587, 0.19212322050571173, 0.21384537042659235, 0.24678958591279532, 0.24230784295959407, 0.20739680293330243, 0.18613677003240003, 0.251118419313869, 0.20663533784790344, 0.19359799096634756, 0.21446639170378734, 0.24149801451404085, 0.2757625075090223, 0.23231416340105226, 0.23542435291166008, 0.21648538216323, 0.1868664967055622, 0.3068165250224264, 0.19696813383362943, 0.29629030370608767, 0.20302248003503576, 0.2415850256895552, 0.21554273539087065, 0.3762601422671167, 0.5191809852299252, 0.22257620562760438, 0.18633807055359553, 0.8724126139938813, 0.7465482131204417, 0.917605511140932, 0.4945652020079425, 0.186220989990731, 0.17128390762199686, 0.5471466776167232, 0.4234483620721353, 0.5911844147217384, 0.21037088608298826, 0.6572981439761494, 0.26289454724308703, 0.21071578822220383, 0.3428244633716224, 0.49270461489898043, 0.6219075499410421, 0.46419879019798493, 0.2117976750917704, 0.20701823424643917, 0.20569865289575873, 0.2080278444434973, 0.19572822989696526, 0.19449844377956338, 0.18823081527207763, 0.18664084307485818, 0.18396399665910734, 0.07550704405409103, 0.07517759631176435, 0.07547328690871968, 0.09512621074360117, 0.08066974572064622, 0.09719089873582631, 0.07241854036289574, 0.11054642818540872, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "98e51fe8-cf87-4e0c-a7a9-9ebc57e30f5f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.7  # Increased inertia weight\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.crossover_probability = 0.9  # Increased crossover probability\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Slightly increased adaptive factor\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic parameter adjustment and adaptive velocity scaling for improved convergence speed.", "configspace": "", "generation": 76, "fitness": 0.34937636746904976, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9195114100478251, 0.8843472063809714, 0.9128815421815859, 0.8572223220820056, 0.8709093971753917, 0.889145940681947, 0.8884908345604136, 0.8923458769650522, 0.8729584257207482, 0.765060947381662, 0.6839249345312834, 0.6852424766084055, 0.7414177830798263, 0.6933620055060694, 0.7107379806763103, 0.6942237178090003, 0.7304724312149434, 0.689570297185685, 0.1869892539668505, 0.15408180371982383, 0.18257839289527966, 0.08286508649385194, 0.42410373819496494, 0.16623182844066065, 0.0637398100524863, 0.11978648260527702, 0.11679817136410697, 0.15216113014800192, 0.1313215468838116, 0.1304052318422091, 0.10494712587800181, 0.12691806699855201, 0.15343053211083912, 0.12110654294606504, 0.11360946547894424, 0.10414431215468134, 0.94270204005123, 0.9501415156251788, 0.7398537671072001, 0.976628704063895, 0.9689033452589623, 0.9486267903599086, 0.9745000746938738, 0.9302627205323574, 0.9841570062975722, 0.563226768729727, 0.4962102394477854, 0.5039054096164521, 0.4476141415623318, 0.4218872904996307, 0.5510156441135192, 0.535542930192817, 0.41230649777047323, 0.5603985954797646, 0.6478894002758415, 0.6775406889294, 0.6564504188917657, 0.42232770995360724, 0.6683592537468892, 0.3469650777246397, 0.7248383352451875, 0.11519277350156076, 0.17844470162471748, 0.31455343675877057, 0.27525541144724786, 0.310540923272138, 0.4254067723645898, 0.20068056446495108, 0.42284006580248934, 0.23503534152544392, 0.31528434584058873, 0.24666452891306423, 0.28172773861807543, 0.03819485101069553, 0.19055619447964778, 0.4376502160710952, 0.31939596951561167, 0.4818576124345716, 0.22619253465185996, 0.36233220805539, 0.5707025945594846, 0.062155299484235704, 0.0065433318772450955, 0.147284499800435, 0.0852532271321994, 0.12667112262593783, 0.14950234830944586, 0.1702238636300475, 0.3065902147276409, 9.999999999998899e-05, 0.1072745750993549, 0.2026377908022251, 0.15207262647155217, 0.2445200676628979, 0.09790928601640081, 0.051327907498848746, 0.12532331305358801, 0.252624937750633, 0.07661163128432291, 0.13474582906740107, 0.1606572351069101, 0.2381020779832148, 0.24439122545917757, 0.3103051275355304, 0.10260562237771342, 0.09636630992293571, 0.11281059962081619, 0.07502640559912166, 0.30717903888350906, 0.24145172436803308, 0.2633357958352681, 0.2728553191883034, 0.242944044384376, 0.3335891189004522, 0.2609637056329489, 0.2812617376608607, 0.0829733902698494, 0.7199992596283546, 0.5883908823232158, 0.5933483535925426, 0.6704429347360574, 0.6021405046774919, 0.5916141926313332, 0.641176307119981, 0.5848107572236612, 0.6698598554794297, 0.11168171506018165, 0.11270496069026481, 0.14010071991552264, 0.08514884590032556, 0.09104682699763467, 0.076510477509663, 0.08784465253715701, 0.11589051900252745, 0.12250697324355786, 0.25829400384051837, 0.18681259282772456, 0.26573970387532486, 0.17596953933496728, 0.19957945391492604, 0.23066118399760238, 0.22673732018300496, 0.16140065857403774, 0.17776034011811404, 0.3354608174316608, 0.33536166675319434, 0.39134315545831433, 0.4341154220957071, 0.3785977286390325, 0.3971021524261258, 0.4208773439595217, 0.20126473683509716, 0.3573289043544351, 0.2935477024522345, 0.3590914478189706, 0.2590150711734974, 0.2560792428076901, 0.24020614145968844, 0.27502783167001477, 0.34668129194761244, 0.28302122164250054, 0.14394061454656715, 0.23119019172483934, 0.21636493735937634, 0.2530167663095495, 0.22795431874845895, 0.2525441809113116, 0.24095900746025367, 0.23900174075004832, 0.24979754442497148, 0.2627752310907392, 0.2250084911186273, 0.21563991829828966, 0.20345895396497904, 0.20510197249315587, 0.20284873997516428, 0.20116319193862098, 0.21140062381795766, 0.23941474683122843, 0.21755765190285148, 0.18807142126675813, 0.8872577479120122, 0.20774367914632974, 0.9220165679866548, 0.20029612822104836, 0.12155935878826607, 0.16798016001159488, 0.19566262453441519, 0.7696133574618698, 0.6230082716056172, 0.20897961989270275, 0.9095596367060185, 0.7639412558862326, 0.2108538605050151, 0.6197818478049887, 0.1546126079275627, 0.7923003076249703, 0.46986712531051633, 0.18918490247029907, 0.22451011500499907, 0.19366111533918573, 0.19958385305892457, 0.19384439219189753, 0.19183782301671193, 0.20055833377226195, 0.19496367129683945, 0.23692639573447805, 0.08512891772844655, 0.07450500751769285, 0.08745027636122138, 0.12231082541212834, 0.09755123320559256, 0.08820665842762465, 0.07819500693438608, 0.08230190986962571, 0.07603756578347165]}, "mutation_prompt": null}
{"id": "0676e086-50ad-4f3b-b68a-550dc79b0d9c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = 0.7 + 0.3 * (self.evaluations / self.budget)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation scaling for DE to improve exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.3631688612519433, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9104296391078881, 0.8785015721715924, 0.9109894083093829, 0.8690322133946418, 0.8654318967298594, 0.8867963757742049, 0.8831162294221602, 0.8997475986044976, 0.8719595944934255, 0.7706260257567517, 0.7092074620427256, 0.7695510797282137, 0.8050157906718283, 0.7451548589775897, 0.7899491847773296, 0.7554711602095068, 0.7799588831174977, 0.7618866401612137, 0.12254035902531013, 0.14831757145668112, 0.4207229754180657, 0.1398758099427776, 0.13312443679760655, 0.1415018756525478, 0.13066532392202157, 0.34739744294298525, 0.07315965685227088, 0.05187148515745832, 0.12898035303768407, 0.10996307140096884, 0.1502078453286393, 0.10777194047131344, 0.15293887502166603, 0.11178646354069277, 0.2583726141746543, 0.37693976316527356, 0.9555740814642983, 0.9598512884671481, 0.9251446533630514, 0.9369760327293275, 0.9766389245211623, 0.9513413710326465, 0.959713029843253, 0.9333836721146114, 0.9545510545320516, 0.6882093454396565, 0.5825356599000723, 0.5111017939650488, 0.5150862714885227, 0.6466042420310572, 0.6076856051390833, 0.6326540712603796, 0.4685706972347008, 0.5548336997124854, 0.8015418496801576, 0.372078473027471, 0.7690655255746789, 0.7617143805671187, 0.8213926561814336, 0.27802189541942757, 0.8190137516379392, 0.17358519816270201, 0.17322517075690635, 0.3405908235012446, 0.1758246690232934, 0.3076138604665051, 0.3040354258578264, 0.36515180618177356, 0.4523319301162927, 0.49383290423635495, 0.24431794551759412, 0.5402569504092858, 0.2869204225532559, 0.25249650945537017, 0.2513304553450736, 0.3500318777216497, 0.41161599634489754, 0.23241525536770058, 0.3012026335181286, 0.5430246937580316, 0.22574341053381164, 0.20896679074809843, 0.05718895697853821, 0.0015318332322743489, 0.07070181238044482, 0.17297236146671602, 0.07044234517739112, 0.17404055871066304, 0.109703184560485, 0.08304813545871803, 0.19867519713472803, 0.19386723493011404, 0.10394231004165289, 0.09312390644759216, 0.14826998225075783, 0.07171219556395403, 0.17442608810773652, 0.25753247606548657, 0.0806715772228992, 0.15218715742806832, 0.16983258265994938, 0.238318145534119, 0.17534870789251322, 0.12592637852660427, 0.15874184950653814, 0.16393934130177445, 0.25534038924379776, 0.07092797631311754, 0.2640790981282555, 0.24649278535449726, 0.2967470438275973, 0.3355695704031537, 0.36439575497158894, 0.32771710075304905, 0.27423416255124855, 0.17154352216556068, 0.24060599977650565, 0.5835306879951493, 0.7412537667206177, 0.6547145619248345, 0.6738132569673962, 0.6001049750180397, 0.6765677078194128, 0.6778579130666122, 0.7064177045063698, 0.6606219114441585, 0.1589522338014292, 0.132987099055911, 0.10507445085782363, 0.11240236226758538, 0.10829856439121066, 0.09782987656099229, 0.13127207433942334, 0.08720302066212904, 0.11272102072751677, 0.19117237544597154, 0.27408167073423406, 0.20934125675983273, 0.25343873978145315, 0.21960642587531887, 0.17431769744892112, 0.20236181711504309, 0.1868136753739158, 0.1670003066293102, 0.36986452639788703, 0.46212585432350883, 0.3943702667022083, 0.38647610836013524, 0.415589777710066, 0.44617206506421836, 0.45868831552747713, 0.39019222021102073, 0.433845513970772, 0.29527514890622353, 0.17560563095783743, 0.22888554592913746, 0.32802041226496537, 0.2972545167511613, 0.31551242364348964, 0.3287335871590692, 0.3448961883945494, 0.32201939027931514, 0.20662672500122503, 0.18103088625601949, 0.213726255676283, 0.24440985987646313, 0.2751844045263656, 0.2323478871271849, 0.23542435291166008, 0.21647731448924712, 0.18776868151937032, 0.3128622263422972, 0.20471264296677605, 0.22280413828901624, 0.21248830233757254, 0.1891133948324999, 0.5515671934985279, 0.23625868408211725, 0.5911031138083052, 0.2251749189921607, 0.18712446878539712, 0.8724658663966696, 0.8193777098888155, 0.917605511140932, 0.20065701392642843, 0.190085328613796, 0.1715534636222963, 0.16866127344799586, 0.16036570487073365, 0.5911833438454489, 0.20734009087153304, 0.5672256507472844, 0.2066958468441723, 0.21071578822220383, 0.2102338039188334, 0.4679374955284574, 0.12377352899908001, 0.46440225999903073, 0.21355478226735702, 0.20693328525600585, 0.19838451507736987, 0.21138745976220386, 0.19525060683580986, 0.1966673623609323, 0.1874820181375194, 0.18784427227392175, 0.18423800115571987, 0.07073535784470042, 0.08847661102704263, 0.08314791848943837, 0.09522879210427504, 0.08082999073590358, 0.09826927670849128, 0.07971169221723118, 0.11054681333037975, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "82985301-0701-4a5c-9055-374c6c4f23b1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.local_best_positions = self.particles.copy()  # New line\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.5, self.mutation_factor * (1 - self.adaptive_factor))  # Adjust mutation factor\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n                self.local_best_positions[i] = self.particles[i].copy()  # Update local best\n\n            # Find local best within a neighborhood\n            neighbors = self.personal_best_positions[np.random.choice(self.swarm_size, 3, replace=False)]\n            local_best_score = min([func(neighbor) for neighbor in neighbors])\n            if local_best_score < func(self.local_best_positions[i]):\n                self.local_best_positions[i] = neighbors[np.argmin([func(neighbor) for neighbor in neighbors])]\n\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.local_best_positions[i] - self.particles[i]) +  # Local best influence\n                                  self.c2 * r3 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with local best strategy and dynamic mutation factor adjustment improves convergence by leveraging local best solutions and dynamically adjusting the mutation factor.", "configspace": "", "generation": 78, "fitness": 0.20403118312830856, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.37878908803735445, 0.37508292338164073, 0.39337657958934746, 0.35961753607755775, 0.35476049343791816, 0.5034020120031004, 0.35499814986642086, 0.5997453710801002, 0.4592659853926915, 0.010939520649676293, 0.06869126891774957, 0.2655875481962736, 0.25638977869026003, 0.4251720878396701, 0.09079010417116684, 0.1926690351923901, 9.999999999998899e-05, 9.999999999998899e-05, 0.09987168817676761, 0.09618235905784278, 0.07660606850005258, 0.14554316710647275, 0.08705327183594158, 0.09279168532198823, 0.08248753502629536, 0.08748604693784823, 0.10712735613681457, 0.03657330427006966, 0.08410708950893475, 0.07278778055857094, 0.08290683547772681, 0.08501225624186659, 0.09306351026623039, 0.07570221356009299, 0.07889244266828432, 0.0998129060422498, 0.9326140622868127, 0.5205347192544503, 0.8728586410398309, 0.9189551705168681, 0.8557630693740658, 0.7604876016599186, 0.9115558788713045, 0.9658662169306708, 0.8708171364597614, 0.22531982972971143, 0.16844187383208242, 0.21738944589943965, 0.22191297372217644, 0.2150692025921772, 0.20850959966891236, 0.22401162403060382, 0.15688968321643315, 0.20819844155031164, 0.2121415196198876, 0.17724354176953983, 0.20045576613123917, 0.2745280036490908, 0.16441565940874403, 0.5491866924876612, 0.6754097199630362, 0.2805321167862662, 0.260744338035635, 0.12517294982568605, 0.11529828771083217, 0.12199084498808133, 0.15913843564663344, 0.14746977765377378, 0.14088380399621003, 0.14470683411635332, 0.11226245274279589, 0.12995355164650246, 0.14466893357812283, 0.09645490056217054, 0.09335367231437253, 0.12200255039940477, 0.156624683547552, 0.13390192161568726, 0.16667772045105345, 0.11641576606596249, 0.12296030661772006, 0.03283815492467834, 9.999999999998899e-05, 9.999999999998899e-05, 0.009283756766245821, 0.024283997177937833, 0.0724045729811198, 0.054297054466270644, 9.999999999998899e-05, 0.09313325874053202, 0.06967843590707612, 0.1195830590230087, 0.17444871975774567, 0.022430350429165635, 0.08648704722720302, 0.04024476071920413, 0.1717521118138673, 0.09918896597494453, 0.05427611685020439, 9.999999999998899e-05, 0.010065546540234949, 0.062054271535215366, 0.1109119017515462, 0.07927524602386116, 0.12910754092178545, 0.1001715522363602, 0.11709253253586738, 0.05980118415856572, 0.07134185888052758, 0.13310319001666993, 0.061769410215239295, 0.05958197450221392, 0.12015219215023132, 0.05962432075919155, 0.13003648072641805, 0.07174855408810543, 0.25762890334681465, 0.4072989870995313, 0.4471807436563381, 0.3916952914421865, 0.486564154646584, 0.4492527227062266, 0.3472892058282535, 0.3597733544337033, 0.42511774575068695, 0.4193879187078393, 0.07594914622185056, 0.06598578917969022, 0.10399399879088145, 0.0810357241004307, 0.09624124110202725, 0.08584003400142992, 0.06811058377527424, 0.0888280604285312, 0.08255773089172158, 0.18029259545873244, 0.1928632947559119, 0.20446712260854716, 0.1990942608354066, 0.18542439210869288, 0.1749050587732479, 0.1539481282894567, 0.15238546691936938, 0.20039120806003918, 0.20723248843661657, 0.23255680075967144, 0.2846933512968597, 0.25878095679600266, 0.2621217512521975, 0.25366689722236246, 0.2911241024589808, 0.26299377322147, 0.3075738651828488, 0.17860400917228925, 0.20578220954606763, 0.2112393884078756, 0.22588919159614773, 0.17071641009880878, 0.17023429396578793, 0.1512447261545874, 0.2161707949930669, 0.13045144912898865, 0.176132530111342, 0.1861993121621235, 0.16771682472003213, 0.1733641402248115, 0.18027417899014964, 0.18333813300473756, 0.1815458529280185, 0.17284078793756252, 0.19187077991470636, 0.18930361949135244, 0.18266426854723405, 0.1841927795386057, 0.16992180412909252, 0.17049001232836614, 0.18037401155013744, 0.17897832350232568, 0.18159034774898997, 0.18217438604886194, 0.16660424153075581, 0.4727745223579479, 0.2610590377860087, 0.16566638898187214, 0.19129501736964372, 0.1565427891452431, 0.16093021553913134, 0.1422199245573076, 0.1643405236542974, 0.4378410037887195, 0.188925245322614, 0.3312662383696642, 0.1966529214629219, 0.1890739316014628, 0.562340664421356, 0.2505620402079669, 0.18605165449504923, 0.22510835583603805, 0.17016962479798492, 0.18652396686739947, 0.18376984218909898, 0.16848320604055766, 0.1689332127095453, 0.1707791720059635, 0.15793913765320977, 0.187286111423435, 0.17287203825907926, 0.08135033089419796, 0.06683375828684424, 0.07587523110578331, 0.0654876562166572, 0.0731046673348561, 0.08471305582450461, 0.055891728001746355, 0.07286048210516072, 0.06721316009798517]}, "mutation_prompt": null}
{"id": "821eab0e-e47b-41e9-b109-e0be3733f99f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = 0.5 + 0.5 * np.sin(self.evaluations / self.budget * np.pi)  # Chaotic inertia weight\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.crossover_probability = 0.9 - 0.5 * (self.evaluations / self.budget)  # Adaptive crossover probability\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover probability and chaotic inertia weight improves convergence by dynamically adjusting exploration-exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.3207985211788466, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.869928958228756, 0.8360922849859191, 0.8368975686490019, 0.8215621545525941, 0.4807209657918926, 0.8237794201530667, 0.5563572585886889, 0.8596871891465045, 0.8212161674824596, 0.6859757550785563, 0.09129875157841905, 0.6951684256000856, 0.7020543469538923, 0.7179747665083609, 0.6919898648615375, 0.6893004852845603, 0.6977594310025942, 0.7150160123294556, 0.3456449195268252, 0.15031989103336563, 0.1498654442626448, 0.20692144750153185, 0.08154507499394681, 0.4419648016005635, 0.14837609119527273, 0.16744850496346975, 0.14870354598470692, 0.1291798691324879, 0.1376512351348983, 0.4046063077276639, 0.09695573795452217, 0.3606032689748714, 0.15875032195228322, 0.13041034538910334, 0.46278338375175665, 0.34124959417809464, 0.9431226813868286, 0.9606488724408203, 0.9034852228879126, 0.9555901793911907, 0.9324979599359807, 0.9659101352226143, 0.9741295905177161, 0.93741223587819, 0.9382570410590428, 0.491950654224239, 0.5050488292307478, 0.5163608464667074, 0.5153406544900863, 0.5190904291847951, 0.4907305773758388, 0.4981191737080174, 0.34540234697281325, 0.43186503930146336, 0.5044143432276713, 0.7478713022551715, 0.69315712492994, 0.683829856411464, 0.3324359406363394, 0.7140269165160221, 0.6805635726435293, 0.7677524222332981, 0.7395535263483675, 0.22434933100729226, 0.18765749633471074, 0.17507828906840117, 0.25695495689043424, 0.2182458536994154, 0.26727599397085544, 0.22174316994527665, 0.18644029811846863, 0.21786327455687238, 0.1976384334015836, 0.1832586751482842, 0.2003440139627789, 0.2601634988746866, 0.25202344002917776, 0.18434149656763876, 0.1965070161187329, 0.2536265826428775, 0.2002344902886335, 0.07925201431625428, 0.05090877757348411, 0.03090984943735109, 0.011501401469915296, 0.06652476823374254, 0.042929599630976756, 0.027898468716423874, 0.23293751161802356, 0.11270447061920363, 0.11425412401369173, 0.12798833836820034, 0.09607046164311706, 0.23111671600377326, 0.22894695790306185, 0.05413479649256081, 0.17014405542976818, 0.11955884657351312, 0.07820995245601592, 0.05245819784027739, 0.055796880279443184, 0.060532501056143384, 0.09905087660923584, 0.07795750242560029, 0.07513147833697764, 0.08662674094084521, 0.022957871115336426, 0.09309639071639908, 0.19892884607401884, 0.18700988601554014, 0.14074173328151807, 0.23052868756258027, 0.18061916425208369, 0.22528756199180566, 0.14992273345224616, 0.1588121970196429, 0.08082919280629797, 0.5358022938776199, 0.5697291415371368, 0.5533166465731321, 0.5621794562856794, 0.5262602611935685, 0.5107117187021524, 0.564996573927361, 0.571094012668571, 0.5444812958367857, 0.09096103908641329, 0.14165271807006463, 0.09282653863041157, 0.09130703333920631, 0.083007462755196, 0.08527914791772129, 0.09477232606010388, 0.09594472054202818, 0.09500869901900966, 0.2234937037876097, 0.2558872967715209, 0.1945186988978771, 0.16896661267256152, 0.26515211612613643, 0.25221986643765215, 0.33203203808452675, 0.17542515245267754, 0.180127415556244, 0.21381027993980073, 0.3297678914721601, 0.3065029671060061, 0.3212226148435794, 0.3927066072676968, 0.358933257598121, 0.3084727283648051, 0.2741342674127978, 0.3349498632830037, 0.26209031292898777, 0.24741044860106798, 0.2227513493442852, 0.20583584438294733, 0.29321865169219896, 0.25305044430795987, 0.18964077109250344, 0.30491020564655447, 0.24176981851681323, 0.23321325245809943, 0.22955398137630323, 0.196829970875659, 0.2188839123819073, 0.18239479813803505, 0.25408892645749115, 0.24648090993929672, 0.23656301040587202, 0.19672524481270404, 0.2318594817856442, 0.21888087189752492, 0.19764652636438085, 0.1955894287126151, 0.21210284038241867, 0.21447491355771287, 0.21369980190349958, 0.24074597824406896, 0.2055210653945614, 0.1872708256067579, 0.7219332152795637, 0.19348722073908908, 0.723920868915128, 0.20052334853998044, 0.1528582188824581, 0.1675749657701352, 0.7355193505037958, 0.18463834465773343, 0.4933879978352176, 0.2097495123281331, 0.7417671335024374, 0.20874083093269902, 0.21057364761998487, 0.2105039714733622, 0.8092724278388215, 0.15164246174199014, 0.34836135813923497, 0.20037373896505983, 0.19332245315454433, 0.19546974204666545, 0.17771292389521187, 0.18273248960708632, 0.20347750033744927, 0.20133073452121908, 0.1854793977377085, 0.18367167147392927, 0.0895344915290136, 0.08103885725616744, 0.07816002970799163, 0.07577625479728634, 0.09281243355997615, 0.10133696225727618, 0.06800178344312047, 0.0988649312354144, 0.10771832328883812]}, "mutation_prompt": null}
{"id": "2f7cc657-c4b6-4432-8926-1bb8c3c65a83", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.mutation_history = []\n        self.crossover_history = []\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            if self.mutation_history:\n                self.mutation_factor = np.mean(self.mutation_history[-5:]) + 0.1 * np.random.rand()\n            if self.crossover_history:\n                self.crossover_probability = np.mean(self.crossover_history[-5:]) + 0.1 * np.random.rand()\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n                self.mutation_history.append(self.mutation_factor)\n                self.crossover_history.append(self.crossover_probability)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and crossover rates using success-history based parameter adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.2797381269325751, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8998945180694712, 0.8887173350368819, 0.9212349485766868, 0.8591760023287882, 0.8529332570141257, 0.9029241791053555, 0.8837217065814419, 0.8881437786009257, 0.890628938945682, 0.7982978650371646, 0.7178887590093708, 0.749153581607167, 0.7233122185899878, 0.648372500564541, 0.7607026031533826, 0.7854593803800396, 0.8022041128000776, 0.634966187256957, 0.0725251141519353, 0.16306314549918566, 0.05238016957337388, 0.08031225676016507, 0.0857111611379141, 0.11092436615467927, 0.08461100531057542, 0.07321930764933893, 0.06410895489561319, 0.10578412742820131, 0.09197171918732261, 0.05342217687376338, 0.1254034444249037, 0.05088678545076131, 0.04634687747201005, 0.0724313085681555, 0.05076564271195516, 0.07433120862747766, 0.9478575640672394, 0.974601585797652, 0.9591732552481873, 0.9761787672356724, 0.8386177733275455, 0.9505061135167232, 0.12940107284519653, 0.9682442543153734, 0.9741724559392222, 0.5704218424661457, 0.4956075630631197, 0.5179716008763426, 0.5498210391358942, 0.5328827080920162, 0.6037661906958562, 0.5712028748526834, 0.4672367529954712, 0.48354575357532836, 0.21213471768241499, 0.19401153313919473, 0.13534057196385618, 0.2746389628354846, 0.17506497155538814, 0.18639128719639764, 0.16685112601094565, 0.12571636261331098, 0.1987168086312261, 0.22606353950686375, 0.12807813112968436, 0.1839544089187466, 0.2653835754002123, 0.2522109491418527, 0.15797785379262352, 0.22032026014062345, 0.13553712574191068, 0.175835854262833, 0.20492257821047655, 0.13464081083558355, 0.200692545360725, 0.21717292543087297, 0.5070242942862337, 0.17478697303269852, 0.22972011958882477, 0.20701570422557303, 0.2231077951219681, 9.999999999998899e-05, 0.020490433450328416, 0.014845609462266873, 0.06027602198031223, 0.08179727787508873, 0.004620757456323399, 0.005913654697935589, 9.999999999998899e-05, 0.037293482270070344, 0.11480375790640374, 0.07273200871032148, 0.10050305949207683, 0.10944601708460455, 0.015868980253202603, 0.1129185661390053, 0.11195198918239546, 0.15695002730745167, 0.08101342029015413, 0.15514723553726595, 0.16179294102141173, 0.17526955443111092, 0.08306997013433504, 0.10705780305071166, 0.10876281467709281, 0.10747538533668899, 0.1634769323450571, 0.07425011220543054, 0.1161949066154584, 0.052547941113687546, 0.2632984993004289, 0.1624342114224473, 0.3260020571768145, 0.25074897587291767, 0.10412815578101331, 0.1551614089327069, 0.08130366104820064, 0.5454187549426222, 0.5052526712245282, 0.48948398349947386, 0.47681286820973434, 0.5345772000627242, 0.568069958138645, 0.5471581468741304, 0.48808728736499785, 0.5455540153373655, 0.06948109829820004, 0.08031730366891221, 0.06061870922437118, 0.08003248246858274, 0.05883433665866156, 0.11753232616375131, 0.0720611424304397, 0.0964972463063728, 0.07079599857373975, 0.3292879584559806, 0.3451977997107444, 0.40103091112883427, 0.19422626446282976, 0.19648105545781114, 0.24150791473429767, 0.17772332978098515, 0.13296915947466537, 0.2340922842142923, 0.18840293039635403, 0.17136218333071462, 0.18010485853303837, 0.26633095191202816, 0.26878147659163965, 0.24158996356726103, 0.17505705415911166, 0.17776914532678578, 0.176650111211194, 0.13282146716811516, 0.19113238116080766, 0.1480686487648687, 0.17442691097948249, 0.1955169041067082, 0.16762595924710544, 0.13671927444303367, 0.1591577764304546, 0.14798738259119038, 0.18636995988866822, 0.18783746705485027, 0.21559794125084708, 0.2016167732445011, 0.21970697506258197, 0.21869923699571547, 0.2235131809611568, 0.21702103416073426, 0.18986491439652087, 0.17780070729155972, 0.20237966094932125, 0.1910023317295868, 0.19002312507977037, 0.1927692826855466, 0.17446691291623861, 0.17225540768162995, 0.19072711877849735, 0.16551133884979352, 0.19938363051505337, 0.8251649655805243, 0.13164429904250596, 0.8295321637848274, 0.20027160844522363, 0.16650023168804706, 0.17008363892914347, 0.21634158237169687, 0.15235633458265163, 0.710536378427561, 0.16319766912113132, 0.5234634197951855, 0.20548346790777228, 0.20940099615582008, 0.20835807366843495, 0.1176770784879615, 0.16504865793116807, 0.3893891341419775, 0.2139643062833979, 0.18969563324959948, 0.2009616234693351, 0.18865228458422012, 0.19588801548323276, 0.20970796128513858, 0.18692451594265358, 0.19096684186055246, 0.1878053314874828, 0.12034998790387397, 0.06361553718982182, 0.07363414898025822, 0.11516936159546398, 0.07391880830983266, 0.07035561123143819, 0.0735709827186205, 0.08258692489080566, 0.08586402673040705]}, "mutation_prompt": null}
{"id": "b2936052-5686-4459-a1d8-574527ac14f7", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.diversity_threshold = 0.5  # New parameter for diversity\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def diversity_measure(self):\n        distances = np.linalg.norm(self.particles - np.mean(self.particles, axis=0), axis=1)\n        return np.std(distances)\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        diversity = self.diversity_measure()\n        if diversity < self.diversity_threshold:  # Adjust inertia based on diversity\n            self.inertia_weight = 0.9\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive inertia weight based on diversity measurement improves convergence by adjusting exploration and exploitation dynamically.", "configspace": "", "generation": 81, "fitness": 0.3596179290484488, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8384902627545678, 0.8281693816551273, 0.7948679056594705, 0.8401957196541004, 0.840555198512925, 0.8318496989234233, 0.7922432993366392, 0.8227851249484833, 0.8019997363235338, 0.6874201822216162, 0.6801041650776541, 0.6712631138960151, 0.7080996639136623, 0.6099826247915159, 0.6945959471952123, 0.6725589660864729, 0.690938973978823, 0.679963242969517, 0.14001466980934896, 0.12784020744205937, 0.1620165661053219, 0.2631971983056316, 0.14291123549634543, 0.4130297624914522, 0.15376444890705443, 0.14216924326455593, 0.35455921140790847, 0.11927185468843249, 0.13068029908869827, 0.11554061327131726, 0.12595821157358456, 0.22208174766721545, 0.3539813381740592, 0.15674390663668925, 0.11159194980261677, 0.14032372213533362, 0.9816683614409101, 0.9774176972091623, 0.9674244706543568, 0.9686587226814284, 0.9503648519093122, 0.9743240469176847, 0.9779036233658487, 0.9521851369965671, 0.9872213712312529, 0.33518718049015006, 0.30776546688539164, 0.31459707864303377, 0.46321541839159663, 0.5052042847258891, 0.5402639210344149, 0.5002900146805527, 0.5376415686847135, 0.6035537953209592, 0.7868070454636125, 0.32739578309569584, 0.7197858760014095, 0.7317555376116309, 0.7528341342541476, 0.626985217614823, 0.8136930379205205, 0.6029008091253916, 0.7436481276084952, 0.36758128984690785, 0.29320145351383775, 0.24053317031369448, 0.3695001214847581, 0.3892009929795478, 0.3224926625743204, 0.32268405875117345, 0.31447513410811656, 0.3782841431717886, 0.3421607625322477, 0.4144515810519187, 0.16811271537936223, 0.26216675785092924, 0.3949665905117198, 0.35681919349652724, 0.2711912670075338, 0.3461391886610311, 0.17309612437185784, 0.06189885408254481, 0.06817786905241852, 0.11599107498692396, 0.14765701112666685, 0.05455700243036321, 0.1178810278593726, 0.2548056643512837, 0.18229159578732979, 0.005181282718090929, 0.3479016979099284, 0.1840465963468625, 0.3451831732919636, 0.14474535498703012, 0.15390127430372247, 0.06371428914159549, 0.36612000731066696, 0.43396334517877044, 0.23556290556350346, 0.06316894670341078, 0.16076785030370122, 0.05392508011384911, 0.22562305168153785, 0.13509063085636697, 0.12919680606183426, 0.1216741247785188, 0.18103041672160214, 0.0088081681288249, 0.29981181617592656, 0.06709644649620583, 0.11643978721678983, 0.3246778381233265, 0.2690923261561433, 0.29035561497492945, 0.3017496104703211, 0.29017741577510714, 0.26533848344484146, 0.570124292792999, 0.6408673791164905, 0.6439932282056363, 0.5424621222473434, 0.5967749731150574, 0.6259720523276139, 0.6860848921789702, 0.593494584245686, 0.5555315165196524, 0.1201362536053775, 0.10488794534705526, 0.10350099007468783, 0.1228662247838711, 0.10857372528527265, 0.11268213082937728, 0.08696274716547359, 0.11292153075596312, 0.10405139732082858, 0.12557917297782173, 0.27408167073423406, 0.20051376887182293, 0.2537471842919642, 0.21960642587531887, 0.15920216636253448, 0.2023951369832968, 0.16911712280777047, 0.17557862138372238, 0.4317951732655627, 0.38055778428632314, 0.30406834161273855, 0.37489688028950263, 0.31566144222404013, 0.3639156346496588, 0.43940481398305087, 0.4690641762183234, 0.36945266964715506, 0.2962995439862328, 0.31716226625662824, 0.3036455914760806, 0.2181173518561157, 0.23519222601550238, 0.2884551217648955, 0.3345100965481056, 0.3021629747932979, 0.2799800942572499, 0.24383069920434663, 0.204922437975104, 0.20959365917307826, 0.23126085334836965, 0.24949275423798234, 0.2438948696787817, 0.23054872694517092, 0.21903991452389426, 0.20331685793231324, 0.20476508833855545, 0.6092355746620142, 0.21335539379384616, 0.23746295229774095, 0.2073729819781842, 0.21590103702787367, 0.48034942958282223, 0.24748345579350484, 0.21217867863651707, 0.1863431064633353, 0.6902149100010003, 0.15414695176511772, 0.9176484995149864, 0.20065701392642843, 0.19651452123101132, 0.16762081438722964, 0.19325635126535012, 0.7902370955703986, 0.7719452501210666, 0.20685717320232322, 0.624736404435289, 0.7132111249032875, 0.2107157882226639, 0.6966467970273518, 0.7979985137277855, 0.2041344925411135, 0.4652995023423234, 0.19082470668695484, 0.19189983518708253, 0.19088748672167544, 0.1854444350420369, 0.18871088383727797, 0.18207652928824092, 0.19130920851567323, 0.17614930302569975, 0.1897713642558353, 0.07181254650304347, 0.08264133055211731, 0.07497407518827004, 0.10733575077248392, 0.08033244580547538, 0.10594052103676199, 0.06364442901137224, 0.09338498213466173, 0.09497810344092572]}, "mutation_prompt": null}
{"id": "98c360aa-ad07-4ba8-b3c7-180c10c8c7ab", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.9\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.03  # Slight increase for more dynamic adaptation\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.2, self.inertia_weight - self.adaptive_factor)  # Linear reduction to encourage exploitation\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.45, min(0.65, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Adaptive Inertia Particle Swarm Optimization with Enhanced Stochastic Ranking refines the balance between exploration and exploitation using adaptive inertia and stochastic rank-based selection.", "configspace": "", "generation": 82, "fitness": 0.37005820349914814, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9034237244458475, 0.9037584209228224, 0.8983071244238622, 0.8581101815488247, 0.8901573393513483, 0.884791546409855, 0.8531565356812552, 0.9105522597155385, 0.894263581120047, 0.766708431567606, 0.6798672000831312, 0.6954508974653718, 0.7298299739060163, 0.6108117316774783, 0.7024620040337957, 0.8140970538666119, 0.8061238154288841, 0.679963242969517, 0.1436643922872769, 0.12136249351430672, 0.1620344308814219, 0.26248991635093544, 0.14345461793800118, 0.4173098017126705, 0.1554753724584933, 0.1420281661449293, 0.35361147760576506, 0.11912533021253746, 0.13048530935345548, 0.11764891732416816, 0.12179453949189789, 0.22211532301103376, 0.3539357300811742, 0.15508606568102623, 0.11177998066667327, 0.14022735003137443, 0.9816686742407157, 0.9774147420877133, 0.9674258258391374, 0.9686751114384512, 0.9505851796381823, 0.9743240469176847, 0.9779033806066458, 0.9523421574722182, 0.9872213712312529, 0.5296868877538778, 0.47279310028649923, 0.2856026793826534, 0.5304675420647607, 0.49026795846479676, 0.5720474130517605, 0.5252105786050112, 0.5301296747085422, 0.6002436732033547, 0.7854370310269863, 0.3278928309635617, 0.7194465687194141, 0.7282656073454645, 0.7520199751737361, 0.6253197658680949, 0.813698548260319, 0.6030238720880947, 0.74292601587685, 0.37329157864268814, 0.3002074395344574, 0.23708820878846104, 0.3718020870275651, 0.42608962689919005, 0.3224926625743204, 0.31560203824179667, 0.3150465205889963, 0.3817186505101827, 0.34798052059658624, 0.4144515810519187, 0.1809248627071549, 0.26590132892500484, 0.3967880239708622, 0.3569982885024101, 0.2676503874546885, 0.32860561917849695, 0.21847077852124752, 0.06189885408254481, 0.06817786905241852, 0.1141091135063933, 0.14658801696645662, 0.06697728397650848, 0.1178810278593726, 0.2548056643512837, 0.18229159578732979, 0.005181282718090929, 0.34656261280073464, 0.1852779985842392, 0.3474019361518985, 0.14235529144560388, 0.15397708994096337, 0.06234066315632447, 0.3660234589181418, 0.43782547114279025, 0.23538023049924173, 0.1380864727328337, 0.2087842740713972, 0.11651152868454884, 0.26683013309801473, 0.16464041016121678, 0.16778413560688532, 0.1321793523676411, 0.43138172570118505, 0.0784679366273684, 0.3088215127646372, 0.07611036904361246, 0.1887675760565649, 0.33719609229261005, 0.28614956843054207, 0.29062893964852954, 0.3017496104703211, 0.29077017460781684, 0.26938034165309754, 0.581293886964336, 0.6460403003414191, 0.6596992086876476, 0.546908900490791, 0.6175822772456299, 0.6289543951295054, 0.6981471070116303, 0.607292476030546, 0.5756373932532551, 0.12011780791582183, 0.10100040007648536, 0.10097629324424795, 0.09400895566275869, 0.11027034359639998, 0.11269413237559711, 0.0919585338051433, 0.1120460572351234, 0.08671826394780946, 0.1790120185838936, 0.22899521954875135, 0.2548740971725879, 0.19762903133886578, 0.44747717734369563, 0.21928367911123148, 0.19376569256816, 0.16475489513727737, 0.2165324517491617, 0.43171795723132234, 0.3653027196323859, 0.30419939127898366, 0.3695763276191587, 0.40185554406007784, 0.3639133033878539, 0.43941056223472674, 0.46926385067001464, 0.36940214344338207, 0.296279833275954, 0.3331025314343862, 0.2996029856018084, 0.22298789981627098, 0.2294491377483311, 0.2902334719706303, 0.3347287013898197, 0.3013079809770469, 0.2799812661269505, 0.18827352267385788, 0.2514835857777711, 0.21016160221241786, 0.20474821155648815, 0.21571690599670923, 0.20177025594709008, 0.26035986098071084, 0.20588413024198293, 0.22168264289601158, 0.19841408708059594, 0.6096387503440224, 0.21185434161836658, 0.23526710051167943, 0.20644920421075652, 0.21390070042893372, 0.4838944524996702, 0.2482397422809689, 0.21173211807739867, 0.1879017236334608, 0.18778004807056037, 0.15414613980695036, 0.956897140743954, 0.20121392243975, 0.1941261163337289, 0.16791161675840705, 0.19518014594462474, 0.7899329081720374, 0.7734450628566412, 0.2041591008315511, 0.6677505786231035, 0.7167132422091251, 0.21128485517056073, 0.7549203578545154, 0.7968666609013211, 0.20448736878775686, 0.33204680508486883, 0.19731477647685047, 0.20695650437679636, 0.1900162567265965, 0.19530861515229825, 0.21140573917809846, 0.18336402269054908, 0.2026087704340923, 0.1934808061114801, 0.19255482820972136, 0.08768464975511214, 0.08611106686446313, 0.07307454702546479, 0.11552783308613723, 0.08550950597039553, 0.08558507107970037, 0.10161218991243093, 0.08342801084945273, 0.07089683853523254]}, "mutation_prompt": null}
{"id": "4dcce509-939f-4cc6-9af7-fc20fd233e26", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.7, self.mutation_factor * (1 - self.adaptive_factor * 0.5))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Improved Particle Swarm Optimization with Adaptive Mutation Factor for Differential Evolution enhances convergence by dynamically adjusting evolution parameters based on progress.", "configspace": "", "generation": 83, "fitness": 0.3717236313055651, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8819890438712508, 0.9109894083093829, 0.8712417235658755, 0.8695826078946308, 0.886455020026294, 0.8858520638298214, 0.8978551405708306, 0.8664113055486814, 0.772748948344216, 0.755983778531301, 0.7675536924499617, 0.8018095551308935, 0.7666436214820544, 0.790871650951011, 0.7377204112109694, 0.7995349667835496, 0.7858138879162586, 0.4358326493080217, 0.14571254206203355, 0.4375631113164462, 0.11948520041200572, 0.14396176894592538, 0.17034545626682351, 0.1394824673467716, 0.12789684902220233, 0.575653940894854, 0.13935270348626017, 0.11832203444059064, 0.11437869311102988, 0.14571292527623614, 0.13505086880482864, 0.10945688911196771, 0.1308783259732239, 0.17022219984265174, 0.12888645213945327, 0.9674794769339503, 0.9515511212976302, 0.9807861711214999, 0.9543212222313443, 0.9607146988443522, 0.9718234345057456, 0.9641652049721955, 0.9444348230685056, 0.9854258741081664, 0.7023309699573171, 0.5273223813912666, 0.5109769412004227, 0.47026233315023946, 0.6063464261856655, 0.5268756305259633, 0.5890337691323779, 0.5908195731915004, 0.5088400888247671, 0.33342248711978695, 0.7561887121637528, 0.8090890258457506, 0.26908631763008384, 0.7704887757549412, 0.7880717874478956, 0.23112810484316793, 0.8426255616384672, 0.17636971058769702, 0.2876094004429397, 0.17929758936203033, 0.2032615534375184, 0.2065113520541797, 0.19520367319953558, 0.18342279350740076, 0.4838817770533904, 0.5863447952704003, 0.2505325877211896, 0.19634497619456748, 0.08950367824189653, 0.1953146121273156, 0.1954525168957476, 0.1827473356400081, 0.7245831224339554, 0.23582840003145478, 0.2362426109461232, 0.21316057286892864, 0.044226463320674925, 0.000309152416303915, 0.06672569809983597, 0.054535336577982485, 0.07306954827510181, 0.047019099168765566, 0.04686036611091182, 9.999999999998899e-05, 0.13867306623305464, 0.2729702300560871, 0.16010348335450986, 0.23816719951947185, 0.23581060432671241, 0.1203314282128567, 0.033910595515249, 0.19523576775920248, 0.35154649742174193, 0.20189340061912509, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.2033329183719722, 0.19167681395853164, 0.2321151968220614, 0.20052753187868633, 0.26654066453248537, 0.23708047197368676, 0.2669627918856432, 0.24594224417687183, 0.3054692936952069, 0.35279727696009644, 0.38580768917692765, 0.1759873415319072, 0.3060747713079427, 0.18872164571402594, 0.555287217181877, 0.6444764481268612, 0.5020251856895833, 0.621297176354711, 0.5805060723435105, 0.6311836571238699, 0.6499550742710987, 0.8052884424053111, 0.698004515988643, 0.05809166177889802, 0.10088951089609077, 0.09855308789680606, 0.08549504734906566, 0.09313626077346704, 0.10442222295928116, 0.10987319906551929, 0.1284919520513842, 0.11270607160503587, 0.2123193704476034, 0.27439885178448387, 0.33807395590515776, 0.25343873978145315, 0.21960642587531887, 0.1319122327607294, 0.2024202871063937, 0.13466154952666132, 0.16873435781167445, 0.44658331917980654, 0.5139201217449616, 0.44485251165297846, 0.4586835099571327, 0.4706106708993467, 0.5016646907058572, 0.5571698964235914, 0.2854653028817232, 0.5202393021518366, 0.35787722263298005, 0.3361123537735522, 0.34961111648270493, 0.24760239033406528, 0.3218083207235557, 0.21127432246005318, 0.2704808336054224, 0.42740956984950806, 0.42760220271173166, 0.20748544274728742, 0.1690064406094436, 0.2134023195368595, 0.24155864263453064, 0.27510760089407127, 0.23238219958954698, 0.23550008379797316, 0.21642062825792163, 0.1864744503060689, 0.7268202383791896, 0.234534026147313, 0.7358869645352085, 0.20892030695458264, 0.21808776615629544, 0.2143063697826969, 0.23262748993017235, 0.24426902676439244, 0.5789959511738205, 0.2096436145144338, 0.8735344766883196, 0.8012212955190309, 0.9177194257391721, 0.20065701392642843, 0.17033110843294474, 0.16887928919725637, 0.8725330993082474, 0.16476715665917907, 0.7794949642735238, 0.20756400625892324, 0.7317855974854567, 0.3469035670182674, 0.21072029340266463, 0.21016330315882992, 0.6888311306496906, 0.15320876105018633, 0.46457481940335477, 0.212160363550156, 0.20698598863859252, 0.18261428782950628, 0.20815079358032373, 0.195468521121006, 0.19417193090786522, 0.18478894330201368, 0.18589449122816792, 0.1899255382080416, 0.0703341416166644, 0.07606677307618903, 0.0753328917164281, 0.0951269066282755, 0.07143306051503273, 0.09712058511363741, 0.07377222619357304, 0.11056368710554221, 0.10546671690644327]}, "mutation_prompt": null}
{"id": "0841d698-41c8-4fd0-a66c-5994aa41ee63", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            # Adaptive mutation factor and crossover probability\n            progress = self.evaluations / self.budget\n            self.mutation_factor = 0.5 + (0.3 * progress)\n            self.crossover_probability = 0.9 - (0.3 * progress)\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introduced adaptive crossover probability and mutation factor tuning based on evaluation progress to enhance convergence.", "configspace": "", "generation": 84, "fitness": 0.3248053614083465, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9106237206820565, 0.8737494799721636, 0.9109894083093829, 0.8871131316721431, 0.8595398205325245, 0.886455020026294, 0.9169629300815185, 0.9040044430061207, 0.8600169978912255, 0.7710617897321732, 0.7092074620427256, 0.7653346020316798, 0.8046446777630131, 0.6775933359473607, 0.7894321245870932, 0.8106896833132315, 0.7833863509551687, 0.697362335707624, 0.15263924914629245, 0.15362995354885867, 0.14020821581097043, 0.5980109883618776, 0.11483202445561513, 0.1349940519542786, 0.6716869005760583, 0.07913620479539418, 0.07315965685227088, 0.10701880545263143, 0.1343296373735522, 0.06714318125238283, 0.5722841023710521, 0.08745163339417339, 0.06908328274240916, 0.1389123906732359, 0.10222098056397266, 0.06813280934402155, 0.8865404674649614, 0.8365008728679231, 0.9439213509530524, 0.9351858487181739, 0.8286878818023199, 0.7770578466289457, 0.6877624025182794, 0.7963610383942981, 0.9243234635971815, 0.6872486641787656, 0.5166750382494825, 0.5117995879329847, 0.43138737568417795, 0.5745946704848925, 0.5259817612749609, 0.5895675235182714, 0.4676730856845428, 0.6182535688245878, 0.22830818928967778, 0.18090450783770906, 0.3550646683677119, 0.2694452304255508, 0.09352488158232752, 0.27576760802906397, 0.36335189543654656, 0.1427285573660403, 0.2318354209320399, 0.2885272191114633, 0.17860609718735632, 0.18138471978684245, 0.167728008129011, 0.1801663882091742, 0.16201616312011158, 0.4838817770533904, 0.13564289875503222, 0.18409208089756723, 0.19986760835099104, 0.15225875005512568, 0.1953146121273156, 0.1954525168957476, 0.15088279940129468, 0.2851631679268952, 0.23582840003145478, 0.22186300066402687, 0.18234243756241975, 0.16172945923590065, 0.000309152416303915, 0.0015318332322743489, 0.07677966206413478, 0.0761689086096059, 0.047019099168765566, 0.04686036611091182, 0.03469535355349673, 0.00902348613571935, 0.11461347332732408, 0.12195365872514108, 0.46569562298481026, 0.2559636731964867, 0.07984564900769997, 0.07200710293230517, 0.08716662167411582, 0.16117029959467433, 0.07523596061473525, 0.15690685969269103, 0.15915588287582982, 0.2383672852677582, 0.17534870789251322, 0.25388711437017153, 0.15874184950653814, 0.16393934130177445, 0.17319220504216915, 0.1459350908827608, 0.11987248252279059, 0.09848522948103822, 0.234285719354432, 0.15264074446056153, 0.3371029039592687, 0.19945495769988497, 0.17848246657509226, 0.120336569476035, 0.3009977728884623, 0.49140358643835214, 0.6011866897024374, 0.4823988511161167, 0.4897243906369616, 0.5128544100081318, 0.4747372297772796, 0.5121483913915987, 0.5454781136964981, 0.6162165788482439, 0.47232355527293823, 0.09604543681459166, 0.1639392821746949, 0.11201918441467273, 0.11393842949774557, 0.14773403889167003, 0.13129333671732635, 0.10832134735304466, 0.11270607160503587, 0.13320991965277296, 0.27408167073423406, 0.19356477780321923, 0.25343873978145315, 0.3129104332229934, 0.14386699554594473, 0.20246115260065223, 0.14650657930994382, 0.1670003066293102, 0.2411296995275689, 0.5504963550014568, 0.22701674360243695, 0.44359807377816174, 0.34356624245108736, 0.4972327670795309, 0.19666659335498748, 0.3033765276043914, 0.14507956344588402, 0.271534323427019, 0.2596623021544917, 0.3803226821711949, 0.4449309516597878, 0.32581286900798034, 0.3124950337040293, 0.12792777949795453, 0.4032477916418121, 0.1607586977958948, 0.21055855698342807, 0.21706068820641955, 0.2198891873616423, 0.2415297120898896, 0.2751995543010888, 0.23249270547859524, 0.23542435291166008, 0.21644725291518907, 0.1896234551893593, 0.1655965727336417, 0.794292768173289, 0.2115891595027144, 0.2075074148089524, 0.20292363847528028, 0.20802165079139323, 0.19667544778054302, 0.22918926534272854, 0.23755179099026735, 0.18635947655368013, 0.873086882074458, 0.8617724064115249, 0.9177744214201318, 0.20065701392642843, 0.7086196037193252, 0.1722824426734897, 0.16346901235703104, 0.1566073498685342, 0.5911833438454489, 0.20986269800563673, 0.5672049110111916, 0.20716597601141273, 0.21125598245622113, 0.21075265241418806, 0.57044434720875, 0.14322760603798468, 0.4641942987760981, 0.21191317313259628, 0.20692667253272912, 0.1825108007748395, 0.20824719912796807, 0.19473330647492415, 0.19406604988428988, 0.19121678039777523, 0.1863339481167804, 0.19002720121268135, 0.09031580929372762, 0.07793437400935876, 0.08519929053337838, 0.09525975915729668, 0.0864829848614268, 0.09706915079228096, 0.09012226763524211, 0.11057537917284899, 0.10574981967513408]}, "mutation_prompt": null}
{"id": "23d60524-d172-49e2-a2e2-5d8c3a8fb3ca", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n        self.mutation_factor = 0.85 + 0.15 * (self.evaluations / self.budget)  # Adapt mutation factor\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation factor improves exploration by adjusting mutation intensity based on evaluations.", "configspace": "", "generation": 85, "fitness": 0.36786109239125286, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8741093181971613, 0.9109894083093829, 0.8603843108353142, 0.8576240643341629, 0.8864786279608031, 0.884293502374892, 0.8974784242400963, 0.8581011023618226, 0.772122433569706, 0.7279370832384368, 0.766041416019678, 0.8020675242332338, 0.6457865117063998, 0.7894321245870932, 0.7372996525073265, 0.7796755075592622, 0.7152525446046609, 0.1516987912523522, 0.15510120142272021, 0.14850960989593986, 0.4202565237801419, 0.16430402986266568, 0.16240667911283213, 0.15116555022964218, 0.15386988588107708, 0.16448716142564934, 0.1648793114448941, 0.16304411717425282, 0.16822071852182852, 0.13275754542760843, 0.1480056967140586, 0.1052011909594972, 0.14243864399526351, 0.31866112978561023, 0.11488658806523266, 0.9816687780536049, 0.9616230489121951, 0.9675191389429353, 0.9656208378330692, 0.9531131617439422, 0.9758808972896357, 0.9680031791229121, 0.9559559248044822, 0.9872225873376961, 0.6872486641787656, 0.5291773118289971, 0.5112504254995127, 0.49228053184472487, 0.5775030740101166, 0.5311308587056487, 0.5890337691323779, 0.5580352870318253, 0.5547058109890676, 0.7224529927910036, 0.7557129752042888, 0.6878458715292015, 0.7918656081265643, 0.6497814680748984, 0.27648975744295345, 0.6998086113877677, 0.7223287369036596, 0.725780282928266, 0.45822377112216695, 0.17424352579195734, 0.34639851206270256, 0.3800061925006625, 0.4074120763333148, 0.15850682675017014, 0.5134198551815992, 0.21034501837454678, 0.35617116909239854, 0.19634497619456748, 0.13867697076357233, 0.1953146121273156, 0.2969987480598488, 0.439273543251427, 0.336019734393066, 0.39054963402970133, 0.3077947888639947, 0.2947396029907613, 0.06518464806541613, 0.0646527229012932, 0.11424304554124942, 0.0664251346938205, 0.10351993404812443, 0.16453412045652627, 0.08201936779137176, 0.12215880416983949, 0.07233798273987613, 0.1444254846225589, 0.1879851164967532, 0.3119069228553376, 0.14592028238747023, 0.06878272975855615, 0.03127548347041831, 0.2677478438371037, 0.4759508830904364, 0.31494094589505506, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.24216533814864383, 0.1265098968836753, 0.19813174801269617, 0.16393934130177445, 0.17319220504216915, 0.07092797631311754, 0.24384495433570597, 0.08685656041890522, 0.27169980140333905, 0.2685338862030967, 0.3360456441881431, 0.2654073316623955, 0.23249895613806415, 0.2298021836089994, 0.23942775457956744, 0.6772806244963125, 0.6215306541939506, 0.6824423889151733, 0.5872167119498353, 0.5787484843865858, 0.47437272819353216, 0.6231819950746735, 0.6049803240629525, 0.6574305397752045, 0.06687993821627192, 0.12328036963953981, 0.061857816081477335, 0.262745616009848, 0.08879947851116143, 0.10024614942009047, 0.10872895470693456, 0.10640068552246562, 0.11270607160503587, 0.17751204297855727, 0.27408167073423406, 0.19356226868511428, 0.25657292824422473, 0.2203038107282238, 0.14099762174682784, 0.2023858730936593, 0.10784000677490169, 0.2966709029701322, 0.3967875787636297, 0.2954729575751802, 0.3623508897844233, 0.35220177447719725, 0.38153103323566406, 0.3852806080378184, 0.4768359843349278, 0.38402377097483753, 0.4135829200164701, 0.27023876838009053, 0.2672427295431151, 0.21659132303160278, 0.2866438108862187, 0.30007088518825376, 0.19808581081847654, 0.2576762634092088, 0.29296556620130865, 0.2793820500274874, 0.20662672500122503, 0.2147187897517311, 0.21391036143881426, 0.24151185147486365, 0.27504637309180335, 0.23230983832817043, 0.2354351626660366, 0.21701012688310228, 0.19515872926953692, 0.43220133608655964, 0.21649385789387499, 0.2115891595027144, 0.5005164075924877, 0.21741171852246366, 0.45322916282016, 0.21038336464532903, 0.6255566863617542, 0.21409081292752208, 0.20720849019487841, 0.8725905963913259, 0.8263200960002105, 0.9176486187333662, 0.20065701392642843, 0.7594240232399335, 0.17461621214168277, 0.18767586588277974, 0.15339161925992062, 0.7834810290924518, 0.20730382187015717, 0.5675280072829945, 0.2072694590497981, 0.21071578822220383, 0.2101589685785783, 0.6676992648998694, 0.18577742309639278, 0.46433507754298686, 0.2121171896768349, 0.20693211190728567, 0.1826686835169702, 0.20828470560535628, 0.21750002552660386, 0.19985049365491525, 0.18879326250823703, 0.18934022734109857, 0.21445965451421034, 0.075381581344101, 0.08082267978858126, 0.08621506665891887, 0.09553219768048327, 0.0789720316079704, 0.09711166968786333, 0.07778907524589573, 0.11054701747281448, 0.10547071081691772]}, "mutation_prompt": null}
{"id": "11473b9b-0586-4757-a139-011c76c5125c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.mutation_probability = 0.1\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n            # Apply memetic mutation\n            if np.random.rand() < self.mutation_probability:\n                self.particles[i] += np.random.normal(0, 0.1, self.dim)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with hybrid mutation strategy combines PSO and DE with memetic mutation for improved exploration.", "configspace": "", "generation": 86, "fitness": 0.3644321315374639, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8432018148948494, 0.8458049046144553, 0.8397105729666052, 0.8278295535543647, 0.8334556773716856, 0.8570914673055743, 0.8308219732929474, 0.8514877623914591, 0.8414417724851931, 0.7186922784985333, 0.710205863337774, 0.6991664198013616, 0.6869572468019602, 0.709567252041424, 0.675588131654289, 0.658749877255842, 0.7308460334238784, 0.6052366808183774, 0.15020470292258248, 0.15101665374391138, 0.12720222581149898, 0.4023100130671371, 0.3440578019696402, 0.5009187965026618, 0.1332067003563978, 0.12776073850117886, 0.4180459104472476, 0.14245738888802095, 0.12193611756902012, 0.1637047929884875, 0.14465681296171473, 0.1421356736723034, 0.11618686975244075, 0.14709638235449352, 0.19128563982713198, 0.10824240066937041, 0.977405054893623, 0.9638595915221212, 0.9633198513747059, 0.9705232672034602, 0.9372538570447897, 0.9379259681106547, 0.9818957357624531, 0.9604610215488325, 0.9510648917531656, 0.5331049277610791, 0.5494250801270695, 0.6158867283818519, 0.5594275083902424, 0.5771218118285586, 0.5539353804126559, 0.6301055051584251, 0.5333404754435598, 0.5247555196690422, 0.41226637493463214, 0.728230095416699, 0.6767248060588855, 0.7425587595134914, 0.7568696637293346, 0.7706697189171283, 0.7233109558913142, 0.7293481389445613, 0.6046540824415987, 0.2804452929039839, 0.48265773261183353, 0.3190049339478228, 0.28145661322142723, 0.3086075350718631, 0.39758931669942343, 0.4120471827382446, 0.4580367766863266, 0.4244301541048613, 0.18229018177429857, 0.2816932363563237, 0.21713113468426648, 0.40660964969848146, 0.5372556106882941, 0.282572582853987, 0.2686645076332128, 0.5162804753561052, 0.2708102599893014, 0.2803513636184386, 0.09274411039559471, 0.011915823559125571, 0.05424769911892002, 0.0717733573821866, 0.024722410158358077, 0.07287580048442865, 0.18916005742391073, 0.027452676077841187, 0.11793807084544083, 0.20780735171489007, 0.14188045602999988, 0.06784393193839455, 0.33482687788725063, 0.14901524768905805, 0.2653015076080676, 0.22208851791161965, 0.3700244157817032, 0.07908059600906758, 0.13154100503817556, 0.14590565578500936, 0.24445912141694714, 0.08338682450764734, 0.09134628577215209, 0.14734274110357037, 0.1585733881259328, 0.09616008492674066, 0.2646377899700585, 0.25795357392594964, 0.2310323851042586, 0.34517013423293375, 0.33395585014075446, 0.3047434806188709, 0.26150559193118705, 0.24171681624696983, 0.24358095620321163, 0.4674327650807881, 0.6158831494830863, 0.5545745954302981, 0.5743218255055778, 0.6243947815260016, 0.6098361898085234, 0.6002750414382994, 0.6063985979063745, 0.703298670310271, 0.11471075122537955, 0.12408070313863451, 0.05154667972654392, 0.12019750842451737, 0.10183118891820775, 0.10662785807215602, 0.11448936170203838, 0.08988268390782339, 0.11871833664649112, 0.1903758437469023, 0.16417176346731865, 0.2652713291456974, 0.2261863157390982, 0.19462684440240496, 0.18682273898608415, 0.2050285346709313, 0.32362147674668673, 0.3293671451073936, 0.3087016173652509, 0.35666820578243774, 0.23153058340712973, 0.33272876172999877, 0.3567397513554129, 0.37945433332219014, 0.3064825109202032, 0.4063836561039541, 0.38834649411236066, 0.27421554800487313, 0.37300088738995507, 0.2726781750497499, 0.27407092178383696, 0.30953528430499877, 0.3228200373751229, 0.33601555822609375, 0.3025261665609026, 0.31105605496842226, 0.21502075185155112, 0.19942679000599473, 0.22735387101317672, 0.22175226184460994, 0.23560179481516463, 0.23905652081740203, 0.22389920183712264, 0.2455461641358656, 0.2027980178521953, 0.22404442360824084, 0.21656512063334998, 0.5796623534300428, 0.18576990403636795, 0.20688091350532467, 0.24666100691582415, 0.2153011534067989, 0.6562663064542484, 0.20989447635999336, 0.34626852412328923, 0.8716577044519899, 0.808662302518273, 0.8789224257115148, 0.21113293023799717, 0.16664565183376912, 0.693397342853258, 0.1674863258138939, 0.20260436440487006, 0.7840471049548486, 0.209246243026583, 0.5682391625468788, 0.20719118558605054, 0.1662017872220688, 0.20843960917233362, 0.14855928754351533, 0.16161342916076538, 0.3859650111872297, 0.19764831043962694, 0.21127317671655343, 0.18294131791678225, 0.19692728319675212, 0.22480900139909865, 0.2273083434586486, 0.19744435667388827, 0.2035363096742625, 0.2142325988352748, 0.06576192295304606, 0.07152122705985076, 0.07908892293999925, 0.09365719097784364, 0.08922597461158444, 0.08432561767226199, 0.07992846912151508, 0.08935026294608273, 0.0882806621458232]}, "mutation_prompt": null}
{"id": "fab86c83-f429-44af-888b-c1f2f38023d2", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = min(1.0, self.mutation_factor * (1 + 0.1 * self.adaptive_factor))\n            self.crossover_probability = max(0.7, self.crossover_probability * (1 - 0.05 * self.adaptive_factor))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introducing dynamic mutation and crossover rates for Differential Evolution to improve convergence speed.", "configspace": "", "generation": 87, "fitness": 0.3201001159390105, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8743739482950872, 0.9110266508626658, 0.862840149644329, 0.8593228931697247, 0.8869472509381315, 0.8846023454808117, 0.8974954349421305, 0.8589594538267648, 0.7702918373111398, 0.7181071541364852, 0.7680070403200836, 0.8018095551308935, 0.5248472197897787, 0.7894321245870932, 0.7372996525073265, 0.7773379968704672, 0.7121095362689058, 0.15882491538201415, 0.478590960072497, 0.2497650676115043, 0.180266727734115, 0.13855381180170956, 0.6007189764459935, 0.15767477742753377, 0.18549709235703637, 0.17737288672556684, 0.11561654271254995, 0.14629858139990715, 0.13454960940126748, 0.14276382000169274, 0.23568505882087187, 0.14595435524692235, 0.07005825519114628, 0.15012793444407058, 0.1413704630057575, 0.9712816870746609, 0.9716675132684234, 0.9673048839893279, 0.9429267542272199, 0.9466498319614669, 0.9762811683828577, 0.9554748449954232, 0.9511489453304318, 0.9872286213983763, 0.6872719891585758, 0.5197851768969206, 0.5112940026229656, 0.43364978467998094, 0.5746969164878075, 0.5264192899720844, 0.5890700699260544, 0.46891832916280307, 0.5088016336302585, 0.22240469278161967, 0.16630873232662746, 0.26756674944474734, 0.27004965893212196, 0.2415036858489258, 0.33025495575967256, 0.3104992636400028, 0.6229695945377948, 0.43829571351420515, 0.2876770346927726, 0.17424352579195734, 0.19328662650922435, 0.2286244546783821, 0.1797966284037943, 0.2564256573229362, 0.4838817770533904, 0.2079114240815485, 0.22065708915985538, 0.2181979055533836, 0.2581357147724991, 0.2142987422030378, 0.19965347020758006, 0.18776000877137178, 0.21932585090303003, 0.23582840003145478, 0.2206737800265821, 0.25044523082801484, 0.041773787296476406, 0.04184941755232052, 0.0015318332322743489, 0.04275438628578454, 0.07306954827510181, 0.047019099168765566, 0.04686036611091182, 0.06705929263272736, 0.03882524946085464, 0.18189472386841588, 0.12391461925083436, 0.1039040333500687, 0.13212244037583243, 0.08411063659489337, 0.06646534006590754, 0.14371288869324472, 0.15734692894460645, 0.12285130291047008, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17534870789251322, 0.11201616813784365, 0.15874184950653814, 0.16393934130177445, 0.17319220504216915, 0.07092797631311754, 0.14213378457863257, 0.1291169795329019, 0.2122785188597639, 0.1776288814224547, 0.3356479235447454, 0.1844469101303614, 0.11054617985526216, 0.1411954341540066, 0.15495535182581677, 0.5155486736068693, 0.5157650269578966, 0.5318808587679362, 0.4901239884670707, 0.5376149575657458, 0.5094410803474642, 0.5503857978790199, 0.6154064354679812, 0.5618435407877811, 0.06233656824636036, 0.11396950119232863, 0.08773930956038933, 0.08547256754218524, 0.09076032480335139, 0.08821926401563795, 0.07745160160953679, 0.08576720226796353, 0.11270607160503587, 0.24560915586577758, 0.27408167073423406, 0.2911928478590394, 0.25358758343212495, 0.21960642587531887, 0.1369704536992371, 0.2024005202734389, 0.1589746669643235, 0.17196951230448654, 0.3116329303496941, 0.2901975279194672, 0.252294419748714, 0.2775075056634587, 0.3435268861886701, 0.3031628349990939, 0.30921417529955664, 0.29842787116056857, 0.3471523198173514, 0.23466962244317335, 0.15708652615724583, 0.2113035188615634, 0.21255515950924797, 0.25065729177434704, 0.17474201741992523, 0.2689022741848316, 0.21453647312552437, 0.19384224574232967, 0.2066541015003186, 0.18686177179620989, 0.21329478777631516, 0.24149801451404085, 0.27504692432233224, 0.23235439400655666, 0.23542435291166008, 0.21726818000577863, 0.21494949445854938, 0.19482915878021367, 0.33043805850079777, 0.21746495743501715, 0.33635122471790624, 0.18958415124770367, 0.29420737044151013, 0.2526400313711621, 0.20405792364890996, 0.30886556272146704, 0.18634190149623142, 0.8725960768245191, 0.15836953010727028, 0.9176492064369759, 0.20065701392642843, 0.15973465636159911, 0.16763477781950964, 0.19350016996816843, 0.5220213491593884, 0.6302371457271818, 0.2086697900451676, 0.5675115359747132, 0.4619667860811453, 0.21071578822220383, 0.21068626996923023, 0.4679602618313915, 0.115105506476192, 0.4641661095839208, 0.21189713727069714, 0.20694154917248597, 0.18245055427865142, 0.21122196187344777, 0.19504189399960858, 0.19751781579501881, 0.19050548688389568, 0.1918513232499376, 0.19825005615130353, 0.07033586808923942, 0.07578774787371023, 0.07976017606731434, 0.09512621074360117, 0.07959059690199188, 0.0970338757370568, 0.0764724376497441, 0.11056102912151655, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "fedfecbe-3d8c-4283-b74e-b224877c64fc", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = min(0.9, self.crossover_probability + 0.05 * (1 - self.evaluations / self.budget))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with dynamic inertia weight adjustment and adaptive crossover rate for improved convergence.", "configspace": "", "generation": 88, "fitness": 0.36508175686245975, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.87423751900787, 0.9109986092731056, 0.8548442134557429, 0.8570103992422998, 0.886455020026294, 0.8829976206131658, 0.8987327398629932, 0.8580689245074431, 0.7702746582515572, 0.7244277142958544, 0.7653659780921219, 0.8018095551308935, 0.7041169458949934, 0.7897673944543593, 0.7505110652891541, 0.7768399699395862, 0.7055117061543774, 0.22369279975391132, 0.14416471790961372, 0.13041003592676226, 0.08270468975956102, 0.1082848521224099, 0.15753936963683024, 0.29492922656609666, 0.30060737281712036, 0.12849501943291075, 0.1511788334451336, 0.16072864771751283, 0.15288157293509153, 0.10524190361285868, 0.13151465907153503, 0.09787711343734007, 0.11899561463316399, 0.11722086274991128, 0.06048663734085691, 0.970489310402837, 0.9540635540076977, 0.8090925160676943, 0.9644900357241846, 0.9546863454358936, 0.9446862211978646, 0.958925812335707, 0.9488166311716077, 0.9811054553323713, 0.6876875923578564, 0.5691537181139144, 0.5795357765050426, 0.5138476427928873, 0.6105075382497331, 0.5630357550319647, 0.635248420071708, 0.46773178825210293, 0.5536289492159647, 0.683475627584013, 0.7648306253749565, 0.20733186921387525, 0.2701469742040594, 0.19700411959375252, 0.7509161120526087, 0.7618345535421105, 0.8152128817874598, 0.22611979474024568, 0.29345644669239423, 0.28860101952578066, 0.6933802962526615, 0.4501223218392705, 0.27107610576881047, 0.4928348263135952, 0.4838817770533904, 0.4581601777849166, 0.3697026262665657, 0.19634497619456748, 0.4733457328671622, 0.1953146121273156, 0.44155667028969614, 0.34021882959765737, 0.5568981236232913, 0.23582840003145478, 0.26557410199056475, 0.5257372826984243, 0.0955590906148085, 0.0994736430279316, 0.121995850637721, 0.0971748221251244, 0.08595352296018188, 0.12979895369894634, 0.04957549588550669, 0.2285336524936713, 0.09865092120721475, 0.2024620872764178, 0.17125704668156994, 0.1801909286979837, 0.13209228962956598, 0.11131404195526562, 0.05263163915119562, 0.34798459873365106, 0.32657822379187773, 0.0794064929189815, 0.15218715742806832, 0.2753886695484241, 0.238318145534119, 0.17534870789251322, 0.14100167659573903, 0.15874184950653814, 0.21941115564200453, 0.26286744312992283, 0.07092797631311754, 0.2382938134146464, 0.3231456712740445, 0.2788437014868772, 0.3438333298572621, 0.4075675746199846, 0.2490516545489535, 0.07943362150959943, 0.2291404746588136, 0.2299610467575297, 0.6825418088999649, 0.7591993987923711, 0.6468861497721226, 0.4917728487953148, 0.614425750814858, 0.5647944210965276, 0.5947239239905784, 0.6078884141909818, 0.6988997427161692, 0.16667962980936624, 0.13197324469739813, 0.08227969154187775, 0.12352302522407044, 0.11474681328600744, 0.11014221094403476, 0.10736120186485643, 0.08603001929277254, 0.16163814081873717, 0.20283804246200088, 0.27408167073423406, 0.19356226868511428, 0.25351618173148827, 0.21960642587531887, 0.17888233493509964, 0.2024917509499432, 0.16188937554629323, 0.1706015023191263, 0.39490848675110435, 0.3780864266934514, 0.3403238146833918, 0.36861355290881526, 0.40316631637351974, 0.3965638176594348, 0.46759391028979436, 0.38476586625891696, 0.4139001031700209, 0.296585186273278, 0.25394432924662047, 0.2659402824586683, 0.33903039651996547, 0.2511249604379385, 0.30272078281023274, 0.34615844109978844, 0.261011687621702, 0.3371530836166403, 0.20662672500122503, 0.1947192690361843, 0.21531730127111937, 0.24149801451404085, 0.27510438180134444, 0.2324301463185825, 0.23542435291166008, 0.2164498189195283, 0.18633280882245729, 0.49733252450345944, 0.20669556907573527, 0.21720917733566203, 0.38994818795873354, 0.20345085781728112, 0.20862355154120327, 0.22527035566403042, 0.21903636841620877, 0.20919438088585662, 0.20825967072662532, 0.8726685856947723, 0.7154850935914403, 0.917605511140932, 0.20065701392642843, 0.18492388353092648, 0.16763921195272524, 0.8546688486797934, 0.18250801526369087, 0.5911833438454489, 0.20968690155315806, 0.5668054282588346, 0.20662550014535797, 0.21071578822222936, 0.2101589685785783, 0.6843031253173905, 0.20381921858137186, 0.46493911767637985, 0.21159392529233478, 0.2074448149083794, 0.18234922156552935, 0.20847289599916508, 0.19481038607812362, 0.1971575888148801, 0.21407455318695545, 0.19173678071088873, 0.18385028177482476, 0.07092132259894679, 0.07416041823125963, 0.08221358138645996, 0.09528156667991639, 0.07144405559952305, 0.09721810689820654, 0.0719221573849409, 0.11061903919452432, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "3efa301d-64a3-49ce-84f5-02bd75367e4e", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.mutation_decay = 0.95  # New parameter for adaptive mutation scaling\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        adaptive_mutation_factor = self.mutation_factor * (self.mutation_decay ** (self.evaluations / self.budget))\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + adaptive_mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation scaling uses context-aware mutation scaling to improve exploration.", "configspace": "", "generation": 89, "fitness": 0.371002827447566, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.874017012429747, 0.9109894083093829, 0.8621824730684954, 0.8632886308479131, 0.8864576511446898, 0.8839791587262852, 0.89747841250029, 0.8584557291187112, 0.7702746582515572, 0.7329254245719182, 0.7678337230844842, 0.8026050830515153, 0.7267348819534312, 0.7899641453723459, 0.7388458196400962, 0.7769075843944087, 0.7203325252019928, 0.13761744870138615, 0.12754942760233456, 0.13045708225677843, 0.10754589221462485, 0.16000618916523923, 0.567960207721184, 0.16913091978489336, 0.4761052790977883, 0.5553233923521659, 0.1234228388643196, 0.13369917507606788, 0.10816868868531204, 0.14939910122581057, 0.150060177801833, 0.15437104725068218, 0.14531245863237474, 0.13683890552404354, 0.23731902641549618, 0.9816683572083107, 0.9774176972091623, 0.9673942841241948, 0.9686152813770426, 0.9517431045773755, 0.9743296521997613, 0.9779036713292247, 0.9660216102704133, 0.9872207187676153, 0.6872486641787656, 0.5393458686144089, 0.5114057992428052, 0.5348744009618338, 0.5928174886743199, 0.5401564986901728, 0.5890337691323779, 0.5853715085841849, 0.552786261062546, 0.8095821693612615, 0.2414392533138605, 0.6743352723227489, 0.6980936210029569, 0.7187095745835499, 0.27655800360290683, 0.23092904886588161, 0.755025604069533, 0.7260175449448298, 0.4894169111109573, 0.25304269955291203, 0.2967727510620336, 0.23768052203145895, 0.4080223004302972, 0.33862298249539413, 0.5603363414723644, 0.26012738073519115, 0.22292822008525703, 0.2682985034514178, 0.24933018539647123, 0.1953146121273156, 0.31389044084630646, 0.26936698432601514, 0.34904432728779167, 0.312736854840707, 0.37647727818896826, 0.3513076454576485, 0.14474803193976926, 0.062316269972975014, 0.12457909493064068, 0.06907890841775788, 0.1592601168957979, 0.06897830195196197, 0.23098380397511786, 0.34612673329999466, 0.12841801917712325, 0.2550521132577206, 0.2919312394276208, 0.31714033292798827, 0.14615256513558483, 0.13202611230078742, 0.033771291729381314, 0.19205659629940264, 0.2589277167852079, 0.07989183243758669, 0.15218715742806832, 0.15914902579803125, 0.238318145534119, 0.17737904711513186, 0.1384021213690868, 0.20087763648596224, 0.16398754075243194, 0.17319220504216915, 0.07092797631311754, 0.2539652902928913, 0.08685656041890522, 0.23662479041405282, 0.32095223743670065, 0.4085068553726795, 0.2981232587635131, 0.19109782065008196, 0.26193216113468687, 0.23086771320904176, 0.7318103500049586, 0.5952474348735046, 0.7058522711818154, 0.5684244231464428, 0.7264174075938563, 0.5727598711700626, 0.5841652702192408, 0.6055231246901758, 0.62156460945427, 0.06286698376490274, 0.08993400854211686, 0.08807631794127613, 0.09101639442047849, 0.0967290581734811, 0.07587217122788481, 0.11316842996056531, 0.11045959969544905, 0.11270607160503587, 0.14070707846257557, 0.27408167073423406, 0.1936284035076571, 0.25356621035065396, 0.24664731970970233, 0.19706779962402432, 0.20239721065151572, 0.22626399821027376, 0.167477758216101, 0.37592658116160427, 0.3386005796404089, 0.329692595322028, 0.2809722126964298, 0.4021506866936517, 0.3504732181081991, 0.27821866875724777, 0.44084374255721526, 0.45518567663969656, 0.2916493870091663, 0.29478899536842373, 0.28956581599656095, 0.2644007770436241, 0.28292945847754414, 0.30187750666222635, 0.2804488812668714, 0.3470486814963155, 0.3429833876071047, 0.20663150721039147, 0.17600256083472599, 0.22018747872238742, 0.24149801451404085, 0.2751559622324907, 0.232306413746726, 0.23542435291166008, 0.21645175873395528, 0.187439376163818, 0.5736800004942229, 0.6143249011497997, 0.211632519189895, 0.2243386636505318, 0.23482754881417733, 0.5335085892699483, 0.18232487222664628, 0.24770067479474678, 0.20176496462868865, 0.1863433275257057, 0.8727584488449013, 0.5965939025038752, 0.9176484189030647, 0.20065701392642843, 0.16115291878760107, 0.1676346509873301, 0.1964066478538884, 0.8550882532492565, 0.7019596690237152, 0.20683395875800092, 0.5675314704750272, 0.76822630021594, 0.21071578522317858, 0.2101589686233858, 0.476967032902482, 0.2039483282116058, 0.4652306166418836, 0.2272330319663769, 0.20709293479012603, 0.18761741935679144, 0.20816695926373108, 0.19525669422585745, 0.19426079564921006, 0.20053905258154558, 0.20215182910708152, 0.22537412975981685, 0.07196117320343276, 0.07418499063626915, 0.08410551204749173, 0.09512625879569236, 0.07491727736655251, 0.09711821596534409, 0.07476272938441397, 0.11054642738627718, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "8d3468f3-b162-4aa6-a023-30eb7e51124f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            # Adaptive mutation and crossover\n            progress = self.evaluations / self.budget\n            self.mutation_factor = 0.6 + 0.4 * (1 - progress)\n            self.crossover_probability = 0.8 + 0.2 * progress\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and crossover in DE enhances convergence by strategically varying these parameters based on progress.", "configspace": "", "generation": 90, "fitness": 0.3405496648054168, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8738739514179109, 0.9109967473597096, 0.8592416194919128, 0.8618170818069387, 0.886623543579351, 0.883004048711811, 0.8977501870211597, 0.8575197789290445, 0.7702746582515572, 0.7093036761134671, 0.765569869188802, 0.8018095551308935, 0.6429380053340377, 0.7894321245870932, 0.7373778714606259, 0.7768998173503832, 0.7110415461144871, 0.1542420344564831, 0.15302456389064933, 0.14768480133430517, 0.14689625378133497, 0.12164868320578481, 0.18250598985602984, 0.1284787227652212, 0.16164244500066693, 0.15752930096148499, 0.04228058547832447, 0.10214743787132652, 0.15682503842201545, 0.41798515323288055, 0.13042989270204963, 0.0469062348853706, 0.40493122519202385, 0.1103259163210969, 0.11722249155956166, 0.9892720999219843, 0.9685765666903776, 0.9918366428044839, 0.9694806773241658, 0.9647964948126634, 0.9874928006581033, 0.9711397731423744, 0.9783266006967639, 0.9733654433996566, 0.6872486641787656, 0.522075833407637, 0.5110055579707627, 0.49050273754838614, 0.5748654765909844, 0.5816057635911671, 0.5890337691323779, 0.46756155306257674, 0.5331671571846937, 0.2219455079901662, 0.2915666050649397, 0.4680457676104557, 0.26942563586773993, 0.2573580106242349, 0.2761989701069477, 0.7052179677920838, 0.1320955499505071, 0.7054576406625268, 0.369266887986342, 0.17906761867243004, 0.35097319495734236, 0.2470675478041079, 0.1797966284037943, 0.35755112595134564, 0.5675021083500662, 0.206126981306058, 0.23188685275199072, 0.19634497619456748, 0.2137985777678003, 0.19566103078831043, 0.1954525168957476, 0.2531709728262841, 0.21023161393122292, 0.23582840003145478, 0.464711508675708, 0.18234243756241975, 0.005650315775238557, 0.07556121248433123, 0.17003785319400755, 0.07664119751157328, 0.07306954827510181, 0.047019099168765566, 0.04686036611091182, 0.06066668921654039, 0.1828612868940086, 0.12269718989874034, 0.059490007132125045, 0.12710925315895416, 0.09171613097787923, 0.041253076830737645, 0.029281748093582194, 0.08716662167411582, 0.25973796417789297, 0.07881453308103303, 0.15218715742806832, 0.1964341290425512, 0.238318145534119, 0.17534870789251322, 0.18642830917137088, 0.15874184950653814, 0.16526037539836758, 0.17319220504216915, 0.10955883308829961, 0.29600549639715845, 0.22389255111050865, 0.3205679306774769, 0.24951117575831183, 0.3356479235447454, 0.2670637308783085, 0.07730900211866176, 0.2948437718351796, 0.27938357066860564, 0.6798384639971256, 0.5711457618058879, 0.5620208933392195, 0.6281639082407118, 0.6414182325788508, 0.47356855301435674, 0.5197386323436848, 0.723124323918432, 0.592037427011851, 0.14046519858638096, 0.1374028027734554, 0.09190445854269491, 0.09572562149994135, 0.12124407810013349, 0.11397199746758435, 0.12243259556082597, 0.09001686614942717, 0.1149486540808895, 0.15911375349843548, 0.27447125228707314, 0.22657105411009237, 0.2541851001533135, 0.21960642587531887, 0.15990759620362638, 0.20238334211947073, 0.19958461540223393, 0.44558239528260224, 0.32776667622717215, 0.34411189728624647, 0.33272711068431404, 0.3670783522240073, 0.4150629437559984, 0.4231730200811177, 0.3548134268466203, 0.38345212610204704, 0.391172113593765, 0.26970233237882757, 0.21360276915425547, 0.2883785166831436, 0.29165837806573225, 0.3396362369002379, 0.30823912735951065, 0.3001247739281382, 0.11844040966924274, 0.11160306004947107, 0.20662672500122503, 0.1700129077960537, 0.21329478777631516, 0.24149801451404085, 0.27504542444875957, 0.23231932692120238, 0.23542435291166008, 0.21652461347607432, 0.18633280882245729, 0.17496724181140721, 0.2035789086887142, 0.6934827746042995, 0.1999418842425672, 0.2326986448000785, 0.20800203193169575, 0.6334605771273767, 0.23218684459643268, 0.19693519022752382, 0.18633807055359553, 0.8728600494873799, 0.7294925731696328, 0.917605511140932, 0.20892802174248526, 0.17906723399042002, 0.17574744919265872, 0.1484949843488974, 0.1819199901540729, 0.5911833438454489, 0.20822580124047552, 0.5671482578786371, 0.20662550014535797, 0.5927483813043748, 0.2101589685785783, 0.5267599195135673, 0.1502666148718519, 0.46428811328247244, 0.2117340887555661, 0.20699357136211893, 0.18234922156552935, 0.20865545672549957, 0.1948880576888533, 0.19435767399221626, 0.19499301210721465, 0.18957812871034496, 0.18494657115985325, 0.07352313397462529, 0.07505246284867373, 0.07920981559493734, 0.09512621074360117, 0.0821331778985952, 0.0970338757370568, 0.08129807968663005, 0.11054642818540872, 0.10545554205999419]}, "mutation_prompt": null}
{"id": "d732399d-5dfa-481d-a4d4-6cc6d4649877", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.swarm_size = self.initial_swarm_size\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.5, self.mutation_factor * (1 - self.adaptive_factor))  # Adaptive mutation factor\n            self.swarm_size = max(12, int(self.initial_swarm_size * (1 - self.evaluations / self.budget)))  # Variable swarm size\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation factor and variable swarm size adapts population dynamics for continuous improvement in convergence.", "configspace": "", "generation": 91, "fitness": 0.3106419604616532, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103967765990081, 0.8747196685612793, 0.9109894083093829, 0.8750687241380001, 0.8890978558525572, 0.8869195663724447, 0.8860211427708237, 0.8980130067572039, 0.8966974467766051, 0.8428021609575191, 0.7145339707325216, 0.768017614024811, 0.8064785821097419, 0.15798279338568422, 0.7922027362793433, 0.7393220490324752, 0.7810004695663751, 0.7022572399026139, 0.1499361718890696, 0.17458171447160653, 0.10387908197018514, 0.1517398951740777, 0.12898217186727268, 0.1590247558416824, 0.1909596144835335, 0.14652872578830833, 0.16810474143681275, 0.13473868640970355, 0.11333237994515855, 0.07031629298653219, 0.14337008104603643, 0.12913090295457863, 0.11301097985088349, 0.09754642668098201, 0.11143131170821419, 0.11603599591648672, 0.9614288025997145, 0.953872262767666, 0.9618828611762765, 0.9543276574449102, 0.9536047376366867, 0.9466242865619386, 0.9534693924805611, 0.9398652539994035, 0.9715657400026402, 0.6872486641787656, 0.5208628481587316, 0.5115191528360246, 0.43138737568417795, 0.5746886170689578, 0.5263769084992773, 0.5890337691323779, 0.4684787921449389, 0.508688669512928, 0.22627344337832933, 0.15914774508311402, 0.13912052756653925, 0.27005873238547384, 0.17862746007442898, 0.8682232954374939, 0.23318174222242316, 0.17884701920071944, 0.17939520999257552, 0.2874944131909446, 0.2056665951937362, 0.18138471978684245, 0.1710378271165568, 0.1838321103192444, 0.160175123163404, 0.4838817770533904, 0.13564289875503222, 0.1795404609184008, 0.21734376976139214, 0.15778736976237429, 0.1953146121273156, 0.1954525168957476, 0.1343928440024671, 0.20995873603327886, 0.23582840003145478, 0.22430349899250546, 0.18234243756241975, 0.0031606321480026622, 0.07546655859443285, 0.0015318332322743489, 0.10564686227605546, 0.07306954827510181, 0.07039296211314017, 0.04686036611091182, 9.999999999998899e-05, 0.007075344688604823, 0.15849379345099968, 0.11145310525868368, 0.11336860897710577, 0.20241416280165303, 0.14521819244384626, 0.0688897694876579, 0.13168017388605202, 0.19217228080202708, 0.08038053385063326, 0.15273940684916665, 0.15914902579803125, 0.238318145534119, 0.23176300591407462, 0.11201616813784365, 0.24399411893181233, 0.17544127001747056, 0.17530563733301696, 0.2221628522264053, 0.17212971928092025, 0.25509322866505213, 0.21188690989400982, 0.07066084645581872, 0.33873690315582994, 0.16959987894479323, 0.13420228952261581, 0.11280722944613175, 0.17887699855603445, 0.47619627819976895, 0.5029920689399732, 0.5045782967533265, 0.4967961502520666, 0.5058839397228443, 0.49654753673786556, 0.5098855205476676, 0.586112153158113, 0.5412213230984376, 0.064970344825372, 0.06827534357798049, 0.10352177923158545, 0.09514449212627973, 0.11117315118194382, 0.09957347682527384, 0.1527732067678469, 0.1461119157687616, 0.11270607160503587, 0.13226774489509063, 0.27408167073423406, 0.2027731908907051, 0.25343873978145315, 0.21960642587531887, 0.1392027881865301, 0.20243102499758947, 0.12482649829334747, 0.24170989320204606, 0.5216208847672841, 0.35120254513029325, 0.31874388652819363, 0.33799730024483843, 0.34446284460084986, 0.2528723209941838, 0.5468160516013523, 0.17155160482044007, 0.37910118044560603, 0.2072581271914301, 0.3436274723571432, 0.19155570050639859, 0.23890107431048668, 0.21774905932044364, 0.21412210064601866, 0.44652576705597247, 0.3132636028000779, 0.3537264115372143, 0.20667480493224744, 0.19311044012820622, 0.21469835662516856, 0.24773510577468927, 0.2750481113708142, 0.2323184735280286, 0.23542435291166008, 0.22518426999518382, 0.21389204568750186, 0.18991372710432886, 0.19856831159468624, 0.2411840998208723, 0.221824348321916, 0.2011820225164258, 0.22655918766272098, 0.2456454799859601, 0.18925632725876962, 0.19415366194319372, 0.1864529381379011, 0.8742505094843411, 0.13494436971870416, 0.917605511140932, 0.20065701392642843, 0.16339448914398857, 0.16762868522787688, 0.19702977406592315, 0.16172997994220384, 0.5912063794796738, 0.20754632131556494, 0.5674702806756275, 0.20677715221071546, 0.2107218763167319, 0.2101619110522458, 0.4731812094847393, 0.2007390231895806, 0.46426792022660734, 0.21183187228227462, 0.20697534341775714, 0.19023968264295732, 0.20857139113900525, 0.19601797598574744, 0.19459288020679644, 0.19227162681437016, 0.20539901459941234, 0.18940944035682483, 0.0886049073108528, 0.07577071479554487, 0.08598964809322829, 0.09542949004362367, 0.07976278297254702, 0.09743112737592907, 0.09172149508343341, 0.11054642818540872, 0.10744962197110275]}, "mutation_prompt": null}
{"id": "9aaa2b4f-f0a7-4cc1-b1fd-5e580a23c3c9", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            velocity_diversification = 0.1 * np.random.normal(0, 1, self.dim)  # New diversification\n            self.velocities[i] += velocity_diversification\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            adaptive_mutation_factor = self.mutation_factor * (1 + 0.1 * np.random.uniform(-0.5, 0.5))  # Adaptive mutation\n            mutant = np.clip(a + adaptive_mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Introducing velocity diversification and adaptive mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.3360657436024436, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.844346828414685, 0.8332465807828557, 0.7995170734524184, 0.44027389638669434, 0.7865973110628202, 0.787965837167571, 0.8395093558742821, 0.43208043314006417, 0.83228827993061, 0.714589252917992, 0.6718228436199741, 0.6989996270378563, 0.6820022614991779, 0.6709468132316738, 0.6864903755753484, 0.0183851584869974, 0.6614001689923825, 0.6879291949241086, 0.16410570594962048, 0.31696920320446687, 0.15592984330414328, 0.3514413448479473, 0.5460167340269069, 0.4262210649861933, 0.19655163158557776, 0.11603538799689561, 0.11087640014828792, 0.1383756559640329, 0.12394904850269484, 0.14358706948351807, 0.13168781196337842, 0.33158238665419093, 0.14882618171305406, 0.14164397028483977, 0.16082655479638108, 0.30187185752369483, 0.9699024765175327, 0.9743994811363347, 0.9484735075494619, 0.9457853373173344, 0.977239661240489, 0.9373044782534734, 0.9662250494910548, 0.9853012640097529, 0.9784319020476506, 0.6248130661640342, 0.298722042951029, 0.307485472415039, 0.2933583196141857, 0.5381885647006039, 0.5157096701099615, 0.3088119466018746, 0.530764387402437, 0.5686282406230578, 0.6833638160582494, 0.35875341699438545, 0.6866844847794102, 0.7390572259469801, 0.2067334228629114, 0.18956479914931912, 0.8150627958876671, 0.777021150164864, 0.6898373069889625, 0.20186071026386354, 0.37593167602576383, 0.3229428766905881, 0.18165340386722784, 0.2643562504189435, 0.1673944278332199, 0.26520456353173505, 0.36552097983062937, 0.32846322949863227, 0.27649099346213957, 0.1468774474572474, 0.18419430960437522, 0.436508146379593, 0.13283850975148248, 0.4892605337801197, 0.25983517659327426, 0.15032516246097638, 0.21726183609981686, 0.0034775074037642906, 0.16421075350731285, 0.059388424328149836, 0.002012808642079311, 0.09031893242873668, 0.08680127645519187, 0.22734818412940183, 0.23065894253332064, 0.062134554184674506, 0.18352537772033617, 0.08615311696701045, 0.23314141375241026, 0.24872515740853263, 0.2663163297821396, 0.16675447332951376, 0.6053211303045356, 0.3078494943849278, 0.2710285800312945, 0.05804939924330976, 0.0669101762562988, 0.15972822888050542, 0.24286308375012344, 0.09577955849441822, 0.1847456010947367, 0.06602943266559502, 0.08452724211794105, 0.15867078225691444, 0.10444378200799387, 0.24840364656434777, 0.30249295124602815, 0.29388107613006165, 0.2879607164367366, 0.25930940358582955, 0.26180069231656444, 0.1857674305578012, 0.0889168762909619, 0.6500924086572315, 0.7335024442252625, 0.7102509362556633, 0.6096483751548678, 0.6274170520619501, 0.5283141543672205, 0.613426093594921, 0.6350816848645446, 0.574781486798227, 0.11329011903883479, 0.09125815998514242, 0.1111735669601076, 0.12509522084810287, 0.08673481150138307, 0.09941977829810622, 0.11492221395241742, 0.08505134767284017, 0.09355993839231613, 0.1747750198596687, 0.23292720574548542, 0.18074117799893974, 0.22562868201034592, 0.29469725607110575, 0.2722609366395258, 0.209419132214261, 0.26091435883406033, 0.29213282477358526, 0.4160149958297463, 0.3817633302260488, 0.37509887278039, 0.38529456469892276, 0.36311226878643943, 0.39077637619346806, 0.4936343765513632, 0.4023269843830254, 0.4197193333198619, 0.30178784213472476, 0.29418242873190836, 0.2667664592260467, 0.3036793464712778, 0.29863195485671534, 0.2909796816536595, 0.25412251537217767, 0.2528129261301484, 0.3035830259504454, 0.2159767571099298, 0.22725070215927246, 0.2102981399953875, 0.1920039467688721, 0.17340966101506727, 0.21512458708185234, 0.19773096928434974, 0.20211004622621287, 0.17751617602085823, 0.5353750734673428, 0.20387236240907158, 0.20812207090228652, 0.2033314474212624, 0.23491156510758748, 0.21290637271007917, 0.21977898134742913, 0.2045683846910773, 0.22811075028018735, 0.19683095114194848, 0.8475947862601649, 0.19558756222865636, 0.6779372052988152, 0.19987565584124145, 0.12194769729259258, 0.1678537815144937, 0.2062768896856534, 0.6758219632771295, 0.6808016531595176, 0.16256957447968945, 0.4582748658536028, 0.2085277660056183, 0.20960424476641726, 0.21069662717087145, 0.34249409642168616, 0.20958047360034737, 0.32706507446165134, 0.19366435608552424, 0.17533602043768481, 0.1798245498196387, 0.18259611582873125, 0.18056233751923223, 0.1771679064199918, 0.16977392800509938, 0.18556937870203183, 0.18349850392975942, 0.07927924428635014, 0.07657594603497742, 0.08047064322588526, 0.10104098329545286, 0.08181165772191923, 0.0819919963052469, 0.08437008075892904, 0.08033525690478016, 0.07090997716535297]}, "mutation_prompt": null}
{"id": "06437a5e-ac6f-4b66-9402-5c21d65e64ff", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.5, self.mutation_factor * (1 - self.adaptive_factor * 0.5))  # Adaptive mutation\n            self.crossover_probability = min(0.95, self.crossover_probability * (1 + self.adaptive_factor * 0.5))  # Adaptive crossover\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation factor and crossover strategy for improved exploration and convergence.", "configspace": "", "generation": 93, "fitness": 0.30402573814181233, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8746366555423631, 0.9109894083093829, 0.8581504619349491, 0.8704742854531365, 0.886799808677716, 0.8876414260123746, 0.8984711130633742, 0.8585676245448097, 0.785043286038435, 0.709836707297288, 0.7653346020316798, 0.8018095551308935, 0.048072547625304995, 0.794919180929946, 0.7372996525073265, 0.7785099296643059, 0.7125004028851376, 0.10701645127390058, 0.11192832668953923, 0.10922811996846016, 0.10076104034034383, 0.11074200173785298, 0.1349940519542786, 0.0936620965137992, 0.1575700470758571, 0.1345402644274183, 0.10172316455708863, 0.07751097376946603, 0.07255185720409352, 0.10524190361285868, 0.10793173599599992, 0.12034570798337241, 0.11490335040069677, 0.09969612052829357, 0.11911260950160618, 0.9465179682262922, 0.9481818686109228, 0.9534774871765838, 0.8179598891073092, 0.8486831709278195, 0.9144086120421285, 0.7440660620796237, 0.9551950616214555, 0.9728456497385971, 0.6872486641787656, 0.5190083252684541, 0.5118409776177768, 0.43164222827332055, 0.5754425459907231, 0.5259817612749609, 0.5892187578801564, 0.4693102409018064, 0.5097129690463114, 0.22186687172757824, 0.9110543418703831, 0.13901576515334213, 0.2698196766545937, 0.18987285015834354, 0.27695279654573957, 0.9029286285544872, 0.23132947651443914, 0.23430445050646231, 0.2874944131909446, 0.17652219872902042, 0.18152088630868257, 0.16944879426273307, 0.1797966284037943, 0.1688087821210723, 0.4838817770533904, 0.16758097913592063, 0.1680573065429447, 0.23261535067251227, 0.1498281119553989, 0.1953146121273156, 0.1954525168957476, 0.1336178225619027, 0.20995873603327886, 0.23582840003145478, 0.22248198400609487, 0.18234243756241975, 0.0031606321480026622, 0.04921682783159653, 0.0015318332322743489, 0.04275438628578454, 0.08148696094644492, 0.047019099168765566, 0.08367408531658127, 9.999999999998899e-05, 0.18790482387598317, 0.24915025007623426, 0.1521373805846763, 0.17114613040496063, 0.10914366088936367, 0.09708568810571538, 0.08231634830841306, 0.10409916471628078, 0.30405202952300314, 0.07453281108625998, 0.1523068090127021, 0.15923809763826557, 0.238318145534119, 0.17534870789251322, 0.11201616813784365, 0.15874184950653814, 0.16393934130177445, 0.20986263518544535, 0.07092797631311754, 0.08945802748803622, 0.08685656041890522, 0.21428296721418316, 0.25942644409983073, 0.33671334355867266, 0.16811311750942115, 0.07894346691590404, 0.11430026099970803, 0.08137357102057463, 0.47637557324975965, 0.5054540911630152, 0.4823988511161167, 0.49676049246283893, 0.49893565511566995, 0.4778093432866589, 0.507915315497316, 0.515976110525297, 0.5412856463800342, 0.0954057941555102, 0.13885960507139683, 0.0881658968775706, 0.1662986523411819, 0.09845209952460277, 0.08782888051003734, 0.09999478997748223, 0.11722487030610806, 0.15511136558050143, 0.13328017000900383, 0.2741219277617396, 0.19356226868511428, 0.25343873978145315, 0.21960642587531887, 0.16208222892708035, 0.2398618505407626, 0.1312853100293494, 0.21631019310811528, 0.265652783131355, 0.2754869561207399, 0.3449476380719174, 0.344198177127796, 0.3435242330077042, 0.18818170680181212, 0.2795316551641803, 0.4143163106943253, 0.3226208070071932, 0.358056448023078, 0.24218271326616703, 0.18212768599413665, 0.19201452512350858, 0.349637078787954, 0.23357872141898828, 0.1160762371379096, 0.14574514507619496, 0.26651176684118616, 0.22463018547973257, 0.1757311939061168, 0.21364441309388793, 0.24149801451404085, 0.2756508605332014, 0.23291050569675753, 0.23542435291166008, 0.22276785311285419, 0.20988798572666323, 0.17695310646259987, 0.1968940181505946, 0.21177333348087912, 0.22017733204144507, 0.18910499211972698, 0.23869882129952524, 0.21139489572846037, 0.2215940105657892, 0.2060226743347433, 0.18644302521164913, 0.8733819352159843, 0.15391879286712307, 0.917605511140932, 0.20065701392642843, 0.16245765674826618, 0.20318186664628712, 0.16611928449701174, 0.15720237581493024, 0.5911833438454489, 0.21037685295355046, 0.5668794067221137, 0.20662550014535797, 0.21072029308888918, 0.2101589685785783, 0.4692590386705183, 0.14701984912035038, 0.46485585210510694, 0.21159090074464015, 0.207047006441632, 0.19436163075698232, 0.2080395961912428, 0.19556668647101128, 0.19613573865365574, 0.18475942732606787, 0.1868017857008103, 0.18872350037147623, 0.07081370586946811, 0.09367228279451356, 0.07543821592882383, 0.09625660785616386, 0.07751001449360706, 0.09901164357542225, 0.108781683077532, 0.11056373777736461, 0.10546460287209825]}, "mutation_prompt": null}
{"id": "76e0856e-a5e9-4230-b0e9-7fbb25162df2", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.6, self.mutation_factor * (1 - self.adaptive_factor * 0.5))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "Incorporate adaptive mutation strategy in Differential Evolution to enhance exploration.", "configspace": "", "generation": 94, "fitness": 0.35725994610215106, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9103879099423106, 0.8792130330726426, 0.9109902872129844, 0.883752076208072, 0.8893622359442535, 0.8871220704830439, 0.8856717993696331, 0.8978686658666613, 0.8577452914287214, 0.799413644661853, 0.7920254087573582, 0.80472682438442, 0.8018095551308935, 0.7371702167941596, 0.7988101070592426, 0.7843765230354798, 0.7780008684340545, 0.7037746385786612, 0.15084866349583959, 0.15192449504132, 0.4783593922820141, 0.2835972817239213, 0.14962758507468676, 0.17211018002004985, 0.16269923045085866, 0.5576759849669612, 0.1655073963905508, 0.10669673123566537, 0.3142209506171545, 0.14241487404294417, 0.12951850544414156, 0.1457611216100133, 0.09668894261784133, 0.13253321759110426, 0.09542834137665213, 0.10022624211936815, 0.9674794769339503, 0.9482825320678538, 0.9807861711214999, 0.9530777549125986, 0.9607146988443522, 0.9718234345057456, 0.9641652049721955, 0.953421545325498, 0.9854258741081664, 0.6872486641787656, 0.5188953118084836, 0.511045521048102, 0.43138737568417795, 0.5746992846583254, 0.5267924811474765, 0.5890337691323779, 0.4704498908423711, 0.5088313258294388, 0.33286396304517907, 0.8716980200921443, 0.21904339659527172, 0.26908631763008384, 0.8768766885948864, 0.3232286761366234, 0.8467155843057887, 0.8353958077419087, 0.17321574614082635, 0.2876094004429397, 0.19485799263284154, 0.18138471978684245, 0.17464976722535352, 0.1797966284037943, 0.16671642653511498, 0.4838817770533904, 0.18872231471383794, 0.17104532017975782, 0.19634497619456748, 0.6877722514146779, 0.1953146121273156, 0.1954525168957476, 0.1507186378589962, 0.20995873603327886, 0.23582840003145478, 0.22263320994453417, 0.190425495955021, 0.0031606321480026622, 0.000309152416303915, 0.07269257717568056, 0.059171154991757624, 0.0932695611644977, 0.07231147692160955, 0.04686036611091182, 9.999999999998899e-05, 0.04845825962392136, 0.15809744026608819, 0.17864085234889748, 0.2215428384271182, 0.09173613113998835, 0.10008965691760385, 0.11594913797093886, 0.21110371045514964, 0.3344221758356086, 0.07468455819709474, 0.15218715742806832, 0.20503269570948623, 0.238318145534119, 0.23854915643584695, 0.11201616813784365, 0.15874184950653814, 0.17156494660793964, 0.17319220504216915, 0.1607070620804103, 0.1621845474074729, 0.24442611303237705, 0.21229751263055974, 0.5037415318099331, 0.33631771926815723, 0.39450902037711566, 0.19161973450589775, 0.21146383716116757, 0.19762673122313068, 0.48569511201559135, 0.524152521629064, 0.5228356877796299, 0.4908599118120749, 0.5230782187931169, 0.5774478880270322, 0.6503841621130335, 0.5255458743825714, 0.8174997079918599, 0.06131647957954445, 0.09906493626867108, 0.10774577536762497, 0.12304531158947973, 0.10478998308156207, 0.14804043014488488, 0.09068868095451887, 0.09542709827886953, 0.11659509012788671, 0.1698404002132442, 0.27439885178448387, 0.193642865487476, 0.25343873978145315, 0.21960642587531887, 0.2320054882139685, 0.2024202871063937, 0.15480795443864848, 0.1670003066293102, 0.3436557347559218, 0.5257224752325962, 0.40373108405386715, 0.4194462348795436, 0.43024320704901897, 0.31196450862853264, 0.5188284176292796, 0.2879969096937127, 0.478360595078436, 0.40405099836742064, 0.4009677268429124, 0.32866834745996554, 0.3685667899411257, 0.3791391395802379, 0.1811461082266932, 0.49060411953448835, 0.4899091908778712, 0.4749020450150583, 0.2066270069950854, 0.1801437244881925, 0.21386138878759953, 0.24155864263453064, 0.27510760089407127, 0.23240264817901501, 0.23550008379797316, 0.2165578229562316, 0.18633280882245729, 0.20640564846432508, 0.22016741416791963, 0.6420057436811102, 0.560944717270194, 0.20568894470166377, 0.20800203193169575, 0.614281359413601, 0.6443934444208343, 0.19607818380216424, 0.20871165649811851, 0.8735363236005999, 0.16406535549944967, 0.9177194257391721, 0.20065701392642843, 0.17105928707990659, 0.196794296434731, 0.8309167262193935, 0.1642786436632927, 0.6265752830145996, 0.2077740282159798, 0.5675567203044471, 0.20805616283163786, 0.21072029308888918, 0.21016330113825554, 0.4679374955284574, 0.15368433738490095, 0.4646056460792918, 0.212160363550156, 0.20756464328410296, 0.1923069924727948, 0.20823172645100785, 0.19951889770569153, 0.19509182173564155, 0.18475942732606787, 0.18668896218327657, 0.18408864706013206, 0.08335971480450222, 0.08577580963318365, 0.07990322257967453, 0.09522927820673, 0.09400207185892928, 0.09712058511363741, 0.09621294680841597, 0.11056368710554221, 0.10546671690644327]}, "mutation_prompt": null}
{"id": "3f182a0d-da8a-46f0-abe3-e627a3ae1596", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.dimension_selection_prob = np.clip(0.1 * (5 / dim), 0.05, 0.15) # New: Dimension selection probability\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            update_mask = np.random.rand(self.dim) < self.dimension_selection_prob # New: Selective dimension update\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i] * update_mask # Apply updates selectively\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with selective dimension update accelerates convergence by focusing updates on promising dimensions.", "configspace": "", "generation": 95, "fitness": 0.3195244921543817, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.7856035234215348, 0.8124280558854314, 0.7937080262425394, 0.3784702827925086, 0.20654503106007238, 0.7439782494039404, 0.8148951051408428, 0.8097127187530585, 0.8168679924922999, 0.6524457734527658, 0.6706421525052604, 9.999999999998899e-05, 0.7157087231922226, 0.06590030039294348, 0.7232774686182264, 0.7230610094260987, 0.7263294828826389, 0.720418238941734, 0.11817609187383127, 0.13439895112761446, 0.10965089367200564, 0.15904071632672845, 0.2205867792438717, 0.14922882169262808, 0.13389703311192447, 0.28778099658319223, 0.14910390829736064, 0.10928232236127133, 0.13855974852949926, 0.09703975170859391, 0.13476302455318745, 0.11513486219191582, 0.14423770158762506, 0.18294142745175757, 0.16126360216494917, 0.4700664968739522, 0.9938121599529164, 0.9757487532680172, 0.9700551156245233, 0.9795662587651267, 0.9680480117683279, 0.9588307994710425, 0.9904001212020658, 0.9758143472802028, 0.9891133006743025, 0.5317908999438299, 0.05587815423619946, 0.06256180208143214, 0.08045849803404859, 0.19026218241156, 0.48571099964868036, 0.1932711698201699, 0.5184393173181459, 0.5306345052047189, 0.5450685206204466, 0.681956518794866, 0.7341318627912445, 0.7181074012551287, 0.808727631670388, 0.7170926759747789, 0.2329836829211036, 0.17569286860946287, 0.14347595520763567, 0.2636328382618949, 0.5003630290941621, 0.5036278945931489, 0.37343630290713625, 0.5157584630601797, 0.1248774024275302, 0.42831611412316795, 0.3031191827232289, 0.325628944772147, 0.31902002809566643, 0.19319960772960276, 0.09863968370996512, 0.4856884379177313, 0.4693573289448041, 0.34337775912943314, 0.3113762429890048, 0.2806250094881556, 0.34017611825198824, 0.058164087623912564, 0.049563491114555824, 0.11382379596242076, 0.024835172397198013, 0.1667169556934257, 0.06562130925362197, 0.15272828551263484, 0.30143708429064375, 0.09247073825663066, 0.15155680707872565, 0.17692804271770002, 0.25724932464487704, 0.29655542704992377, 0.16668557236289983, 0.1518905556133694, 0.08490854610619902, 0.209095499526316, 0.15450019104569002, 0.09549619652528052, 0.0022999798040713726, 0.17566472485556572, 0.1032205336678631, 0.004129152996302565, 0.10795042944581745, 0.12534092708889566, 0.06986624172740175, 0.0653594292192583, 0.26050053028451126, 0.266790651287244, 0.20383204993093196, 0.25832520257320635, 0.30254635510076633, 0.2731596637366802, 0.07634187289128969, 9.999999999998899e-05, 0.28246853562362384, 0.6365859903526931, 0.6818689948611985, 0.6844084865469082, 0.5956367047578532, 0.6452584687465726, 0.5295594606679046, 0.5869899205503643, 0.5811108167483628, 0.522483981354193, 0.1056035986352275, 0.10758418783026702, 0.09703965665340364, 0.09123356071587463, 0.16924101160166227, 0.08603556489655928, 0.08221236204970794, 0.1135678221751516, 0.1121820113045171, 0.1216372750017155, 0.19252070527386955, 0.12989456530961685, 0.19535598104472074, 0.21406764581876747, 0.18062941787580455, 0.13004470835392967, 0.12725036484798802, 0.16911885263060267, 0.3850522561149703, 0.3450817851373986, 0.3876999331947629, 0.37937481811819596, 0.36442632044310863, 0.3697346858416859, 0.1794902569750111, 0.4052031860801536, 0.4239962145754257, 0.2001551215686096, 0.334764408831566, 0.2763869943378541, 0.19837686185324366, 0.2900492515512395, 0.2860786591107398, 0.22003781196810246, 0.31444691465449726, 0.27533159970563315, 0.1902218787064588, 0.21936715382285943, 0.18149174267155088, 0.17468129702278912, 0.1945380146932877, 0.21077638340241578, 0.19544273275773538, 0.23072123530533606, 0.21581217383904483, 0.21030855114839075, 0.6376892460378971, 0.21279028736265482, 0.2143221842992632, 0.2269512716978903, 0.22633026819241864, 0.5461417583858498, 0.1971601409118462, 0.5908040367454215, 0.17855824808263876, 0.17908864733527008, 0.8459876723254052, 0.7182398326318968, 0.21168829508118292, 0.19057099782191989, 0.16497677608957007, 0.8138274534116413, 0.5320374687790517, 0.3773910443745373, 0.7933569169788537, 0.21793982861546024, 0.19830512905680275, 0.159050099335189, 0.23884455776861446, 0.1098548906441098, 0.20585257141197522, 0.3060061692155278, 0.1776246669589331, 0.17612567653870537, 0.1659567997294049, 0.16890570298363727, 0.17830082769397781, 0.18345415982683855, 0.17856323996301504, 0.1782688314042683, 0.19827783776359253, 0.0726122707025012, 0.07278695401792534, 0.05922729321065601, 0.06251020174847977, 0.0704725676867296, 0.07628066434069203, 0.07731409896743535, 0.07813423806713549, 0.0893155913773378]}, "mutation_prompt": null}
{"id": "e834bd78-33d7-48ef-aa8f-061e6834fb6c", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.7  # Adjusted initial inertia weight\n        self.mutation_factor = 0.9  # Adjusted initial mutation factor\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = max(0.7, self.mutation_factor * (1 - self.adaptive_factor))  # Adaptive mutation factor\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation factor and inertia weight introduces further adaptability to improve convergence.", "configspace": "", "generation": 96, "fitness": 0.3521078667677236, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.9123858476641509, 0.8688704111604408, 0.8797586773694811, 0.8416436520755899, 0.9092882972046441, 0.9177745386355762, 0.8962844756147268, 0.8895164461227185, 0.8764836305715829, 0.7915733933057425, 0.7511221094232384, 0.7797597343555254, 0.7956151577279079, 0.7535840039925701, 0.7277213722437756, 0.7444085317274286, 0.7922972795667029, 0.7568718851077758, 0.2323824057875039, 0.15117522330801492, 0.15899959759917925, 0.11994702684087011, 0.07723044112934818, 0.13269370902368371, 0.10691902436259992, 0.48834994218155625, 0.12256306854376986, 0.09452565181863737, 0.12535417770043078, 0.15292908778679448, 0.1340595433055234, 0.14768069007716966, 0.10652122227831529, 0.12307671271809073, 0.11603897933370988, 0.13205473392224398, 0.9856893460897354, 0.9470384638736642, 0.967156287399027, 0.9534414573089454, 0.9575795680556595, 0.9879461893468432, 0.9477372705125049, 0.9716832404545589, 0.980590275366883, 0.5028997759872196, 0.6645544532051193, 0.4889152718930745, 0.5690229000497922, 0.4874392561643327, 0.5524009137256997, 0.6657251717206412, 0.5103778353226305, 0.6216452336488774, 0.8532413212804462, 0.16722747548184047, 0.20478934130408066, 0.80332519289157, 0.20896612778142398, 0.3208500197038249, 0.8362258564940417, 0.22936313932184593, 0.23393657804427426, 0.18949414419260147, 0.1780824978701523, 0.1733338958123275, 0.27019642044837267, 0.21080893520047317, 0.1690179710828108, 0.22705990875597604, 0.13563548120721514, 0.18938230128818156, 0.3762226293993248, 0.0839314169156633, 0.1713066090141323, 0.20901835535277258, 0.16970979130937336, 0.20231597592231598, 0.2236324266894214, 0.5611554080576144, 0.2666129233553033, 0.0003909795295269358, 0.14587153889203242, 0.10535190004532957, 0.12676408914312665, 0.12361384047445245, 0.10643692468634258, 0.22305817464597089, 0.21306431736415354, 0.030687447155841263, 0.2367405150985794, 0.19460822934861688, 0.2789508646782338, 0.11971968261871646, 0.044857103961195244, 0.14885623632859335, 0.08182744020100308, 0.35121439535505683, 0.155045873746673, 0.176950587101103, 0.17252111771785417, 0.18579568261664636, 0.18995229765456767, 0.14671084451721306, 0.20249647953419103, 0.189478953534173, 0.33120333479302877, 0.1808647968633028, 0.21733972287474157, 0.17457935343538666, 0.22748387105756962, 0.3105467991197376, 0.26295835836598846, 0.19911870200301462, 0.38748024204157794, 0.250678958216892, 0.24317267407750154, 0.6882962885307573, 0.5869220413125027, 0.584815825876214, 0.5870560801567197, 0.6021797938940863, 0.5925864192642463, 0.6656769456456186, 0.6460655015548836, 0.6317824125366958, 0.10471188161600786, 0.08225846381519719, 0.10472956370683839, 0.08058848706728694, 0.09204525718968959, 0.08146182274606506, 0.12623726633967958, 0.14987481412039283, 0.10794690290903619, 0.1846331119008111, 0.3564934953396103, 0.14507095635198763, 0.28118414875493214, 0.27807749359103084, 0.26124361892938053, 0.23531861544137167, 0.20809225286080335, 0.14549615670094396, 0.5073436963415849, 0.37755411284353735, 0.492480030897975, 0.23637224635436938, 0.46973285578666657, 0.5476617625858158, 0.5157195876831806, 0.5668964873729699, 0.4540473564956705, 0.17534502983270372, 0.2846612829782178, 0.32251235285462354, 0.38002652718811814, 0.20653193723562768, 0.2101591218540999, 0.42513998502879125, 0.42398718550524794, 0.38964211293254125, 0.20799244455370258, 0.18119413357515746, 0.20960402615669882, 0.2522733622420449, 0.19187557037324332, 0.2053029201243437, 0.20507802390391838, 0.20193475300254282, 0.22110158656969947, 0.20705441529206492, 0.2302087073422615, 0.21215760319578458, 0.22459827169288427, 0.21966435324435774, 0.2143576375079076, 0.33571983941848116, 0.22971082574816637, 0.6215057429111246, 0.4189710205138514, 0.8755668276876458, 0.8620218993062095, 0.9299876600843772, 0.20032877876616728, 0.17293906409606974, 0.2708295172376789, 0.19724609601900456, 0.18115255474235936, 0.6312844580312957, 0.20954363661628173, 0.7800026179882938, 0.20819569843031738, 0.2108305049573762, 0.4465642195358872, 0.28663328431601587, 0.20455759973141707, 0.5074004385718354, 0.18392823246387102, 0.20325176356246655, 0.18102829113233143, 0.2070841483329695, 0.18654061050960347, 0.20410537545229035, 0.1882650215654832, 0.18307311706153628, 0.1990123868699072, 0.08583488637811698, 0.07090048536549531, 0.06914773954472353, 0.07347388491254847, 0.0843576119042333, 0.11339340000865739, 0.09215664607206941, 0.07680358402989462, 0.12035458856355219]}, "mutation_prompt": null}
{"id": "c526a7cc-4f25-4388-88d8-6a2f41757fd4", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.velocity_reset_threshold = 0.3  # New variable for resetting velocity\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.crossover_probability = max(0.6, min(0.9, self.crossover_probability * (1 + self.adaptive_factor)))  # Adaptively adjust crossover probability\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n            # Selectively reset velocity if particle is stuck\n            if np.random.uniform() < self.velocity_reset_threshold and np.linalg.norm(self.velocities[i]) < 0.1:\n                self.velocities[i] = np.random.uniform(-0.5, 0.5, self.dim)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive crossover strategy and selective velocity reset augments exploration and exploitation balance for improved convergence.", "configspace": "", "generation": 97, "fitness": 0.3600861779655189, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8567168974016386, 0.8455855541055797, 0.8384174544406707, 0.7930343855139901, 0.8222740753450936, 0.6429612812519452, 0.8470375084018356, 0.8342305553598288, 0.8245021107114168, 0.6920727168225262, 0.7072243294503424, 0.2972042904866088, 0.2584762092178752, 0.692517689573887, 0.7494661113538743, 0.6806478540255272, 0.6612081500277893, 0.6946169828802894, 0.36280470322540115, 0.17041264331852068, 0.36497280801392296, 0.08984535180344866, 0.1293098330729887, 0.1439056675039312, 0.15027711259006205, 0.1467360929334458, 0.1544205897880454, 0.13153715937118937, 0.10817070092713843, 0.11769006911458124, 0.12394833867542343, 0.1541757446880796, 0.12242307581415368, 0.09997462968381965, 0.20980873103934428, 0.1030004505979667, 0.9838656483276477, 0.8994179433514656, 0.9062260462258056, 0.9852958287176721, 0.9213857439137905, 0.9536352470249201, 0.976700815747037, 0.9387051296648322, 0.9832949143111402, 0.5794919282948485, 0.5960719388464614, 0.4571848063229833, 0.5329898582354071, 0.5673919717232088, 0.5481114418938082, 0.5530387014275964, 0.5107893855804133, 0.38585012241842953, 0.7077328477818283, 0.7412950521843851, 0.7546098297584709, 0.8245486551698585, 0.7997727548204656, 0.2056542776213811, 0.22097170092855245, 0.7665220978550349, 0.7193764015505646, 0.195334173900223, 0.30075676663269824, 0.15363392039147294, 0.37094456339928383, 0.30268114209657415, 0.3583358507746287, 0.37354257735829555, 0.48653359807213625, 0.5089404746317832, 0.22011770431530875, 0.23059352520984477, 0.18329428601626718, 0.5364080525848337, 0.2862732576141027, 0.47272520530784334, 0.47340797325329576, 0.28290426453096096, 0.3133862890774519, 0.1602151630059312, 0.016821922512145426, 0.12099266885847848, 0.2355192502623118, 0.17765338550757193, 0.08778148119487394, 0.4121439546760446, 0.21421745787878166, 0.0853880672941204, 0.19230121000448197, 0.403098272189082, 0.10734231410293638, 0.11135673227048226, 0.07433026862060255, 0.1822532932644343, 0.12056824890993245, 0.3851635229647449, 0.3278342801426313, 0.07206034749762635, 0.11751307717922232, 0.09080418684550373, 0.07170547962638085, 0.35100534125571325, 0.10611856309625178, 0.15975240297477233, 0.1425752695953446, 0.0919263738339996, 0.2788722875254209, 0.289388171936808, 0.2947259387046288, 0.3104212848679765, 0.34251047614563235, 0.28259243156472325, 0.28058514458662176, 0.26426404944779036, 0.20803139497930379, 0.6725580961902755, 0.6532410582134189, 0.6669147647759079, 0.5774518972127536, 0.5188857082570477, 0.5331713368746887, 0.6229063598708268, 0.6813133285506331, 0.6932433531185871, 0.1030171782818845, 0.1461111792972224, 0.07350670181125729, 0.0966103547789322, 0.0949223650787322, 0.12168209145658715, 0.08950339775395078, 0.11781622673130987, 0.0753750904556062, 0.21694665797465218, 0.24619424803059364, 0.2503427235310123, 0.3265199404347682, 0.2840355029520547, 0.17376746839185964, 0.16702253148903723, 0.21556731107159044, 0.24981110424788822, 0.3314800421092051, 0.4078010259249194, 0.38087813712607144, 0.3743320166907522, 0.4357006291865344, 0.34614832057891765, 0.4080633033900952, 0.36388959438608726, 0.3928927487883275, 0.2030924094233919, 0.3039698538391026, 0.3005434994695232, 0.3338236207774937, 0.17351580271885292, 0.31977799635504234, 0.3159203901373029, 0.3327598468302877, 0.31879852360999195, 0.1868156977636558, 0.17944456774888073, 0.2533688599621543, 0.265623228199102, 0.2367103658020554, 0.23277600469877513, 0.19918770725123724, 0.21746414453812124, 0.20967318935041113, 0.22290542084027898, 0.5604900012170708, 0.23142443470263463, 0.22516196770269115, 0.5089809713364717, 0.20592605830201394, 0.19645970194322038, 0.248641437507506, 0.18925740871330832, 0.18754214685661452, 0.8456836907625398, 0.8478430746446135, 0.8919272653463185, 0.21113678708720895, 0.1628673654339753, 0.171554413033982, 0.16433332195072448, 0.7618410517539846, 0.8379278772480139, 0.2084872967470276, 0.7035449919704763, 0.2055692392048154, 0.2080391812091512, 0.6669114634762543, 0.19540696193299978, 0.15446672106793646, 0.7966483992536537, 0.17651235925857656, 0.18642014447710775, 0.18363570532446705, 0.17602503760644972, 0.1766175989768921, 0.17692345746950544, 0.1989401689149739, 0.18634220506960597, 0.19788584045596558, 0.10635360901837043, 0.0744091736922392, 0.07438625878514937, 0.09317297122183044, 0.07113762328546125, 0.101730548843599, 0.08087056093161427, 0.07334774002320632, 0.0788489937417034]}, "mutation_prompt": null}
{"id": "659d7749-d131-4c7d-be9f-10dc67653112", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.mutation_adapt_factor = 0.02\n        self.crossover_adapt_factor = 0.02\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = min(1.0, self.mutation_factor * (1 + self.mutation_adapt_factor * (np.random.rand() - 0.5)))\n            self.crossover_probability = min(1.0, self.crossover_probability * (1 + self.crossover_adapt_factor * (np.random.rand() - 0.5)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and crossover rates improves convergence by dynamically adjusting exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.3753028996629605, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "b5cd022f-5698-4ecf-a326-42d4cf6ba91d", "metadata": {"aucs": [0.8998945180694712, 0.8902002557641091, 0.9212349485766868, 0.8681492971535658, 0.8572574383764152, 0.9016248385727959, 0.8842473912702308, 0.8891096527884909, 0.8911571495709095, 0.7983291877464745, 0.733567286343755, 0.752387537432085, 0.739759804353586, 0.6785758513656763, 0.7628045281441611, 0.7854593803800396, 0.8024023714122792, 0.7103627818815873, 0.20738218861881808, 0.5923144543434382, 0.37082146922519355, 0.1880141523447434, 0.14281230864275896, 0.4461232238348817, 0.14662091179018988, 0.1594025265699447, 0.30715292470858435, 0.1803123773846742, 0.12716373707680217, 0.12364252945565235, 0.12545473697041565, 0.16541537083535207, 0.2602956193295337, 0.5323334928108101, 0.1030301920241995, 0.11093138992331564, 0.9771942457856292, 0.9609862302812318, 0.9649646376394656, 0.971913004996268, 0.9703772904759398, 0.9614104755503529, 0.9529615389860371, 0.9674524734367191, 0.9682553732528308, 0.5825206480292728, 0.5606915745376961, 0.5770862191538124, 0.5813233622197764, 0.5998144801152543, 0.6042735415365097, 0.5960797327077481, 0.46737528244546533, 0.48252674916240734, 0.778657130052306, 0.6898089579036919, 0.3444822189229658, 0.7151599393020203, 0.15694394588044835, 0.7778007893956185, 0.6129072802167704, 0.772600512666501, 0.6998796016469355, 0.4648482978021823, 0.27551308717738343, 0.19433185092137617, 0.35177399273412, 0.3897337614725319, 0.1582424179926345, 0.34048827938849846, 0.19123989466459212, 0.26343072226212805, 0.26988902508687274, 0.2629468847562856, 0.200692545360725, 0.368197180054028, 0.5085382536167644, 0.5281207733582303, 0.3104222591154274, 0.20701570422557303, 0.2231077951219681, 9.999999999998899e-05, 0.07994681241807045, 0.024659083667560866, 0.1686593438156786, 0.08179727787508873, 0.1752501764084482, 0.12650600752361807, 0.038110020002194656, 0.06707061553348936, 0.1894397814537696, 0.13712905789004248, 0.2689876715557763, 0.16516743646930354, 0.23855820179862963, 0.30085099234284696, 0.11195198918239546, 0.16268969717129056, 0.1657521757159548, 0.15514723553726595, 0.16179294102141173, 0.2590780270162971, 0.19044345569440857, 0.16945441910487657, 0.10876281467709281, 0.1542813919229037, 0.16390331931887214, 0.14995037166832914, 0.2506053984462182, 0.28053082270396534, 0.30450689670875253, 0.25250216267239733, 0.3587496822989389, 0.30947124513938007, 0.24159796320780458, 0.2598491710998021, 0.2705249147178802, 0.6379517571669422, 0.6649299562973638, 0.6751662617832521, 0.5698959020651628, 0.6862443280752148, 0.6077096877907738, 0.5795845070444767, 0.6156680298470962, 0.6547698193877232, 0.1082397586119096, 0.10323416644784811, 0.12559244744161646, 0.10298217514026708, 0.0933109940089033, 0.11775990215148102, 0.11363574703588764, 0.09650903985896331, 0.14820465880160139, 0.3834603965053327, 0.34481280774675394, 0.4010577815741404, 0.19422626446282976, 0.2729298436307719, 0.2761899371987194, 0.1777755692515629, 0.2422830155591138, 0.23416760359540012, 0.33604155653698986, 0.3811556010545817, 0.35393817908157166, 0.3750683894174536, 0.3988455104284432, 0.3946042466474484, 0.4022322554968394, 0.42031193819883605, 0.4371316377873542, 0.1725383154339757, 0.27441122794914063, 0.2532439756394066, 0.11182874270090393, 0.24630829265044074, 0.3424824794592507, 0.3766684409777471, 0.35934252132591527, 0.30375256274217377, 0.1853628930328035, 0.2020992551131091, 0.21560373708751335, 0.2021110785371859, 0.21993003673015032, 0.21873043749008192, 0.2235131809611568, 0.21724915967738478, 0.18997258971205055, 0.19590791284502185, 0.5374876741736323, 0.21580304721360255, 0.41132549888346215, 0.19526696305982605, 0.2925986263180236, 0.19506805084476786, 0.3393638970945322, 0.5332288482735585, 0.17672353211148806, 0.8252326143474427, 0.40413354890099906, 0.8295321637848274, 0.20562994124795353, 0.8351780430042832, 0.16768523981948946, 0.19302505377768897, 0.7023916340695845, 0.710536378427561, 0.16612654256490855, 0.5241607165639575, 0.20545638562809854, 0.20941070597372213, 0.2083580743829263, 0.7716645414970508, 0.6034119509785918, 0.38936040472162226, 0.2139643062833979, 0.18817941552431716, 0.2010599338675454, 0.19453918592284458, 0.19702382711688549, 0.21007787279732126, 0.1877514139742641, 0.19017559058072953, 0.1878053314874828, 0.12035377883845433, 0.09606895421060124, 0.07837110372999234, 0.11518077502943214, 0.06943275095731083, 0.0703962852599197, 0.08483491914843666, 0.08364825891866312, 0.08621767240883549]}, "mutation_prompt": null}
{"id": "2087af1a-ff6f-40c0-92c5-285608e195d4", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = min(60, max(12, int(0.12 * dim)))\n        self.de_size = self.swarm_size\n        self.particles = np.random.uniform(-5, 5, (self.swarm_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, dim))\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_scores = np.full((self.swarm_size,), np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.de_population = np.random.uniform(-5, 5, (self.de_size, dim))\n        self.population_scores = np.full((self.de_size,), np.inf)\n        self.c1 = 1.6\n        self.c2 = 1.4\n        self.inertia_weight = 0.6\n        self.mutation_factor = 0.85\n        self.crossover_probability = 0.85\n        self.evaluations = 0\n        self.adaptive_factor = 0.025\n        self.rank_probability = 0.5\n        self.initial_velocity_clamp = 0.5\n        self.mutation_adapt_factor = 0.02\n        self.crossover_adapt_factor = 0.02\n\n    def adapt_parameters(self):\n        if self.global_best_score < np.inf:\n            self.inertia_weight = max(0.3, self.inertia_weight * (1 - self.adaptive_factor))\n            self.c1 = min(2.2, self.c1 * (1 + self.adaptive_factor))\n            self.c2 = min(2.2, self.c2 * (1 + self.adaptive_factor))\n            self.rank_probability = max(0.4, min(0.6, self.rank_probability * (1 + self.adaptive_factor)))\n            self.mutation_factor = min(1.0, self.mutation_factor * (1 + self.mutation_adapt_factor * (np.random.rand() - 0.5)))\n            self.crossover_probability = min(1.0, self.crossover_probability * (1 + self.crossover_adapt_factor * (np.random.rand() - 0.5)))\n\n    def stochastic_ranking(self, scores):\n        idx = np.argsort(scores)\n        for i in range(len(scores) - 1):\n            if np.random.uniform() < self.rank_probability:\n                if scores[idx[i]] > scores[idx[i + 1]]:\n                    idx[i], idx[i + 1] = idx[i + 1], idx[i]\n        return idx\n\n    def optimize_particle_swarm(self, func):\n        velocity_clamp = self.initial_velocity_clamp * (1 - self.evaluations / self.budget)\n        for i in range(self.swarm_size):\n            score = func(self.particles[i])\n            self.evaluations += 1\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i].copy()\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i].copy()\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best_position - self.particles[i]))\n            self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], -5, 5)\n\n    def optimize_differential_evolution(self, func):\n        ranks = self.stochastic_ranking(self.population_scores)\n        for i in ranks:\n            candidates = list(range(self.de_size))\n            candidates.remove(i)\n            a, b, c = self.de_population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.de_population[i])\n            score = func(trial)\n            self.evaluations += 1\n            if score < self.population_scores[i]:\n                self.population_scores[i] = score\n                self.de_population[i] = trial\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.adapt_parameters()\n            self.optimize_particle_swarm(func)\n            self.optimize_differential_evolution(func)\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE with adaptive mutation and crossover rates improves convergence by dynamically adjusting exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "659d7749-d131-4c7d-be9f-10dc67653112", "metadata": {"aucs": [0.8998945180694712, 0.8902002557641091, 0.9212349485766868, 0.8681492971535658, 0.8572574383764152, 0.9016248385727959, 0.8842473912702308, 0.8891096527884909, 0.8911571495709095, 0.7983291877464745, 0.733567286343755, 0.752387537432085, 0.739759804353586, 0.6785758513656763, 0.7628045281441611, 0.7854593803800396, 0.8024023714122792, 0.7103627818815873, 0.20738218861881808, 0.5923144543434382, 0.37082146922519355, 0.1880141523447434, 0.14281230864275896, 0.4461232238348817, 0.14662091179018988, 0.1594025265699447, 0.30715292470858435, 0.1803123773846742, 0.12716373707680217, 0.12364252945565235, 0.12545473697041565, 0.16541537083535207, 0.2602956193295337, 0.5323334928108101, 0.1030301920241995, 0.11093138992331564, 0.9771942457856292, 0.9609862302812318, 0.9649646376394656, 0.971913004996268, 0.9703772904759398, 0.9614104755503529, 0.9529615389860371, 0.9674524734367191, 0.9682553732528308, 0.5825206480292728, 0.5606915745376961, 0.5770862191538124, 0.5813233622197764, 0.5998144801152543, 0.6042735415365097, 0.5960797327077481, 0.46737528244546533, 0.48252674916240734, 0.778657130052306, 0.6898089579036919, 0.3444822189229658, 0.7151599393020203, 0.15694394588044835, 0.7778007893956185, 0.6129072802167704, 0.772600512666501, 0.6998796016469355, 0.4648482978021823, 0.27551308717738343, 0.19433185092137617, 0.35177399273412, 0.3897337614725319, 0.1582424179926345, 0.34048827938849846, 0.19123989466459212, 0.26343072226212805, 0.26988902508687274, 0.2629468847562856, 0.200692545360725, 0.368197180054028, 0.5085382536167644, 0.5281207733582303, 0.3104222591154274, 0.20701570422557303, 0.2231077951219681, 9.999999999998899e-05, 0.07994681241807045, 0.024659083667560866, 0.1686593438156786, 0.08179727787508873, 0.1752501764084482, 0.12650600752361807, 0.038110020002194656, 0.06707061553348936, 0.1894397814537696, 0.13712905789004248, 0.2689876715557763, 0.16516743646930354, 0.23855820179862963, 0.30085099234284696, 0.11195198918239546, 0.16268969717129056, 0.1657521757159548, 0.15514723553726595, 0.16179294102141173, 0.2590780270162971, 0.19044345569440857, 0.16945441910487657, 0.10876281467709281, 0.1542813919229037, 0.16390331931887214, 0.14995037166832914, 0.2506053984462182, 0.28053082270396534, 0.30450689670875253, 0.25250216267239733, 0.3587496822989389, 0.30947124513938007, 0.24159796320780458, 0.2598491710998021, 0.2705249147178802, 0.6379517571669422, 0.6649299562973638, 0.6751662617832521, 0.5698959020651628, 0.6862443280752148, 0.6077096877907738, 0.5795845070444767, 0.6156680298470962, 0.6547698193877232, 0.1082397586119096, 0.10323416644784811, 0.12559244744161646, 0.10298217514026708, 0.0933109940089033, 0.11775990215148102, 0.11363574703588764, 0.09650903985896331, 0.14820465880160139, 0.3834603965053327, 0.34481280774675394, 0.4010577815741404, 0.19422626446282976, 0.2729298436307719, 0.2761899371987194, 0.1777755692515629, 0.2422830155591138, 0.23416760359540012, 0.33604155653698986, 0.3811556010545817, 0.35393817908157166, 0.3750683894174536, 0.3988455104284432, 0.3946042466474484, 0.4022322554968394, 0.42031193819883605, 0.4371316377873542, 0.1725383154339757, 0.27441122794914063, 0.2532439756394066, 0.11182874270090393, 0.24630829265044074, 0.3424824794592507, 0.3766684409777471, 0.35934252132591527, 0.30375256274217377, 0.1853628930328035, 0.2020992551131091, 0.21560373708751335, 0.2021110785371859, 0.21993003673015032, 0.21873043749008192, 0.2235131809611568, 0.21724915967738478, 0.18997258971205055, 0.19590791284502185, 0.5374876741736323, 0.21580304721360255, 0.41132549888346215, 0.19526696305982605, 0.2925986263180236, 0.19506805084476786, 0.3393638970945322, 0.5332288482735585, 0.17672353211148806, 0.8252326143474427, 0.40413354890099906, 0.8295321637848274, 0.20562994124795353, 0.8351780430042832, 0.16768523981948946, 0.19302505377768897, 0.7023916340695845, 0.710536378427561, 0.16612654256490855, 0.5241607165639575, 0.20545638562809854, 0.20941070597372213, 0.2083580743829263, 0.7716645414970508, 0.6034119509785918, 0.38936040472162226, 0.2139643062833979, 0.18817941552431716, 0.2010599338675454, 0.19453918592284458, 0.19702382711688549, 0.21007787279732126, 0.1877514139742641, 0.19017559058072953, 0.1878053314874828, 0.12035377883845433, 0.09606895421060124, 0.07837110372999234, 0.11518077502943214, 0.06943275095731083, 0.0703962852599197, 0.08483491914843666, 0.08364825891866312, 0.08621767240883549]}, "mutation_prompt": null}
