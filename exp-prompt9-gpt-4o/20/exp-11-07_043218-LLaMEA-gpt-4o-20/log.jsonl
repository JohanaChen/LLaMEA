{"id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 0, "fitness": 0.27303003247911445, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "eff60f41-3818-43d1-b3b6-d992af0b5ed2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "cd824599-5441-4796-a3cf-252853c90022", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "0cb6d7aa-c846-42ad-971d-83638810a6ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "6061d6de-35dd-42be-a9da-1341b5d9f988", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "bf25ce67-a7c3-4afe-a95e-cd630eb8078a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "24e8a3d9-57ad-4ff7-80c4-e550200d6fec", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "98c1a4af-818e-451e-85a4-d7639882849b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "396c1169-efbf-44fe-a826-5a57e17815e4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "1c163cb3-821a-4d50-ae4b-d57c048dd63b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "4ab60a06-de43-4550-a91a-7665565c9401", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "3a7c8e8d-0452-42ae-acb3-f3eff210e462", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "2691fff4-62bb-41b2-af8d-a462e56699c4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "ae509d6e-3bee-44c5-bef8-b15c9737a296", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "a9569f49-ec1b-48d0-9367-8445d0cc0f2d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "320c4d6f-84cb-495e-b0a9-a0c7a5209bc6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "b6874cd6-9440-491a-801c-ec68871f1f55", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "355b5f31-9876-4fa0-ba81-48e4b123f492", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "b4dafbfb-e8aa-4a35-90d7-e2f3058cb706", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "e446ed88-29d7-4027-b3ff-4c1087b747f0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "954fca56-7f9b-4dd3-84f8-fad5e586638a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "ecf898ed-f345-4a4c-b36c-42e6b64a0d7f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveDifferentialEvolution", "description": "An Adaptive Differential Evolution algorithm with dynamic population resizing and mutation strategy adaptation for versatile black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.7273825629322098, 0.6875736973576255, 0.6824686559765828, 0.7122509711280722, 0.7002292835405651, 0.7182969758461606, 0.7297218380437651, 0.7322012292605913, 0.7120637403518493, 0.48072016918165983, 0.47963735327600976, 0.46865706954531516, 0.47126944940538473, 0.450877099375409, 0.4471186398237743, 0.49643896584456326, 0.4555975541327816, 0.4748517538621656, 0.11646671877410064, 0.1254499128523785, 0.1300856216654802, 0.1251303776595909, 0.11201411296137798, 0.11580464970483595, 0.11388537264340814, 0.13077464740356226, 0.12570292433420527, 0.10518873443988708, 0.12040859767306133, 0.10999127844984302, 0.11428790632285823, 0.11878941224220285, 0.1095116677643786, 0.11872938614462669, 0.11901812398383305, 0.11092221446100137, 0.9616402496994138, 0.9745640468396699, 0.9685557844149046, 0.9425106755734033, 0.9474240942484089, 0.9516209653276564, 0.9964492681520407, 0.9539605402258748, 0.9390835003767126, 0.3148863665755861, 0.3084195577435306, 0.30592703461433135, 0.3033539872389849, 0.30434741804454046, 0.30334487037163527, 0.30494259894128795, 0.32334650922225894, 0.27315875141805157, 0.41934811194455435, 0.4460306386188061, 0.4212861607120323, 0.6246467312013544, 0.513880841304087, 0.4939495452402217, 0.5076090136579646, 0.5548342212072132, 0.47185230634997866, 0.21182709203661187, 0.19098569206523586, 0.17745691608768954, 0.19771557407903673, 0.19124201584982015, 0.1713228410884714, 0.22699994978914573, 0.21142967429053616, 0.1682908298876178, 0.20711277829547858, 0.16187012029442538, 0.12467641158472487, 0.17287763338187656, 0.20935169631660633, 0.2116256228521991, 0.21353173123794822, 0.1907495424146316, 0.18108081776807883, 0.085294375119502, 0.09799178733040903, 0.08469356007464979, 0.07976017842829408, 0.09957169066008298, 0.06759151399375274, 0.07935718140793546, 0.07439808357427757, 0.07077230287083802, 0.1444486301984007, 0.2331245243823865, 0.17937195801524308, 0.17885087529600718, 0.17830731350354667, 0.15660592831062836, 0.2232619929510351, 0.2129135481856066, 0.1870606631252224, 0.021608690078594783, 0.008415422023785535, 0.015094951736489004, 0.027477670108712493, 0.04655544909459408, 0.02770852969098292, 0.02743735862507113, 0.042146692884960424, 0.013297411399978976, 0.15191631178907683, 0.15205787408077198, 0.13740650897914997, 0.1485997795879186, 0.16543812504155886, 0.15959774566411344, 0.14033900614335015, 0.1529223185290357, 0.14241774559440679, 0.48362047409025233, 0.4913574157138706, 0.47104092825625155, 0.48007148767166685, 0.5225310068467911, 0.4943594614372574, 0.4816881735881089, 0.5073981100328252, 0.48933838495520776, 0.09440871792245031, 0.08856807790171095, 0.09726213955223162, 0.0845935341432611, 0.09800859475266499, 0.08584855586586304, 0.09290025760962728, 0.09449686760566489, 0.10361678055354584, 0.16555467717593897, 0.13828071544166765, 0.14896603274526532, 0.1440501322587241, 0.14637636944319743, 0.15963251579191673, 0.1514268226338722, 0.13048989382387377, 0.15242046668301956, 0.2911433934917116, 0.2765068015230273, 0.28852567449264865, 0.2608628808070331, 0.2964583207382854, 0.2901397704783404, 0.2928112352019373, 0.3246262354606855, 0.31061440682486463, 0.19439962062010896, 0.22294543825662416, 0.2043589946583646, 0.19671387727030565, 0.19668857411614837, 0.19786100464278422, 0.22596248152745124, 0.22829534357756553, 0.20999606238017154, 0.17862048777273487, 0.1840242100160906, 0.19517937026984555, 0.19778457353692425, 0.18771624067858816, 0.16165752810729517, 0.17234995674315545, 0.17587034843579386, 0.1728335222703703, 0.1853305945098528, 0.19245040765919375, 0.18383825959398137, 0.20517302225390743, 0.19520402676571857, 0.1869674328120654, 0.18210178137675515, 0.18279852680284925, 0.1979848115802494, 0.47467760085915756, 0.388105217893858, 0.5539868261786592, 0.1743165782575119, 0.15256750989993362, 0.27599277084474894, 0.17390766390997725, 0.17400085980765723, 0.45755064209015817, 0.16398496594641088, 0.343980963363672, 0.4627977017225703, 0.18932125103396225, 0.17769061168632327, 0.30240076101493807, 0.5416417789197234, 0.6387669801399511, 0.5321757582168298, 0.18647398038756302, 0.18127753524150425, 0.18717689980106034, 0.17513181575068737, 0.18247093180564633, 0.1936062349008526, 0.18754587344686002, 0.19203809688417517, 0.18506719246640446, 0.07987862675894009, 0.07610641777616789, 0.0748060391513069, 0.07407883608488719, 0.07693976702632777, 0.0652416175322762, 0.0775623340514876, 0.07188563869234021, 0.06977782876391303]}, "mutation_prompt": null}
{"id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.2  # New parameter for hybrid mutation strategy\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.1:  # Population size adaptation\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population control and hybrid mutation strategies for improved performance on diverse optimization landscapes.", "configspace": "", "generation": 22, "fitness": 0.27831363237002305, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "4a3cb7da-82b7-44ef-affa-3d94c9290267", "metadata": {"aucs": [0.720168223319482, 0.7561789327031998, 0.6843118920909561, 0.7265332545646994, 0.7553163264258591, 0.7062005763767172, 0.708889748889602, 0.7610838442968919, 0.6926108296733915, 0.5191054236586509, 0.5659053774892747, 0.49003588675352083, 0.5055161683170114, 0.5640656531590087, 0.497032917982139, 0.5195745584228257, 0.5839202728703865, 0.4767307121274825, 0.12540847436578528, 0.12163591679154628, 0.12464319547768066, 0.1625143264200022, 0.13141833907763956, 0.13958114142613687, 0.14335170849270418, 0.13000652007360458, 0.12158977559700146, 0.10951404459772729, 0.1237279904233376, 0.1084100558244474, 0.11654655694647931, 0.11954491004064371, 0.11793232259617781, 0.11453330631956504, 0.12252830722835173, 0.11618272935416407, 0.9311421234097502, 0.9399964629155679, 0.9461505542574293, 0.9432302732562675, 0.900809383709063, 0.96368849967082, 0.9510170382559352, 0.9559675672872279, 0.9407736418619157, 0.3130348383286087, 0.3323094456446699, 0.28477446211105584, 0.33450198676214726, 0.3423081885701478, 0.2980626031516015, 0.3111815897507514, 0.31966833297769925, 0.2742916892054905, 0.4162267203002751, 0.653538846953315, 0.45379836723375433, 0.6184813575956511, 0.5934566658940597, 0.4530519595112672, 0.5465826760258665, 0.6289307927570875, 0.5297072679437024, 0.18731385837364056, 0.1867490809752288, 0.1846758822090444, 0.17434083526740196, 0.20006679300073305, 0.1659500384847119, 0.18643029681062984, 0.19806903331182746, 0.16847167711648758, 0.11821247592569384, 0.1580049912075363, 0.17476076220047654, 0.20959683310675858, 0.17545336048860372, 0.1454912379207295, 0.1919143235953602, 0.18946421924925794, 0.1663422952429977, 0.09632465206060481, 0.1269451481382694, 0.08017802292424747, 0.08853503073658264, 0.0916956083253031, 0.061028516666099875, 0.08130243172429785, 0.10224559402207234, 0.05851515080699832, 0.18714359731801455, 0.2311844240101203, 0.19732072210201745, 0.17865842545373767, 0.23207037877412062, 0.1646494754675819, 0.2521887550560018, 0.2566613973268467, 0.2055701197015397, 0.027435485320603026, 0.07780363736195561, 0.018901603005358814, 0.020440440210955924, 0.023281996270887118, 0.031263316288994925, 0.024615544230557118, 0.05614659559517732, 0.015505313085820482, 0.14355645516451, 0.1685823850792484, 0.15499380894164094, 0.16633145222042878, 0.18067442908808062, 0.14340416807138878, 0.14876217598098795, 0.15899325554590782, 0.1322169586560491, 0.5381212365531007, 0.5373356460245393, 0.48867792684347566, 0.4904473760538818, 0.5418648325050102, 0.49561581797942866, 0.5159045154188855, 0.5200744343355441, 0.4858861004282138, 0.08931763943316529, 0.10503663296585386, 0.08091469623998926, 0.10147355489880316, 0.09401106286330108, 0.10079115912754655, 0.09094558165735545, 0.10301053523516746, 0.09286942223819827, 0.13790093147283455, 0.1368167685937688, 0.1550508628092444, 0.13594392654142995, 0.15080083436885394, 0.15499266673535073, 0.13268103628103622, 0.16622943927763334, 0.13952455444305556, 0.30424474731605256, 0.29777366688151774, 0.28290438251792804, 0.2932308310144941, 0.3010085074101454, 0.26143639582777367, 0.3236689887198869, 0.3558445833090451, 0.30604939614563464, 0.21454058519617536, 0.2188342132701303, 0.21715295891602315, 0.21052308125214825, 0.23283275381839652, 0.21386454342120165, 0.20653564555122683, 0.2653445925020719, 0.20154554173799488, 0.1930503054129471, 0.20316879168538493, 0.18260262734974153, 0.18852265580007566, 0.19075892985111276, 0.18900015890646316, 0.20472096755691604, 0.21552635221167404, 0.20156136785610723, 0.19003833564115025, 0.201890199128277, 0.19776869832832922, 0.19221810634225756, 0.20327681794994967, 0.184804488712482, 0.21197492897906456, 0.18048770234661682, 0.19582765381605427, 0.5228589386628666, 0.17169770224031455, 0.22251235012997794, 0.43977872672385354, 0.347144656006835, 0.5030203562964188, 0.16726694392691277, 0.17052073080924401, 0.32375428902408177, 0.1517069646287198, 0.5930364044493026, 0.18469529842525712, 0.1703593989330051, 0.30511054342158495, 0.17933890414954035, 0.19910268833887734, 0.6435909268877074, 0.20552039181276527, 0.17920903829106882, 0.18942950799717295, 0.20581811028694752, 0.18006608931446988, 0.19340780287457116, 0.1760651363770297, 0.18976011579974017, 0.17264251995134905, 0.18647122241407044, 0.0680302275755561, 0.07842327821515993, 0.07315200215750306, 0.08344935204841308, 0.08823152575967019, 0.07269084634642364, 0.07790973360653008, 0.07544472762718046, 0.08238542567238549]}, "mutation_prompt": null}
{"id": "d41b55f0-a0db-4957-b2c8-4a62c646ea54", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.2  # New parameter for hybrid mutation strategy\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.1:  # Population size adaptation\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population control and hybrid mutation strategies for improved performance on diverse optimization landscapes.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "metadata": {"aucs": [0.720168223319482, 0.7561789327031998, 0.6843118920909561, 0.7265332545646994, 0.7553163264258591, 0.7062005763767172, 0.708889748889602, 0.7610838442968919, 0.6926108296733915, 0.5191054236586509, 0.5659053774892747, 0.49003588675352083, 0.5055161683170114, 0.5640656531590087, 0.497032917982139, 0.5195745584228257, 0.5839202728703865, 0.4767307121274825, 0.12540847436578528, 0.12163591679154628, 0.12464319547768066, 0.1625143264200022, 0.13141833907763956, 0.13958114142613687, 0.14335170849270418, 0.13000652007360458, 0.12158977559700146, 0.10951404459772729, 0.1237279904233376, 0.1084100558244474, 0.11654655694647931, 0.11954491004064371, 0.11793232259617781, 0.11453330631956504, 0.12252830722835173, 0.11618272935416407, 0.9311421234097502, 0.9399964629155679, 0.9461505542574293, 0.9432302732562675, 0.900809383709063, 0.96368849967082, 0.9510170382559352, 0.9559675672872279, 0.9407736418619157, 0.3130348383286087, 0.3323094456446699, 0.28477446211105584, 0.33450198676214726, 0.3423081885701478, 0.2980626031516015, 0.3111815897507514, 0.31966833297769925, 0.2742916892054905, 0.4162267203002751, 0.653538846953315, 0.45379836723375433, 0.6184813575956511, 0.5934566658940597, 0.4530519595112672, 0.5465826760258665, 0.6289307927570875, 0.5297072679437024, 0.18731385837364056, 0.1867490809752288, 0.1846758822090444, 0.17434083526740196, 0.20006679300073305, 0.1659500384847119, 0.18643029681062984, 0.19806903331182746, 0.16847167711648758, 0.11821247592569384, 0.1580049912075363, 0.17476076220047654, 0.20959683310675858, 0.17545336048860372, 0.1454912379207295, 0.1919143235953602, 0.18946421924925794, 0.1663422952429977, 0.09632465206060481, 0.1269451481382694, 0.08017802292424747, 0.08853503073658264, 0.0916956083253031, 0.061028516666099875, 0.08130243172429785, 0.10224559402207234, 0.05851515080699832, 0.18714359731801455, 0.2311844240101203, 0.19732072210201745, 0.17865842545373767, 0.23207037877412062, 0.1646494754675819, 0.2521887550560018, 0.2566613973268467, 0.2055701197015397, 0.027435485320603026, 0.07780363736195561, 0.018901603005358814, 0.020440440210955924, 0.023281996270887118, 0.031263316288994925, 0.024615544230557118, 0.05614659559517732, 0.015505313085820482, 0.14355645516451, 0.1685823850792484, 0.15499380894164094, 0.16633145222042878, 0.18067442908808062, 0.14340416807138878, 0.14876217598098795, 0.15899325554590782, 0.1322169586560491, 0.5381212365531007, 0.5373356460245393, 0.48867792684347566, 0.4904473760538818, 0.5418648325050102, 0.49561581797942866, 0.5159045154188855, 0.5200744343355441, 0.4858861004282138, 0.08931763943316529, 0.10503663296585386, 0.08091469623998926, 0.10147355489880316, 0.09401106286330108, 0.10079115912754655, 0.09094558165735545, 0.10301053523516746, 0.09286942223819827, 0.13790093147283455, 0.1368167685937688, 0.1550508628092444, 0.13594392654142995, 0.15080083436885394, 0.15499266673535073, 0.13268103628103622, 0.16622943927763334, 0.13952455444305556, 0.30424474731605256, 0.29777366688151774, 0.28290438251792804, 0.2932308310144941, 0.3010085074101454, 0.26143639582777367, 0.3236689887198869, 0.3558445833090451, 0.30604939614563464, 0.21454058519617536, 0.2188342132701303, 0.21715295891602315, 0.21052308125214825, 0.23283275381839652, 0.21386454342120165, 0.20653564555122683, 0.2653445925020719, 0.20154554173799488, 0.1930503054129471, 0.20316879168538493, 0.18260262734974153, 0.18852265580007566, 0.19075892985111276, 0.18900015890646316, 0.20472096755691604, 0.21552635221167404, 0.20156136785610723, 0.19003833564115025, 0.201890199128277, 0.19776869832832922, 0.19221810634225756, 0.20327681794994967, 0.184804488712482, 0.21197492897906456, 0.18048770234661682, 0.19582765381605427, 0.5228589386628666, 0.17169770224031455, 0.22251235012997794, 0.43977872672385354, 0.347144656006835, 0.5030203562964188, 0.16726694392691277, 0.17052073080924401, 0.32375428902408177, 0.1517069646287198, 0.5930364044493026, 0.18469529842525712, 0.1703593989330051, 0.30511054342158495, 0.17933890414954035, 0.19910268833887734, 0.6435909268877074, 0.20552039181276527, 0.17920903829106882, 0.18942950799717295, 0.20581811028694752, 0.18006608931446988, 0.19340780287457116, 0.1760651363770297, 0.18976011579974017, 0.17264251995134905, 0.18647122241407044, 0.0680302275755561, 0.07842327821515993, 0.07315200215750306, 0.08344935204841308, 0.08823152575967019, 0.07269084634642364, 0.07790973360653008, 0.07544472762718046, 0.08238542567238549]}, "mutation_prompt": null}
{"id": "4149cd14-90d7-4e4e-b678-e6f2bb50b570", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.2  # New parameter for hybrid mutation strategy\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.1:  # Population size adaptation\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population control and hybrid mutation strategies for improved performance on diverse optimization landscapes.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "metadata": {"aucs": [0.720168223319482, 0.7561789327031998, 0.6843118920909561, 0.7265332545646994, 0.7553163264258591, 0.7062005763767172, 0.708889748889602, 0.7610838442968919, 0.6926108296733915, 0.5191054236586509, 0.5659053774892747, 0.49003588675352083, 0.5055161683170114, 0.5640656531590087, 0.497032917982139, 0.5195745584228257, 0.5839202728703865, 0.4767307121274825, 0.12540847436578528, 0.12163591679154628, 0.12464319547768066, 0.1625143264200022, 0.13141833907763956, 0.13958114142613687, 0.14335170849270418, 0.13000652007360458, 0.12158977559700146, 0.10951404459772729, 0.1237279904233376, 0.1084100558244474, 0.11654655694647931, 0.11954491004064371, 0.11793232259617781, 0.11453330631956504, 0.12252830722835173, 0.11618272935416407, 0.9311421234097502, 0.9399964629155679, 0.9461505542574293, 0.9432302732562675, 0.900809383709063, 0.96368849967082, 0.9510170382559352, 0.9559675672872279, 0.9407736418619157, 0.3130348383286087, 0.3323094456446699, 0.28477446211105584, 0.33450198676214726, 0.3423081885701478, 0.2980626031516015, 0.3111815897507514, 0.31966833297769925, 0.2742916892054905, 0.4162267203002751, 0.653538846953315, 0.45379836723375433, 0.6184813575956511, 0.5934566658940597, 0.4530519595112672, 0.5465826760258665, 0.6289307927570875, 0.5297072679437024, 0.18731385837364056, 0.1867490809752288, 0.1846758822090444, 0.17434083526740196, 0.20006679300073305, 0.1659500384847119, 0.18643029681062984, 0.19806903331182746, 0.16847167711648758, 0.11821247592569384, 0.1580049912075363, 0.17476076220047654, 0.20959683310675858, 0.17545336048860372, 0.1454912379207295, 0.1919143235953602, 0.18946421924925794, 0.1663422952429977, 0.09632465206060481, 0.1269451481382694, 0.08017802292424747, 0.08853503073658264, 0.0916956083253031, 0.061028516666099875, 0.08130243172429785, 0.10224559402207234, 0.05851515080699832, 0.18714359731801455, 0.2311844240101203, 0.19732072210201745, 0.17865842545373767, 0.23207037877412062, 0.1646494754675819, 0.2521887550560018, 0.2566613973268467, 0.2055701197015397, 0.027435485320603026, 0.07780363736195561, 0.018901603005358814, 0.020440440210955924, 0.023281996270887118, 0.031263316288994925, 0.024615544230557118, 0.05614659559517732, 0.015505313085820482, 0.14355645516451, 0.1685823850792484, 0.15499380894164094, 0.16633145222042878, 0.18067442908808062, 0.14340416807138878, 0.14876217598098795, 0.15899325554590782, 0.1322169586560491, 0.5381212365531007, 0.5373356460245393, 0.48867792684347566, 0.4904473760538818, 0.5418648325050102, 0.49561581797942866, 0.5159045154188855, 0.5200744343355441, 0.4858861004282138, 0.08931763943316529, 0.10503663296585386, 0.08091469623998926, 0.10147355489880316, 0.09401106286330108, 0.10079115912754655, 0.09094558165735545, 0.10301053523516746, 0.09286942223819827, 0.13790093147283455, 0.1368167685937688, 0.1550508628092444, 0.13594392654142995, 0.15080083436885394, 0.15499266673535073, 0.13268103628103622, 0.16622943927763334, 0.13952455444305556, 0.30424474731605256, 0.29777366688151774, 0.28290438251792804, 0.2932308310144941, 0.3010085074101454, 0.26143639582777367, 0.3236689887198869, 0.3558445833090451, 0.30604939614563464, 0.21454058519617536, 0.2188342132701303, 0.21715295891602315, 0.21052308125214825, 0.23283275381839652, 0.21386454342120165, 0.20653564555122683, 0.2653445925020719, 0.20154554173799488, 0.1930503054129471, 0.20316879168538493, 0.18260262734974153, 0.18852265580007566, 0.19075892985111276, 0.18900015890646316, 0.20472096755691604, 0.21552635221167404, 0.20156136785610723, 0.19003833564115025, 0.201890199128277, 0.19776869832832922, 0.19221810634225756, 0.20327681794994967, 0.184804488712482, 0.21197492897906456, 0.18048770234661682, 0.19582765381605427, 0.5228589386628666, 0.17169770224031455, 0.22251235012997794, 0.43977872672385354, 0.347144656006835, 0.5030203562964188, 0.16726694392691277, 0.17052073080924401, 0.32375428902408177, 0.1517069646287198, 0.5930364044493026, 0.18469529842525712, 0.1703593989330051, 0.30511054342158495, 0.17933890414954035, 0.19910268833887734, 0.6435909268877074, 0.20552039181276527, 0.17920903829106882, 0.18942950799717295, 0.20581811028694752, 0.18006608931446988, 0.19340780287457116, 0.1760651363770297, 0.18976011579974017, 0.17264251995134905, 0.18647122241407044, 0.0680302275755561, 0.07842327821515993, 0.07315200215750306, 0.08344935204841308, 0.08823152575967019, 0.07269084634642364, 0.07790973360653008, 0.07544472762718046, 0.08238542567238549]}, "mutation_prompt": null}
{"id": "2fcf53f2-ea15-4c2f-9a70-92ff4e6e5e75", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.2  # New parameter for hybrid mutation strategy\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.1:  # Population size adaptation\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population control and hybrid mutation strategies for improved performance on diverse optimization landscapes.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "metadata": {"aucs": [0.720168223319482, 0.7561789327031998, 0.6843118920909561, 0.7265332545646994, 0.7553163264258591, 0.7062005763767172, 0.708889748889602, 0.7610838442968919, 0.6926108296733915, 0.5191054236586509, 0.5659053774892747, 0.49003588675352083, 0.5055161683170114, 0.5640656531590087, 0.497032917982139, 0.5195745584228257, 0.5839202728703865, 0.4767307121274825, 0.12540847436578528, 0.12163591679154628, 0.12464319547768066, 0.1625143264200022, 0.13141833907763956, 0.13958114142613687, 0.14335170849270418, 0.13000652007360458, 0.12158977559700146, 0.10951404459772729, 0.1237279904233376, 0.1084100558244474, 0.11654655694647931, 0.11954491004064371, 0.11793232259617781, 0.11453330631956504, 0.12252830722835173, 0.11618272935416407, 0.9311421234097502, 0.9399964629155679, 0.9461505542574293, 0.9432302732562675, 0.900809383709063, 0.96368849967082, 0.9510170382559352, 0.9559675672872279, 0.9407736418619157, 0.3130348383286087, 0.3323094456446699, 0.28477446211105584, 0.33450198676214726, 0.3423081885701478, 0.2980626031516015, 0.3111815897507514, 0.31966833297769925, 0.2742916892054905, 0.4162267203002751, 0.653538846953315, 0.45379836723375433, 0.6184813575956511, 0.5934566658940597, 0.4530519595112672, 0.5465826760258665, 0.6289307927570875, 0.5297072679437024, 0.18731385837364056, 0.1867490809752288, 0.1846758822090444, 0.17434083526740196, 0.20006679300073305, 0.1659500384847119, 0.18643029681062984, 0.19806903331182746, 0.16847167711648758, 0.11821247592569384, 0.1580049912075363, 0.17476076220047654, 0.20959683310675858, 0.17545336048860372, 0.1454912379207295, 0.1919143235953602, 0.18946421924925794, 0.1663422952429977, 0.09632465206060481, 0.1269451481382694, 0.08017802292424747, 0.08853503073658264, 0.0916956083253031, 0.061028516666099875, 0.08130243172429785, 0.10224559402207234, 0.05851515080699832, 0.18714359731801455, 0.2311844240101203, 0.19732072210201745, 0.17865842545373767, 0.23207037877412062, 0.1646494754675819, 0.2521887550560018, 0.2566613973268467, 0.2055701197015397, 0.027435485320603026, 0.07780363736195561, 0.018901603005358814, 0.020440440210955924, 0.023281996270887118, 0.031263316288994925, 0.024615544230557118, 0.05614659559517732, 0.015505313085820482, 0.14355645516451, 0.1685823850792484, 0.15499380894164094, 0.16633145222042878, 0.18067442908808062, 0.14340416807138878, 0.14876217598098795, 0.15899325554590782, 0.1322169586560491, 0.5381212365531007, 0.5373356460245393, 0.48867792684347566, 0.4904473760538818, 0.5418648325050102, 0.49561581797942866, 0.5159045154188855, 0.5200744343355441, 0.4858861004282138, 0.08931763943316529, 0.10503663296585386, 0.08091469623998926, 0.10147355489880316, 0.09401106286330108, 0.10079115912754655, 0.09094558165735545, 0.10301053523516746, 0.09286942223819827, 0.13790093147283455, 0.1368167685937688, 0.1550508628092444, 0.13594392654142995, 0.15080083436885394, 0.15499266673535073, 0.13268103628103622, 0.16622943927763334, 0.13952455444305556, 0.30424474731605256, 0.29777366688151774, 0.28290438251792804, 0.2932308310144941, 0.3010085074101454, 0.26143639582777367, 0.3236689887198869, 0.3558445833090451, 0.30604939614563464, 0.21454058519617536, 0.2188342132701303, 0.21715295891602315, 0.21052308125214825, 0.23283275381839652, 0.21386454342120165, 0.20653564555122683, 0.2653445925020719, 0.20154554173799488, 0.1930503054129471, 0.20316879168538493, 0.18260262734974153, 0.18852265580007566, 0.19075892985111276, 0.18900015890646316, 0.20472096755691604, 0.21552635221167404, 0.20156136785610723, 0.19003833564115025, 0.201890199128277, 0.19776869832832922, 0.19221810634225756, 0.20327681794994967, 0.184804488712482, 0.21197492897906456, 0.18048770234661682, 0.19582765381605427, 0.5228589386628666, 0.17169770224031455, 0.22251235012997794, 0.43977872672385354, 0.347144656006835, 0.5030203562964188, 0.16726694392691277, 0.17052073080924401, 0.32375428902408177, 0.1517069646287198, 0.5930364044493026, 0.18469529842525712, 0.1703593989330051, 0.30511054342158495, 0.17933890414954035, 0.19910268833887734, 0.6435909268877074, 0.20552039181276527, 0.17920903829106882, 0.18942950799717295, 0.20581811028694752, 0.18006608931446988, 0.19340780287457116, 0.1760651363770297, 0.18976011579974017, 0.17264251995134905, 0.18647122241407044, 0.0680302275755561, 0.07842327821515993, 0.07315200215750306, 0.08344935204841308, 0.08823152575967019, 0.07269084634642364, 0.07790973360653008, 0.07544472762718046, 0.08238542567238549]}, "mutation_prompt": null}
{"id": "2e462821-c23c-4fa6-b706-400e82d726d6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.2  # New parameter for hybrid mutation strategy\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.1:  # Population size adaptation\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population control and hybrid mutation strategies for improved performance on diverse optimization landscapes.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "metadata": {"aucs": [0.720168223319482, 0.7561789327031998, 0.6843118920909561, 0.7265332545646994, 0.7553163264258591, 0.7062005763767172, 0.708889748889602, 0.7610838442968919, 0.6926108296733915, 0.5191054236586509, 0.5659053774892747, 0.49003588675352083, 0.5055161683170114, 0.5640656531590087, 0.497032917982139, 0.5195745584228257, 0.5839202728703865, 0.4767307121274825, 0.12540847436578528, 0.12163591679154628, 0.12464319547768066, 0.1625143264200022, 0.13141833907763956, 0.13958114142613687, 0.14335170849270418, 0.13000652007360458, 0.12158977559700146, 0.10951404459772729, 0.1237279904233376, 0.1084100558244474, 0.11654655694647931, 0.11954491004064371, 0.11793232259617781, 0.11453330631956504, 0.12252830722835173, 0.11618272935416407, 0.9311421234097502, 0.9399964629155679, 0.9461505542574293, 0.9432302732562675, 0.900809383709063, 0.96368849967082, 0.9510170382559352, 0.9559675672872279, 0.9407736418619157, 0.3130348383286087, 0.3323094456446699, 0.28477446211105584, 0.33450198676214726, 0.3423081885701478, 0.2980626031516015, 0.3111815897507514, 0.31966833297769925, 0.2742916892054905, 0.4162267203002751, 0.653538846953315, 0.45379836723375433, 0.6184813575956511, 0.5934566658940597, 0.4530519595112672, 0.5465826760258665, 0.6289307927570875, 0.5297072679437024, 0.18731385837364056, 0.1867490809752288, 0.1846758822090444, 0.17434083526740196, 0.20006679300073305, 0.1659500384847119, 0.18643029681062984, 0.19806903331182746, 0.16847167711648758, 0.11821247592569384, 0.1580049912075363, 0.17476076220047654, 0.20959683310675858, 0.17545336048860372, 0.1454912379207295, 0.1919143235953602, 0.18946421924925794, 0.1663422952429977, 0.09632465206060481, 0.1269451481382694, 0.08017802292424747, 0.08853503073658264, 0.0916956083253031, 0.061028516666099875, 0.08130243172429785, 0.10224559402207234, 0.05851515080699832, 0.18714359731801455, 0.2311844240101203, 0.19732072210201745, 0.17865842545373767, 0.23207037877412062, 0.1646494754675819, 0.2521887550560018, 0.2566613973268467, 0.2055701197015397, 0.027435485320603026, 0.07780363736195561, 0.018901603005358814, 0.020440440210955924, 0.023281996270887118, 0.031263316288994925, 0.024615544230557118, 0.05614659559517732, 0.015505313085820482, 0.14355645516451, 0.1685823850792484, 0.15499380894164094, 0.16633145222042878, 0.18067442908808062, 0.14340416807138878, 0.14876217598098795, 0.15899325554590782, 0.1322169586560491, 0.5381212365531007, 0.5373356460245393, 0.48867792684347566, 0.4904473760538818, 0.5418648325050102, 0.49561581797942866, 0.5159045154188855, 0.5200744343355441, 0.4858861004282138, 0.08931763943316529, 0.10503663296585386, 0.08091469623998926, 0.10147355489880316, 0.09401106286330108, 0.10079115912754655, 0.09094558165735545, 0.10301053523516746, 0.09286942223819827, 0.13790093147283455, 0.1368167685937688, 0.1550508628092444, 0.13594392654142995, 0.15080083436885394, 0.15499266673535073, 0.13268103628103622, 0.16622943927763334, 0.13952455444305556, 0.30424474731605256, 0.29777366688151774, 0.28290438251792804, 0.2932308310144941, 0.3010085074101454, 0.26143639582777367, 0.3236689887198869, 0.3558445833090451, 0.30604939614563464, 0.21454058519617536, 0.2188342132701303, 0.21715295891602315, 0.21052308125214825, 0.23283275381839652, 0.21386454342120165, 0.20653564555122683, 0.2653445925020719, 0.20154554173799488, 0.1930503054129471, 0.20316879168538493, 0.18260262734974153, 0.18852265580007566, 0.19075892985111276, 0.18900015890646316, 0.20472096755691604, 0.21552635221167404, 0.20156136785610723, 0.19003833564115025, 0.201890199128277, 0.19776869832832922, 0.19221810634225756, 0.20327681794994967, 0.184804488712482, 0.21197492897906456, 0.18048770234661682, 0.19582765381605427, 0.5228589386628666, 0.17169770224031455, 0.22251235012997794, 0.43977872672385354, 0.347144656006835, 0.5030203562964188, 0.16726694392691277, 0.17052073080924401, 0.32375428902408177, 0.1517069646287198, 0.5930364044493026, 0.18469529842525712, 0.1703593989330051, 0.30511054342158495, 0.17933890414954035, 0.19910268833887734, 0.6435909268877074, 0.20552039181276527, 0.17920903829106882, 0.18942950799717295, 0.20581811028694752, 0.18006608931446988, 0.19340780287457116, 0.1760651363770297, 0.18976011579974017, 0.17264251995134905, 0.18647122241407044, 0.0680302275755561, 0.07842327821515993, 0.07315200215750306, 0.08344935204841308, 0.08823152575967019, 0.07269084634642364, 0.07790973360653008, 0.07544472762718046, 0.08238542567238549]}, "mutation_prompt": null}
{"id": "05cbe13a-653c-4693-9f56-f6dc5c4525fc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.2  # New parameter for hybrid mutation strategy\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.1:  # Population size adaptation\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population control and hybrid mutation strategies for improved performance on diverse optimization landscapes.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "metadata": {"aucs": [0.720168223319482, 0.7561789327031998, 0.6843118920909561, 0.7265332545646994, 0.7553163264258591, 0.7062005763767172, 0.708889748889602, 0.7610838442968919, 0.6926108296733915, 0.5191054236586509, 0.5659053774892747, 0.49003588675352083, 0.5055161683170114, 0.5640656531590087, 0.497032917982139, 0.5195745584228257, 0.5839202728703865, 0.4767307121274825, 0.12540847436578528, 0.12163591679154628, 0.12464319547768066, 0.1625143264200022, 0.13141833907763956, 0.13958114142613687, 0.14335170849270418, 0.13000652007360458, 0.12158977559700146, 0.10951404459772729, 0.1237279904233376, 0.1084100558244474, 0.11654655694647931, 0.11954491004064371, 0.11793232259617781, 0.11453330631956504, 0.12252830722835173, 0.11618272935416407, 0.9311421234097502, 0.9399964629155679, 0.9461505542574293, 0.9432302732562675, 0.900809383709063, 0.96368849967082, 0.9510170382559352, 0.9559675672872279, 0.9407736418619157, 0.3130348383286087, 0.3323094456446699, 0.28477446211105584, 0.33450198676214726, 0.3423081885701478, 0.2980626031516015, 0.3111815897507514, 0.31966833297769925, 0.2742916892054905, 0.4162267203002751, 0.653538846953315, 0.45379836723375433, 0.6184813575956511, 0.5934566658940597, 0.4530519595112672, 0.5465826760258665, 0.6289307927570875, 0.5297072679437024, 0.18731385837364056, 0.1867490809752288, 0.1846758822090444, 0.17434083526740196, 0.20006679300073305, 0.1659500384847119, 0.18643029681062984, 0.19806903331182746, 0.16847167711648758, 0.11821247592569384, 0.1580049912075363, 0.17476076220047654, 0.20959683310675858, 0.17545336048860372, 0.1454912379207295, 0.1919143235953602, 0.18946421924925794, 0.1663422952429977, 0.09632465206060481, 0.1269451481382694, 0.08017802292424747, 0.08853503073658264, 0.0916956083253031, 0.061028516666099875, 0.08130243172429785, 0.10224559402207234, 0.05851515080699832, 0.18714359731801455, 0.2311844240101203, 0.19732072210201745, 0.17865842545373767, 0.23207037877412062, 0.1646494754675819, 0.2521887550560018, 0.2566613973268467, 0.2055701197015397, 0.027435485320603026, 0.07780363736195561, 0.018901603005358814, 0.020440440210955924, 0.023281996270887118, 0.031263316288994925, 0.024615544230557118, 0.05614659559517732, 0.015505313085820482, 0.14355645516451, 0.1685823850792484, 0.15499380894164094, 0.16633145222042878, 0.18067442908808062, 0.14340416807138878, 0.14876217598098795, 0.15899325554590782, 0.1322169586560491, 0.5381212365531007, 0.5373356460245393, 0.48867792684347566, 0.4904473760538818, 0.5418648325050102, 0.49561581797942866, 0.5159045154188855, 0.5200744343355441, 0.4858861004282138, 0.08931763943316529, 0.10503663296585386, 0.08091469623998926, 0.10147355489880316, 0.09401106286330108, 0.10079115912754655, 0.09094558165735545, 0.10301053523516746, 0.09286942223819827, 0.13790093147283455, 0.1368167685937688, 0.1550508628092444, 0.13594392654142995, 0.15080083436885394, 0.15499266673535073, 0.13268103628103622, 0.16622943927763334, 0.13952455444305556, 0.30424474731605256, 0.29777366688151774, 0.28290438251792804, 0.2932308310144941, 0.3010085074101454, 0.26143639582777367, 0.3236689887198869, 0.3558445833090451, 0.30604939614563464, 0.21454058519617536, 0.2188342132701303, 0.21715295891602315, 0.21052308125214825, 0.23283275381839652, 0.21386454342120165, 0.20653564555122683, 0.2653445925020719, 0.20154554173799488, 0.1930503054129471, 0.20316879168538493, 0.18260262734974153, 0.18852265580007566, 0.19075892985111276, 0.18900015890646316, 0.20472096755691604, 0.21552635221167404, 0.20156136785610723, 0.19003833564115025, 0.201890199128277, 0.19776869832832922, 0.19221810634225756, 0.20327681794994967, 0.184804488712482, 0.21197492897906456, 0.18048770234661682, 0.19582765381605427, 0.5228589386628666, 0.17169770224031455, 0.22251235012997794, 0.43977872672385354, 0.347144656006835, 0.5030203562964188, 0.16726694392691277, 0.17052073080924401, 0.32375428902408177, 0.1517069646287198, 0.5930364044493026, 0.18469529842525712, 0.1703593989330051, 0.30511054342158495, 0.17933890414954035, 0.19910268833887734, 0.6435909268877074, 0.20552039181276527, 0.17920903829106882, 0.18942950799717295, 0.20581811028694752, 0.18006608931446988, 0.19340780287457116, 0.1760651363770297, 0.18976011579974017, 0.17264251995134905, 0.18647122241407044, 0.0680302275755561, 0.07842327821515993, 0.07315200215750306, 0.08344935204841308, 0.08823152575967019, 0.07269084634642364, 0.07790973360653008, 0.07544472762718046, 0.08238542567238549]}, "mutation_prompt": null}
{"id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)  # Adjusted population size for efficiency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Fine-tuned mutation factor\n        self.crossover_rate = 0.7  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.3  # Increased switch rate for more hybridization\n        self.local_search_probability = 0.1  # New parameter for selective local search\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Enhanced hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                # Selective local search\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5\n        # More dynamic population size adaptation\n        if np.random.rand() < 0.15:\n            self.pop_size = max(4, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic strategy adjustments and selective local search for enhanced convergence on complex landscapes.", "configspace": "", "generation": 28, "fitness": 0.32838239224042587, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "1a2554bd-9b0e-444b-9667-859aaca30f3c", "metadata": {"aucs": [0.7777918667829213, 0.7737410861315823, 0.8258220433734444, 0.7865167240625431, 0.7632468410830641, 0.84402713855499, 0.7743966876852314, 0.7631838441006913, 0.8258811307056031, 0.6184994855401089, 0.6048482716741683, 0.6990812385056024, 0.6205102236007046, 0.6035194536400259, 0.7083582366098643, 0.5885738489181344, 0.6247971331944069, 0.7234366784067454, 0.12302390849761558, 0.21910045238522857, 0.1349705720572898, 0.15695418369076541, 0.15837748803364737, 0.15152124599125805, 0.14083576555253297, 0.1771432161185994, 0.21296758122442583, 0.1047150055222491, 0.1157108751554139, 0.13718891729584026, 0.11608690409632472, 0.12535994604809397, 0.1424379257705306, 0.11052723881346083, 0.12401517745700907, 0.1412851304472177, 0.9554538511850137, 0.9517492659185288, 0.9080061570175507, 0.9592152777259164, 0.9408566469335599, 0.9790129483346977, 0.9622628626121253, 0.9531773886768288, 0.9657113167896461, 0.3569934547231802, 0.46222725287885036, 0.49163591206469415, 0.35659698317486377, 0.46635584658544993, 0.5546862861724839, 0.39295431233442724, 0.4517798775380718, 0.563988487311904, 0.6170246591672152, 0.6456903897783295, 0.7600114955337637, 0.645276917096739, 0.7138804844910109, 0.7495254021659835, 0.6042579285774421, 0.6763382399948736, 0.6892139949401328, 0.20996312225498603, 0.23385852931813855, 0.19283458352647476, 0.21137111572347955, 0.2522311204531541, 0.16454722636201036, 0.23795906843372627, 0.24670181214504694, 0.16274306130205807, 0.21768847660559354, 0.25183677748406763, 0.1930656236407372, 0.20811810725515278, 0.19241431077637505, 0.23328488283496585, 0.17889930766404105, 0.22349018003280507, 0.1935316997504175, 0.14794449492463269, 0.1876877664927662, 0.21552814578921264, 0.13372292550488873, 0.23070527729464596, 0.2436862577572415, 0.1506980677532942, 0.2634001160495215, 0.1922712488562086, 0.2660562463762295, 0.3717182821903603, 0.41455428744882616, 0.22399449984579933, 0.34483023805227575, 0.25843417701126026, 0.3317235357637265, 0.3962229084475438, 0.42076564416509077, 0.04880662979357586, 0.12020710774934118, 0.08947728684485934, 0.06534133655055996, 0.13920499754959814, 0.15480513553717923, 0.06339228397474017, 0.11902100136256244, 0.12940431800682983, 0.1881578497516242, 0.24359322549255946, 0.33127826081304224, 0.20689250541767668, 0.2713621885423052, 0.3412297144016858, 0.18632916668593957, 0.2414084930596362, 0.27319626412104625, 0.5560843065882102, 0.6391654564081355, 0.6463398628057542, 0.5907105656793322, 0.6100544047582761, 0.691276829446549, 0.5889385978071116, 0.6338710938359269, 0.6218289753523317, 0.0938725996181271, 0.09740009140480399, 0.0949817372113887, 0.09121429209970444, 0.09134408098885904, 0.10503631053204643, 0.09579409972964315, 0.09132020565867716, 0.1069633839148022, 0.12401915246114059, 0.143273175690521, 0.16836317270790913, 0.15430318177330504, 0.15202412616077798, 0.17983102041100996, 0.12591042937336605, 0.13174475806420394, 0.2507952996767391, 0.35863347792979516, 0.37739499817078737, 0.4266406579077283, 0.33355795775209385, 0.3755519254843186, 0.4008563386767623, 0.38182823390360277, 0.4499139933048697, 0.47742043337959417, 0.25093913573248483, 0.26195822978734873, 0.34046156789755777, 0.24221991842698531, 0.27549068129271326, 0.340245585797454, 0.23478934263537343, 0.2996744305541411, 0.35049143463870625, 0.19069498747646862, 0.20461810399749258, 0.21652226710123157, 0.19186814815413777, 0.1825560852976832, 0.20536448550979214, 0.19222466701134056, 0.17966486057187392, 0.18923596474708815, 0.18189189485384027, 0.23698873468342674, 0.2128990712084371, 0.2021911559142615, 0.2661789086147037, 0.21782381494358827, 0.18970703723154636, 0.21351878467782393, 0.1873244558689493, 0.1654911108336803, 0.17687460970293345, 0.6944820771593783, 0.49854793089008886, 0.17410883604059324, 0.5996357374992876, 0.28315885768828386, 0.15712285136377502, 0.19008888758066256, 0.2530933795334508, 0.16182792580641092, 0.20029452765428546, 0.1939939311683826, 0.1517702496764749, 0.1584016156739817, 0.2048349430602524, 0.20487952365219897, 0.20927227998893372, 0.175132400886285, 0.18371861113241406, 0.21052055287380522, 0.18975683976048607, 0.17890178790641897, 0.18481136638710016, 0.2056978671696018, 0.1816152122485707, 0.1888825916064758, 0.07298443761316664, 0.08153428471866264, 0.08328587256339892, 0.08084750774081217, 0.07922533649745744, 0.08120593605246906, 0.08377969605749147, 0.08210202970812219, 0.08898413934941307]}, "mutation_prompt": null}
{"id": "aa395f18-8aaa-4152-a6df-501d2a9adac5", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)  # Adjusted population size for efficiency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Fine-tuned mutation factor\n        self.crossover_rate = 0.7  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.3  # Increased switch rate for more hybridization\n        self.local_search_probability = 0.1  # New parameter for selective local search\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Enhanced hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                # Selective local search\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5\n        # More dynamic population size adaptation\n        if np.random.rand() < 0.15:\n            self.pop_size = max(4, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic strategy adjustments and selective local search for enhanced convergence on complex landscapes.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.7777918667829213, 0.7737410861315823, 0.8258220433734444, 0.7865167240625431, 0.7632468410830641, 0.84402713855499, 0.7743966876852314, 0.7631838441006913, 0.8258811307056031, 0.6184994855401089, 0.6048482716741683, 0.6990812385056024, 0.6205102236007046, 0.6035194536400259, 0.7083582366098643, 0.5885738489181344, 0.6247971331944069, 0.7234366784067454, 0.12302390849761558, 0.21910045238522857, 0.1349705720572898, 0.15695418369076541, 0.15837748803364737, 0.15152124599125805, 0.14083576555253297, 0.1771432161185994, 0.21296758122442583, 0.1047150055222491, 0.1157108751554139, 0.13718891729584026, 0.11608690409632472, 0.12535994604809397, 0.1424379257705306, 0.11052723881346083, 0.12401517745700907, 0.1412851304472177, 0.9554538511850137, 0.9517492659185288, 0.9080061570175507, 0.9592152777259164, 0.9408566469335599, 0.9790129483346977, 0.9622628626121253, 0.9531773886768288, 0.9657113167896461, 0.3569934547231802, 0.46222725287885036, 0.49163591206469415, 0.35659698317486377, 0.46635584658544993, 0.5546862861724839, 0.39295431233442724, 0.4517798775380718, 0.563988487311904, 0.6170246591672152, 0.6456903897783295, 0.7600114955337637, 0.645276917096739, 0.7138804844910109, 0.7495254021659835, 0.6042579285774421, 0.6763382399948736, 0.6892139949401328, 0.20996312225498603, 0.23385852931813855, 0.19283458352647476, 0.21137111572347955, 0.2522311204531541, 0.16454722636201036, 0.23795906843372627, 0.24670181214504694, 0.16274306130205807, 0.21768847660559354, 0.25183677748406763, 0.1930656236407372, 0.20811810725515278, 0.19241431077637505, 0.23328488283496585, 0.17889930766404105, 0.22349018003280507, 0.1935316997504175, 0.14794449492463269, 0.1876877664927662, 0.21552814578921264, 0.13372292550488873, 0.23070527729464596, 0.2436862577572415, 0.1506980677532942, 0.2634001160495215, 0.1922712488562086, 0.2660562463762295, 0.3717182821903603, 0.41455428744882616, 0.22399449984579933, 0.34483023805227575, 0.25843417701126026, 0.3317235357637265, 0.3962229084475438, 0.42076564416509077, 0.04880662979357586, 0.12020710774934118, 0.08947728684485934, 0.06534133655055996, 0.13920499754959814, 0.15480513553717923, 0.06339228397474017, 0.11902100136256244, 0.12940431800682983, 0.1881578497516242, 0.24359322549255946, 0.33127826081304224, 0.20689250541767668, 0.2713621885423052, 0.3412297144016858, 0.18632916668593957, 0.2414084930596362, 0.27319626412104625, 0.5560843065882102, 0.6391654564081355, 0.6463398628057542, 0.5907105656793322, 0.6100544047582761, 0.691276829446549, 0.5889385978071116, 0.6338710938359269, 0.6218289753523317, 0.0938725996181271, 0.09740009140480399, 0.0949817372113887, 0.09121429209970444, 0.09134408098885904, 0.10503631053204643, 0.09579409972964315, 0.09132020565867716, 0.1069633839148022, 0.12401915246114059, 0.143273175690521, 0.16836317270790913, 0.15430318177330504, 0.15202412616077798, 0.17983102041100996, 0.12591042937336605, 0.13174475806420394, 0.2507952996767391, 0.35863347792979516, 0.37739499817078737, 0.4266406579077283, 0.33355795775209385, 0.3755519254843186, 0.4008563386767623, 0.38182823390360277, 0.4499139933048697, 0.47742043337959417, 0.25093913573248483, 0.26195822978734873, 0.34046156789755777, 0.24221991842698531, 0.27549068129271326, 0.340245585797454, 0.23478934263537343, 0.2996744305541411, 0.35049143463870625, 0.19069498747646862, 0.20461810399749258, 0.21652226710123157, 0.19186814815413777, 0.1825560852976832, 0.20536448550979214, 0.19222466701134056, 0.17966486057187392, 0.18923596474708815, 0.18189189485384027, 0.23698873468342674, 0.2128990712084371, 0.2021911559142615, 0.2661789086147037, 0.21782381494358827, 0.18970703723154636, 0.21351878467782393, 0.1873244558689493, 0.1654911108336803, 0.17687460970293345, 0.6944820771593783, 0.49854793089008886, 0.17410883604059324, 0.5996357374992876, 0.28315885768828386, 0.15712285136377502, 0.19008888758066256, 0.2530933795334508, 0.16182792580641092, 0.20029452765428546, 0.1939939311683826, 0.1517702496764749, 0.1584016156739817, 0.2048349430602524, 0.20487952365219897, 0.20927227998893372, 0.175132400886285, 0.18371861113241406, 0.21052055287380522, 0.18975683976048607, 0.17890178790641897, 0.18481136638710016, 0.2056978671696018, 0.1816152122485707, 0.1888825916064758, 0.07298443761316664, 0.08153428471866264, 0.08328587256339892, 0.08084750774081217, 0.07922533649745744, 0.08120593605246906, 0.08377969605749147, 0.08210202970812219, 0.08898413934941307]}, "mutation_prompt": null}
{"id": "694709c4-3a56-4497-a750-b15b19ddcea4", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)  # Adjusted population size for efficiency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Fine-tuned mutation factor\n        self.crossover_rate = 0.7  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.3  # Increased switch rate for more hybridization\n        self.local_search_probability = 0.1  # New parameter for selective local search\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Enhanced hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                # Selective local search\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5\n        # More dynamic population size adaptation\n        if np.random.rand() < 0.15:\n            self.pop_size = max(4, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic strategy adjustments and selective local search for enhanced convergence on complex landscapes.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.7777918667829213, 0.7737410861315823, 0.8258220433734444, 0.7865167240625431, 0.7632468410830641, 0.84402713855499, 0.7743966876852314, 0.7631838441006913, 0.8258811307056031, 0.6184994855401089, 0.6048482716741683, 0.6990812385056024, 0.6205102236007046, 0.6035194536400259, 0.7083582366098643, 0.5885738489181344, 0.6247971331944069, 0.7234366784067454, 0.12302390849761558, 0.21910045238522857, 0.1349705720572898, 0.15695418369076541, 0.15837748803364737, 0.15152124599125805, 0.14083576555253297, 0.1771432161185994, 0.21296758122442583, 0.1047150055222491, 0.1157108751554139, 0.13718891729584026, 0.11608690409632472, 0.12535994604809397, 0.1424379257705306, 0.11052723881346083, 0.12401517745700907, 0.1412851304472177, 0.9554538511850137, 0.9517492659185288, 0.9080061570175507, 0.9592152777259164, 0.9408566469335599, 0.9790129483346977, 0.9622628626121253, 0.9531773886768288, 0.9657113167896461, 0.3569934547231802, 0.46222725287885036, 0.49163591206469415, 0.35659698317486377, 0.46635584658544993, 0.5546862861724839, 0.39295431233442724, 0.4517798775380718, 0.563988487311904, 0.6170246591672152, 0.6456903897783295, 0.7600114955337637, 0.645276917096739, 0.7138804844910109, 0.7495254021659835, 0.6042579285774421, 0.6763382399948736, 0.6892139949401328, 0.20996312225498603, 0.23385852931813855, 0.19283458352647476, 0.21137111572347955, 0.2522311204531541, 0.16454722636201036, 0.23795906843372627, 0.24670181214504694, 0.16274306130205807, 0.21768847660559354, 0.25183677748406763, 0.1930656236407372, 0.20811810725515278, 0.19241431077637505, 0.23328488283496585, 0.17889930766404105, 0.22349018003280507, 0.1935316997504175, 0.14794449492463269, 0.1876877664927662, 0.21552814578921264, 0.13372292550488873, 0.23070527729464596, 0.2436862577572415, 0.1506980677532942, 0.2634001160495215, 0.1922712488562086, 0.2660562463762295, 0.3717182821903603, 0.41455428744882616, 0.22399449984579933, 0.34483023805227575, 0.25843417701126026, 0.3317235357637265, 0.3962229084475438, 0.42076564416509077, 0.04880662979357586, 0.12020710774934118, 0.08947728684485934, 0.06534133655055996, 0.13920499754959814, 0.15480513553717923, 0.06339228397474017, 0.11902100136256244, 0.12940431800682983, 0.1881578497516242, 0.24359322549255946, 0.33127826081304224, 0.20689250541767668, 0.2713621885423052, 0.3412297144016858, 0.18632916668593957, 0.2414084930596362, 0.27319626412104625, 0.5560843065882102, 0.6391654564081355, 0.6463398628057542, 0.5907105656793322, 0.6100544047582761, 0.691276829446549, 0.5889385978071116, 0.6338710938359269, 0.6218289753523317, 0.0938725996181271, 0.09740009140480399, 0.0949817372113887, 0.09121429209970444, 0.09134408098885904, 0.10503631053204643, 0.09579409972964315, 0.09132020565867716, 0.1069633839148022, 0.12401915246114059, 0.143273175690521, 0.16836317270790913, 0.15430318177330504, 0.15202412616077798, 0.17983102041100996, 0.12591042937336605, 0.13174475806420394, 0.2507952996767391, 0.35863347792979516, 0.37739499817078737, 0.4266406579077283, 0.33355795775209385, 0.3755519254843186, 0.4008563386767623, 0.38182823390360277, 0.4499139933048697, 0.47742043337959417, 0.25093913573248483, 0.26195822978734873, 0.34046156789755777, 0.24221991842698531, 0.27549068129271326, 0.340245585797454, 0.23478934263537343, 0.2996744305541411, 0.35049143463870625, 0.19069498747646862, 0.20461810399749258, 0.21652226710123157, 0.19186814815413777, 0.1825560852976832, 0.20536448550979214, 0.19222466701134056, 0.17966486057187392, 0.18923596474708815, 0.18189189485384027, 0.23698873468342674, 0.2128990712084371, 0.2021911559142615, 0.2661789086147037, 0.21782381494358827, 0.18970703723154636, 0.21351878467782393, 0.1873244558689493, 0.1654911108336803, 0.17687460970293345, 0.6944820771593783, 0.49854793089008886, 0.17410883604059324, 0.5996357374992876, 0.28315885768828386, 0.15712285136377502, 0.19008888758066256, 0.2530933795334508, 0.16182792580641092, 0.20029452765428546, 0.1939939311683826, 0.1517702496764749, 0.1584016156739817, 0.2048349430602524, 0.20487952365219897, 0.20927227998893372, 0.175132400886285, 0.18371861113241406, 0.21052055287380522, 0.18975683976048607, 0.17890178790641897, 0.18481136638710016, 0.2056978671696018, 0.1816152122485707, 0.1888825916064758, 0.07298443761316664, 0.08153428471866264, 0.08328587256339892, 0.08084750774081217, 0.07922533649745744, 0.08120593605246906, 0.08377969605749147, 0.08210202970812219, 0.08898413934941307]}, "mutation_prompt": null}
{"id": "eea5663f-e8b7-4ef3-b05e-cee2525edcda", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)  # Adjusted population size for efficiency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Fine-tuned mutation factor\n        self.crossover_rate = 0.7  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.3  # Increased switch rate for more hybridization\n        self.local_search_probability = 0.1  # New parameter for selective local search\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Enhanced hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                # Selective local search\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5\n        # More dynamic population size adaptation\n        if np.random.rand() < 0.15:\n            self.pop_size = max(4, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic strategy adjustments and selective local search for enhanced convergence on complex landscapes.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.7777918667829213, 0.7737410861315823, 0.8258220433734444, 0.7865167240625431, 0.7632468410830641, 0.84402713855499, 0.7743966876852314, 0.7631838441006913, 0.8258811307056031, 0.6184994855401089, 0.6048482716741683, 0.6990812385056024, 0.6205102236007046, 0.6035194536400259, 0.7083582366098643, 0.5885738489181344, 0.6247971331944069, 0.7234366784067454, 0.12302390849761558, 0.21910045238522857, 0.1349705720572898, 0.15695418369076541, 0.15837748803364737, 0.15152124599125805, 0.14083576555253297, 0.1771432161185994, 0.21296758122442583, 0.1047150055222491, 0.1157108751554139, 0.13718891729584026, 0.11608690409632472, 0.12535994604809397, 0.1424379257705306, 0.11052723881346083, 0.12401517745700907, 0.1412851304472177, 0.9554538511850137, 0.9517492659185288, 0.9080061570175507, 0.9592152777259164, 0.9408566469335599, 0.9790129483346977, 0.9622628626121253, 0.9531773886768288, 0.9657113167896461, 0.3569934547231802, 0.46222725287885036, 0.49163591206469415, 0.35659698317486377, 0.46635584658544993, 0.5546862861724839, 0.39295431233442724, 0.4517798775380718, 0.563988487311904, 0.6170246591672152, 0.6456903897783295, 0.7600114955337637, 0.645276917096739, 0.7138804844910109, 0.7495254021659835, 0.6042579285774421, 0.6763382399948736, 0.6892139949401328, 0.20996312225498603, 0.23385852931813855, 0.19283458352647476, 0.21137111572347955, 0.2522311204531541, 0.16454722636201036, 0.23795906843372627, 0.24670181214504694, 0.16274306130205807, 0.21768847660559354, 0.25183677748406763, 0.1930656236407372, 0.20811810725515278, 0.19241431077637505, 0.23328488283496585, 0.17889930766404105, 0.22349018003280507, 0.1935316997504175, 0.14794449492463269, 0.1876877664927662, 0.21552814578921264, 0.13372292550488873, 0.23070527729464596, 0.2436862577572415, 0.1506980677532942, 0.2634001160495215, 0.1922712488562086, 0.2660562463762295, 0.3717182821903603, 0.41455428744882616, 0.22399449984579933, 0.34483023805227575, 0.25843417701126026, 0.3317235357637265, 0.3962229084475438, 0.42076564416509077, 0.04880662979357586, 0.12020710774934118, 0.08947728684485934, 0.06534133655055996, 0.13920499754959814, 0.15480513553717923, 0.06339228397474017, 0.11902100136256244, 0.12940431800682983, 0.1881578497516242, 0.24359322549255946, 0.33127826081304224, 0.20689250541767668, 0.2713621885423052, 0.3412297144016858, 0.18632916668593957, 0.2414084930596362, 0.27319626412104625, 0.5560843065882102, 0.6391654564081355, 0.6463398628057542, 0.5907105656793322, 0.6100544047582761, 0.691276829446549, 0.5889385978071116, 0.6338710938359269, 0.6218289753523317, 0.0938725996181271, 0.09740009140480399, 0.0949817372113887, 0.09121429209970444, 0.09134408098885904, 0.10503631053204643, 0.09579409972964315, 0.09132020565867716, 0.1069633839148022, 0.12401915246114059, 0.143273175690521, 0.16836317270790913, 0.15430318177330504, 0.15202412616077798, 0.17983102041100996, 0.12591042937336605, 0.13174475806420394, 0.2507952996767391, 0.35863347792979516, 0.37739499817078737, 0.4266406579077283, 0.33355795775209385, 0.3755519254843186, 0.4008563386767623, 0.38182823390360277, 0.4499139933048697, 0.47742043337959417, 0.25093913573248483, 0.26195822978734873, 0.34046156789755777, 0.24221991842698531, 0.27549068129271326, 0.340245585797454, 0.23478934263537343, 0.2996744305541411, 0.35049143463870625, 0.19069498747646862, 0.20461810399749258, 0.21652226710123157, 0.19186814815413777, 0.1825560852976832, 0.20536448550979214, 0.19222466701134056, 0.17966486057187392, 0.18923596474708815, 0.18189189485384027, 0.23698873468342674, 0.2128990712084371, 0.2021911559142615, 0.2661789086147037, 0.21782381494358827, 0.18970703723154636, 0.21351878467782393, 0.1873244558689493, 0.1654911108336803, 0.17687460970293345, 0.6944820771593783, 0.49854793089008886, 0.17410883604059324, 0.5996357374992876, 0.28315885768828386, 0.15712285136377502, 0.19008888758066256, 0.2530933795334508, 0.16182792580641092, 0.20029452765428546, 0.1939939311683826, 0.1517702496764749, 0.1584016156739817, 0.2048349430602524, 0.20487952365219897, 0.20927227998893372, 0.175132400886285, 0.18371861113241406, 0.21052055287380522, 0.18975683976048607, 0.17890178790641897, 0.18481136638710016, 0.2056978671696018, 0.1816152122485707, 0.1888825916064758, 0.07298443761316664, 0.08153428471866264, 0.08328587256339892, 0.08084750774081217, 0.07922533649745744, 0.08120593605246906, 0.08377969605749147, 0.08210202970812219, 0.08898413934941307]}, "mutation_prompt": null}
{"id": "53a2f31e-701f-4e6d-a71e-3e69ce90ccb1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.4 + np.random.rand() * 0.3  # Dynamic mutation factor\n        self.crossover_rate = 0.6 + np.random.rand() * 0.3  # Dynamic crossover rate\n        self.strategy_switch_rate = 0.35  # Adjusted switch rate for balanced hybridization\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Enhanced hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) - 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                # Selective local search\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.15, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.2 + np.random.rand() * 0.8\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        # More dynamic population size adaptation\n        if np.random.rand() < 0.2:\n            self.pop_size = max(5, min(int(self.pop_size * (0.7 + np.random.rand() * 0.5)), 60))", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with improved parameter adaptation and exploration-exploitation balance for better optimization performance.", "configspace": "", "generation": 32, "fitness": 0.27477257268845107, "feedback": "The algorithm EnhancedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.7987736299733827, 0.7600944482224538, 0.5944338361299459, 0.7893178375386896, 0.5977488848336318, 0.48898553063878203, 0.7844187311007665, 0.7680425814832705, 0.5162422143620365, 0.6927090958679691, 0.5215426152221214, 0.30232204483715464, 0.6593562240026503, 0.4091893985880718, 0.35474812794650845, 0.6092736760840343, 0.3336086130121513, 0.308193805791698, 0.2277260344965667, 0.22014833792379507, 0.13895106528703272, 0.18080084481244696, 0.11395308556624872, 0.22383669074235713, 0.18468833499547677, 0.14806483526164282, 0.16093032865937296, 0.11451259629834554, 0.12456340542675393, 0.12775159947965675, 0.13076171686700544, 0.12892560567617073, 0.12474777108708257, 0.15097343672500196, 0.09904619554948857, 0.13917169031274712, 0.9633436210712927, 0.9630949785251273, 0.9233233655086549, 0.9439237799908207, 0.9487548642819366, 0.9381783527814543, 0.9215357904287482, 0.9873867395108483, 0.9276345901290923, 0.35511632261888704, 0.25526596130418444, 0.29788831075033684, 0.3400118161747374, 0.33035948633266776, 0.2584030431432569, 0.36880017488399375, 0.2759592302204751, 0.269517732298738, 0.7300673757414562, 0.2909901369572159, 0.3135734922913278, 0.6712670665716534, 0.33488481718315966, 0.2033205914466566, 0.3327854043702104, 0.7187615355864663, 0.3606345673684518, 0.1598284774949782, 0.1581903812819241, 0.17404419704044338, 0.1623877003731412, 0.18551655168657732, 0.12221107745870885, 0.18759143922690413, 0.24881600148226724, 0.13132766242358196, 0.21650251301773882, 0.0983657648195927, 0.13235521700690678, 0.15207717119323483, 0.1233955273749251, 0.18536393015252273, 0.14258100782047767, 0.17056365587650202, 0.1436536223543231, 0.09956493400192035, 9.999999999998899e-05, 9.999999999998899e-05, 0.05757497123512456, 0.1316880231933103, 0.04737547955718513, 0.033469901423139214, 0.050410971076264244, 9.999999999998899e-05, 0.18444623313397557, 0.1717679253265635, 0.1500423989270826, 0.16282907641313327, 0.25227429048316985, 0.1415989234729388, 0.31438578475892887, 0.19519407527706267, 0.08379663812880767, 0.10836493146835435, 0.157133901432984, 0.060410750523486434, 0.14281663121037969, 0.23636128319723682, 0.07125798754355839, 0.19167272077657438, 0.15711515606033066, 0.11387084316674267, 0.18460569244600777, 0.2312666582827304, 0.10354629247300617, 0.1803403157958261, 0.19586935461648258, 0.15443077627605017, 0.19963326337525655, 0.16250751793417162, 0.15834000200725784, 0.4709593196600733, 0.5158700258451892, 0.39879782430553157, 0.501688700090545, 0.48391844580960297, 0.3995490385553331, 0.5918959065916136, 0.5368573934907948, 0.4282881569988084, 0.11456514083246971, 0.10023319579057366, 0.08665650732370445, 0.08934295155799332, 0.0907669841222889, 0.08874297373813678, 0.10311679937142493, 0.11126897989695395, 0.11451677103643265, 0.13996575874526074, 0.26813800675072197, 0.16626970490972504, 0.1603785821698226, 0.18757923982392988, 0.19119209386928593, 0.17298628114281733, 0.2439089751407082, 0.21444253748195918, 0.46598281989128865, 0.3456658549162721, 0.30114764105583314, 0.3244812243659191, 0.3312338388377719, 0.3265971793817868, 0.4024986390951635, 0.3406117663453848, 0.260911229017155, 0.23082397723235604, 0.36164384964491614, 0.21319791100268326, 0.3074189420168184, 0.24250201924826686, 0.1686304667253915, 0.28739071199758626, 0.2512335110216961, 0.21609738911445364, 0.184321639882445, 0.20138604049154074, 0.22545124380267456, 0.18003210123992774, 0.19475935175852743, 0.21291265649039015, 0.1943086061542988, 0.20227076415589829, 0.19361008395041657, 0.45369180550810284, 0.2153184856243071, 0.1872075163853567, 0.19399922072521292, 0.20165704688176633, 0.19096508938507972, 0.2102649016934619, 0.18915993008578758, 0.20850127723733747, 0.43987999022298596, 0.5361587841501727, 0.5210688755486446, 0.190444699996556, 0.1877119362633085, 0.181117334164693, 0.17718377133180252, 0.17422190137570648, 0.6058120056878241, 0.20204619575055494, 0.16523235394241853, 0.16396476905508806, 0.16486102776951395, 0.19862553810272487, 0.1987522821771437, 0.20362610240139556, 0.199482042730611, 0.15190934911085385, 0.1824609304024415, 0.18415421122572984, 0.19530851621458045, 0.22753863954319165, 0.18596916782756423, 0.1955044458218187, 0.21867250353985979, 0.187219118710784, 0.1682485904231169, 0.07673753479492185, 0.08469049829173125, 0.07042602854900293, 0.08227963912627001, 0.07986625880620246, 0.08618987840610626, 0.07621484325978145, 0.08544287091795721, 0.07769641629323831]}, "mutation_prompt": null}
{"id": "98a41850-e5c2-44a8-b42b-c617358dd87e", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.25  # Fine-tuned switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Adjusted local search step\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6\n        self.crossover_rate = 0.4 + np.random.rand() * 0.6\n        if np.random.rand() < 0.2:  # Adjusted adaptation probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with refined parameter adaptation and streamlined operations for improved efficiency and convergence.", "configspace": "", "generation": 33, "fitness": 0.2769770649128031, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.7180186145880096, 0.6703027379672176, 0.7029223354451588, 0.7156811541298564, 0.6729372129428874, 0.7115264096306764, 0.7149404923139153, 0.6723766369700064, 0.6940664134080409, 0.5440744343686985, 0.4492466677949737, 0.49257742537354887, 0.5249642262350334, 0.4236824680478045, 0.4986754436603048, 0.5231553921259169, 0.4502655129423082, 0.499975769731582, 0.17784725951023317, 0.12221937512312797, 0.16186365479042308, 0.18956750999227412, 0.14525514684718543, 0.17485122801386643, 0.13008258908426396, 0.15301141727642498, 0.16331457607698396, 0.16846425308476098, 0.11499722114188682, 0.12713264940415414, 0.17434760582193143, 0.1229594346330819, 0.12025764135149475, 0.1533233933089606, 0.11575698272000623, 0.1388067865879481, 0.9422044452808244, 0.9390077018951084, 0.9509021841242185, 0.940132084171759, 0.9134624767514327, 0.9228760665058104, 0.9418481834034077, 0.8785182336049318, 0.8960718576448272, 0.38794616687485317, 0.30033677847547546, 0.3146575865228177, 0.35261314834728996, 0.3023117701030281, 0.3113452235308237, 0.38055475104870373, 0.3060560073974471, 0.34257754301725474, 0.569905959330796, 0.47530866549527595, 0.4461232321682025, 0.5766673309558288, 0.45319581096702855, 0.4832000199345795, 0.6145390291950146, 0.5122735421446919, 0.5562006901823385, 0.17391469518839953, 0.18318031079295272, 0.18279955374154866, 0.1539272066322105, 0.15205632238967992, 0.1710521353263662, 0.16873851390847827, 0.1631196054466263, 0.1749930603650227, 0.17397019186701457, 0.16732804917570065, 0.1666815791505757, 0.17067797130145468, 0.1549154242367513, 0.2252394320468707, 0.17126662837684614, 0.16637697926055695, 0.19261349287920582, 0.11656920436842133, 0.06295936648544553, 0.0660691500887659, 0.10103070036349382, 0.05592647958894126, 0.08697663899259367, 0.08743087584618625, 0.05329194445641772, 0.07265663310151083, 0.1901394333249239, 0.1884552935046364, 0.204296782557018, 0.16445353523426454, 0.1471279484298158, 0.16519669568704776, 0.26206930667647, 0.24265536127096832, 0.260325425571295, 0.036033636178418815, 0.030550310056761898, 0.03146750567989276, 0.052022475178536975, 0.03652427952670967, 0.029270618227899337, 0.03922227805498246, 0.02362153671717837, 0.03744779903943185, 0.15093948580717642, 0.1486053893232926, 0.14665688325638893, 0.1985332009330395, 0.14437796468159447, 0.15713056247211954, 0.16872595931027012, 0.13948187124790223, 0.13995840905881163, 0.5055550079748339, 0.47644116684387283, 0.48723702968136917, 0.5212486894412545, 0.47706907545366717, 0.48856986702087957, 0.5041426484714651, 0.4800862936732082, 0.49777428984189587, 0.08857325574211206, 0.10323239981258014, 0.0946925103056383, 0.10023386374171583, 0.09810447048361726, 0.08688431123062201, 0.0897965725046046, 0.09215647379948677, 0.07604097510535412, 0.15486926990794614, 0.13302435791871536, 0.14277705746959435, 0.1568353583157548, 0.1603415043018629, 0.1448694677679998, 0.15932034811707996, 0.1589931574234772, 0.15697092268004376, 0.31614878610362174, 0.30372945897367054, 0.31030905771947637, 0.3066606388512292, 0.29763994449644937, 0.31826433380548813, 0.3495473899785535, 0.30833901772612127, 0.33283403412073653, 0.21937870082827748, 0.23464080857829772, 0.19878896658804646, 0.2401695026028875, 0.1999108386203825, 0.2106483399712833, 0.22522575937961442, 0.23512752890856758, 0.2459885780557256, 0.18546215771984198, 0.18068421732376516, 0.17711886865530013, 0.1904074791263144, 0.18151604909704744, 0.19291233899680238, 0.2174171811991621, 0.18037928261079417, 0.20703259297059862, 0.18993997976685628, 0.18221429923153432, 0.1881006808610115, 0.23462452140231238, 0.23369815798025362, 0.18933564981447903, 0.19328386937966058, 0.1978155686684916, 0.19551815696981, 0.1485797502266829, 0.5321883953878704, 0.5453340182752675, 0.4465786814455658, 0.15510219298610572, 0.4399159182918826, 0.304538833977428, 0.3409677219544027, 0.5628015707063687, 0.3436824150470481, 0.4806976206000362, 0.15895967010090806, 0.1827524028012042, 0.18064644498536275, 0.3331549682817002, 0.1975523941595726, 0.2035323869674759, 0.21257484231280954, 0.17000894125242028, 0.1893752726509741, 0.17861387557387953, 0.18931078354452524, 0.1935596215589751, 0.18914945919421222, 0.1831707994346916, 0.17452059178321178, 0.1829629443174503, 0.07590798371481344, 0.07645546332655229, 0.08712115319511504, 0.0747863218838164, 0.07337731570635386, 0.0804640258414846, 0.07297706050663333, 0.08362168884298915, 0.08011275431296072]}, "mutation_prompt": null}
{"id": "24cb54ac-2f27-45ff-a421-473b073e289a", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 50)  # Adjusted population size for efficiency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Fine-tuned mutation factor\n        self.crossover_rate = 0.7  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.3  # Increased switch rate for more hybridization\n        self.local_search_probability = 0.1  # New parameter for selective local search\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Enhanced hybrid strategy switch\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                # Selective local search\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5\n        # More dynamic population size adaptation\n        if np.random.rand() < 0.15:\n            self.pop_size = max(4, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic strategy adjustments and selective local search for enhanced convergence on complex landscapes.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.7777918667829213, 0.7737410861315823, 0.8258220433734444, 0.7865167240625431, 0.7632468410830641, 0.84402713855499, 0.7743966876852314, 0.7631838441006913, 0.8258811307056031, 0.6184994855401089, 0.6048482716741683, 0.6990812385056024, 0.6205102236007046, 0.6035194536400259, 0.7083582366098643, 0.5885738489181344, 0.6247971331944069, 0.7234366784067454, 0.12302390849761558, 0.21910045238522857, 0.1349705720572898, 0.15695418369076541, 0.15837748803364737, 0.15152124599125805, 0.14083576555253297, 0.1771432161185994, 0.21296758122442583, 0.1047150055222491, 0.1157108751554139, 0.13718891729584026, 0.11608690409632472, 0.12535994604809397, 0.1424379257705306, 0.11052723881346083, 0.12401517745700907, 0.1412851304472177, 0.9554538511850137, 0.9517492659185288, 0.9080061570175507, 0.9592152777259164, 0.9408566469335599, 0.9790129483346977, 0.9622628626121253, 0.9531773886768288, 0.9657113167896461, 0.3569934547231802, 0.46222725287885036, 0.49163591206469415, 0.35659698317486377, 0.46635584658544993, 0.5546862861724839, 0.39295431233442724, 0.4517798775380718, 0.563988487311904, 0.6170246591672152, 0.6456903897783295, 0.7600114955337637, 0.645276917096739, 0.7138804844910109, 0.7495254021659835, 0.6042579285774421, 0.6763382399948736, 0.6892139949401328, 0.20996312225498603, 0.23385852931813855, 0.19283458352647476, 0.21137111572347955, 0.2522311204531541, 0.16454722636201036, 0.23795906843372627, 0.24670181214504694, 0.16274306130205807, 0.21768847660559354, 0.25183677748406763, 0.1930656236407372, 0.20811810725515278, 0.19241431077637505, 0.23328488283496585, 0.17889930766404105, 0.22349018003280507, 0.1935316997504175, 0.14794449492463269, 0.1876877664927662, 0.21552814578921264, 0.13372292550488873, 0.23070527729464596, 0.2436862577572415, 0.1506980677532942, 0.2634001160495215, 0.1922712488562086, 0.2660562463762295, 0.3717182821903603, 0.41455428744882616, 0.22399449984579933, 0.34483023805227575, 0.25843417701126026, 0.3317235357637265, 0.3962229084475438, 0.42076564416509077, 0.04880662979357586, 0.12020710774934118, 0.08947728684485934, 0.06534133655055996, 0.13920499754959814, 0.15480513553717923, 0.06339228397474017, 0.11902100136256244, 0.12940431800682983, 0.1881578497516242, 0.24359322549255946, 0.33127826081304224, 0.20689250541767668, 0.2713621885423052, 0.3412297144016858, 0.18632916668593957, 0.2414084930596362, 0.27319626412104625, 0.5560843065882102, 0.6391654564081355, 0.6463398628057542, 0.5907105656793322, 0.6100544047582761, 0.691276829446549, 0.5889385978071116, 0.6338710938359269, 0.6218289753523317, 0.0938725996181271, 0.09740009140480399, 0.0949817372113887, 0.09121429209970444, 0.09134408098885904, 0.10503631053204643, 0.09579409972964315, 0.09132020565867716, 0.1069633839148022, 0.12401915246114059, 0.143273175690521, 0.16836317270790913, 0.15430318177330504, 0.15202412616077798, 0.17983102041100996, 0.12591042937336605, 0.13174475806420394, 0.2507952996767391, 0.35863347792979516, 0.37739499817078737, 0.4266406579077283, 0.33355795775209385, 0.3755519254843186, 0.4008563386767623, 0.38182823390360277, 0.4499139933048697, 0.47742043337959417, 0.25093913573248483, 0.26195822978734873, 0.34046156789755777, 0.24221991842698531, 0.27549068129271326, 0.340245585797454, 0.23478934263537343, 0.2996744305541411, 0.35049143463870625, 0.19069498747646862, 0.20461810399749258, 0.21652226710123157, 0.19186814815413777, 0.1825560852976832, 0.20536448550979214, 0.19222466701134056, 0.17966486057187392, 0.18923596474708815, 0.18189189485384027, 0.23698873468342674, 0.2128990712084371, 0.2021911559142615, 0.2661789086147037, 0.21782381494358827, 0.18970703723154636, 0.21351878467782393, 0.1873244558689493, 0.1654911108336803, 0.17687460970293345, 0.6944820771593783, 0.49854793089008886, 0.17410883604059324, 0.5996357374992876, 0.28315885768828386, 0.15712285136377502, 0.19008888758066256, 0.2530933795334508, 0.16182792580641092, 0.20029452765428546, 0.1939939311683826, 0.1517702496764749, 0.1584016156739817, 0.2048349430602524, 0.20487952365219897, 0.20927227998893372, 0.175132400886285, 0.18371861113241406, 0.21052055287380522, 0.18975683976048607, 0.17890178790641897, 0.18481136638710016, 0.2056978671696018, 0.1816152122485707, 0.1888825916064758, 0.07298443761316664, 0.08153428471866264, 0.08328587256339892, 0.08084750774081217, 0.07922533649745744, 0.08120593605246906, 0.08377969605749147, 0.08210202970812219, 0.08898413934941307]}, "mutation_prompt": null}
{"id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 35, "fitness": 0.3673020046215435, "feedback": "The algorithm EnhancedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "f88f4bcf-61f4-4f16-a30f-7f84e00dfd39", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "ff36ed5e-4f0b-4408-a017-2fe124a7e64a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "8ee98bf4-9ded-47e6-b84c-369b0784fbf6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "3417b2f4-5774-4eff-9ebf-a697874a8d1c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "7ffa3df3-aea0-43f7-9e7a-0dcd1bd980b6", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Dynamic population adjustment\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Adjusted mutation factor for stability\n        self.crossover_rate = 0.9  # Enhanced crossover rate for diversity\n        self.strategy_switch_rate = 0.4  # Fine-tuned switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n            \n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Narrowed range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Narrowed range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Differential Evolution with dynamic population management and adaptive strategies for balanced exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.33106027344760125, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.8310281910481001, 0.6857436148394133, 0.7661712851604252, 0.8282106506207466, 0.8053743392486479, 0.7590224060619469, 0.8350221295651772, 0.6800058157330376, 0.7605072502804892, 0.6223697743886063, 0.43332617406614915, 0.604011135554669, 0.6617202448929158, 0.6758119602792256, 0.6220644135817299, 0.7128319209963425, 0.4611898119128135, 0.6207683720094914, 0.13613494616854005, 0.13976748058984756, 0.10192234569156011, 0.1308718967533372, 0.2504622354574241, 0.1519341453057026, 0.1237494863497679, 0.16751579886621382, 0.12340599519059747, 0.11456192162838852, 0.1279235422669106, 0.12931175485891677, 0.12588617630336485, 0.1300768575522454, 0.10682055914522226, 0.10939495631333851, 0.1273646102959448, 0.10291155987941425, 0.9160902359089047, 0.9183266095698943, 0.8845822310808984, 0.9153601431781205, 0.9450480005556982, 0.8774652773129911, 0.9011708796483426, 0.9222170670019835, 0.8882591094048099, 0.38261647046596214, 0.37985781347015835, 0.421252611806883, 0.3771369274580815, 0.38911883088174326, 0.5015656977898666, 0.40665798269313724, 0.35731335310035783, 0.48088459219672863, 0.7763715159668048, 0.37791562566369097, 0.6864975133457206, 0.760871338201188, 0.8161707505608055, 0.7337280347448476, 0.7565008546716978, 0.3302069070644915, 0.7620089257043318, 0.21572159037365668, 0.17769125208688952, 0.2954894405516061, 0.16916474678450666, 0.12312606311665586, 0.3120751899724584, 0.22945694811327144, 0.16105254345935083, 0.2883375132722428, 0.2298028183359383, 0.15890093223190693, 0.2544862663659384, 0.17225194131354804, 0.12200188469745243, 0.19682763222031052, 0.17093299008606389, 0.1532410952779497, 0.4507347524489175, 0.1769512958137608, 0.07333283319726469, 0.2683660594262277, 0.16183001097940175, 0.11805678777810613, 0.26983958982639267, 0.2712336908450802, 0.07044396794693619, 0.3599809052188866, 0.29035042754861584, 0.20573770430552574, 0.38504574302803407, 0.10792122526157677, 0.1862799098084008, 0.3826381323420538, 0.390139087754217, 0.2943569444311577, 0.5081568196821133, 0.14265833835130526, 0.11675849204306377, 0.10190728773030022, 0.15041104259322746, 0.14575880103748606, 0.21897131772239098, 0.18451076077995854, 0.24969384428553965, 0.13520214564802102, 0.2874476588980601, 0.3274929155010141, 0.29283282840560276, 0.2665921896909985, 0.17907298952525597, 0.32560641962959636, 0.2553582408108901, 0.15310918538684948, 0.2900217817351598, 0.6060822488412937, 0.5549195868390856, 0.6648503566820162, 0.6263294289557271, 0.4913524504684845, 0.670010471094209, 0.5668915981889219, 0.5005380371302801, 0.6561509009657693, 0.1085366036913551, 0.15908725685961633, 0.10478150200062597, 0.11598950271826436, 0.13131809421853746, 0.09359568401043727, 0.10151812754601253, 0.24988563647400552, 0.12812964782266667, 0.14497656491468225, 0.17223849796631696, 0.14579946801389965, 0.17448454591462592, 0.1527068683516527, 0.13824315295320155, 0.28662504699378233, 0.13728133985147783, 0.14735627314637334, 0.3563005669340027, 0.39658337244204533, 0.3709462756926477, 0.3790062701999939, 0.3016526765129963, 0.37856814814455064, 0.43704863241340075, 0.3559875365786924, 0.43443863238263614, 0.30523741850754305, 0.22308416814760756, 0.29872841194392385, 0.29505192630916466, 0.2947325074019812, 0.26386064518124863, 0.3563208448754437, 0.24034138890070822, 0.301257635807754, 0.21913102407978147, 0.1890321292902133, 0.18022179584547815, 0.2048327246579822, 0.21065815240197505, 0.188924404872435, 0.19692525123735138, 0.1937890947851857, 0.17691448301802482, 0.37090361767390634, 0.19662819045107227, 0.2146902749007602, 0.34289255033619015, 0.23038338328038088, 0.18920004194006046, 0.22606252752907308, 0.19096986444717445, 0.2505233493888761, 0.7579258335231963, 0.1650875286517014, 0.6982017863775505, 0.17789712012694892, 0.7190686128666908, 0.17882580834809925, 0.1830972805139517, 0.1402446836439022, 0.7843744231375581, 0.19600983528290128, 0.2017715837154248, 0.583019196564124, 0.2072526864877846, 0.1617246890770312, 0.44431720302972944, 0.20452796732474998, 0.2075922720125999, 0.2064419893867273, 0.19392496367926249, 0.18974840636841261, 0.16830736081400755, 0.1830767978485317, 0.19593095127065197, 0.1997133701209226, 0.19119771139832842, 0.18340286143765305, 0.18349491424947129, 0.08445402826669068, 0.08250951662942585, 0.06948180536659543, 0.08665205443160284, 0.08633556471106385, 0.08654261579913158, 0.08426944083707277, 0.09874624035278523, 0.07658711592206413]}, "mutation_prompt": null}
{"id": "22ba4b40-56b8-4ed9-ad73-0780372f413d", "solution": "import numpy as np\n\nclass OptimizedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Refined mutation factor\n        self.crossover_rate = 0.85  # Refined crossover rate\n        self.strategy_switch_rate = 0.3  # Adjusted switch rate\n        self.local_search_probability = 0.2  # Adjusted local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Expanded range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "OptimizedMemeticDifferentialEvolution", "description": "Optimized Memetic Differential Evolution with enhanced parameter adaptation and dynamic local search for improved efficiency.", "configspace": "", "generation": 40, "fitness": 0.3510887389834628, "feedback": "The algorithm OptimizedMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.8210633268734097, 0.8271868593099557, 0.7683109022080635, 0.8416433076006673, 0.833948420387328, 0.7715783885471721, 0.8235884129336424, 0.8509063528661942, 0.7702696022273919, 0.6657548066932868, 0.6822880245023023, 0.6700851692703617, 0.6702663997372785, 0.697610346264355, 0.6651965546171303, 0.6638425928686515, 0.525699357268705, 0.6583347704451592, 0.11996027407876753, 0.12861945316285528, 0.12741919060232065, 0.13856199174772443, 0.1484672210457738, 0.12066490859852586, 0.1292580635322369, 0.14402158708287005, 0.14149836542518657, 0.11249221424476108, 0.13709642708673642, 0.12325771371737859, 0.11553291481716932, 0.13381041485885925, 0.12705682094831228, 0.1066117559760712, 0.1466794053058995, 0.12435982540503943, 0.9385084663882273, 0.8886160871435282, 0.9131693190470759, 0.9682643826735418, 0.8949573440261516, 0.903990763242672, 0.9302424037048921, 0.8547777006978431, 0.9043055606677081, 0.444035615329993, 0.3633248870795954, 0.40912582462987435, 0.4145189855056658, 0.4403313222716474, 0.43509350823655324, 0.4774172692814692, 0.36746513559481986, 0.4372412342885359, 0.7594024563982527, 0.7803261486485867, 0.704209431420524, 0.8359192908415228, 0.7747727686251176, 0.720016570729735, 0.7637806163491276, 0.816977587528056, 0.7063508633424965, 0.22310109658592314, 0.17772327619419426, 0.17863027206014825, 0.22863531860295216, 0.18696749548142333, 0.15726106802319806, 0.19846414543893764, 0.18009118355422138, 0.16270127122098144, 0.15849790738962166, 0.17107064331982547, 0.1833923921459254, 0.3286057490109564, 0.17787461031637664, 0.19375863749424072, 0.3090872641846413, 0.25778347843387506, 0.1659114580771166, 0.34285254699760204, 0.16166508722604667, 0.22852481538200053, 0.34530453304154773, 0.1443531861760432, 0.13697884647583392, 0.3310651375910113, 0.1524665042688279, 0.1917965654796221, 0.46829476772160794, 0.337138676535918, 0.2766567862232887, 0.4494388717077894, 0.3508990039236919, 0.333740928363923, 0.49163355651403207, 0.3091318556292777, 0.3228397886674548, 0.10618670685558373, 0.0890651136211138, 0.09390320971414234, 0.14821874481894082, 0.07774029060141363, 0.13222933181192964, 0.18818598033398848, 0.15677792934997137, 0.11584324996246764, 0.297044970121242, 0.33673488714670063, 0.24492946661972048, 0.33363379486665423, 0.2656439683880951, 0.31837324115553256, 0.3009871231850517, 0.21202887553840888, 0.23262142314863454, 0.706798173032107, 0.6258534490759842, 0.6017714417045408, 0.6841280479158232, 0.5578119036675091, 0.6366663316649337, 0.6886561747335702, 0.6195290602970449, 0.6214884645669347, 0.10453673909847783, 0.104571347444267, 0.10244076368270238, 0.1211322660369013, 0.10853817211368644, 0.10062303991002575, 0.09949914159098228, 0.10534826403968911, 0.10140975850505984, 0.18430949699670518, 0.17910534261667033, 0.1817977632511948, 0.16271160362200898, 0.2034295310359937, 0.1850844953481765, 0.15510853539316793, 0.12778689506606877, 0.19250377377023775, 0.41142145481681114, 0.3657277767038266, 0.3807396171476789, 0.38149772869260934, 0.45531255996632114, 0.38069550552591314, 0.42049995495350756, 0.39231656208426635, 0.4528786274332307, 0.30031786529964277, 0.2817587273022548, 0.28286089567786876, 0.28555458160572544, 0.2803537667733773, 0.3478409753919893, 0.3356974425714718, 0.2618892939863039, 0.3021504129033119, 0.20613593877559133, 0.18793514928210087, 0.20324317669878433, 0.16536142384026042, 0.20102778794617338, 0.20819598901333403, 0.20182656580618608, 0.2127753216325302, 0.2032005030880467, 0.2910919861753507, 0.19518285187277562, 0.19073520687391643, 0.3392616203507587, 0.22282031099316169, 0.18681341495544745, 0.18658764412966322, 0.33368249595830723, 0.20501210129505676, 0.747760013032993, 0.7873860002694117, 0.3985759272794377, 0.18249769699459517, 0.6352746209368425, 0.6691987263034846, 0.1842291981929618, 0.6067065292352221, 0.7332630316772246, 0.18768651327581776, 0.16560241252181318, 0.4583385232798697, 0.20248694837790637, 0.19506783850474763, 0.16439675058190983, 0.6281530799785199, 0.2078640871394406, 0.6279969152758293, 0.19200897950499995, 0.19148757716856046, 0.1939362459763352, 0.17624432958327563, 0.19783574273300497, 0.18095014380586627, 0.18558601428348798, 0.1832548833244163, 0.20714492402371887, 0.08483700208972955, 0.0881249139369018, 0.08627800280590403, 0.08265454294374464, 0.07919238416194863, 0.07858441456613396, 0.0895633108361853, 0.0959328534745928, 0.09145260999667904]}, "mutation_prompt": null}
{"id": "c2b7befb-5341-433b-a406-e84470cb9590", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Adjusted mutation factor\n        self.crossover_rate = 0.7  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.25  # Adjusted switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                d = self.population[np.random.choice(idxs)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    mutant = np.clip(a + self.mutation_factor * (b - d) + 0.5 * self.mutation_factor * (c - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Narrowed range\n        self.crossover_rate = 0.5 + np.random.rand() * 0.3  # Narrowed range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 70))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with dynamic strategy adaptation and refined parameter control for improved performance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "046166ca-c9e0-4509-95dd-51f7b43d5757", "solution": "import numpy as np\n\nclass RefinedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 60)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Further adjusted mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.strategy_switch_rate = 0.4  # Modified switch rate\n        self.local_search_probability = 0.18  # Further increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.permutation(self.pop_size)\n                a, b, c = self.population[idxs[idxs != i][:3]]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[idxs[3]]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Modified noise level\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.35 + np.random.rand() * 0.65  # Adjusted range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.3:  # Adjusted probability\n            self.pop_size = max(6, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 60))  # Adjusted range", "name": "RefinedAdaptiveMemeticDifferentialEvolution", "description": "A refined Memetic Differential Evolution with dynamic crossover and mutation rate adjustment to enhance convergence and robustness.", "configspace": "", "generation": 42, "fitness": 0.35879751816746824, "feedback": "The algorithm RefinedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.7540445686364133, 0.7825791754576702, 0.8006099210953459, 0.7707441995421466, 0.7948450436700413, 0.809996550800385, 0.7509667525016792, 0.7783460418480586, 0.7883895082258546, 0.5920262937373106, 0.6521961359335551, 0.6875779372614957, 0.5878385885182463, 0.6400055937594044, 0.6744860659318366, 0.5582578517289298, 0.66157936288339, 0.6650855409832794, 0.12989977481739112, 0.23553736356240895, 0.13360344245689482, 0.1215601401593347, 0.12896247823840734, 0.16480165332578345, 0.11984095389035843, 0.14233525843992956, 0.1430153038993338, 0.10571951459620976, 0.12509787483851165, 0.11845897814232742, 0.0990089080660902, 0.12326538582966184, 0.1301938300408736, 0.10515150813894036, 0.12619100213195888, 0.11236684353372661, 0.9824197671802263, 0.9002903405564902, 0.9064935393080026, 0.9380963075832316, 0.9604633367071962, 0.8825132479075604, 0.9029137303222408, 0.9259315316124165, 0.8863249258384932, 0.42729162893429373, 0.4036405105150199, 0.4268339086976526, 0.403609015245612, 0.47497412441063724, 0.47895941733669467, 0.4286468958533952, 0.3888726721977378, 0.5336065357757389, 0.6554136171724427, 0.7696870087780829, 0.7298150390610653, 0.767077186892472, 0.7680583785884525, 0.7157070161809698, 0.7147122650286069, 0.7574571544156734, 0.7287996139075271, 0.34151940595833097, 0.19380420398504727, 0.2373431744359441, 0.18971202057654069, 0.18070863852694496, 0.1157650167535268, 0.2751859563230834, 0.15882854564185223, 0.20237505700370162, 0.18980990042054402, 0.28509484737948343, 0.18827109921714358, 0.23274698937132587, 0.21615373664914228, 0.18373917376935933, 0.17898844646118794, 0.18845437483948158, 0.20753902086744203, 0.3106644936053896, 0.23085045230020618, 0.30108393306741776, 0.33003607275062363, 0.20215085704470115, 0.4140317577541266, 0.35248702706146906, 0.22337210270752528, 0.34136917253873333, 0.485685750862323, 0.3244362059930881, 0.3780577400428281, 0.43193765489728, 0.36411881561084714, 0.45422573736739413, 0.4573973898738004, 0.4104077207691984, 0.40181258363277117, 0.14914347000794803, 0.11793337041435747, 0.11678343429628146, 0.134608642187937, 0.16447755471573278, 0.3390262575320626, 0.12744299508829648, 0.10272208852486253, 0.1774906559315934, 0.28537869252726966, 0.22269256733894183, 0.23918048410154014, 0.3107903900174721, 0.2570343056363281, 0.3330046202010185, 0.24865248348225344, 0.21681078388912522, 0.2394100925591358, 0.6284964829512891, 0.645371655191906, 0.7292385458255246, 0.6686619490856739, 0.6708419796998757, 0.5928208368012338, 0.6569121679263651, 0.6140248808788656, 0.6514400952701567, 0.09850712985070331, 0.1174132837432097, 0.10223993339544324, 0.10190763719142792, 0.08988812743016639, 0.10128583323140106, 0.0994155867044283, 0.11071921585843136, 0.10749352312634997, 0.14768743296785347, 0.16026037670877047, 0.15906672416514633, 0.14302026558656344, 0.19190883555858695, 0.1485780547770028, 0.13089985273553972, 0.15752429604983864, 0.15401848264837137, 0.4018656433487453, 0.375433096216817, 0.40126945752663856, 0.3878173011002175, 0.39141676654327295, 0.48641392333534117, 0.42706973171826357, 0.47135316964708196, 0.44376473880862133, 0.3085339298384566, 0.28457900228285793, 0.3590411343911408, 0.2859527297199641, 0.36129704192180434, 0.331040129536907, 0.3080162595517084, 0.3011939613695729, 0.38961991027381004, 0.18841466707845234, 0.21865727292943837, 0.224257334868451, 0.20842958292666225, 0.19739309528822468, 0.18881970153783412, 0.18465566532731048, 0.19948292677823443, 0.21586401453860693, 0.19779454616013825, 0.2577452865096489, 0.27665628052967384, 0.19966226909358242, 0.2133984984497127, 0.20996947358504225, 0.18136585082839274, 0.2147636513230986, 0.33427437026382134, 0.6962670627364843, 0.6695606291670074, 0.6367192527491119, 0.15761790902366135, 0.5622667964250133, 0.618701344410389, 0.5995770289713244, 0.16775445326517113, 0.7525623424064185, 0.6078296951177724, 0.5602432359328113, 0.46611589625736005, 0.5135067465116875, 0.20192954695165832, 0.5722309491599218, 0.1936541808722938, 0.2123898007112861, 0.2033823750677175, 0.17747317802587625, 0.18216512460013556, 0.17942754011311168, 0.18586782228341214, 0.18615846862442764, 0.18319620434807482, 0.20355552326422377, 0.18137095189877261, 0.1867925978720708, 0.07689668040966335, 0.07326259156217607, 0.07481043817506217, 0.07893657867389814, 0.08000807646467967, 0.08123339043560152, 0.0712287476268606, 0.07914104529769139, 0.08356209110957402]}, "mutation_prompt": null}
{"id": "e9b0ad7f-c138-456b-9f53-0cbd2c77b6e4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "ffdf0d5e-8e00-462f-89c0-3b641d012007", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.strategy_switch_rate = 0.4\n        self.local_search_probability = 0.2\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                if np.random.rand() < self.strategy_switch_rate:\n                    mutant += 0.3 * (self.population[np.random.choice(idxs)] - a)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.02, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3\n        if np.random.rand() < 0.15:\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Memetic Differential Evolution with refined mutation strategy and dynamic adjustment for improved optimization efficiency.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 52 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 52 is out of bounds for axis 0 with size 50')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "b3375cbe-335f-426c-b8a4-4c2593976f28", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "8f46bacb-be3a-4b8d-810b-97e0ade41696", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "f2ae4478-9ded-41e1-87ed-3b28e4c0d071", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Modified mutation factor\n        self.crossover_rate = 0.85  # Modified crossover rate\n        self.strategy_switch_rate = 0.4  # Slightly increased switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.delete(np.arange(self.pop_size), i)\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.35 + np.random.rand() * 0.65  # Narrowed range more\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Narrowed range more\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.25)), 70))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with refined parameter adaptation and dynamic strategy switching for improved optimization efficiency.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 61 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 61 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "6931c497-9edb-4a0c-b4b7-12587ed0191a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "29cc2e2a-fd21-4d53-bd67-697fc845fd68", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 80)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Enhanced mutation factor for exploration\n        self.crossover_rate = 0.9  # Enhanced crossover rate for better offspring\n        self.strategy_switch_rate = 0.3  # Reduced to balance strategies\n        self.local_search_probability = 0.2  # Intensified local search\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.random.choice(self.pop_size, 4, replace=False)\n                a, b, c, d = self.population[idxs]\n                if np.random.rand() < self.strategy_switch_rate:\n                    mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 80))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced memetic DE with strategic adaptive mutation and crossover, integrating novel population control and local search intensification.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "0ba78ba5-0ed9-4499-862f-4b7b7d0b33c6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "8ee8dd68-515a-4403-8b1f-ecc908d77054", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "0bba31a8-2b97-4cba-a039-14e155029ccf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "2f1dafe0-8206-4fa3-9e72-8bfec9ee4a92", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Slightly increased and dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Further adjusted mutation factor\n        self.crossover_rate = 0.75  # Further adjusted crossover rate\n        self.strategy_switch_rate = 0.3  # Adjusted switch rate\n        self.local_search_probability = 0.2  # Adjusted local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (np.random.uniform(-1, 1, self.dim)), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)  # Adjusted local search step\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Modified range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Modified range\n        if np.random.rand() < 0.15:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.25)), 70))  # Updated range", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with refined crossover and mutation parameters for improved convergence.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "6ac68df4-4c60-489b-bd55-fb2d155ace2f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 72)  # Slightly expanded population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.4  # Increased switch rate\n        self.local_search_probability = 0.18  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(6, min(int(self.pop_size * (0.9 + np.random.rand() * 0.25)), 72))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with improved parameter adaptation, dynamic population size, and refined local search for better convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "66b9d973-3553-420d-9136-02989cb9eb76", "solution": "import numpy as np\n\nclass RefinedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 55)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Further adjusted mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.strategy_switch_rate = 0.3  # Adjusted switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial += np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Adjusted range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Adjusted range", "name": "RefinedMemeticDifferentialEvolution", "description": "Refined Memetic Differential Evolution with enhanced adaptation mechanisms and dynamic population adjustments for optimized convergence.", "configspace": "", "generation": 55, "fitness": 0.3650228848858927, "feedback": "The algorithm RefinedMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.8171137848243943, 0.8155810193935442, 0.7650550322290601, 0.8167148788848488, 0.8212620260000224, 0.7743107516015028, 0.8157353999644776, 0.8240697498682883, 0.7692721023747495, 0.6870555655378794, 0.7013326700408886, 0.6509549082802282, 0.687653988000627, 0.7192127550244516, 0.6568835724802287, 0.670372947264929, 0.6917821130323238, 0.640686752628411, 0.1152862624129688, 0.14112520767893888, 0.12949110101875883, 0.1379499661600404, 0.22012649126596295, 0.1518014239150398, 0.1198873450309691, 0.14157730877256125, 0.1504678854370919, 0.10296979208265222, 0.12573600878115498, 0.11127109910564614, 0.11098993248410316, 0.13165862014881513, 0.11163634913525, 0.10914167265885466, 0.14131266592332592, 0.10208956709890227, 0.9229978688971794, 0.9726294367439862, 0.9365506706376179, 0.9742834185057252, 0.9133088935170504, 0.9089756196671275, 0.8582640920054521, 0.9035173998249371, 0.952595045817486, 0.46251671641197734, 0.46775509515692115, 0.4407811962248781, 0.40587863914838807, 0.4738623662263173, 0.5758580884928265, 0.44078471773820294, 0.4395586256467444, 0.4716505154475912, 0.7533226305258934, 0.7605429780045263, 0.6852769914316452, 0.7637309610380352, 0.7998052664548924, 0.7489635321881039, 0.7616815395459267, 0.7531589841624721, 0.7150815654143808, 0.32534815075650236, 0.17548082608075533, 0.43052756393249403, 0.23408799079273024, 0.1987968973606391, 0.37147965693152896, 0.36914758083709454, 0.2101386449167566, 0.4800949153663816, 0.2621083892817019, 0.19545782266860756, 0.2614388861499659, 0.24366300989628986, 0.1810843378061331, 0.26595351991592964, 0.30242802686549297, 0.18588323254566863, 0.19794725667081337, 0.2992816803890299, 0.20419528548300092, 0.3281498065206041, 0.33189162661973715, 0.4642125270665304, 0.2918620219546275, 0.332073585993665, 0.3489237558730356, 0.38390180890088177, 0.48337068997093846, 0.46471873556484755, 0.39707721337715396, 0.4648181929524522, 0.5922887705786917, 0.4320483300626825, 0.48959215874292816, 0.4267859668676065, 0.4877782518974957, 0.2309589882399805, 0.1390942839549214, 0.11246570111056775, 0.12129539369136799, 0.21884840830516894, 0.10100490523224503, 0.17405867000515196, 0.1119911925012097, 0.11490623608089501, 0.28490912991138273, 0.3152731291921347, 0.3085007316796009, 0.3181724787041529, 0.3246516080454639, 0.31110118354716165, 0.26840182921034006, 0.33794109128731165, 0.30998144033758446, 0.6865665646737714, 0.7387658878537511, 0.637424514653314, 0.6949261613782164, 0.6560176465481531, 0.6520669947643766, 0.7049417703138081, 0.7559153374557671, 0.6439171443600098, 0.10129508061968628, 0.107076148045128, 0.12170006836345315, 0.0946898496542764, 0.11169313106273515, 0.09672722862726568, 0.08865447039594543, 0.12207038795705516, 0.10735392300622493, 0.21336016025873628, 0.1553298767015715, 0.14340724129121296, 0.14265199396671557, 0.16735462625937236, 0.18597609602370901, 0.1457028838935801, 0.15650305146493393, 0.13645627630257062, 0.38815587461235634, 0.4474803725279384, 0.38289467551964484, 0.391552554459472, 0.5124160076545287, 0.4054471972584729, 0.44059096753963944, 0.5054563113457322, 0.44073665054356004, 0.2879228466304887, 0.31768986571250113, 0.3701522142541761, 0.290734986323663, 0.3504110738097346, 0.29498114278360343, 0.33577551569233655, 0.368329108236537, 0.34394050235440754, 0.20648009122241084, 0.21042697914857145, 0.2030699322797147, 0.21877563134401323, 0.2106833066715812, 0.1907126122098387, 0.2099011682475238, 0.19235328756579406, 0.19816701454285135, 0.19089930776519604, 0.18634764738663345, 0.19477567950613994, 0.19217923071448473, 0.2985200774615233, 0.21724722697660526, 0.19597646464998741, 0.21746020280867862, 0.2910550153947463, 0.16016074162045002, 0.16692915954173038, 0.16216851534640297, 0.6272422829203503, 0.1951162771064595, 0.7439028806418003, 0.524029663557331, 0.1711249592789078, 0.17964266217261515, 0.1589208218891648, 0.19020646236851468, 0.6928780037957386, 0.19380865916271728, 0.1989793016554371, 0.5470771787287302, 0.14644708096415393, 0.7523197700714502, 0.19543898795322767, 0.1764762152926609, 0.17747443369741556, 0.18470105496550793, 0.18030017664718745, 0.20117839253851433, 0.19554072249425758, 0.174804852971016, 0.20995578800178183, 0.20841176169899422, 0.07714522027488513, 0.07966011865608014, 0.09158645488457007, 0.0726764049458497, 0.08005664885769981, 0.0723325613031004, 0.0732317168942953, 0.08035761584594892, 0.07392123751122803]}, "mutation_prompt": null}
{"id": "574e2368-bbbc-487d-82c0-99ad338cd30c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "12bc3bf9-d9db-4860-8af4-e774f83d9bd4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Adjusted mutation factor\n        self.crossover_rate = 0.75  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.3  # Slightly reduced switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Updated range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Updated range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.25)), 50))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with selective parameter update and dynamic local search for improved optimization.", "configspace": "", "generation": 57, "fitness": 0.2928782029558154, "feedback": "The algorithm EnhancedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.736233182683743, 0.6072783341285846, 0.6809286297141464, 0.7954248754345, 0.7814685525489448, 0.5554483862318558, 0.8445652664134671, 0.6850937779054955, 0.5779520334333872, 0.3610564020825737, 0.3447152978799878, 0.27573114653100805, 0.3480398552449877, 0.10082147729122881, 0.1997807514091141, 0.4328950846471079, 0.3398403831520441, 0.14312704081353445, 0.17405429765502045, 0.15556289235758558, 0.1551770521925473, 0.1472244058459501, 0.13832490650563434, 0.1789542984541337, 0.13385939559323035, 0.17348628585616332, 0.12924341450444576, 0.11500512246181549, 0.1382943402736302, 0.15230216614168657, 0.1308460928864037, 0.10521641995128317, 0.1066487383334297, 0.14482160337359495, 0.11091605409368765, 0.14978731761064135, 0.89060715288061, 0.9122505283441329, 0.9388895379790828, 0.9771160789982588, 0.8770417093243714, 0.9269230473991321, 0.9007122418044365, 0.9442111243757139, 0.9300420873819558, 0.36613202207478845, 0.3871843189635539, 0.3640302354925278, 0.37719132585429793, 0.37062258048579166, 0.39683414400545647, 0.38096440924704844, 0.36288540495166643, 0.35287624275350826, 0.8562913864824636, 0.8632371713769131, 0.9025261615451217, 0.8302737651422895, 0.3497412455102147, 0.8807788228431218, 0.8584975776764312, 0.7365747786835724, 0.21835399852540294, 0.19581168296187357, 0.15936193885450034, 0.19477021766436087, 0.1789399361727645, 0.168904588626953, 0.12535949990402206, 0.17253577388280594, 0.19619906739228343, 0.1449664849532999, 0.18671528405244375, 0.16879815212956295, 0.17886071325114916, 0.1523499183177104, 0.16961575146904384, 0.12594571485553918, 0.1712042889208244, 0.1841107199609584, 0.17585360678686757, 0.06659183961591386, 0.14606849478818462, 0.06440640143589338, 0.1119409121818078, 0.10017004534900265, 0.012583782617357597, 0.06935011935357238, 0.0985194481286098, 0.0801277307526359, 0.2971110077498803, 0.14821938814042224, 0.07512233141078994, 0.10729879587673408, 0.13720495002182231, 0.1000387974983149, 0.25443622910200336, 0.2712930032625429, 0.11026941020537417, 0.15133505645513268, 0.11407677153502283, 0.16088481203223493, 0.1394162629716813, 0.10052467013384647, 0.18780577326296777, 0.18769980776620487, 0.21936188897725473, 0.10096422748374134, 0.19261062675356133, 0.19961775829334916, 0.14406297358989395, 0.20488267537539873, 0.28757231592437216, 0.15975119533852444, 0.17765029211952443, 0.1884450287215197, 0.1031659805863736, 0.49841796824630724, 0.5017492385396516, 0.49431121344198004, 0.5799853153537283, 0.46487097021226453, 0.46673955739235207, 0.5203823743528597, 0.5135912228848569, 0.5193589813120976, 0.14917378711014284, 0.14996758600532323, 0.147670821657936, 0.12486813964271715, 0.1099776782904599, 0.11035839333633735, 0.16698226538487015, 0.11923979578650268, 0.16949764453989624, 0.181713011937376, 0.2113377703116992, 0.22114733731181546, 0.16230230041104987, 0.14038833088611224, 0.24649725138844858, 0.18283685261506744, 0.2009350873492879, 0.19819253303728113, 0.38417222414471985, 0.35163326724944244, 0.3471459140320251, 0.34199453285550785, 0.350676781328925, 0.28731333571595297, 0.3299732173418364, 0.4349292880528034, 0.32781037833443716, 0.2371180145211922, 0.2429886388180671, 0.23492113057552289, 0.2529866517764011, 0.2569465276084023, 0.22066330405088874, 0.33001762078594565, 0.2681355885032246, 0.2929699534851329, 0.21623353572965465, 0.2160006348613026, 0.19281661035476327, 0.19472265021642676, 0.2059421537958087, 0.21461103007010052, 0.22313240894257824, 0.2036450653675903, 0.23530892480389243, 0.21804076353561297, 0.20366669513211255, 0.1810080670318559, 0.171189866876729, 0.19312407945412147, 0.1914292118752401, 0.18655859766964644, 0.1936831559130977, 0.19411730184781306, 0.7643917214880576, 0.9018614997031666, 0.19444573936353826, 0.18872985460209468, 0.1694206719366792, 0.8870090079546491, 0.819883501671412, 0.16621548656199225, 0.18291774888269752, 0.3869493183571834, 0.20637980318404436, 0.15421406903312274, 0.2050061201743557, 0.20546835551510745, 0.20544019586239448, 0.20695625776877968, 0.21109178534976702, 0.20488437375383228, 0.1798114208979772, 0.1989571802781943, 0.18476366739940242, 0.20202577772132202, 0.18922537962417896, 0.19684356801624103, 0.19597543608380297, 0.18633053632802055, 0.1800980881537968, 0.08568263290114941, 0.09869958951054991, 0.07267203707955017, 0.08488340612940626, 0.08570352459599162, 0.09101089596381373, 0.08040348192294, 0.09450281013408057, 0.08891781644874941]}, "mutation_prompt": null}
{"id": "8cce8e9e-9724-4c4c-a738-873a4914b2c5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "d6da2a59-1ed9-4c10-b0a7-41b8facf3eca", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(8 * dim, 50)  # Refined population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Refined mutation factor\n        self.crossover_rate = 0.75  # Refined crossover rate\n        self.strategy_switch_rate = 0.30  # Refined switch rate\n        self.local_search_probability = 0.20  # Enhanced local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c + 0.3 * (d - a)), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Enhanced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 50))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Optimized Adaptive Memetic Differential Evolution with refined parameter adaptation and enhanced local search for improved convergence.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "c669143d-c93c-4c4a-bcaf-eb63f5b1660c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "7ae3380e-e00d-4713-bc19-896a1aaab308", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Tuned mutation factor\n        self.crossover_rate = 0.85  # Tuned crossover rate\n        self.strategy_switch_rate = 0.4  # Tuned switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Tuned range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.3  # Tuned range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "A refined version of Enhanced Adaptive Memetic Differential Evolution with tuned parameters and improved local search strategy for better performance.", "configspace": "", "generation": 61, "fitness": 0.33799525120527596, "feedback": "The algorithm EnhancedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.8335284761157192, 0.8230110678945745, 0.81502124704754, 0.839510927479495, 0.809705349012145, 0.794620387167606, 0.8389258973218763, 0.7535066402728596, 0.7780396075366409, 0.7307884619500786, 0.4107049659689106, 0.6567958009292043, 0.7449070256365298, 0.34926063899034265, 0.6306149096056937, 0.73036753559097, 0.39999221468004553, 0.6357045593102817, 0.22357707962732243, 0.16012774681232878, 0.14701266311546046, 0.13431627834638005, 0.16297354108221374, 0.12712094448966782, 0.15540355400407846, 0.14472958839249372, 0.1615919604761431, 0.20636130501557004, 0.134385599047824, 0.10050752951107822, 0.11615146531452702, 0.10867694019945251, 0.11012983087973516, 0.1462787770604056, 0.13886973301915972, 0.10579561698455642, 0.9268351277226249, 0.9264185440999501, 0.9119088708302829, 0.9303895773319396, 0.9496347799323154, 0.9465842221167873, 0.9038754092496584, 0.963003452251093, 0.877977046220543, 0.31609928820674515, 0.3233246163234357, 0.45809392987118214, 0.34637237147528177, 0.34560323674732096, 0.4984371581688971, 0.39470261218488734, 0.33058743781022615, 0.5137058264847492, 0.613204925133791, 0.6046568723761774, 0.6601770788957717, 0.7805315504047428, 0.8290846198740629, 0.7293762341728984, 0.7811909171686903, 0.8062564390373019, 0.7175922353056087, 0.17174687967175284, 0.1509664868620033, 0.19912675773466115, 0.16600075656596547, 0.18805557271661955, 0.17527011502276002, 0.15976347067593522, 0.1723271327909215, 0.1900051152234533, 0.18743149476358856, 0.179032342797821, 0.31487283431509705, 0.19685502107104025, 0.14726087426823142, 0.2916510147094975, 0.14108083546260586, 0.17734851204252178, 0.20132708290826484, 0.3511445861268887, 0.08025244453609726, 0.25229371742656226, 0.1859263294498794, 0.05526873720893144, 0.2548259192818426, 0.2490602408613094, 0.054171228353273926, 0.25665029851377996, 0.38775977739065504, 0.24398603172399902, 0.41929681702708244, 0.18578823298466673, 0.12312586510049406, 0.4333956337632797, 0.2792516371065811, 0.19375490172014587, 0.42921191746921794, 0.07751527328888186, 0.023312407945852986, 0.1182876902867045, 0.13659556598969336, 0.15011831054457403, 0.12247333728196375, 0.13415647226581928, 0.11607904323370799, 0.12758178516802332, 0.2567027866035335, 0.1911943217214238, 0.25775061666486665, 0.296188728346525, 0.13820481399316742, 0.2840003317362081, 0.2403135216996759, 0.16325407091498623, 0.26208744960257546, 0.5313650444685751, 0.5443178979569674, 0.6456653262482939, 0.5327274540522797, 0.53341521132844, 0.6467971691955454, 0.5602374213065326, 0.5256969914040719, 0.6502609609699406, 0.12178399990282929, 0.144882691626805, 0.09499078857655752, 0.10313984637068663, 0.11312155600717633, 0.10608329553852924, 0.10206543866174289, 0.1429929894718014, 0.09504658069125349, 0.1469521857515923, 0.31499983990979985, 0.1566665312212563, 0.15704099963065454, 0.228690705325302, 0.13720460314644656, 0.1863829876511972, 0.1462007072028949, 0.1653124595701806, 0.40484320738742685, 0.34054362720396025, 0.4201515887282168, 0.4056346334385674, 0.3984589163543336, 0.4220301396688102, 0.5362640873700273, 0.3722426195639167, 0.43374132672193977, 0.3288475190232033, 0.29289737525781523, 0.28069980508055536, 0.3072020065347155, 0.2760175788187733, 0.2912329123963878, 0.28169414510443047, 0.23226274104685685, 0.31933319740314414, 0.24260875903168666, 0.22039666270469394, 0.19195748183220418, 0.21959602267352774, 0.2242270258282626, 0.19154885948139244, 0.1981278828916604, 0.2033075048915256, 0.22131842502101928, 0.3184480254906381, 0.19730970744745813, 0.4077932072080196, 0.22874974795388148, 0.21083988521139463, 0.19334667090786817, 0.3289925421296436, 0.1961383264093769, 0.40547335308563337, 0.773084310490826, 0.18671911342996206, 0.6595604048623708, 0.7569789736030578, 0.16887894040975115, 0.5281465028230354, 0.6403069655214627, 0.7523138757037486, 0.17795158151215096, 0.5281167424986104, 0.2030823819800972, 0.4734945079420577, 0.19698427025626364, 0.2021269189052759, 0.18785172583418097, 0.20811689447109405, 0.6722769551497896, 0.20724447266434642, 0.18133151329143715, 0.1862287121725389, 0.1842904366327992, 0.18593510108269362, 0.18956960241523457, 0.19361419506734578, 0.17671336533019288, 0.18877203102817164, 0.18164761955562814, 0.08410662986671491, 0.09137597649309914, 0.08516364656828612, 0.08512146748121574, 0.0845923631596841, 0.07910535918839412, 0.08255144621384247, 0.08001123072024985, 0.07954543730218988]}, "mutation_prompt": null}
{"id": "b1e18f30-1168-4df4-b0be-3f2218a3139d", "solution": "import numpy as np\n\nclass RefinedEnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Refined crossover rate\n        self.strategy_switch_rate = 0.4  # Slightly increased switch rate\n        self.local_search_probability = 0.18  # Adjusted local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.delete(np.arange(self.pop_size), i)\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Refined range\n        if np.random.rand() < 0.3:  # Increased probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Adjusted limits", "name": "RefinedEnhancedAdaptiveMemeticDifferentialEvolution", "description": "Refined Enhanced Adaptive Memetic Differential Evolution with optimized parameter adaptation and localized search strategies for improved convergence.", "configspace": "", "generation": 62, "fitness": 0.30925909099918447, "feedback": "The algorithm RefinedEnhancedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.7204930061834931, 0.7065792814788027, 0.7348892053648428, 0.734894601546737, 0.7293178155860589, 0.7371769232863228, 0.7300616197314332, 0.7206797818268463, 0.7316456354402094, 0.5245616038536607, 0.5286041122363547, 0.5876031283707033, 0.5661124343180945, 0.5505773578773776, 0.5614000294738176, 0.5247948863738794, 0.517643946403961, 0.5408994111190132, 0.11561557077541218, 0.1096271971875834, 0.12630608161608414, 0.11712319201161592, 0.11736807545686223, 0.14594965432195273, 0.10322067140471824, 0.10850777798515865, 0.14000369950477065, 0.09510522155275758, 0.09854993797121858, 0.11301519840531327, 0.10433086689641768, 0.09587896654258476, 0.11615667127230156, 0.09095338001947872, 0.10492927298074028, 0.10451055790077513, 0.9323656328503525, 0.9529708596317534, 0.9375567676806229, 0.9225887133140789, 0.9348957154133373, 0.9554583997091136, 0.9471735512186972, 0.9520715742220857, 0.9405967514210452, 0.35307363973597816, 0.35040175542998686, 0.4170471235547051, 0.37983828154033106, 0.3298201847342187, 0.3843986893330672, 0.4006932972769126, 0.3680890955468078, 0.43324860029186374, 0.5675121040397704, 0.5867825837954304, 0.6107514371871845, 0.6209789249205111, 0.5313764581150462, 0.6501595078367715, 0.6059574904028918, 0.6099868483677692, 0.6430577737196044, 0.22992016128503334, 0.2847029176697914, 0.24734701606067766, 0.23773228794601264, 0.2284817361111403, 0.21262672315939768, 0.2817314759985826, 0.18285072552620008, 0.26211043939833223, 0.26628946815227694, 0.2158868441399765, 0.39497095390600556, 0.25626076193729763, 0.2396350534910775, 0.3201966318600046, 0.24168309199922755, 0.18712940955523283, 0.19451148721600464, 0.19878149995045702, 0.15164759648691983, 0.22101013157115124, 0.22648266032767495, 0.11860785589904499, 0.20167610402863534, 0.19888624410242361, 0.1795184283790624, 0.1860443475425907, 0.34739559444857937, 0.2456055668903231, 0.38366172189611236, 0.2981388572932463, 0.2374883803046851, 0.3502858154302251, 0.3402411220559286, 0.3241530118279078, 0.3764021496572231, 0.07653480416064029, 0.045329063200954756, 0.06488783788375474, 0.19141294814905263, 0.08500222665947621, 0.09839525940816696, 0.10324830968661824, 0.10581087305229198, 0.06946914082198274, 0.20478050821999372, 0.2030819482460825, 0.24145346316780092, 0.25303684688884054, 0.2125814756355221, 0.2571267292534315, 0.22675171856444853, 0.18925960267714537, 0.2541395212914568, 0.6066061395673236, 0.5595992627388704, 0.6591705898876009, 0.5734022361296924, 0.5384332540482507, 0.571972292404864, 0.5526974147823404, 0.5566143391514979, 0.5988732218500763, 0.09782158645668826, 0.09636190713334258, 0.09934012369265599, 0.08367478704783848, 0.09113197816330798, 0.0985450660380518, 0.08501321128317907, 0.09069418054895118, 0.08629551190778761, 0.14617074125031282, 0.15863203006043736, 0.16540295344407607, 0.15533518692766046, 0.16119249426722093, 0.17173889676289178, 0.12220156618284639, 0.14580665621577404, 0.15238505342678343, 0.32664443223569073, 0.2912357635202315, 0.34253779133084195, 0.31555784067725035, 0.3453337296743688, 0.31127743278342024, 0.33039934814735583, 0.32052766497932006, 0.3760449360417175, 0.26094327113259164, 0.23370767099662582, 0.26152647200742873, 0.2325426904868173, 0.22128817367887688, 0.2580964719416574, 0.25829275882075475, 0.2586089671953766, 0.27947038803692803, 0.18493410089112694, 0.19028632517970478, 0.18129792901572073, 0.182176129488287, 0.18326257890413433, 0.1948140390991856, 0.19810997851268708, 0.18332148606234844, 0.18507754154056533, 0.17698371238590282, 0.19318939432176319, 0.2593331313321281, 0.18174396465111975, 0.19101958103700067, 0.19456393713947906, 0.21823177559292595, 0.18354681297904252, 0.2182927516461085, 0.5552471694534585, 0.556674847151493, 0.5630049394624242, 0.5181657868917744, 0.1738908987388158, 0.16188327503485966, 0.17780778453273338, 0.18325372512171723, 0.17496973749665956, 0.5735075106280992, 0.46067086236213317, 0.18677529182143093, 0.1961096340292081, 0.19782040594510886, 0.25811042635107684, 0.2027211585417441, 0.2031779882500917, 0.2066212287247987, 0.1927486499587142, 0.18029868284012063, 0.19959116876326166, 0.18129228905112516, 0.17065478974882575, 0.19828743579401276, 0.17904873442095737, 0.19623094959425136, 0.20191885287729205, 0.0638860081142888, 0.08207902574251258, 0.0652186644664029, 0.07691528402668169, 0.07747999046826937, 0.06988086755834888, 0.07390892262530047, 0.08629028808447492, 0.07815164027515675]}, "mutation_prompt": null}
{"id": "0874f9f1-a7bb-46e9-a65e-e7c04abc4223", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "e0bb8b42-d83b-4579-ae54-8964b6369b09", "solution": "import numpy as np\n\nclass AdaptivePortfolioMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.strategy_switch_rate = 0.4  # Adjusted switch rate\n        self.local_search_probability = 0.1  # Adjusted local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d, e = self.population[np.random.choice(idxs, 2, replace=False)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - e), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Adjusted noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.15:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 70))  # Updated range", "name": "AdaptivePortfolioMemeticDifferentialEvolution", "description": "Adaptive Portfolio Memetic Differential Evolution with diversified mutation strategies for enhanced exploration and convergence.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 61 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 61 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "b8e67dc9-1504-4f92-b829-398995f494d9", "solution": "import numpy as np\n\nclass RefinedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Altered mutation factor for balance\n        self.crossover_rate = 0.75  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.4  # Slightly higher switch rate\n        self.local_search_probability = 0.18  # Higher local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Even smaller noise for precision\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Modified range for adaptability\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5  # Broadened range\n        if np.random.rand() < 0.25:  # Slightly higher adjustment probability\n            self.pop_size = max(6, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 70))  # Further adjusted range", "name": "RefinedAdaptiveMemeticDifferentialEvolution", "description": "Refined Adaptive Memetic Differential Evolution with improved parameter tuning and efficient local search for enhanced performance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "8125225f-b1f0-4427-b19a-7d85fab306c8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "abb67ac5-eeb5-4795-b60b-6d27ef8de025", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "6ec3f65f-48ee-41fd-9574-8c4764434d5c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Further adjusted mutation factor\n        self.crossover_rate = 0.7  # Further adjusted crossover rate\n        self.strategy_switch_rate = 0.3  # Adjusted switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (np.random.choice(self.population) - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.02, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with refined parameter adaptation and targeted local search for improved convergence.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "43b43e91-c25f-4f32-91d6-da8011f42b14", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "2fa3cb07-af90-41de-a23f-78c644ca5696", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "e8cbdd14-d00c-410f-8b82-1278bb26c3e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Further adjusted mutation factor\n        self.crossover_rate = 0.7  # Improved crossover rate\n        self.strategy_switch_rate = 0.4  # Enhanced switch rate\n        self.local_search_probability = 0.2  # Further increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Adjusted range\n        if np.random.rand() < 0.25:  # Enhanced probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 70))  # Adjusted range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with refined parameter tuning and enhanced local search probability for improved optimization efficiency.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "1518b269-411f-4b06-bf0c-445c4f92cf3d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "82da8a3e-ffcc-4394-85b3-8d4d153cacbf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "88114a79-7fa0-4c50-9ccd-b52d9fa099a4", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.local_search_probability = 0.2\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.02, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic crossover and mutation adaptation for enhanced search efficiency.", "configspace": "", "generation": 74, "fitness": 0.27968041147221345, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.7116700927210936, 0.6994636540382126, 0.7213422513953491, 0.7156915499399382, 0.733465882316055, 0.7291871840139857, 0.7273497787450192, 0.70128224530235, 0.7070090712960815, 0.5375701969684863, 0.5239337861331103, 0.5173719899664142, 0.5303007563983514, 0.4719472699296461, 0.5342014252420827, 0.5060111593691979, 0.4904768827748577, 0.4814148145905307, 0.11926278635351195, 0.12970258868368822, 0.11566955407154511, 0.11657092459433949, 0.12803591786688207, 0.11183624941739201, 0.1276691045173236, 0.1126023171673427, 0.12657889748783746, 0.10008539223553858, 0.13379002105763516, 0.11861362428213285, 0.1221369163696665, 0.11329412685779594, 0.11739459003313146, 0.11988775416869524, 0.12247154376932923, 0.11952731423150875, 0.9174160732799488, 0.9566716849054253, 0.9646938896427419, 0.9664587326392126, 0.9277061858539312, 0.9284201159286595, 0.942266867863967, 0.9462562426880186, 0.9249343525281695, 0.3056931100249518, 0.32466423111790577, 0.3223553514377945, 0.29899346732503085, 0.29051391186102404, 0.31942049266408434, 0.33737253037148507, 0.2909868021134071, 0.3507225558979682, 0.591891688431186, 0.5269874707611988, 0.5088543491213883, 0.589074969357525, 0.5630065257279259, 0.5723937348557739, 0.5843639792777415, 0.457229499098215, 0.5421282798561877, 0.1951544819694454, 0.1669049420877251, 0.16570393558292074, 0.18984805646192338, 0.18952629616342276, 0.1558907795366391, 0.19002257948681323, 0.1806290998219291, 0.18285468512078662, 0.10715656558618136, 0.1545547518805408, 0.1764296527726259, 0.25274580868193564, 0.16711884676916033, 0.17757156885018666, 0.195259373144964, 0.18593783956716226, 0.19435510723852645, 0.09152722872152641, 0.06250623683059675, 0.05357153735448916, 0.09036015233837702, 0.045546960947123294, 0.08317907995996288, 0.09837154123736613, 0.05269608855220853, 0.06948038306275484, 0.1698944017219275, 0.20171550315999276, 0.2289583473230994, 0.24282558480853467, 0.14474538213293764, 0.2002463292695198, 0.2077073275908079, 0.1770616507591325, 0.25606468838780405, 0.03368472933907507, 0.026358277333158764, 0.04863500893145811, 0.07931216978068711, 0.025933884579822708, 0.03564161859542725, 0.028518421161497498, 0.030816445728323427, 0.032286894223316764, 0.1536903849516097, 0.11944653886562084, 0.14329510750282293, 0.16081353360189987, 0.15484860113951615, 0.14388847823988604, 0.15515332149190653, 0.13901493418444155, 0.15283960031205712, 0.5443556033138309, 0.4907232201534415, 0.502445487024309, 0.5159890839588441, 0.48298184274854894, 0.5320251734050851, 0.5239191648136055, 0.4797524819373691, 0.5336066018747532, 0.09536768247681393, 0.10588143861847243, 0.0973614556411676, 0.09688426234458691, 0.08110672180469414, 0.11197110751221517, 0.11677070961893843, 0.07990660946846151, 0.09958310396610015, 0.2371401117388362, 0.1397154363023153, 0.1464661594149247, 0.12234935117058099, 0.15627710081368063, 0.16599322197871746, 0.13766144013221893, 0.16838036405830104, 0.15950207025578056, 0.31153898251626755, 0.29745428390345685, 0.3013259240089947, 0.296149043507555, 0.26065015122941115, 0.30612145620861697, 0.33013009922229, 0.32268277202509443, 0.33935413685013616, 0.21279568724701425, 0.21876615040696357, 0.21908441638845355, 0.24151616115338115, 0.21939806109559967, 0.2349775449811179, 0.2307558650813809, 0.22126619673308212, 0.24384763639013085, 0.1885249842152199, 0.1891569879399836, 0.18674081447202406, 0.20933823682372865, 0.183593166621982, 0.20588172476071354, 0.18895129777736563, 0.18560322658229156, 0.18265163079085855, 0.18520522485531365, 0.1979401284230653, 0.18742609537865185, 0.1968931670931472, 0.19541125918276425, 0.1838042474246051, 0.20807053172662837, 0.18148694531207343, 0.18798781505597872, 0.4850147073517326, 0.5287767691668255, 0.5329621610227562, 0.5465235044416661, 0.35122245284277176, 0.16596078978359274, 0.1766391841062661, 0.47258281955037296, 0.30402193334297223, 0.18841313464647635, 0.16033821259786074, 0.1835883242733909, 0.19259595144291908, 0.16354490125906684, 0.48058639590784824, 0.2048703346803804, 0.48083991716508834, 0.45163324303917607, 0.18217134553147807, 0.19080362818869812, 0.1866493254104229, 0.19310328272220678, 0.19680033429464672, 0.18337197899748503, 0.17672252162913737, 0.19075776493109897, 0.1765422863718048, 0.0782613106555533, 0.07895006947317196, 0.07269882854738574, 0.0678288444807762, 0.07461659999012227, 0.0771268443377845, 0.07171919902439894, 0.0784818472859039, 0.07305161579242525]}, "mutation_prompt": null}
{"id": "893a6fe4-ae47-4c07-9e70-7db46fe97d8b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Refined mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.4  # Modified strategy switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Further narrowed range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Further narrowed range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Memetic Differential Evolution with refined mutation and adaptive strategies for improved convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "44b43cd5-b2d5-4a66-a0fa-1f12635ba69d", "solution": "import numpy as np\n\nclass OptimizedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 55)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Tweaked mutation factor\n        self.crossover_rate = 0.75  # Tweaked crossover rate\n        self.strategy_switch_rate = 0.4  # Further adjusted switch rate\n        self.local_search_probability = 0.2  # Enhanced local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Adjusted range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Adjusted range\n        if np.random.rand() < 0.3:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.25)), 55))  # Updated range", "name": "OptimizedAdaptiveMemeticDifferentialEvolution", "description": "Optimized Adaptive Memetic Differential Evolution with refined parameter adaptation and enhanced local search for improved efficiency.", "configspace": "", "generation": 76, "fitness": 0.30177862841786823, "feedback": "The algorithm OptimizedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.7365003090851119, 0.7232988844619282, 0.6921509140625481, 0.7576069125367482, 0.7311064855597916, 0.7288348444534898, 0.7460538742252891, 0.7287927515630719, 0.7237531824979061, 0.5957895795736834, 0.4972954713928518, 0.5070189877103051, 0.5715687842326718, 0.4987560736567265, 0.4986879762969806, 0.5947659176377265, 0.5134521251034636, 0.5038606060844929, 0.12935148989565137, 0.11135967827141446, 0.1125324409383871, 0.10965571287003917, 0.11866232860887616, 0.10423189448144532, 0.12444756664527123, 0.10108297488738538, 0.11324254860376604, 0.10457571240131291, 0.09985024055147718, 0.1271829118981832, 0.09648604706080821, 0.10111193384493289, 0.10209131567215113, 0.10770053160056836, 0.09943477529029021, 0.11227559541623, 0.9708334585980996, 0.9067184222031097, 0.8698695716314562, 0.9134623432325517, 0.9358548288974811, 0.9515224112970184, 0.8931724637785777, 0.8986166034927776, 0.8959727824423017, 0.39460590943850804, 0.3263614627850594, 0.3277734849184536, 0.4121696829064917, 0.3242804274316944, 0.33962992505838574, 0.3641864149113142, 0.3153720342770333, 0.32411574790963804, 0.6931992870401231, 0.46611604847454235, 0.6058205070309022, 0.6864277675647672, 0.5464629365294564, 0.6582914839962011, 0.67138144286582, 0.6152133422230072, 0.6604239040742376, 0.24549148123189346, 0.1902328993900284, 0.1463697668968258, 0.16718274004466926, 0.17781152077178142, 0.15540368091150836, 0.17971520586994916, 0.1860842101470358, 0.20458020895721862, 0.14869743150170267, 0.15421194195872412, 0.19976910318567498, 0.28757134124134354, 0.23285887348377976, 0.20595537242334194, 0.22877423904500016, 0.15239127033841282, 0.17715213218979387, 0.22748675451478007, 0.11940770143314161, 0.16665480044490177, 0.198943454046137, 0.13847794697885163, 0.16199192762978054, 0.19297065972584948, 0.12350547475629103, 0.15020171758851097, 0.3413407092024271, 0.22689900840902277, 0.25880866893208554, 0.3224684988955754, 0.23095672719488647, 0.279326785662827, 0.36330609734186803, 0.28407211945154454, 0.32245674391898205, 0.052700410801396536, 0.051354161770435724, 0.04895965241192557, 0.1003302152491975, 0.06270102679960277, 0.09188912268205152, 0.11578450435547971, 0.06521675290080875, 0.0357742746020282, 0.19498650751676727, 0.17214432702328364, 0.1845189517028103, 0.2471150639380928, 0.18114207111962455, 0.1888019824164946, 0.1961788213137191, 0.1831254495250697, 0.17734630301824839, 0.5617329363173365, 0.5621446066403728, 0.5408750792245127, 0.5702918417312465, 0.5152902213389343, 0.5409956115652954, 0.5794312431557161, 0.5399064474177777, 0.5212922515952932, 0.08781967042153282, 0.0937642475656294, 0.08849242741277197, 0.10779044473053623, 0.10659530899138714, 0.08094238332394288, 0.08763635948658288, 0.09546625812072507, 0.08494115887221365, 0.124572968267049, 0.1316043712882583, 0.17226118162730686, 0.1400953765483136, 0.13302656999910378, 0.15901437013271025, 0.12814325543779925, 0.1463759778347552, 0.13981757085128288, 0.3293716810634115, 0.32066902410506914, 0.3022906981605955, 0.3306872986811342, 0.31914081101526337, 0.31393137800641224, 0.3610654523062755, 0.3397205554976144, 0.3548691581267017, 0.2763948062068037, 0.22483460760465646, 0.24298827788361854, 0.2401652260072562, 0.23367614078821486, 0.2213946858027842, 0.30832884272215644, 0.2382594886247147, 0.24298950946628162, 0.20225307008924776, 0.1999319937010139, 0.20074591288995014, 0.202618187537575, 0.19393891052850687, 0.1685073964148618, 0.17948017845890496, 0.19802374983842097, 0.17774838174610774, 0.18834216456330155, 0.18545980832665, 0.18742298078262964, 0.1948787294377975, 0.18165991425416272, 0.17750153066546603, 0.18861483594781925, 0.18649705490078772, 0.18444523521891787, 0.16848176555147332, 0.6273914692569669, 0.181773190165186, 0.6677980563047526, 0.17323710832413142, 0.3929736760727315, 0.598772877707247, 0.5123901365226304, 0.39330531951560965, 0.18819980491351684, 0.1636559053633253, 0.5161898706194186, 0.584423596908308, 0.2834353513187181, 0.3686794204077668, 0.441115437294598, 0.1504410640216738, 0.5584294391940003, 0.1949031352291366, 0.19398127507149954, 0.18836908530049734, 0.19080757277146176, 0.2028847231220512, 0.19033061470865864, 0.17987115069149662, 0.1825419760524144, 0.1831394418580813, 0.07617011035174037, 0.07295734294749623, 0.07458348396276648, 0.07657223006948899, 0.08162622327326186, 0.08330735016805779, 0.06904781972936458, 0.07212136149286164, 0.06908464578250129]}, "mutation_prompt": null}
{"id": "7719002d-2f4c-44b5-80af-c35691d709b5", "solution": "import numpy as np\n\nclass ImprovedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Dynamic scaling factor\n        self.crossover_rate = 0.7  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.4  # Increased switch rate\n        self.local_search_probability = 0.2  # Enhanced local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (self.population[np.random.choice(idxs)] - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Adjusted noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Dynamic scaling\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5  # Wider range\n        if np.random.rand() < 0.25:  # Increased probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 70))  # Updated range", "name": "ImprovedAdaptiveMemeticDifferentialEvolution", "description": "Improved Adaptive Memetic Differential Evolution integrates dynamic scaling and adaptive local search to enhance optimization efficiency.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "eaee2d4a-dd64-403d-bd5f-0f9606e277bf", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(15 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Further adjusted mutation factor\n        self.crossover_rate = 0.7  # Further adjusted crossover rate\n        self.strategy_switch_rate = 0.3  # Modified switch rate\n        self.local_search_probability = 0.1  # Reduced local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = np.delete(np.arange(self.pop_size), i)\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)  # Adjusted noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with refined strategies for improved optimization efficiency.", "configspace": "", "generation": 78, "fitness": 0.3217221752086286, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.791872303707319, 0.7679275676065721, 0.811036183267653, 0.787982825674413, 0.8572884735957755, 0.8257524067574249, 0.7875652102163164, 0.864386506319462, 0.8228065923914578, 0.6218433176020519, 0.5613813668275449, 0.7064953952899351, 0.6499349902237972, 0.5459800893715392, 0.7016050548349314, 0.6204386150803314, 0.536728016210019, 0.7153247697519408, 0.16715304313469592, 0.22919847609750876, 0.15850228946465394, 0.1343702401970881, 0.1311539396960929, 0.13810332322923946, 0.2380055055006871, 0.1618064413979744, 0.1413483056632091, 0.14066759320177058, 0.13058405121292926, 0.13530622593653185, 0.11892251796682862, 0.12683172925585873, 0.13035052380264422, 0.1720625580852635, 0.11338067977184274, 0.14131129129065634, 0.9774918331914043, 0.9131516718830999, 0.9412978111129446, 0.9346338901310413, 0.9591324505599309, 0.957085023585633, 0.9608693114954079, 0.9557342413639978, 0.9830051007684021, 0.3739985644944712, 0.3446433980653677, 0.4430394862087922, 0.41677510229912285, 0.30658577512519436, 0.3814692762437274, 0.43326557602099713, 0.3450723323002166, 0.38779330816960234, 0.5914850922422075, 0.7942090045777344, 0.2288816545374328, 0.6424008677767843, 0.8125829008658609, 0.7713222172385149, 0.7121176822562447, 0.7969177915185202, 0.7453341300109584, 0.1919783359099534, 0.17965354273784728, 0.18402159557824238, 0.22537662151809523, 0.14694351847233578, 0.15598662073105551, 0.23102168691272473, 0.18849470797664203, 0.25017661744684583, 0.2620701284484436, 0.1399452474064392, 0.15736927045878546, 0.2704105727995264, 0.17836640431514483, 0.2006193931874044, 0.24764171812320201, 0.12678186798862157, 0.18460601224177697, 0.16305532193299166, 0.18784050736207902, 0.12203398319783132, 0.21126312142816128, 0.17032220525253272, 0.06699256513640484, 0.21953677507115932, 0.10225320593997334, 0.15245549846989148, 0.2915186166314726, 0.10999679293772824, 0.17995942805530207, 0.29874709727479454, 0.18018186962509586, 0.15366507094669601, 0.38275065619846116, 0.1601247958804981, 0.2747424386125453, 0.057813990160250794, 0.1338644843705291, 0.13861553308881103, 0.04172011939360676, 0.23333904913363335, 0.16848214814015394, 0.12530991055068186, 0.2247718235682271, 0.14313297339638753, 0.22920640707226858, 0.17159746678752386, 0.2213111424018933, 0.23173405386201307, 0.1807997881433434, 0.23225413993526367, 0.21182079373613572, 0.20551332232627584, 0.24641054702446707, 0.6030767888597408, 0.48990761717863274, 0.536185594891695, 0.6316968242619811, 0.5657975510484041, 0.5016240573867328, 0.6116738227462148, 0.6064059039792566, 0.6075664023029952, 0.13048937070100586, 0.13678951803121286, 0.12084270788468943, 0.0983714061474531, 0.12465775509740795, 0.11877013118396884, 0.09731854162841103, 0.10991687364007452, 0.11248754403075378, 0.14470530404935833, 0.14686932491598204, 0.13875885955298595, 0.1426994326798362, 0.13445223724145294, 0.12924616371473707, 0.14521040866884027, 0.18811570166588865, 0.16455122693367974, 0.31849508277349237, 0.3509566912652019, 0.38381533769177, 0.31716105865354804, 0.28660808744614075, 0.41704579019033494, 0.3894938224102501, 0.3564765019311712, 0.38241598688941836, 0.23342367413212672, 0.2814002751537815, 0.2770762240660005, 0.26316238568472317, 0.2994949417081756, 0.34944962952669867, 0.2739579515219721, 0.3539770470856667, 0.2697467251172526, 0.18771084464670584, 0.21581059355821153, 0.20609563885362447, 0.19093746157387737, 0.20337751172502028, 0.22925827967115442, 0.19506413473820017, 0.1730903328573702, 0.19552944507999048, 0.20260535711205774, 0.1824974558437087, 0.17710006273368073, 0.19293348972833368, 0.19991813909925515, 0.30619193705734005, 0.19169557936753867, 0.33858352061719044, 0.3460294877121146, 0.5647101653877877, 0.19080710943235546, 0.19051535133870368, 0.16983599035359997, 0.6484620086461377, 0.4770436508246294, 0.16609139849301224, 0.1730586081121217, 0.20337985121220736, 0.599401584050005, 0.2000326674039995, 0.18428333285984866, 0.585102274241566, 0.3634860741634103, 0.4983485159536821, 0.2070501890808608, 0.20780875823759237, 0.20632394698066492, 0.17431900614667428, 0.19976909178346924, 0.19269580745725945, 0.19794153058863417, 0.1757055498381942, 0.1811050971756517, 0.1865418191838416, 0.18474623073799523, 0.18331590095596673, 0.07817262972605254, 0.09675216190366887, 0.08505396743959004, 0.07917168729323876, 0.0910471118723104, 0.07504195203335351, 0.07174547984741098, 0.09761685821513055, 0.08642751147092409]}, "mutation_prompt": null}
{"id": "6951ed6a-5bd5-4d75-bab5-237614f8bcf9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 50)  # Reduced max population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Tweaked mutation factor\n        self.crossover_rate = 0.75  # Tweaked crossover rate\n        self.strategy_switch_rate = 0.3  # Tweaked switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial += np.random.normal(0, 0.03, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.4  # Further narrowed range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.3  # Further narrowed range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.25)), 50))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with refined parameter adaptation and optimized local search for improved performance.", "configspace": "", "generation": 79, "fitness": 0.28831579500656246, "feedback": "The algorithm EnhancedAdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.6472868246278255, 0.5720000413215814, 0.5551214240663271, 0.7901554151120699, 0.6775159836954168, 0.5926540133148428, 0.6865155167091657, 0.7035324354402746, 0.66638406225666, 0.4756683727776504, 0.3945723740526095, 0.2774064084752047, 0.351547528518527, 0.36881573985451643, 0.24092234563928483, 0.40213212202146853, 0.15965987590371356, 0.28186771784674747, 0.14787236035532447, 0.17974370844948184, 0.17962670864736408, 0.17292660376968783, 0.17496603343446093, 0.15367384585279198, 0.24680119783404453, 0.17828383309801998, 0.35808576311572127, 0.11532274512291218, 0.10693019105462132, 0.1041617228374222, 0.13624289482166518, 0.1199139363782733, 0.14701567685579575, 0.16469349142409628, 0.10627924799501365, 0.13925812992786146, 0.9494234547467801, 0.9309787562928831, 0.9569180533556799, 0.8806033333193382, 0.9216911130969156, 0.9243825700870548, 0.9353530733663489, 0.9128194114454983, 0.9347873215239422, 0.3562859171540439, 0.33182460269064074, 0.3780036761699175, 0.380261921165848, 0.38816516649214605, 0.3896056256736111, 0.38038079977098205, 0.33819699230626576, 0.34441209198503964, 0.8261613473935379, 0.8254378444563537, 0.23497392963395203, 0.3297829610735237, 0.8925813644196116, 0.27201694681726896, 0.22597648803404669, 0.38283284617715563, 0.23165567732230807, 0.1576851737136039, 0.16661771012745152, 0.1715010251444974, 0.18685265398968143, 0.20446850581890352, 0.1578875721371773, 0.15926654835460008, 0.1794240011865621, 0.16054325599313035, 0.19810863751625585, 0.15905462353668698, 0.17951972915457204, 0.21624317069603427, 0.1704992384892552, 0.17136303147009424, 0.18621279213463315, 0.15663011348797773, 0.17953766290645867, 0.12667602448506765, 9.999999999998899e-05, 0.011980341422024532, 0.07553917888574446, 0.12828805538974153, 0.0037890725909012213, 0.2006015048196378, 0.0037516044847881735, 0.03202581141991867, 0.12917688839347174, 0.12315825626561361, 0.12466596205317582, 0.13590173812499362, 0.12888523940337926, 0.05508737566713462, 0.16426813855492095, 0.13165688275854004, 0.16420194605216565, 0.0793303686871708, 0.12219393009138857, 0.09443226791437087, 0.15136861718565908, 0.1592893304713734, 0.07358006633130065, 0.14078316664550405, 0.2817411262991758, 0.17361399757155327, 0.2046932909589151, 0.10243301443411179, 0.15581331472901438, 0.2242132499918773, 0.15594082346601223, 0.14293855920153653, 0.23101440885975988, 0.31865464711591496, 0.15263306293949352, 0.4793839855002058, 0.5980130022861051, 0.4623615079462863, 0.5064404285699007, 0.48625282444060036, 0.48557301739960446, 0.5251516630604507, 0.5209941489024967, 0.4915412999883102, 0.13672266739509342, 0.12731373254207323, 0.12283662489434155, 0.1495111455562672, 0.10730990236780724, 0.10913725228108107, 0.11414203972388148, 0.16679210676809253, 0.0796172820168014, 0.19859120017804954, 0.1650057837940514, 0.16446536985679872, 0.17453185441010532, 0.19662106003380608, 0.2159126656593443, 0.17320071750312294, 0.14428212557295284, 0.15581646311154074, 0.3605322428364649, 0.34624552500382255, 0.29173825525485986, 0.36942591671368497, 0.3794294032256281, 0.3596251557791176, 0.3481333488107039, 0.43633871771517796, 0.4055246555668246, 0.23645401375153352, 0.27294798587433877, 0.30849385810399976, 0.24185131160082807, 0.2564581917495239, 0.3043892383596676, 0.27451949469331205, 0.2643401853954159, 0.19763077847718757, 0.23275672110327117, 0.20791907188833447, 0.1961678579514038, 0.2437835217849229, 0.23547906762567705, 0.2101711977841939, 0.2063697717177948, 0.19131651467152888, 0.2291512588973793, 0.23849539418699628, 0.3677804165224934, 0.19123017001588805, 0.2412592950582797, 0.20362409585302, 0.2242297035286307, 0.21611937697952444, 0.20432832080824714, 0.24879762726012233, 0.6751635694981696, 0.7878618891241492, 0.19294977510357225, 0.7595155046769214, 0.15535350541919957, 0.8345510524717237, 0.6638951703994163, 0.18285159803194506, 0.162083297448964, 0.5422653114798553, 0.20519504295952973, 0.15366028309823598, 0.21235949632368212, 0.20982384021768818, 0.5461942760025202, 0.20572865956334963, 0.20606629286289457, 0.5697005163730542, 0.18407622593808437, 0.18196476396067784, 0.20038292802347057, 0.18037922296572306, 0.17430936065823333, 0.17331258309482256, 0.17722041879651607, 0.17807935953995435, 0.19561181093419566, 0.09784215341216662, 0.09658320441156865, 0.12442978055301734, 0.09935493837725173, 0.08622989287556615, 0.09032643185201139, 0.09754477225717728, 0.09354775446333718, 0.08231121583780365]}, "mutation_prompt": null}
{"id": "266a006d-5f88-485f-8047-1aaf85cfaed1", "solution": "import numpy as np\n\nclass ImprovedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(8 * dim, 50)  # Reduced population size for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.strategy_switch_rate = 0.4  # Adjusted switch rate for more exploration\n        self.local_search_probability = 0.2  # Further increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial_local = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial_local = np.clip(trial_local, self.lower_bound, self.upper_bound)\n                    trial_fitness_local = func(trial_local)\n                    self.evals += 1\n                    if trial_fitness_local < self.fitness[i]:\n                        self.fitness[i] = trial_fitness_local\n                        self.population[i] = trial_local\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range for dynamic tuning\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range for dynamic tuning\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(6, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "ImprovedAdaptiveMemeticDifferentialEvolution", "description": "Improved Adaptive Memetic Differential Evolution with dynamic parameter tuning and refined local search strategy for enhanced convergence efficiency.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 40')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "1ac32cac-14d1-4ef7-be0d-e50552935cc7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "2c3f0fdc-8ab4-4578-bb72-8816223c9e69", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Modified mutation factor\n        self.crossover_rate = 0.9  # Modified crossover rate\n        self.strategy_switch_rate = 0.4  # Increased switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.7  # Adjusted range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.75 + np.random.rand() * 0.4)), 70))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with enhanced mutation strategies and dynamic local search for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 62 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 62 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "a5d288d0-1746-41e5-b658-afefeceed4fe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "37e19030-647c-44f1-aec8-a96091fa68aa", "solution": "import numpy as np\n\nclass AdaptivePopulationSizedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(15 * dim, 70)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.40  # Further increased switch rate\n        self.local_search_probability = 0.20  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                trial_fitness = func(trial)\n                self.evals += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Modified noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n            self._adapt_mutation_crossover()\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_mutation_crossover(self):\n        self.mutation_factor = 0.45 + np.random.rand() * 0.5  # Tweaked range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Tweaked range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.9 + np.random.rand() * 0.25)), 70))  # Updated range", "name": "AdaptivePopulationSizedDE", "description": "Adaptive Population-Sized Differential Evolution with Strategic Local Search for Enhanced Optimization.", "configspace": "", "generation": 84, "fitness": 0.258285442995069, "feedback": "The algorithm AdaptivePopulationSizedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.6741296851670848, 0.6124869479808397, 0.6161714351607173, 0.6563708796286825, 0.6532299459853101, 0.6450932790535402, 0.643259405511155, 0.6197798167395623, 0.6144875287840424, 0.38050161688214235, 0.34019073733138483, 0.31901808135851184, 0.3834634238591246, 0.3422700323049134, 0.33289023067128887, 0.3641918636836661, 0.3743616615544827, 0.33762506171340667, 0.1239857034158306, 0.10682101307447467, 0.10033907397172659, 0.09388611531544955, 0.10283853250737318, 0.11350902678152941, 0.09129301880371277, 0.10416596991330584, 0.11105545350926604, 0.08254278826143979, 0.08664445959883504, 0.08197723985334382, 0.10387838773378522, 0.09560372901420922, 0.08694609352353777, 0.09110569148155301, 0.08308986129618168, 0.09311543560298474, 0.9217555022849447, 0.9578019130081236, 0.9262456993954754, 0.950335507436656, 0.9330191935280749, 0.9450330818844884, 0.8944664618352591, 0.9600471377124719, 0.880430292825298, 0.268315141900734, 0.26534699009697815, 0.2260680410709467, 0.29031083137945246, 0.24685000874346275, 0.23254235582908145, 0.2823525764828634, 0.26027536059435885, 0.2592627887699359, 0.4879141344079182, 0.5744683765087234, 0.5024222431942085, 0.6119302621859166, 0.5501245700536513, 0.44741581964842037, 0.6242273547770573, 0.5382059668302377, 0.5266250782850206, 0.15881960330457623, 0.16133910388494133, 0.1704380073250451, 0.18405920522958963, 0.15677027907836105, 0.15546756607586953, 0.18116563286528464, 0.17072154312939603, 0.16008056317914654, 0.13622046287703782, 0.13833488498431945, 0.1411986212917422, 0.18612028723737117, 0.176816849534297, 0.1870698729626381, 0.19820507725171965, 0.17348046035663278, 0.1425031537345931, 0.11335331678165639, 0.1221379000081333, 0.07518036165343023, 0.1283348175657547, 0.11673215296414108, 0.07001084124157808, 0.11653488695432968, 0.11457410694684478, 0.08677696676362778, 0.2505915768220166, 0.23355364993292138, 0.22132563439680497, 0.24040008568484117, 0.23288159352586568, 0.1871400549835306, 0.296947512991664, 0.2526265962285821, 0.21819499869339587, 0.056178169499434105, 0.019767501160904644, 0.014187249911179256, 0.030150226567254634, 0.05764236558343383, 0.02524555589362698, 0.025300458441366525, 0.0267938412127543, 0.026762493266375698, 0.1504312694946126, 0.15438362887615453, 0.12164768216165378, 0.16164316614275065, 0.14907615886161651, 0.14297681501885362, 0.16116513184864145, 0.13922534046063206, 0.13297769068802556, 0.510016033012769, 0.4831728859456935, 0.4691946741180364, 0.5018474992404439, 0.4774449027026829, 0.4820962047558969, 0.49953975028983044, 0.48293130143981855, 0.44897177731183324, 0.09715602782572641, 0.0850433713793105, 0.08697419000381779, 0.08640105263221343, 0.09600387811665645, 0.08120162814204157, 0.09386518387952547, 0.09398266939002564, 0.08692782063480486, 0.14551150856763584, 0.18968032907138, 0.2017773000411901, 0.13235394494173602, 0.12718035378939407, 0.12506148272105078, 0.13629439194340953, 0.15230764817859233, 0.13383186358965826, 0.2709127896328952, 0.28403509593774046, 0.2639820066851657, 0.2905825646150455, 0.276342950513333, 0.2502814048483628, 0.29986906738737806, 0.2808885513586783, 0.2797702082811172, 0.2169398768514229, 0.2091723523647806, 0.19830597853500942, 0.20781633847611825, 0.20464396908148896, 0.17652026216223093, 0.21085328398946057, 0.22337108422666363, 0.21476204893982453, 0.17935108758593765, 0.18651096787111476, 0.18627545977802862, 0.1825989993300965, 0.1844988396198617, 0.18506351019126954, 0.2146334639576214, 0.19358271105334512, 0.19298152083480868, 0.1858325030819593, 0.18297051324729696, 0.1778998580241179, 0.18579601033665782, 0.16922747861580523, 0.17077365889645613, 0.18361190408460593, 0.17246325947403807, 0.17957046441297042, 0.44478205019993033, 0.16261411970845707, 0.582092687311395, 0.26371711841957246, 0.25022050678185537, 0.24417448438758915, 0.33489550385358546, 0.37796378092298266, 0.2817781187621814, 0.33782185826738365, 0.19425065264703067, 0.19005307480094302, 0.3333013893763167, 0.21625372109106555, 0.23522707977521018, 0.19980530164577215, 0.5322318672888808, 0.20314801072381183, 0.18502260431176432, 0.1864497737405062, 0.17929667937681348, 0.17621319566327198, 0.1878456253904568, 0.19203733264011402, 0.1978518480221111, 0.1978496867031747, 0.18571340004262116, 0.07932242745361795, 0.07989433790360456, 0.07322430552961601, 0.0708249933736308, 0.07417832839268435, 0.07014885299450668, 0.07113128431464288, 0.07088622102746323, 0.07019685491335659]}, "mutation_prompt": null}
{"id": "7adcb45b-c451-4d43-917b-ce5ef730e0d3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "d7a211de-5d1b-49b6-9faa-ea387ede3c7b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "b60a7d1c-16d3-4f5b-aaaa-0d3e753d8947", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(8 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Refined mutation factor\n        self.crossover_rate = 0.75  # Refined crossover rate\n        self.strategy_switch_rate = 0.4  # Modified switch rate\n        self.local_search_probability = 0.2  # Adjusted local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Further reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Further narrowed range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.3  # Further narrowed range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.8 + np.random.rand() * 0.4)), 50))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with refined parameter adaptation and efficient local search for improved convergence rate.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 40')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "3eb7a751-b14b-4477-a61a-465a487ae249", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "a165ff0f-b2af-4b2f-a83d-e4fb0529edf1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "b3972e7d-f239-48d3-8996-472da225c0aa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "996906e5-7c7f-4679-ace7-c94aeb6541f5", "solution": "import numpy as np\n\nclass OptimizedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Adjusted population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Modified mutation factor for exploration\n        self.crossover_rate = 0.7  # Modified crossover rate for balance\n        self.strategy_switch_rate = 0.3  # Fine-tuned switch rate\n        self.local_search_probability = 0.2  # Adjusted local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial += np.random.normal(0, 0.03, self.dim)  # Fine-tuned noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        if np.random.rand() < 0.3:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 70))  # Updated range", "name": "OptimizedMemeticDifferentialEvolution", "description": "Optimized Memetic Differential Evolution with adaptive strategy tuning and streamlined logic for improved convergence.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 62 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 62 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "7224a0e8-dac4-4937-90cd-bce11dd38999", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "d4709589-257d-4624-96ca-06acfa9a05ce", "solution": "import numpy as np\n\nclass RefinedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(9 * dim, 50)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Fine-tuned mutation factor\n        self.crossover_rate = 0.85  # Fine-tuned crossover rate\n        self.strategy_switch_rate = 0.4  # Increased switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.04, self.dim)  # Fine-tuned noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._dynamic_adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _dynamic_adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Dynamic range\n        self.crossover_rate = 0.65 + np.random.rand() * 0.35  # Dynamic range\n        if np.random.rand() < 0.25:  # Increased probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 50))  # Updated range", "name": "RefinedAdaptiveMemeticDifferentialEvolution", "description": "Refined Adaptive Memetic Differential Evolution with dynamic adaptation, tuned parameters, and enhanced local search for improved robustness.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 45').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 45')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "091749bb-390e-42b3-abf5-02765256c14a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "3c2c7d75-42bf-43f9-9f71-a10a4b72974a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "92b768bc-82b6-4c0b-9a83-830e3ff324df", "solution": "import numpy as np\n\nclass AdvancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.4  # Further increased switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.1, self.dim)  # Adjusted noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Adjusted range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Adjusted range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 70))  # Updated range", "name": "AdvancedHybridDifferentialEvolution", "description": "Advanced Hybrid Differential Evolution with dynamic local search and adaptive mutation strategies for enhanced convergence.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "a26e332c-29a2-49d7-a2e4-51413bdc7cf3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(12 * dim, 70)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.5  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.4  # Further increased switch rate\n        self.local_search_probability = 0.2  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.03, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.3 + np.random.rand() * 0.5  # Narrowed range\n        self.crossover_rate = 0.7 + np.random.rand() * 0.3  # Narrowed range\n        if np.random.rand() < 0.25:  # Adjusted probability\n            self.pop_size = max(5, min(int(self.pop_size * (0.9 + np.random.rand() * 0.2)), 70))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution optimized with enhanced mutation strategies and population dynamics for improved convergence efficiency.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {}, "mutation_prompt": null}
{"id": "3cfbe0da-287e-4c3f-b5f1-4f44ff3708ae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
{"id": "67c6eb5d-8cb1-4340-8a6b-9395e24eab21", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, 60)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evals = 0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.strategy_switch_rate = 0.35  # Further increased switch rate\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < self.strategy_switch_rate:\n                    d = self.population[np.random.choice(idxs)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c) + 0.4 * self.mutation_factor * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evals += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n\n                if np.random.rand() < self.local_search_probability:\n                    trial = trial + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial)\n                    self.evals += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial\n\n            self._adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def _adapt_parameters(self):\n        self.mutation_factor = 0.4 + np.random.rand() * 0.6  # Narrowed range\n        self.crossover_rate = 0.6 + np.random.rand() * 0.4  # Narrowed range\n        if np.random.rand() < 0.2:  # Adjusted probability\n            self.pop_size = max(4, min(int(self.pop_size * (0.85 + np.random.rand() * 0.3)), 60))  # Updated range", "name": "EnhancedAdaptiveMemeticDifferentialEvolution", "description": "Enhanced Adaptive Memetic Differential Evolution with strategic parameter adaptation and improved local search for robust performance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d3c8880-1655-4c5d-b2d6-c49d0b9d949f", "metadata": {"aucs": [0.825349841150957, 0.774301719161441, 0.8116702797576307, 0.8399178024402703, 0.7991160109726942, 0.8097370858376212, 0.8233488381860781, 0.7921491404599752, 0.8090295968598842, 0.7264307061184849, 0.6782862765323379, 0.7063885152940551, 0.7497281187530671, 0.664900447091062, 0.7059400837098966, 0.7320247821935743, 0.6743405909270054, 0.7106644977983815, 0.15329923557935166, 0.12510416677290614, 0.12094480685265485, 0.14534183676701418, 0.4958898984427935, 0.18243833128074805, 0.1507797804206108, 0.16089044926044682, 0.12864733073812074, 0.13824293384806774, 0.11359934870239285, 0.12239135122320732, 0.14032846895846085, 0.11481189373843459, 0.13471638644049144, 0.10721259714468467, 0.17840331726384284, 0.1272370718630138, 0.8921509621399273, 0.9781042808483795, 0.9010241286457131, 0.9263592311143898, 0.936179647200602, 0.9857687532257965, 0.9130803053150113, 0.9227513133500139, 0.9231452284070288, 0.4821498973271965, 0.5093454356723252, 0.5537603251424368, 0.4791145488451143, 0.5182367191522256, 0.4992502135145648, 0.5475403315703331, 0.396905309006062, 0.35101626296820987, 0.7481682492981163, 0.6791010020401268, 0.7431482444599379, 0.7772800825458741, 0.737962508819042, 0.6951351509391979, 0.7801984958770349, 0.725371566853873, 0.7364863904280999, 0.1981102519261062, 0.20590931966867942, 0.2010134726196825, 0.21500635574185922, 0.217806395697981, 0.4740883364408538, 0.2219689284580757, 0.18447585436424974, 0.20866596893035538, 0.24287769302350748, 0.19140395978007996, 0.18975919348208348, 0.1720627185950192, 0.19584141257389032, 0.16868632024029162, 0.15059362735113646, 0.20280655241350876, 0.22341763919511237, 0.2817584017184517, 0.3015004819430924, 0.3188836238306947, 0.23626150771562116, 0.3169666000741871, 0.08923425374826033, 0.186087451331716, 0.33786303886168767, 0.2977445442092461, 0.44356734120191066, 0.3154121903867777, 0.35047458461747993, 0.4899119049323595, 0.3782338643674009, 0.2864356605660814, 0.27645744715754295, 0.4574390358156756, 0.39751837875810203, 0.08825919508879654, 0.236016180266308, 0.04852030561792531, 0.1554425469348647, 0.16877552331041, 0.12263116307540745, 0.12999965365417288, 0.11638577067214906, 0.20527833187739675, 0.3413421198635922, 0.22612541009457632, 0.2631487644203496, 0.33657832013048516, 0.330021299877157, 0.33559689159696104, 0.2905855250055901, 0.2947980635010705, 0.27590222738578374, 0.6700630347246952, 0.6848309808021522, 0.6270823387201583, 0.6052283597132928, 0.5788332125593065, 0.5935557924876982, 0.6772236996017527, 0.5689919963721805, 0.6723863581518417, 0.11148710348411062, 0.10547455309610376, 0.11614549001155916, 0.097942137225145, 0.08754417837404349, 0.09032421463915563, 0.12546815709896086, 0.11352947273752778, 0.10771229326581921, 0.14722016138058713, 0.13466863789633898, 0.15852253016946183, 0.15793827015853545, 0.1304058136295404, 0.12868034404657303, 0.1700088780834158, 0.14408488150307053, 0.13678647628872553, 0.45325157666772464, 0.4304987358194977, 0.4734364249520123, 0.40022997332101695, 0.3722837232268821, 0.3714509254797488, 0.4258920650412371, 0.43610732490942006, 0.4859643590627143, 0.3168915243854552, 0.262364625628974, 0.3179178648716072, 0.35805141551394104, 0.3786083284330143, 0.3298460421652232, 0.3597183644861148, 0.29514656914446424, 0.336824405667699, 0.18747351811134072, 0.1793707259987919, 0.1922323253983511, 0.2004011389857463, 0.18918686398785267, 0.1886284776253606, 0.19753055717006385, 0.2050269486685412, 0.20290440568577528, 0.19884033098989617, 0.18748525957871165, 0.20218754850271725, 0.20731599535918155, 0.39473347534729497, 0.516092150151775, 0.4704430955300166, 0.19625710033418886, 0.19127004235627432, 0.15792750778467657, 0.7442402022590925, 0.7873173318767361, 0.16207572571107665, 0.17749417903963371, 0.6995170731310267, 0.7476048171721639, 0.5935943334518989, 0.6483488946673356, 0.4106064686656653, 0.6016832497225266, 0.1923290355734686, 0.6607431356381337, 0.1844310248015799, 0.7096914614366595, 0.20490587310348096, 0.6122435105236209, 0.20303470339597496, 0.184936617136492, 0.17841128779291815, 0.17561101600796225, 0.17552887136579576, 0.1857792493004552, 0.18071382584121698, 0.1780886936133722, 0.18970235537600444, 0.19263547787902757, 0.0786552990552909, 0.08219198490477853, 0.07911984423268714, 0.08366233870585349, 0.08395761402757385, 0.083632865070562, 0.08133250282603333, 0.07987842787290333, 0.0876128971492881]}, "mutation_prompt": null}
