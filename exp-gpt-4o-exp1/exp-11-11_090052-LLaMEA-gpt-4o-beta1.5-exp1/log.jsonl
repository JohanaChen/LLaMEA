{"id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 0, "fitness": 0.3803534701096285, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": null, "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "e5188078-a8d3-42b6-be50-e6e0162677fe", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Dynamic mutation factor\n                dynamic_mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)\n                \n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance HybridGADE by introducing dynamic mutation factor to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.35811184481331787, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.30.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9459557222736867, 0.9363483121423534, 0.953732819134597, 0.9452668085684995, 0.9387786727569897, 0.9490854846772313, 0.9474359578377758, 0.9493571720123976, 0.9523743198324438, 0.9089447385178319, 0.9093469135511368, 0.9032234763553841, 0.9022950825586932, 0.908619949258135, 0.9112025762892739, 0.9125991896715211, 0.907718505297908, 0.916467083765059, 0.1465579999860942, 0.795415990146743, 0.1518886136367018, 0.14997335443005722, 0.1287873412129089, 0.3604969426571055, 0.1536103017322581, 0.15098479889922622, 0.14252281047374327, 0.13249669996095603, 0.146454495900616, 0.13300883581810763, 0.1611699245982232, 0.15363755429059567, 0.12918568450820944, 0.15927266914629234, 0.14003128426693567, 0.18050800819098367, 0.9415896923740797, 0.8363802587657507, 0.9354157181245459, 0.9349517440184603, 0.938431320890822, 0.9481357857387748, 0.9437163377661905, 0.9506670319465444, 0.9339680394350603, 0.6037528843797553, 0.2977360369730597, 0.3947157458384456, 0.48528586822501607, 0.4527158763498256, 0.14621758810826901, 0.27190248968478703, 0.36371352343103724, 0.3529149264659073, 0.9229296709477574, 0.38252702728822774, 0.9203995635145841, 0.2821715799212313, 0.3876126022080769, 0.9295899185148949, 0.9219463265039641, 0.9211014281363159, 0.9189020734075337, 0.5689487808499855, 0.13409402786250757, 0.15950339696926474, 0.1513676743784519, 0.1761042927350891, 0.16630991230358905, 0.15471597726330089, 0.3658491314978304, 0.16717585433193471, 0.14623545740288557, 0.11806342004780945, 0.1496011369206499, 0.1956013798120756, 0.14756875360968547, 0.16328910504520988, 0.19761313623109478, 0.2093386588207402, 0.24051836889886358, 0.15662192582085388, 9.999999999998899e-05, 0.18408867413484054, 0.06184492933876029, 0.0480635092525552, 0.12325374207661721, 0.1690216943636026, 0.01169567758747303, 0.1696932874610817, 0.12322767317121341, 0.14234357250129503, 0.1972332096978946, 0.11282157701213125, 0.06718399197214198, 0.07402056259089773, 0.16060619378992347, 0.09916514649828112, 0.18768401730515538, 0.11902774052069831, 0.39947867664139325, 0.13643976486620557, 0.13914110776311117, 0.16648114955103288, 0.13416020984905985, 0.09464560241425934, 0.30611189309759845, 0.14586401057180187, 0.18095828794717228, 0.08490358671297848, 0.2702916624457039, 0.44055991218224144, 0.325353274852342, 0.054957934551969845, 0.106710550366801, 0.11294874831600632, 0.08962014028160048, 0.6291657444562279, 0.5205177395100342, 0.5863292617436642, 0.593844930326835, 0.680374134335558, 0.6696793372178305, 0.5802462788628344, 0.6439122160522519, 0.6882899244807819, 0.11860898239902817, 0.1551903175023457, 0.12190516456584666, 0.13196255453694505, 0.14389171699497272, 0.1622126244876505, 0.13707526764898015, 0.15905018246926061, 0.14193402896700258, 0.2942107434502772, 0.17214594765418112, 0.20170290805824775, 0.14253205579236805, 0.18505091516397465, 0.16459288221560542, 0.2569504101191523, 0.19417054037041248, 0.19246514997665476, 0.6215307009409743, 0.5349342045703955, 0.37807926178450546, 0.5624941100835346, 0.5724130184607245, 0.7801681577093444, 0.8596006794044397, 0.6958065063528162, 0.6688134148950537, 0.28424695415718393, 0.6588374403628595, 0.36219532896348716, 0.2925628352066201, 0.22151029594058602, 0.34522397839640906, 0.48167764625924114, 0.43445532202303394, 0.5272058038904996, 0.22873531341122477, 0.2248499332471522, 0.19975345308505998, 0.21675993475697308, 0.21121312708399387, 0.21005752579988735, 0.23074513799069163, 0.20984419406548183, 0.21937852626759125, 0.1902406966436897, 0.1952634945420254, 0.22003772050652992, 0.2093968528982335, 0.22197068649062413, 0.21017821505236456, 0.23917820082211438, 0.21119317792911652, 0.2211951662822017, 0.15589272419138667, 0.18606702323380775, 0.1537585481623286, 0.9200429980345028, 0.19971985162301953, 0.19725625232986854, 0.938275631068929, 0.9396401087779006, 0.165721653186927, 0.1680238402207478, 0.1688381325252638, 0.1278297272353378, 0.21058376707514315, 0.21046719442385953, 0.212975256486709, 0.10527880915402654, 0.21341937726625204, 0.15628511518189792, 0.19031901277972907, 0.17466389656035186, 0.19207360475347446, 0.18733549574764496, 0.1850784006579015, 0.175229557747539, 0.18539031576434783, 0.19357778155321892, 0.20301201065400132, 0.09928092888848039, 0.09790562774747014, 0.09019878273514792, 0.0905805313230601, 0.08582302262167851, 0.12798184929188172, 0.0878553527408722, 0.09887710815768624, 0.0947709583354377]}, "mutation_prompt": null}
{"id": "51cb247e-bcf2-402e-9342-f6e0f3717c7b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "4a0f1a92-794b-4c5f-9104-2dfaef2085e6", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                current_diversity = np.std(self.fitness) / np.mean(self.fitness)\n                dynamic_mutation_factor = self.mutation_factor * current_diversity\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance HybridGADE by adjusting the mutation factor dynamically based on the current fitness diversity to improve convergence.", "configspace": "", "generation": 3, "fitness": 0.12748659981515223, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.08.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.30315434160206134, 0.16041222955670997, 0.30787321994132644, 0.33350985087116236, 0.10368136246127158, 0.1921600201465994, 0.23555152398224843, 0.12576851805821754, 0.1198815263145927, 0.050857604070751794, 0.0980753448629772, 9.999999999998899e-05, 0.14758548428004137, 0.1692185762231022, 0.17816979658926047, 9.999999999998899e-05, 0.09920962725385019, 0.15309034794831766, 0.09491893460332701, 0.0689280330808224, 0.06442697810539555, 0.16869723211143517, 0.09867350036423828, 0.11168812360490188, 0.11926975405886475, 0.07261058277867649, 0.11919886796658141, 0.1008516185650693, 0.06236557972729917, 0.07434932167207076, 0.08730304743490036, 0.054190606437497624, 0.07090892305108043, 0.06461128773625824, 0.09229379262306814, 0.09704735918967344, 0.07324563700009024, 0.221934000911296, 0.062368447684400086, 0.07539868710000175, 0.08300559502966731, 0.06428103735987156, 0.07477097049114678, 0.05640508352765705, 0.0718439584004884, 0.09273315548207084, 0.06310580566988788, 0.07101738933843538, 0.057148388870229105, 0.036399269405926304, 0.0600164942051612, 0.13593839925370266, 0.09223515854605135, 0.10439217289578628, 0.1735513303870846, 0.1320699020018563, 0.1440593778384438, 0.23602436991472853, 0.1834857829704648, 0.17581812217221182, 0.17395559884869505, 0.1333262419865594, 0.10215667855562538, 0.0022250858915265903, 9.999999999998899e-05, 0.1468817770449925, 0.08389352794179084, 0.14316445375548503, 0.10899440014761419, 0.12882437651640888, 0.13122943093136985, 0.07914088745896641, 0.05086695418510312, 0.011363249934180586, 0.06054485585027236, 0.12155364489761955, 0.08953533503672317, 0.06899580997094834, 0.14320325834015946, 0.13352011914492756, 0.1660523654354763, 9.999999999998899e-05, 9.999999999998899e-05, 0.07469069263157291, 9.999999999998899e-05, 9.999999999998899e-05, 0.043846611856069306, 9.999999999998899e-05, 9.999999999998899e-05, 0.029939912094367194, 0.0593996991758291, 0.09299001323591038, 0.1002162070978393, 0.08911055576624771, 0.056132851999070255, 0.08359950342254119, 0.1101712834802474, 0.14588788466394598, 0.05713948416421699, 0.021834651626065016, 9.999999999998899e-05, 0.06977339380600878, 0.07408904302785746, 0.08064174997069262, 0.033801334590691345, 9.999999999998899e-05, 0.1320920150717635, 0.07286755000003908, 9.999999999998899e-05, 9.999999999998899e-05, 0.024167714843331134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04513643894220254, 0.060509493420919935, 0.07708899706908179, 0.21848093545868885, 0.256819842970356, 0.1692310505533926, 0.19938757500730786, 0.29525849416357, 0.21645049361410285, 0.19726282071323398, 0.20548539069516225, 0.25923784150179185, 0.022767138521950447, 0.012986222468583719, 0.046434848173868115, 0.09204815641770492, 0.0767222011460924, 0.09364456068133764, 0.08974721119702844, 0.13526000896316415, 0.1033461253901079, 0.14845667211866642, 0.174810865690874, 0.1784162266243, 0.31392288108524535, 0.13473690211414013, 0.1370802469519582, 0.21171810358494014, 0.15881305881770258, 0.18264995927793015, 0.27664585063331015, 0.21171666242133702, 0.23864025310499615, 0.19651590367594396, 0.19707037245467818, 0.14497840091812564, 0.1381144053265949, 0.18296503012571796, 0.12606042849879773, 0.21777939749313135, 0.20260992610985773, 0.16449446757374064, 0.15639436239267257, 0.15173462603454368, 0.2826899464735856, 0.10583399825139661, 0.1350054482305213, 0.08306540119473871, 0.2451080642411223, 0.23389875120156423, 0.2181654556578354, 0.26684499063866873, 0.22028705225341083, 0.23845402988199105, 0.26695696368518806, 0.19933743786217129, 0.20350185484220995, 0.17546843265547563, 0.164330151453562, 0.15582888718562515, 0.20188310375534024, 0.16211924155299362, 0.18312382335662336, 0.17379222111230808, 0.17446953836760548, 0.16962843141365647, 0.1799384408700676, 0.15823787326003935, 0.11833187447375781, 0.3098414913427162, 0.1992535428773725, 0.22728145684988188, 0.12902012302059596, 0.10455064898004862, 0.1027425775882913, 0.22933595972775145, 0.10463281659025181, 0.16839597917328142, 0.1614760009893187, 0.16601035504999895, 0.15462044425464372, 0.21252967043062077, 0.20126376694824744, 0.21063484486589135, 0.18124034730612704, 0.19300608676305142, 0.18052658715836933, 0.1801093731171146, 0.18005899893738786, 0.18782730975652107, 0.18817932436165552, 0.22430929997240157, 0.21555566471970855, 0.08930351258355351, 0.08419439318518473, 0.07502158945875093, 0.11038145141152167, 0.08980081021319553, 0.09319784583907276, 0.09419028488187864, 0.06830842265655535, 0.10917065696254391]}, "mutation_prompt": null}
{"id": "81abec64-bf44-4e46-a5b9-4eb52e8e4af9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "bb4c0e13-6a6e-45fe-91f5-16b11b265a43", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 7  # Increased neighborhood size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = np.random.uniform(0.5, 0.9)  # Adaptive mutation factor\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhancing exploration by adjusting the neighborhood size and integrating a probability-based adaptive mutation rate.", "configspace": "", "generation": 5, "fitness": 0.3353611861892708, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9561311083115993, 0.9511862609971249, 0.9532088065528136, 0.9563205346144696, 0.7864884309861884, 0.9585316423409598, 0.9591434106996422, 0.9632526329680849, 0.9532009660989517, 0.14593635622900292, 0.9192225961037495, 0.922894189722911, 0.9213889649300563, 0.9208213580057455, 0.9175900172726527, 0.9065201193367498, 0.6741720764243722, 0.907607943822108, 0.1910416662438592, 0.16076775959209588, 0.13240203461700184, 0.13186153920859012, 0.3584640082785773, 0.14385774910932536, 0.1450765150501946, 0.1589060570439449, 0.16160945188523368, 0.13022811471201168, 0.15773687357746036, 0.11789961975249208, 0.13444665449820037, 0.1460629069653231, 0.12551144057577746, 0.11774483289668713, 0.15087205694472727, 0.12917374380569457, 0.9264861408436112, 0.9233545750923156, 0.9281057145105518, 0.15014518919298392, 0.9171990589909481, 0.8925418384128444, 0.9456390568701376, 0.9246709471428622, 0.9483663614340112, 0.07354536478226548, 0.10725320851061204, 0.374936731634702, 0.29243453304784994, 0.12848038687410135, 0.3012341380025503, 0.32823421644163586, 0.12490809106069778, 0.2337681124305312, 0.9037958212941059, 0.21517129751668573, 0.935135258585152, 0.279299102828932, 0.2154021875315063, 0.38637184912537137, 0.9456083353868465, 0.937048401327407, 0.23939161402944742, 0.1349555742641232, 0.13873568962754435, 0.17498419664794496, 0.1482011337610788, 0.17610730679292996, 0.18370126377814278, 0.1319354316543484, 0.14554126328360695, 0.15437215368071333, 0.17332647595334472, 0.13627910324872194, 0.13188067593792507, 0.17093490079285023, 0.1421912848384247, 0.1461235654018852, 0.14209347079352042, 0.1857510643535415, 0.13690504181741947, 0.0043626284246707225, 0.04736830796998326, 0.09004156681884157, 0.09536587677313269, 0.1308798284308066, 0.01717275450067357, 0.05646212074755563, 9.999999999998899e-05, 9.999999999998899e-05, 0.1882194830553704, 0.09049311961561324, 0.14587397651657452, 0.11901200463283201, 0.05703140157615505, 0.10876015645694626, 0.16567779840861618, 0.13383969832438414, 0.15062141487297953, 0.22146618964287823, 0.0629621658518219, 0.17635431781799638, 0.10606083848457404, 0.21080126248939646, 0.2908442383565564, 0.0995705836390609, 0.29476982006104224, 0.0983868306463973, 0.13829305757694887, 0.09592018688754311, 0.17626260044958586, 0.07736455880299542, 0.12594076644805408, 0.1677366810862626, 0.1338462396875033, 0.14077264968103687, 0.0900568987817254, 0.6290651673750587, 0.4916701552004944, 0.5020826677047017, 0.5736402725494602, 0.646086472355504, 0.6413020547159776, 0.34233033110188293, 0.6584260811914211, 0.6689781979828744, 0.1325853061334803, 0.6573880331166448, 0.11409301889777068, 0.12688640054069966, 0.1419519737229541, 0.1745827072961159, 0.13581086903172868, 0.1828208665004012, 0.1437558539952173, 0.2912491826453384, 0.17964921901675857, 0.20268146205145054, 0.21834650906538644, 0.21567372130345597, 0.38778326407574704, 0.15042562713999563, 0.23636370637213477, 0.12458592894642351, 0.3475988535349649, 0.4975895061075084, 0.4928837134990124, 0.44511020626573194, 0.5004599248718513, 0.7724559776543123, 0.7016836694458641, 0.8860892904808736, 0.656070500206203, 0.30734256598817145, 0.2853301626034378, 0.2701288323813348, 0.31295666416872847, 0.26207410374772766, 0.20925379579297987, 0.5109552703206242, 0.4561799389792057, 0.5349233841904499, 0.2312523440528963, 0.2243409785454683, 0.21437633710861204, 0.21053747808354395, 0.2185478689940138, 0.18879551616143087, 0.21404320751883765, 0.20966443497680964, 0.21457722104037835, 0.20272389170426275, 0.24898874145656003, 0.2532574788157832, 0.22130915467389256, 0.8656535386786919, 0.25359779707603347, 0.20955480948475147, 0.25285181556924086, 0.20827309035628416, 0.9336879870701453, 0.9520889281581393, 0.17233088317679135, 0.9502845921744916, 0.20117693071017184, 0.20022983748690326, 0.9609312195564015, 0.9010623590104582, 0.9450735407066174, 0.21107410162050955, 0.16890022017987594, 0.08324134969061592, 0.2129047736415216, 0.2123094158839247, 0.21248727809362522, 0.2108903736984652, 0.1566878358043885, 0.11320433813332642, 0.17734217886105963, 0.185464605652909, 0.18232205070560026, 0.18785511409052147, 0.19035482397015335, 0.17770179995416946, 0.18367357457551436, 0.19322787678047926, 0.19892367739709116, 0.08526871587663976, 0.10054820666664654, 0.08134488856259481, 0.09012698724896906, 0.08233418940282478, 0.08099677375557257, 0.09715478495011032, 0.0853651847492316, 0.08917811110086094]}, "mutation_prompt": null}
{"id": "d583c292-2024-428f-9d07-88248595f23a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "839c76a3-2324-4c43-8208-4c61271a01fa", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "6592854d-b2f4-4dac-9bc4-faf34122717b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_factor = np.random.rand() * self.mutation_factor  # Adaptive mutation scaling\n                mutant = np.clip(a + adaptive_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce adaptive mutation scaling to enhance diversity while maintaining convergence stability.", "configspace": "", "generation": 8, "fitness": 0.1623859520104034, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.13.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.33657856250710916, 0.7145511967334253, 0.42853822990310486, 0.1608789454156906, 0.2411659804892412, 0.3935882846226266, 0.4324423287317025, 0.8672484517639285, 0.2065940460874368, 0.007768499292229891, 0.15574123103262605, 0.007102281905428165, 0.061431963384505406, 0.09475219196518336, 9.999999999998899e-05, 9.999999999998899e-05, 0.026943655994000837, 9.999999999998899e-05, 0.16632626985524201, 0.1379157263262748, 0.09027967343676868, 0.10213327717174292, 0.15634976593144778, 0.1266420964831001, 0.135376984174451, 0.13579122866119664, 0.143258892054681, 0.11332810282500538, 0.08031567220101266, 0.0628057791031228, 0.10774150197483812, 0.09739561986613277, 0.09467172620679065, 0.06374791635620258, 0.1181825463191748, 0.08352365067495449, 0.17429380678266593, 0.10859282088623567, 0.11238024783449052, 0.0942376140809209, 0.14918744560663577, 0.17485228436803846, 0.10917353653980066, 0.1806785079728488, 0.14422105240647431, 0.18275909894160047, 0.006348851313217385, 0.05983930991575803, 0.07101082995416597, 0.03653112744486864, 0.06296317329831946, 0.16056685361382028, 0.07053741879927888, 0.13777925459417528, 0.23118358297883934, 0.17123616596461833, 0.10940060159352338, 0.28357224207452336, 0.9529543106723413, 0.17993081635016694, 0.10399853648009649, 0.3414887255838286, 0.3745430860214578, 9.999999999998899e-05, 0.17009144591930014, 0.02383652249119439, 0.15345169688874716, 0.1422181199930599, 0.23091829079497816, 0.12617629218876958, 0.14364185620876346, 0.13516400323375743, 0.1460689602455737, 0.10678039492158009, 0.15469582106221913, 0.13319459029648173, 0.018763939520783035, 0.07853044792441655, 0.134235385543222, 0.14540876614495069, 0.14157753482820667, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05879972280500556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1073451911059412, 0.09370864190945072, 0.04397029844649858, 0.08921277192137622, 0.060359673342831544, 0.021462602180934875, 0.11948665573456763, 0.03933171080174358, 0.11860359754109218, 9.999999999998899e-05, 9.999999999998899e-05, 0.04695526391528271, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08895356201717441, 0.17722543508686872, 0.0336360001029099, 0.04737591496058047, 0.033824077821163145, 0.032052150733439366, 0.0276669587324877, 0.09543753585429682, 0.04277125090319367, 9.999999999998899e-05, 0.26365648806689956, 0.3040367523485461, 0.445657904776938, 0.2080049768001102, 0.24113799337936626, 0.1664994552554766, 0.39696238142536366, 0.2611803088371062, 0.5036043695321974, 0.1102008012788308, 0.13558768081129857, 0.11723481211280018, 0.1403829683229566, 0.07941979758340934, 0.13082450944059965, 0.0856630233834389, 0.11982695989481618, 0.12242035064698031, 0.18911246848447294, 0.18282987998554145, 0.20396802956187954, 0.19584598453856883, 0.22436364192718672, 0.2441454732208247, 0.25116511060218083, 0.24075903174437374, 0.18501166689470638, 0.38752405142337265, 0.2792521638259131, 0.19862917230915578, 0.2774140290497997, 0.2362584598321903, 0.31159583739527696, 0.34954613103705334, 0.4447015635027697, 0.13943658295229489, 0.24961878447718833, 0.19439185110657498, 0.1845730607340813, 0.18483048397574509, 0.2326350385602758, 0.25694904699776766, 0.19488137631057667, 0.2775606463119923, 0.12565580942861165, 0.2459692534090645, 0.23203537877506564, 0.23570896113811002, 0.21153848791782393, 0.24344967115221372, 0.19626673166028208, 0.23163341585844488, 0.2377128554736807, 0.26419727631870493, 0.20214323274638435, 0.18985829651186248, 0.18770018122640764, 0.18565021038198626, 0.16802859799490766, 0.18689784713190094, 0.21440711287848957, 0.21404816911942248, 0.16768963951691007, 0.18799429096077724, 0.18911642940587559, 0.1486167689192509, 0.16935604432042506, 0.2001002948179662, 0.22911974391552248, 0.433185901974694, 0.11430191296368941, 0.1772061232105252, 0.16726219329302772, 0.20830389369571267, 0.4077546934599716, 0.21269409662529337, 0.20484126947841785, 0.10866058234213538, 0.1049373593833518, 0.3754006609724867, 0.22550536637505025, 0.18597664040171136, 0.18967103152661624, 0.18621225085023818, 0.1864520932788608, 0.18704354546391433, 0.18010671824388536, 0.1810726705083392, 0.20410461665299484, 0.18134021011750479, 0.10159364897366885, 0.10608303149383957, 0.10741047472654974, 0.09246445230923128, 0.08777968623063659, 0.1293776980564353, 0.10608290638007534, 0.1103580453391989, 0.0976793926341516]}, "mutation_prompt": null}
{"id": "4408becc-db07-4a3a-b167-76896d6e27b1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "83e888be-db39-49ea-841f-08529f92da6d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "091f8887-d442-4012-835d-e682ed4eef2a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adjust mutation factor based on fitness variance\n                self.mutation_factor = 0.5 + 0.5 * np.var(self.fitness) / (np.mean(self.fitness) + 1e-8)\n                \n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce population diversity maintenance by adjusting mutation factor based on fitness variance to enhance exploration.", "configspace": "", "generation": 11, "fitness": 0.18226553844708876, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.21.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.6923042073849067, 0.44866980875479534, 0.8735291298550791, 0.8078440033075969, 0.23018905082347063, 0.30324007954018317, 0.22071907038499206, 0.21551265258350083, 0.14217700269813216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10051674793784826, 0.12140125081048214, 0.1226605610654049, 0.23147941405819938, 0.16350440468393168, 0.166554783939164, 0.13210017860233458, 0.07025868784053946, 0.17928418737097218, 0.07553303023492886, 0.11193817932602246, 0.08507973475925756, 0.12016957700787134, 0.10728704006957701, 0.12830651552383276, 0.10541945146642051, 0.10815001424385251, 0.1469158852781447, 0.9908008819604464, 0.9872518781030819, 0.9882491506785944, 0.5028060133139339, 0.5519946370267909, 0.33390739802383507, 0.6312324420102504, 0.9613412683693145, 0.6238938681225553, 0.058685474379305935, 0.05820972647237943, 0.13079230302185185, 0.19847189432343326, 0.15619359008636458, 0.19594391211950357, 0.07680583498510929, 0.08354930380325332, 0.049914571154434095, 0.2094324287301782, 0.3059675226873738, 0.8259162671798043, 0.2579560383582429, 0.20294941258553467, 0.2509657263238181, 0.8499672446322235, 0.3158632824801887, 0.17436274530895624, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008920963729007747, 0.035441334214585396, 9.999999999998899e-05, 9.999999999998899e-05, 0.021793990193706314, 0.05182788821292539, 0.015429378312186826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030559491211212708, 0.04753839096873691, 0.03444774462416755, 0.031303701387362715, 0.031617963291014295, 0.010581894446956897, 0.0073171629728132626, 0.019540042033158178, 0.030925840031068574, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02701740050538881, 0.02259275670482297, 0.03756168080304323, 0.0009395518575739947, 9.999999999998899e-05, 9.999999999998899e-05, 0.024032471334635708, 0.037247406455347076, 0.02574527432648066, 0.45893449449221335, 0.2659703536746716, 0.3837632730422702, 0.1673687396910868, 0.4281970208647493, 0.33132005702439804, 0.41791350856072684, 0.4179550666002214, 0.3477864841153314, 0.147549743444353, 0.11491174405700788, 0.13944922047877373, 0.12271074869903387, 0.17701508838596458, 0.14151218089740647, 0.051578054051874656, 0.04065194743144607, 0.0494270992086111, 0.5198707791211066, 0.30384564078084775, 0.15053948051206967, 0.30698844209568776, 0.4068792952178475, 0.21821247316720016, 0.2228601011456578, 0.1383334528897916, 0.25785491416318684, 0.30966987168172144, 0.22839879362578364, 0.6917046233533288, 0.30782621488011797, 0.48591074383307364, 0.779772361027171, 0.32487238837961363, 0.600847357272114, 0.39264629926907657, 0.13281619569605085, 0.1968319963838564, 0.1970876521434749, 0.22865318811100654, 0.35603643592597356, 0.28406543972141285, 0.19343151161390615, 0.29878140477879167, 0.24038992654204883, 0.20407347203878046, 0.2209999270232621, 0.19884940870190837, 0.21120290973598776, 0.21830802196107002, 0.20017105197183505, 0.22138872082701067, 0.2189112022848554, 0.22613785772762163, 0.04183557733332033, 0.08413022482407939, 0.06261285359951763, 0.05391577956594684, 0.06392242410812254, 0.10971131114510957, 0.053760745466553406, 0.07205152253083558, 0.07502296562895594, 0.16383558872078063, 0.16368253337358019, 0.14750635650065813, 0.17951527210074747, 0.2975752068847982, 0.18657919358543318, 0.2890829764697279, 0.16716616705338916, 0.1038083604585276, 0.28733034115791845, 0.2134725443828034, 0.28151418370132375, 0.3132969301776002, 0.16753498175817927, 0.20794487484194302, 0.12386859983058662, 0.1967709274823537, 0.18727241973651942, 0.19633913715054707, 0.17548855557549647, 0.1773941037107667, 0.17902930969750763, 0.1709918756318337, 0.19323009515322487, 0.18193803775142903, 0.1809418528278942, 0.19756747368548544, 0.09013782738070075, 0.08346092974704677, 0.0862009064197864, 0.09063637643098843, 0.09013888428540262, 0.09508309455591857, 0.08605128779912752, 0.0802469473491133, 0.07982257326680298]}, "mutation_prompt": null}
{"id": "e1a1b20a-cc2d-43cb-b663-23e9743c7f7c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "ef00a317-fe47-474f-9e6f-d1a200f876a7", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "6fc4b32f-2fca-4c06-aecd-ff85b654058c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "9126fbe9-3cd8-49de-bc48-d2ee51ce6841", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "6063e5f0-260c-4217-9270-cf400de8e9d2", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "26b75ea8-f9da-4321-bb89-551688fc8cd7", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Dynamic mutation factor\n                mutation_factor = 0.5 + 0.3 * (1 - (self.evaluations / self.budget))\n                \n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Improved exploration by dynamically adjusting the mutation factor based on the current iteration.", "configspace": "", "generation": 17, "fitness": 0.3653566261560331, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9442270921933127, 0.940230760721869, 0.9486113035656145, 0.9439397491015532, 0.9416419371677076, 0.9506615850518102, 0.9449311133974158, 0.9429255005253517, 0.9490688436179897, 0.9060713429971651, 0.9047215777394364, 0.9073132294481362, 0.9037082055884896, 0.9038753267756714, 0.9084819083499145, 0.9119437944378556, 0.8966145711164125, 0.912078754879089, 0.18216530797546515, 0.18072409553491653, 0.17968515416551123, 0.7043388031365554, 0.7573247033740034, 0.18483030388471355, 0.17646065354967522, 0.17747769204250596, 0.8127620137131096, 0.16452137877378714, 0.12445080230028926, 0.1593563182217571, 0.10064390536863954, 0.13976425079290877, 0.15527239288966233, 0.15435150745782755, 0.11595908569543623, 0.14006856218870323, 0.9677694560105167, 0.9264237681070145, 0.9535748606227982, 0.9324797533154724, 0.9422144364811184, 0.9582557109226156, 0.9663174464954088, 0.93366358423623, 0.9323972147241724, 0.35544247053715583, 0.3105675558435711, 0.3521299468988154, 0.40191540955843685, 0.32546522258514565, 0.44027834949486533, 0.6674231256341523, 0.22504715058520164, 0.3889739663152716, 0.25389866142138184, 0.9145830370640236, 0.3586256780527325, 0.9284143663842904, 0.28222224234623294, 0.9231909054910438, 0.18041387940532405, 0.8995615835801711, 0.9313826739845819, 0.14984624161402793, 0.20094938085873382, 0.16425743877031196, 0.2506044219650597, 0.17956090343824704, 0.2004736506327326, 0.35514282209671477, 0.1351342801017168, 0.19346902612865746, 0.1981509723296283, 9.999999999998899e-05, 0.17791942738569433, 0.16239059302105074, 0.15823865610633636, 0.15636273781888033, 0.14151441801950737, 0.11895478314614683, 0.16998157143376424, 0.07950920312748855, 0.09316035060398731, 0.006669042863510777, 0.1078964343970209, 0.03420897253266508, 0.06504552505016636, 0.0920379683143927, 0.03258182010667965, 0.10045698170422579, 0.13053630793546567, 0.16395300197875606, 0.13175165735154182, 0.08729823561333183, 0.09434026773578785, 0.05527515476074385, 0.1694870325089789, 0.1987895263983862, 0.1047035955111627, 0.14660494451493944, 0.1727196766571487, 0.1976020989624595, 0.08907320662742257, 0.13024267597303152, 0.17196182050802467, 0.09260244230674874, 0.2818974016686223, 0.17468275855726356, 0.13412525680780496, 0.1068867825351777, 0.18486115767101696, 0.1699551971379205, 0.21085380755717031, 0.12761030731777467, 0.14858131575769862, 0.10080024268362708, 0.11918032637303899, 0.6477499423500551, 0.6716508511887127, 0.5494956005997755, 0.5890085883534133, 0.6363145619694772, 0.647342723884043, 0.669815593287002, 0.6726319508817978, 0.6563052157411978, 0.11477699478408099, 0.11346515915414368, 0.15047801952366302, 0.1586910712845031, 0.15567821511542201, 0.10116631171667523, 0.14614346538345435, 0.12470558099388496, 0.12412444100138287, 0.17365981308452394, 0.1687188294118358, 0.12878139298015523, 0.1451198098020533, 0.16969731421384426, 0.22677294053949693, 0.14542014918120316, 0.14956547495649686, 0.22035198336093076, 0.6152863250451814, 0.521907489975348, 0.39463091658470106, 0.49481739466387764, 0.6988430963140779, 0.7663058382994656, 0.518927171770054, 0.8460393534414746, 0.8304304307503234, 0.3366135153873874, 0.32276568002547157, 0.26851496645032225, 0.3682804082242749, 0.4210637340488409, 0.27076423071333466, 0.3947896536964679, 0.49384141901483825, 0.4650977467485825, 0.20305930540333816, 0.22462108585092477, 0.22654182611698592, 0.2217025784381883, 0.20957200312554614, 0.21083522913746433, 0.22923532373321664, 0.2434220932191823, 0.24247293927293134, 0.8314290794333131, 0.20948430710694232, 0.2245824449394428, 0.2062233996855778, 0.8434585966963624, 0.2518952590267045, 0.20908411604709387, 0.24842093711727775, 0.7634274686153903, 0.1657583760979735, 0.1871111403505945, 0.1535909701025434, 0.9297426460076376, 0.1999720147650682, 0.14615753021929445, 0.9323443193729495, 0.9451207223031822, 0.16617131958143905, 0.5899818532201544, 0.1689674079859973, 0.12839174315242474, 0.21061823223028364, 0.16879570869601335, 0.21308601612956513, 0.20505019755453902, 0.2135162604051304, 0.8782715688674355, 0.1843226458912941, 0.17347707382711197, 0.18817400941745677, 0.20018304949864674, 0.17701587387283635, 0.1841919503614129, 0.18819026857919574, 0.18524302923431446, 0.18032038964730834, 0.09598713778644963, 0.08964779279910706, 0.09581193418145373, 0.09188730588680283, 0.09044190202745062, 0.08472545654405972, 0.09234903574539943, 0.09590901707374233, 0.0856561846073457]}, "mutation_prompt": null}
{"id": "8a4e8542-5314-428e-ade5-8d9d070a1b20", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "8e31b4c8-bd5d-4e6f-aa3e-59988b26a54c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "6e3c7792-11b4-42a8-82dc-894054343f85", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "c4315f28-a01b-4223-82e1-cdeb69a79920", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            current_gen = self.evaluations // self.population_size\n            dynamic_mutation_factor = self.mutation_factor * (1 - current_gen / (self.budget / self.population_size))\n            dynamic_crossover_probability = self.crossover_probability * (1 - current_gen / (self.budget / self.population_size))\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < dynamic_crossover_probability, mutant, self.population[i])\n\n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhanced HybridGADE by integrating a dynamic mutation factor and crossover probability for better exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.32234299696991764, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9442925446949654, 0.946237224118098, 0.9528510036101567, 0.9369199307213967, 0.9441964468899071, 0.9470503695432325, 0.9487105295393616, 0.9459358559516046, 0.9546529325535767, 0.916154301719985, 0.9202861190896612, 0.4108901589376188, 0.9021172947867891, 0.9132711137335259, 0.8923793095420611, 0.9151098977322945, 0.32776302159904813, 0.9087073377337127, 0.18634282407046998, 0.783050869148955, 0.17615336476514531, 0.14441836665117702, 0.15380104984666687, 0.18320046763056375, 0.18735784945033962, 0.13463551558938547, 0.5392264550559056, 0.1153766986292869, 0.10071239495641493, 0.09987221812101821, 0.15669143726677537, 0.14610776660380675, 0.1842744513621195, 0.1409553245164552, 0.13247474931626968, 0.17800691775481614, 0.9383505094560084, 0.9279803559526882, 0.9337929718504625, 0.9538504699509014, 0.9455698057707745, 0.9316481724937835, 0.9475350885455976, 0.9751089068182737, 0.9271902404573255, 0.061265476526207174, 0.27439599240833945, 0.20936005454620432, 0.26474615675668134, 0.34239645345389924, 0.17572038770930354, 0.20025793190970542, 0.21712493334329175, 0.2081416286138692, 0.23101717532107102, 0.2274933492402471, 0.22895407433778425, 0.2830038175762727, 0.361140653136496, 0.3861421603402889, 0.2359194987253488, 0.24745918939398748, 0.9107140015653722, 0.14976029844020544, 0.16194277115136335, 0.18237335088558382, 0.15595256422201276, 0.17823538766436575, 0.15178656923511002, 0.1455458323058163, 0.18609778224300644, 0.13295669102747565, 0.16607544104060745, 0.12671754359611698, 0.16273369070282062, 0.1402579526722495, 0.13058597411673, 0.24542243973150846, 0.17375960622857278, 0.11382791799411496, 0.21103764091043964, 0.05018116959497476, 0.0018066839975580118, 0.00727135499494036, 0.09938792012128528, 0.019600668335550298, 0.042111719562404115, 0.006938949015062645, 0.02530398900620401, 0.06716042260969957, 0.10931277173986387, 0.11490738423639069, 0.16012867459118674, 0.07810692101810712, 0.08900194449287069, 0.03935646140456939, 0.14406979658788022, 0.1664487334087491, 0.13328328125958688, 0.11031742050919802, 0.10732384940230644, 0.1446109408924382, 0.12302457787422116, 0.09775862186216366, 0.14442824742937443, 0.09514681499012945, 0.16413714720793904, 0.18346546500297167, 0.038656056442099906, 0.17320907038516342, 0.19017932128917714, 0.17311174319976963, 0.21477476575388466, 0.10505848079374225, 0.11072764720314465, 0.07267479391185461, 0.09742993893655694, 0.6403980955916273, 0.6325261672461091, 0.6413606569802482, 0.6062283028633526, 0.6427949833310336, 0.6194817283217204, 0.575467556928253, 0.604414253948726, 0.4865606611883263, 0.14653216878500153, 0.17056868563480254, 0.11630940123598232, 0.13764596400791285, 0.11550803553888711, 0.13020337474665988, 0.12633516218917062, 0.12782702945517954, 0.16476359864640067, 0.18486517662497703, 0.1850671455400793, 0.25942761239511836, 0.162612100152836, 0.20070247468097546, 0.16224840139710617, 0.16229925915707322, 0.15581402814297363, 0.1394593495904326, 0.5253943248450339, 0.7572140733183653, 0.4025983893845927, 0.8450352186937946, 0.5252615447351714, 0.333442705233702, 0.4733001662214755, 0.8661487908977217, 0.8461151091402884, 0.3657101055681662, 0.37682369698594453, 0.3099840457330596, 0.4274254400197809, 0.24340566385873752, 0.31652924849384134, 0.2648478049871251, 0.39556971853434775, 0.48587142957263674, 0.2048331205427978, 0.20462510341329954, 0.21232638733674525, 0.21926230526694934, 0.20937200687607593, 0.19424348171844008, 0.2183627383140404, 0.2511970044632933, 0.23513259390999253, 0.19611646059733434, 0.2062196654672771, 0.22030890914215717, 0.25019407917712433, 0.3872295661939257, 0.20125190299975393, 0.249632367341998, 0.2532536829920097, 0.25151610268681046, 0.16584846053127078, 0.16600605909056243, 0.16021319210191654, 0.9424918213484003, 0.20022066049419107, 0.19626553579941686, 0.6042555502087676, 0.9194943943100125, 0.19029776207037308, 0.6089048772268015, 0.16912474381273934, 0.12816055264107495, 0.21164352853466128, 0.20522103649002688, 0.2129711990952865, 0.8587718248230132, 0.21365046936901266, 0.21165205113670793, 0.18545340436263058, 0.17704985247369698, 0.19629350991482353, 0.18487369108657825, 0.18086272320326158, 0.1918046910159632, 0.1831448376561624, 0.17958807225091278, 0.18308392468386592, 0.09199950174204719, 0.08364416897285265, 0.09236509604886889, 0.09922196612169665, 0.08993107965723723, 0.0968404598589192, 0.10847873790700469, 0.08646239027093106, 0.09467241754187017]}, "mutation_prompt": null}
{"id": "a631eee0-d205-4016-9f48-fa0334df2b53", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "1c29e033-22d4-49a7-a639-0c1f97306f97", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "6b2245de-19fd-47cd-b7ef-60723f4e23e7", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "40cbf09b-e325-45d4-8972-093e6378df21", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "1c2e0661-279c-42b2-83c5-2f8bbe5ca22c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution and adaptive neighborhood search to balance exploration and exploitation across diverse functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9469109738065168, 0.9343290400969988, 0.9521225897341021, 0.9388590462821501, 0.9395110138862292, 0.9490580179750612, 0.9446107982980416, 0.9363256080624343, 0.9543638312037128, 0.8952517409977129, 0.9018707356602522, 0.8960199102496403, 0.9062183580877156, 0.9138396696459398, 0.9100850361278146, 0.8981872493210142, 0.8999000932063613, 0.9143604635738566, 0.1423336155144047, 0.7273390432115843, 0.1818943506445203, 0.19199791959515933, 0.1332766426253451, 0.18959328194345404, 0.1420374979169826, 0.17367730981793883, 0.1797541633005847, 0.14287295832511593, 0.1590444504121673, 0.14360725088308413, 0.1253789889637157, 0.1412110619377721, 0.156980258181046, 0.15592537293591646, 0.1394581548123348, 0.14336302610781826, 0.9665863822106124, 0.9479787546964097, 0.9683414847990256, 0.943637648371846, 0.9328587797415541, 0.9586898478179041, 0.9649333363028887, 0.9365334240918837, 0.9361963606313957, 0.6560915070747517, 0.8300944090629212, 0.7358955606974455, 0.8405508132761151, 0.8424268565795624, 0.8416258552862365, 0.5546619388575302, 0.808862365496094, 0.6566377057330437, 0.23056512732691936, 0.9128695216436061, 0.894605375991912, 0.413997488234771, 0.8597995048290501, 0.9117766690582925, 0.2461537802547238, 0.9533854783397715, 0.23794702972147463, 0.16157207677723873, 0.1332708762581869, 0.16583403012413855, 0.16465082147783272, 0.1629880976012944, 0.13327396526576119, 0.2002875605263239, 0.2587295438170727, 0.1733376637287567, 0.21075213834070006, 0.224087659190933, 0.17106303860747318, 0.20119507574999174, 0.2064093859670667, 0.28303801477208324, 0.23070497954021052, 0.1270690161305038, 0.2033305696183565, 0.10325507181373306, 0.017368547757750097, 0.05218996287681543, 0.08254951120072151, 0.07253500636953436, 0.029768585749377796, 0.049827855463667636, 0.0723449131832451, 0.057787175743116315, 0.0876184316982428, 0.15441014251237561, 0.1232203940209734, 0.10085290828919147, 0.08834838477344509, 0.08703853540165818, 0.1706522808963693, 0.15421072286637938, 0.11031069540963268, 0.13514325118588055, 0.226452504706933, 0.5202287238230926, 0.08971004961078666, 0.17998937787352753, 0.10281817240620716, 0.1323404895336764, 0.304868806903008, 0.19744170144405349, 0.17565348683717807, 0.2944973357597098, 0.2745226875026655, 0.28558461043804895, 0.24397875880633824, 0.1623295566076307, 0.13620269451621225, 0.16917151104619843, 0.10537849954551515, 0.6372024983023148, 0.6735742330363348, 0.6445968663733916, 0.6438184618837608, 0.6521852268856723, 0.6257916330180795, 0.6446657353577371, 0.6901614393545575, 0.6358898661610308, 0.26272638524445335, 0.13026648006572428, 0.14271544895535948, 0.19535101793683696, 0.10802724223783411, 0.10752666340319306, 0.145725943660588, 0.1072879609662698, 0.16135433984668912, 0.22235795412889459, 0.16608039220338888, 0.226689187399443, 0.1524683880523302, 0.14680847684225484, 0.18884884202025642, 0.18156148242126613, 0.11901737060546913, 0.14458362299490068, 0.6621002902191704, 0.8281102414198515, 0.6070139513353455, 0.7927482613121211, 0.7664520892572559, 0.39402854942014465, 0.6637229266097678, 0.4935727816508676, 0.8398062456549772, 0.38890642208738524, 0.49343636803103896, 0.4748691272619163, 0.36195234683149924, 0.2709636793297401, 0.3310743237718917, 0.5853545560066653, 0.7195811820480804, 0.48916474651123254, 0.2202784344543226, 0.22808411641179738, 0.2008717388622263, 0.2229522220750526, 0.19025812897684413, 0.22101523375647247, 0.22779406053284934, 0.21056325278578492, 0.21173397785501902, 0.25188101749532554, 0.78089766031798, 0.7936888768454341, 0.22380709530407394, 0.2478354107718308, 0.2243485408310042, 0.7551941203986574, 0.20146330206101926, 0.22226983884037343, 0.15594403901996645, 0.1868344792767389, 0.20146551385689393, 0.16903195095118795, 0.19981879433420813, 0.16868872858188466, 0.9264161211092027, 0.8705849875695572, 0.1671800549528185, 0.16843699491697006, 0.8415351756642306, 0.12829104399993796, 0.21016865131453255, 0.16940819150577846, 0.2131124053189941, 0.20845333173172675, 0.21355542353362467, 0.15554246481353462, 0.18677926867652628, 0.19256113394865393, 0.18632597924448424, 0.19174425434366393, 0.18289701875788777, 0.1838687467309834, 0.1817017248017917, 0.18411519243006402, 0.1836446128635535, 0.10343002527063438, 0.08662866342969477, 0.09265164290110783, 0.09068209752424905, 0.084886294581489, 0.10953467960661456, 0.08816735855338853, 0.08345683249486024, 0.08625900083621385]}, "mutation_prompt": null}
{"id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a tournament selection mechanism to improve individual selection for diversity.", "configspace": "", "generation": 27, "fitness": 0.39009650458879186, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.31.", "error": "", "parent_id": "6b1e1847-ed4b-4ac3-bf90-b0bc2011aeb8", "metadata": {"aucs": [0.9422216968416194, 0.9444748675244793, 0.9352146504922559, 0.9377110151250405, 0.9430619291787178, 0.9390636655250387, 0.9448642625910232, 0.940451334604493, 0.9336143505685688, 0.8897041952728477, 0.9047859608953581, 0.8948268201171585, 0.8988325373051383, 0.8893513782423796, 0.8918416332323527, 0.8925500936429702, 0.9045970721216785, 0.8847772958693664, 0.17859672714634367, 0.13753478740316638, 0.15859773136335897, 0.15706673166095786, 0.18511342542410048, 0.17850835957529598, 0.1782473543294485, 0.18550679285508131, 0.16764754184864283, 0.13095212110180277, 0.1554963755982106, 0.15399718228087644, 0.15542422274669354, 0.15947306859302846, 0.12168087344056622, 0.09601920846846823, 0.1411293860147652, 0.11517226227676491, 0.9479995942791688, 0.9586325233343297, 0.9557735443925945, 0.9623339999365172, 0.9768317358482133, 0.9744418566666997, 0.9513390784455709, 0.9708509121399067, 0.9727440584342222, 0.8372517586506952, 0.8278512508000636, 0.8320854395182977, 0.777898434181939, 0.7190980408545158, 0.8213494432409394, 0.8291504661720812, 0.8275118482431636, 0.8392750516719366, 0.39612039049413017, 0.8879257680523647, 0.44348173715560724, 0.21483492648098956, 0.38539119762095353, 0.38388035622611305, 0.9268420619870731, 0.23364884759220905, 0.232647286304421, 0.2778164678030167, 0.2551801337283347, 0.20980101607336388, 0.2239850164943139, 0.25029183018587986, 0.2164333301799034, 0.2034890893131207, 0.23954976618888435, 0.20294738829914594, 0.1681750711819342, 0.22734836358572363, 0.20225314820372964, 0.2436169603636752, 0.22777905583119706, 0.23739811966723123, 0.13019113002672655, 0.11498226979095394, 0.24095203135407794, 0.06357508980198068, 0.1344515853001521, 0.007633359782707849, 0.059265889644057324, 0.04569340561288915, 0.062283881642926864, 0.03892765199573045, 0.06143008447530052, 0.07527853493897751, 0.09766925135534088, 0.12037951432972405, 0.0780618934786147, 0.1179420298947822, 0.11581723298425128, 0.0941023220505669, 0.13198390944388483, 0.11967388661878153, 0.16863090753048926, 0.14225047650348188, 0.06596723505649693, 0.05271207812986556, 0.08395365393229115, 0.12092271197964655, 0.0865995817832309, 0.16648636640414083, 0.29223762208766957, 0.08103359188613102, 0.07433667564648627, 0.24599169602219195, 0.22610865834241, 0.27526734612449166, 0.17352301788953917, 0.15891398359310172, 0.18241295263402202, 0.09459528107981408, 0.31451444211064583, 0.64515523942753, 0.6305419120864676, 0.5922466889611314, 0.6447375005711987, 0.6199561413352885, 0.6291544735703158, 0.6026360463136469, 0.6363352294416369, 0.6571448875845198, 0.15224895090715052, 0.16206926710094482, 0.13833845752274987, 0.1304299690899503, 0.15006864632641204, 0.12041726224028404, 0.15184448596803846, 0.5713209054056534, 0.13898358178490744, 0.15773807696839937, 0.1806740760592911, 0.28235972279010313, 0.2827572683032127, 0.18601124107028666, 0.5629698386611739, 0.2447349949327512, 0.14436740943284443, 0.13045049109091456, 0.8119576865848144, 0.7761928901580412, 0.4197013670855265, 0.4936232039804819, 0.7225632427741331, 0.4390141006813396, 0.8026700991173684, 0.8485206739927376, 0.3994094103449397, 0.4712145792866226, 0.31838550357174733, 0.282125114506541, 0.2678006860840868, 0.3407547814135281, 0.3809182750543535, 0.6261959129919494, 0.47045922507151994, 0.4682366497765471, 0.21503019871267015, 0.21443839850265345, 0.21251455395778862, 0.2019222836968555, 0.2145558508949892, 0.2315289805022298, 0.2124697684238166, 0.2120778451430121, 0.20790474520517832, 0.7892869775502029, 0.25128971002847966, 0.20581486147080108, 0.6083420154361332, 0.25231154157062596, 0.7145605703824078, 0.21494983817051805, 0.2501195360352869, 0.22376237557876133, 0.9507115615520835, 0.18496920367077951, 0.9131858542131166, 0.9212936656009162, 0.1653442953355947, 0.9576890397776002, 0.18372542745508602, 0.8972046237210713, 0.1659955773083257, 0.8416696655016744, 0.21323347483420685, 0.8983861799914095, 0.21193319126108023, 0.7512885777118363, 0.21266340209076484, 0.21214162783104573, 0.2116385818549843, 0.8603049113625599, 0.18317010763965602, 0.19085539918313066, 0.17387187982922292, 0.17637732431624153, 0.17632845933707997, 0.1884036827951514, 0.19214875102536533, 0.20697442927354337, 0.22075360384398823, 0.09069503085155362, 0.10367697478607063, 0.08837474035230009, 0.09265580807392526, 0.08028185531001053, 0.08588014824209678, 0.09834179953994937, 0.09848055270773381, 0.08376085395158439]}, "mutation_prompt": null}
{"id": "249b220b-4beb-4620-94b2-bbf2fb149eda", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation with random mutation factor\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration by employing a random mutation factor for diversity in DE mutation.", "configspace": "", "generation": 28, "fitness": 0.38619528380343543, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.31.", "error": "", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.928066270132814, 0.941530874994635, 0.9459999099294658, 0.9349698533351013, 0.9461408676628388, 0.946243406300895, 0.9448040083407167, 0.9389860219296954, 0.9389702418592287, 0.9010656080546436, 0.8953820923246197, 0.8989083865307665, 0.8865081967098983, 0.8981595028232061, 0.894235708856288, 0.8761574317397582, 0.8956458152816494, 0.9041292503987753, 0.1885430944106401, 0.1848523589197283, 0.15904930920548266, 0.14220008095237113, 0.6778944824318859, 0.16884703402083867, 0.7704022143124358, 0.18430704523512997, 0.7492509392740367, 0.15359076686774098, 0.13812253203232905, 0.11708041580041917, 0.15845844229471095, 0.11778033660349096, 0.1838684711947215, 0.14169742184276857, 0.1419298249232015, 0.15940467862791252, 0.987671022040156, 0.9464820928101932, 0.9581340905036309, 0.9493320250959848, 0.9710031793993619, 0.9414442016141948, 0.9463705964541632, 0.9699879226394004, 0.9618184575522125, 0.8500176278209631, 0.8140204365630603, 0.797694214616695, 0.7791110959694506, 0.8455029456741794, 0.8357972783417356, 0.8104261573904205, 0.8113766968441107, 0.8285577339050042, 0.39594146246260076, 0.9236054544773216, 0.3951102990908574, 0.9026270680846541, 0.3620645819950019, 0.2814162249513563, 0.18094307561653888, 0.8947358799408953, 0.8305015486909358, 0.1900048043350625, 0.2625016727599022, 0.17318957636630916, 0.29688601089967237, 0.20943197978611505, 0.18186856271593066, 0.20447031686468475, 0.20388942882547156, 0.19438660258397167, 0.20107344411846007, 0.19698884977181164, 0.22184900689294595, 0.20885541045893763, 0.18458878986140248, 0.18962409603072394, 0.21531277309064334, 0.24884815113812875, 0.22373499955315435, 0.15263472084357288, 0.08082533488699573, 0.09401594573932559, 0.0008281960085653184, 0.06118541854862147, 0.12251497761533447, 0.07243244294053419, 0.04344287893443688, 0.17622077039990036, 0.04342856242683191, 0.09425301041666079, 0.13438528028731067, 0.10933150774091283, 0.09535002452500652, 0.028725454306635534, 0.07244888870348043, 0.12492341880988078, 0.14868253282829214, 0.07608976558975078, 0.17686549859248912, 0.2692095238878721, 0.12312182071006572, 0.20494335588899926, 0.11589375914394151, 0.2656981996331166, 0.1526972436956937, 0.08588920849912429, 0.08851788782316816, 0.16209822036232413, 0.2303933636816614, 0.2560147301947654, 0.256313837837299, 0.09984364150517433, 0.17203563699552638, 0.07194974830816592, 0.11993607265251938, 0.6654219989509722, 0.6582497867842942, 0.694329889729956, 0.6277038031842925, 0.6227425083461682, 0.6657289271607802, 0.659644937404063, 0.5965536071964872, 0.6701696283971555, 0.1416351104420368, 0.15610866807107593, 0.12163928116964784, 0.14794867683360657, 0.13698347978265957, 0.13448033893678624, 0.09658785567910821, 0.1376581283320053, 0.09988504717699509, 0.6204650983942139, 0.16185747579892817, 0.1596099559147075, 0.1547790883352318, 0.4605945158122078, 0.23936120940176742, 0.19276380601404886, 0.22392062330577378, 0.1488743776198771, 0.40008570698157986, 0.5432778762446044, 0.7725021985269787, 0.6092095787747477, 0.7725684780370774, 0.34695820538208744, 0.8373807805845098, 0.6014556449678758, 0.6713097362699865, 0.28900797685096635, 0.47653193027124785, 0.32059445213750626, 0.5644676894398407, 0.4599547085901714, 0.29192748304516003, 0.5301666489577264, 0.46903644869378536, 0.40203935796546075, 0.1985730098013242, 0.22600251817313788, 0.22041934245243489, 0.20198788037549764, 0.22335833076796063, 0.21256685628452554, 0.20118173233509684, 0.21077234548297874, 0.21153211510151615, 0.8322014581579492, 0.20889528106562194, 0.20557198051587444, 0.23147928718688204, 0.20816234821991164, 0.1927853630843257, 0.19027064975960029, 0.18991553567382458, 0.20390488607656787, 0.18684741740748512, 0.18566470904727628, 0.16535349128976762, 0.8974605689333226, 0.2001545269867998, 0.19983319917121833, 0.9111420769462956, 0.9304944298296997, 0.1637471685977947, 0.16934094545073763, 0.21331739590334886, 0.12661572790368458, 0.5374323472008664, 0.21291752090452032, 0.8673061265799563, 0.21291556647847842, 0.157315623968316, 0.8366920990594454, 0.18339022225171564, 0.18271694967650054, 0.17619034206218198, 0.19690489363089758, 0.18380283192577862, 0.1925428733318727, 0.18418516921090355, 0.1857448639297794, 0.17746439983650575, 0.0965456313801093, 0.0983227904471472, 0.09216839996505755, 0.08567692384449632, 0.08020715578313198, 0.08816217578871088, 0.09791439658411638, 0.10232974953120899, 0.10008532057452835]}, "mutation_prompt": null}
{"id": "2fed3bbc-e95d-4aa1-ada3-111bbb0cedd6", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                self.mutation_factor = 0.5 + (0.9 - 0.5) * (self.evaluations / self.budget)  # Self-adaptive mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a self-adaptive mutation factor to enhance diversity and convergence speed.", "configspace": "", "generation": 29, "fitness": 0.29411469685472197, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.939918660086337, 0.5969647517415646, 0.7739313952242484, 0.9527282979908065, 0.8117374386843409, 0.954909700123834, 0.9524643960161004, 0.703987599902341, 0.9498668750497106, 0.9173773680125767, 0.9205946846974216, 0.6119948061434111, 0.8020983086928242, 0.35859854154679693, 0.8798991070168767, 0.8994213263922783, 0.2068376470757235, 0.8938102716359307, 0.7480623999083211, 0.8896980292336161, 0.11568416577454876, 0.11890854070854928, 0.11780553168820174, 0.11911281471835022, 0.16418556708347531, 0.16038443889584653, 0.16253923593953346, 0.1441410839331817, 0.11179580424109359, 0.16144994582110872, 0.10729581449701764, 0.1410186769079026, 0.08540235007029895, 0.08951770872249198, 0.1418628473725344, 0.10164104001476948, 0.9161329022779002, 0.7302243463153033, 0.7261265288622775, 0.5337744957914108, 0.38777921293159967, 0.9444706753762935, 0.9012971048214068, 0.9240046414557697, 0.9201505228176304, 0.34592094907177695, 0.14959075553405943, 0.20025180826585487, 0.16614729238094827, 0.19372886356765373, 0.3244742931080271, 0.25902993518950934, 0.15298347134806645, 0.14047326672987037, 0.24442046624312674, 0.22846103076504853, 0.230021448296457, 0.31601505615155934, 0.2828327431258578, 0.21486730274134125, 0.23823888282303507, 0.23855845403441844, 0.2624839524955007, 0.19977210195579576, 0.15083057002975697, 0.14586971213272992, 0.15723940733723962, 0.1363758565187847, 0.17087469032081737, 0.17032934577677084, 0.13403133407015633, 0.14931621565736675, 0.1764083430283907, 0.13617793724503102, 0.16143140908281206, 0.13348870119827938, 0.13404873117036753, 0.14323226640712272, 0.23786163974331176, 0.2312341008247275, 0.21205466078479795, 0.044933720432653756, 0.06696272340990361, 0.10701436975566903, 0.09082532606161497, 0.04631148775414129, 0.0032070713771514825, 0.008476691055764096, 9.999999999998899e-05, 9.999999999998899e-05, 0.1632236181123109, 0.13533293459161433, 0.13068312808329252, 0.15874453677603484, 0.06435542485673107, 0.08428553473894973, 0.1737528178351404, 0.11968919482778606, 0.09965131711446229, 0.3550109764584186, 0.018610326512438213, 0.1037438179733865, 0.09795571372713019, 0.1001792323087689, 0.1958863769935021, 0.26521235691976874, 0.11156042040634806, 0.19138389633228892, 0.14503841842773169, 0.07890626814305435, 0.18765101969649023, 0.16528887798384206, 0.0988919648298503, 0.1344612457516412, 0.24440598486458598, 0.16335186516137434, 0.16804974811493645, 0.611798577168364, 0.4983334942040226, 0.32779466520831424, 0.585938192371042, 0.481157394301035, 0.6386241737542675, 0.5399613689040457, 0.5601816225820394, 0.5216848427440705, 0.18666755277332392, 0.13495474517953154, 0.12647203149020048, 0.12953320562582138, 0.12258556428391909, 0.14434918095569615, 0.09626090236806961, 0.1425552645543734, 0.11971908864976266, 0.18844168827972674, 0.37261286132992477, 0.26370615800968844, 0.32148392213931076, 0.40983157656668623, 0.18799801053188958, 0.15016691363507473, 0.44642676511424484, 0.5262427142298653, 0.4002463425453514, 0.3348761131628978, 0.4170225806033072, 0.5678041951034787, 0.46950800750077104, 0.2861126313611492, 0.24285272155244153, 0.44777630700853976, 0.6600448267304846, 0.3309510600458465, 0.3978293179004272, 0.2506725850303194, 0.27439581197739327, 0.317787127243089, 0.4060934914858192, 0.2850848806079461, 0.27029830516570563, 0.23237050086234523, 0.23601647225390643, 0.21673460422909785, 0.1951398056648358, 0.21690605694659149, 0.21100049759503858, 0.23551150311962232, 0.23499269609856366, 0.23661450647246585, 0.2188896522654602, 0.19808403072718206, 0.22859903808881243, 0.22753719493389557, 0.21519477054575564, 0.20173351254656924, 0.18858126244971285, 0.22889967074228879, 0.8620364901371372, 0.18725733779064724, 0.15814920923788434, 0.18770526978694424, 0.1880002505675572, 0.17371416096377468, 0.20116896618495994, 0.8126622899971824, 0.155983472932975, 0.13688239993235107, 0.15363846932484815, 0.687183000813727, 0.21390011617981974, 0.41338177172895263, 0.21380010870133814, 0.16912384838346983, 0.21313920641355244, 0.11325458177466952, 0.29555129405621006, 0.30614616171009634, 0.17094222998220998, 0.18463625714058152, 0.1860000658291775, 0.18460149869310993, 0.1960225756086872, 0.18621889963274552, 0.17772712558433523, 0.188200930836117, 0.17197879369630864, 0.10701156880729634, 0.09204603623806074, 0.09126644226230018, 0.08866086670732054, 0.09687864522759504, 0.08826126056608952, 0.09327664708134087, 0.09131689757535477, 0.08948181025308699]}, "mutation_prompt": null}
{"id": "8d009fec-5a8f-4397-b046-c2bad0eefa6c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a tournament selection mechanism to improve individual selection for diversity.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.9422216968416194, 0.9444748675244793, 0.9352146504922559, 0.9377110151250405, 0.9430619291787178, 0.9390636655250387, 0.9448642625910232, 0.940451334604493, 0.9336143505685688, 0.8897041952728477, 0.9047859608953581, 0.8948268201171585, 0.8988325373051383, 0.8893513782423796, 0.8918416332323527, 0.8925500936429702, 0.9045970721216785, 0.8847772958693664, 0.17859672714634367, 0.13753478740316638, 0.15859773136335897, 0.15706673166095786, 0.18511342542410048, 0.17850835957529598, 0.1782473543294485, 0.18550679285508131, 0.16764754184864283, 0.13095212110180277, 0.1554963755982106, 0.15399718228087644, 0.15542422274669354, 0.15947306859302846, 0.12168087344056622, 0.09601920846846823, 0.1411293860147652, 0.11517226227676491, 0.9479995942791688, 0.9586325233343297, 0.9557735443925945, 0.9623339999365172, 0.9768317358482133, 0.9744418566666997, 0.9513390784455709, 0.9708509121399067, 0.9727440584342222, 0.8372517586506952, 0.8278512508000636, 0.8320854395182977, 0.777898434181939, 0.7190980408545158, 0.8213494432409394, 0.8291504661720812, 0.8275118482431636, 0.8392750516719366, 0.39612039049413017, 0.8879257680523647, 0.44348173715560724, 0.21483492648098956, 0.38539119762095353, 0.38388035622611305, 0.9268420619870731, 0.23364884759220905, 0.232647286304421, 0.2778164678030167, 0.2551801337283347, 0.20980101607336388, 0.2239850164943139, 0.25029183018587986, 0.2164333301799034, 0.2034890893131207, 0.23954976618888435, 0.20294738829914594, 0.1681750711819342, 0.22734836358572363, 0.20225314820372964, 0.2436169603636752, 0.22777905583119706, 0.23739811966723123, 0.13019113002672655, 0.11498226979095394, 0.24095203135407794, 0.06357508980198068, 0.1344515853001521, 0.007633359782707849, 0.059265889644057324, 0.04569340561288915, 0.062283881642926864, 0.03892765199573045, 0.06143008447530052, 0.07527853493897751, 0.09766925135534088, 0.12037951432972405, 0.0780618934786147, 0.1179420298947822, 0.11581723298425128, 0.0941023220505669, 0.13198390944388483, 0.11967388661878153, 0.16863090753048926, 0.14225047650348188, 0.06596723505649693, 0.05271207812986556, 0.08395365393229115, 0.12092271197964655, 0.0865995817832309, 0.16648636640414083, 0.29223762208766957, 0.08103359188613102, 0.07433667564648627, 0.24599169602219195, 0.22610865834241, 0.27526734612449166, 0.17352301788953917, 0.15891398359310172, 0.18241295263402202, 0.09459528107981408, 0.31451444211064583, 0.64515523942753, 0.6305419120864676, 0.5922466889611314, 0.6447375005711987, 0.6199561413352885, 0.6291544735703158, 0.6026360463136469, 0.6363352294416369, 0.6571448875845198, 0.15224895090715052, 0.16206926710094482, 0.13833845752274987, 0.1304299690899503, 0.15006864632641204, 0.12041726224028404, 0.15184448596803846, 0.5713209054056534, 0.13898358178490744, 0.15773807696839937, 0.1806740760592911, 0.28235972279010313, 0.2827572683032127, 0.18601124107028666, 0.5629698386611739, 0.2447349949327512, 0.14436740943284443, 0.13045049109091456, 0.8119576865848144, 0.7761928901580412, 0.4197013670855265, 0.4936232039804819, 0.7225632427741331, 0.4390141006813396, 0.8026700991173684, 0.8485206739927376, 0.3994094103449397, 0.4712145792866226, 0.31838550357174733, 0.282125114506541, 0.2678006860840868, 0.3407547814135281, 0.3809182750543535, 0.6261959129919494, 0.47045922507151994, 0.4682366497765471, 0.21503019871267015, 0.21443839850265345, 0.21251455395778862, 0.2019222836968555, 0.2145558508949892, 0.2315289805022298, 0.2124697684238166, 0.2120778451430121, 0.20790474520517832, 0.7892869775502029, 0.25128971002847966, 0.20581486147080108, 0.6083420154361332, 0.25231154157062596, 0.7145605703824078, 0.21494983817051805, 0.2501195360352869, 0.22376237557876133, 0.9507115615520835, 0.18496920367077951, 0.9131858542131166, 0.9212936656009162, 0.1653442953355947, 0.9576890397776002, 0.18372542745508602, 0.8972046237210713, 0.1659955773083257, 0.8416696655016744, 0.21323347483420685, 0.8983861799914095, 0.21193319126108023, 0.7512885777118363, 0.21266340209076484, 0.21214162783104573, 0.2116385818549843, 0.8603049113625599, 0.18317010763965602, 0.19085539918313066, 0.17387187982922292, 0.17637732431624153, 0.17632845933707997, 0.1884036827951514, 0.19214875102536533, 0.20697442927354337, 0.22075360384398823, 0.09069503085155362, 0.10367697478607063, 0.08837474035230009, 0.09265580807392526, 0.08028185531001053, 0.08588014824209678, 0.09834179953994937, 0.09848055270773381, 0.08376085395158439]}, "mutation_prompt": null}
{"id": "a9a9dec5-27b7-4c86-9d95-0a4f5fb7747f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a tournament selection mechanism to improve individual selection for diversity.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.9422216968416194, 0.9444748675244793, 0.9352146504922559, 0.9377110151250405, 0.9430619291787178, 0.9390636655250387, 0.9448642625910232, 0.940451334604493, 0.9336143505685688, 0.8897041952728477, 0.9047859608953581, 0.8948268201171585, 0.8988325373051383, 0.8893513782423796, 0.8918416332323527, 0.8925500936429702, 0.9045970721216785, 0.8847772958693664, 0.17859672714634367, 0.13753478740316638, 0.15859773136335897, 0.15706673166095786, 0.18511342542410048, 0.17850835957529598, 0.1782473543294485, 0.18550679285508131, 0.16764754184864283, 0.13095212110180277, 0.1554963755982106, 0.15399718228087644, 0.15542422274669354, 0.15947306859302846, 0.12168087344056622, 0.09601920846846823, 0.1411293860147652, 0.11517226227676491, 0.9479995942791688, 0.9586325233343297, 0.9557735443925945, 0.9623339999365172, 0.9768317358482133, 0.9744418566666997, 0.9513390784455709, 0.9708509121399067, 0.9727440584342222, 0.8372517586506952, 0.8278512508000636, 0.8320854395182977, 0.777898434181939, 0.7190980408545158, 0.8213494432409394, 0.8291504661720812, 0.8275118482431636, 0.8392750516719366, 0.39612039049413017, 0.8879257680523647, 0.44348173715560724, 0.21483492648098956, 0.38539119762095353, 0.38388035622611305, 0.9268420619870731, 0.23364884759220905, 0.232647286304421, 0.2778164678030167, 0.2551801337283347, 0.20980101607336388, 0.2239850164943139, 0.25029183018587986, 0.2164333301799034, 0.2034890893131207, 0.23954976618888435, 0.20294738829914594, 0.1681750711819342, 0.22734836358572363, 0.20225314820372964, 0.2436169603636752, 0.22777905583119706, 0.23739811966723123, 0.13019113002672655, 0.11498226979095394, 0.24095203135407794, 0.06357508980198068, 0.1344515853001521, 0.007633359782707849, 0.059265889644057324, 0.04569340561288915, 0.062283881642926864, 0.03892765199573045, 0.06143008447530052, 0.07527853493897751, 0.09766925135534088, 0.12037951432972405, 0.0780618934786147, 0.1179420298947822, 0.11581723298425128, 0.0941023220505669, 0.13198390944388483, 0.11967388661878153, 0.16863090753048926, 0.14225047650348188, 0.06596723505649693, 0.05271207812986556, 0.08395365393229115, 0.12092271197964655, 0.0865995817832309, 0.16648636640414083, 0.29223762208766957, 0.08103359188613102, 0.07433667564648627, 0.24599169602219195, 0.22610865834241, 0.27526734612449166, 0.17352301788953917, 0.15891398359310172, 0.18241295263402202, 0.09459528107981408, 0.31451444211064583, 0.64515523942753, 0.6305419120864676, 0.5922466889611314, 0.6447375005711987, 0.6199561413352885, 0.6291544735703158, 0.6026360463136469, 0.6363352294416369, 0.6571448875845198, 0.15224895090715052, 0.16206926710094482, 0.13833845752274987, 0.1304299690899503, 0.15006864632641204, 0.12041726224028404, 0.15184448596803846, 0.5713209054056534, 0.13898358178490744, 0.15773807696839937, 0.1806740760592911, 0.28235972279010313, 0.2827572683032127, 0.18601124107028666, 0.5629698386611739, 0.2447349949327512, 0.14436740943284443, 0.13045049109091456, 0.8119576865848144, 0.7761928901580412, 0.4197013670855265, 0.4936232039804819, 0.7225632427741331, 0.4390141006813396, 0.8026700991173684, 0.8485206739927376, 0.3994094103449397, 0.4712145792866226, 0.31838550357174733, 0.282125114506541, 0.2678006860840868, 0.3407547814135281, 0.3809182750543535, 0.6261959129919494, 0.47045922507151994, 0.4682366497765471, 0.21503019871267015, 0.21443839850265345, 0.21251455395778862, 0.2019222836968555, 0.2145558508949892, 0.2315289805022298, 0.2124697684238166, 0.2120778451430121, 0.20790474520517832, 0.7892869775502029, 0.25128971002847966, 0.20581486147080108, 0.6083420154361332, 0.25231154157062596, 0.7145605703824078, 0.21494983817051805, 0.2501195360352869, 0.22376237557876133, 0.9507115615520835, 0.18496920367077951, 0.9131858542131166, 0.9212936656009162, 0.1653442953355947, 0.9576890397776002, 0.18372542745508602, 0.8972046237210713, 0.1659955773083257, 0.8416696655016744, 0.21323347483420685, 0.8983861799914095, 0.21193319126108023, 0.7512885777118363, 0.21266340209076484, 0.21214162783104573, 0.2116385818549843, 0.8603049113625599, 0.18317010763965602, 0.19085539918313066, 0.17387187982922292, 0.17637732431624153, 0.17632845933707997, 0.1884036827951514, 0.19214875102536533, 0.20697442927354337, 0.22075360384398823, 0.09069503085155362, 0.10367697478607063, 0.08837474035230009, 0.09265580807392526, 0.08028185531001053, 0.08588014824209678, 0.09834179953994937, 0.09848055270773381, 0.08376085395158439]}, "mutation_prompt": null}
{"id": "edf19563-eec5-4036-abff-86fee918db38", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a tournament selection mechanism to improve individual selection for diversity.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.9422216968416194, 0.9444748675244793, 0.9352146504922559, 0.9377110151250405, 0.9430619291787178, 0.9390636655250387, 0.9448642625910232, 0.940451334604493, 0.9336143505685688, 0.8897041952728477, 0.9047859608953581, 0.8948268201171585, 0.8988325373051383, 0.8893513782423796, 0.8918416332323527, 0.8925500936429702, 0.9045970721216785, 0.8847772958693664, 0.17859672714634367, 0.13753478740316638, 0.15859773136335897, 0.15706673166095786, 0.18511342542410048, 0.17850835957529598, 0.1782473543294485, 0.18550679285508131, 0.16764754184864283, 0.13095212110180277, 0.1554963755982106, 0.15399718228087644, 0.15542422274669354, 0.15947306859302846, 0.12168087344056622, 0.09601920846846823, 0.1411293860147652, 0.11517226227676491, 0.9479995942791688, 0.9586325233343297, 0.9557735443925945, 0.9623339999365172, 0.9768317358482133, 0.9744418566666997, 0.9513390784455709, 0.9708509121399067, 0.9727440584342222, 0.8372517586506952, 0.8278512508000636, 0.8320854395182977, 0.777898434181939, 0.7190980408545158, 0.8213494432409394, 0.8291504661720812, 0.8275118482431636, 0.8392750516719366, 0.39612039049413017, 0.8879257680523647, 0.44348173715560724, 0.21483492648098956, 0.38539119762095353, 0.38388035622611305, 0.9268420619870731, 0.23364884759220905, 0.232647286304421, 0.2778164678030167, 0.2551801337283347, 0.20980101607336388, 0.2239850164943139, 0.25029183018587986, 0.2164333301799034, 0.2034890893131207, 0.23954976618888435, 0.20294738829914594, 0.1681750711819342, 0.22734836358572363, 0.20225314820372964, 0.2436169603636752, 0.22777905583119706, 0.23739811966723123, 0.13019113002672655, 0.11498226979095394, 0.24095203135407794, 0.06357508980198068, 0.1344515853001521, 0.007633359782707849, 0.059265889644057324, 0.04569340561288915, 0.062283881642926864, 0.03892765199573045, 0.06143008447530052, 0.07527853493897751, 0.09766925135534088, 0.12037951432972405, 0.0780618934786147, 0.1179420298947822, 0.11581723298425128, 0.0941023220505669, 0.13198390944388483, 0.11967388661878153, 0.16863090753048926, 0.14225047650348188, 0.06596723505649693, 0.05271207812986556, 0.08395365393229115, 0.12092271197964655, 0.0865995817832309, 0.16648636640414083, 0.29223762208766957, 0.08103359188613102, 0.07433667564648627, 0.24599169602219195, 0.22610865834241, 0.27526734612449166, 0.17352301788953917, 0.15891398359310172, 0.18241295263402202, 0.09459528107981408, 0.31451444211064583, 0.64515523942753, 0.6305419120864676, 0.5922466889611314, 0.6447375005711987, 0.6199561413352885, 0.6291544735703158, 0.6026360463136469, 0.6363352294416369, 0.6571448875845198, 0.15224895090715052, 0.16206926710094482, 0.13833845752274987, 0.1304299690899503, 0.15006864632641204, 0.12041726224028404, 0.15184448596803846, 0.5713209054056534, 0.13898358178490744, 0.15773807696839937, 0.1806740760592911, 0.28235972279010313, 0.2827572683032127, 0.18601124107028666, 0.5629698386611739, 0.2447349949327512, 0.14436740943284443, 0.13045049109091456, 0.8119576865848144, 0.7761928901580412, 0.4197013670855265, 0.4936232039804819, 0.7225632427741331, 0.4390141006813396, 0.8026700991173684, 0.8485206739927376, 0.3994094103449397, 0.4712145792866226, 0.31838550357174733, 0.282125114506541, 0.2678006860840868, 0.3407547814135281, 0.3809182750543535, 0.6261959129919494, 0.47045922507151994, 0.4682366497765471, 0.21503019871267015, 0.21443839850265345, 0.21251455395778862, 0.2019222836968555, 0.2145558508949892, 0.2315289805022298, 0.2124697684238166, 0.2120778451430121, 0.20790474520517832, 0.7892869775502029, 0.25128971002847966, 0.20581486147080108, 0.6083420154361332, 0.25231154157062596, 0.7145605703824078, 0.21494983817051805, 0.2501195360352869, 0.22376237557876133, 0.9507115615520835, 0.18496920367077951, 0.9131858542131166, 0.9212936656009162, 0.1653442953355947, 0.9576890397776002, 0.18372542745508602, 0.8972046237210713, 0.1659955773083257, 0.8416696655016744, 0.21323347483420685, 0.8983861799914095, 0.21193319126108023, 0.7512885777118363, 0.21266340209076484, 0.21214162783104573, 0.2116385818549843, 0.8603049113625599, 0.18317010763965602, 0.19085539918313066, 0.17387187982922292, 0.17637732431624153, 0.17632845933707997, 0.1884036827951514, 0.19214875102536533, 0.20697442927354337, 0.22075360384398823, 0.09069503085155362, 0.10367697478607063, 0.08837474035230009, 0.09265580807392526, 0.08028185531001053, 0.08588014824209678, 0.09834179953994937, 0.09848055270773381, 0.08376085395158439]}, "mutation_prompt": null}
{"id": "280424fb-5fce-44a7-bf12-214911f035cb", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a tournament selection mechanism to improve individual selection for diversity.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.9422216968416194, 0.9444748675244793, 0.9352146504922559, 0.9377110151250405, 0.9430619291787178, 0.9390636655250387, 0.9448642625910232, 0.940451334604493, 0.9336143505685688, 0.8897041952728477, 0.9047859608953581, 0.8948268201171585, 0.8988325373051383, 0.8893513782423796, 0.8918416332323527, 0.8925500936429702, 0.9045970721216785, 0.8847772958693664, 0.17859672714634367, 0.13753478740316638, 0.15859773136335897, 0.15706673166095786, 0.18511342542410048, 0.17850835957529598, 0.1782473543294485, 0.18550679285508131, 0.16764754184864283, 0.13095212110180277, 0.1554963755982106, 0.15399718228087644, 0.15542422274669354, 0.15947306859302846, 0.12168087344056622, 0.09601920846846823, 0.1411293860147652, 0.11517226227676491, 0.9479995942791688, 0.9586325233343297, 0.9557735443925945, 0.9623339999365172, 0.9768317358482133, 0.9744418566666997, 0.9513390784455709, 0.9708509121399067, 0.9727440584342222, 0.8372517586506952, 0.8278512508000636, 0.8320854395182977, 0.777898434181939, 0.7190980408545158, 0.8213494432409394, 0.8291504661720812, 0.8275118482431636, 0.8392750516719366, 0.39612039049413017, 0.8879257680523647, 0.44348173715560724, 0.21483492648098956, 0.38539119762095353, 0.38388035622611305, 0.9268420619870731, 0.23364884759220905, 0.232647286304421, 0.2778164678030167, 0.2551801337283347, 0.20980101607336388, 0.2239850164943139, 0.25029183018587986, 0.2164333301799034, 0.2034890893131207, 0.23954976618888435, 0.20294738829914594, 0.1681750711819342, 0.22734836358572363, 0.20225314820372964, 0.2436169603636752, 0.22777905583119706, 0.23739811966723123, 0.13019113002672655, 0.11498226979095394, 0.24095203135407794, 0.06357508980198068, 0.1344515853001521, 0.007633359782707849, 0.059265889644057324, 0.04569340561288915, 0.062283881642926864, 0.03892765199573045, 0.06143008447530052, 0.07527853493897751, 0.09766925135534088, 0.12037951432972405, 0.0780618934786147, 0.1179420298947822, 0.11581723298425128, 0.0941023220505669, 0.13198390944388483, 0.11967388661878153, 0.16863090753048926, 0.14225047650348188, 0.06596723505649693, 0.05271207812986556, 0.08395365393229115, 0.12092271197964655, 0.0865995817832309, 0.16648636640414083, 0.29223762208766957, 0.08103359188613102, 0.07433667564648627, 0.24599169602219195, 0.22610865834241, 0.27526734612449166, 0.17352301788953917, 0.15891398359310172, 0.18241295263402202, 0.09459528107981408, 0.31451444211064583, 0.64515523942753, 0.6305419120864676, 0.5922466889611314, 0.6447375005711987, 0.6199561413352885, 0.6291544735703158, 0.6026360463136469, 0.6363352294416369, 0.6571448875845198, 0.15224895090715052, 0.16206926710094482, 0.13833845752274987, 0.1304299690899503, 0.15006864632641204, 0.12041726224028404, 0.15184448596803846, 0.5713209054056534, 0.13898358178490744, 0.15773807696839937, 0.1806740760592911, 0.28235972279010313, 0.2827572683032127, 0.18601124107028666, 0.5629698386611739, 0.2447349949327512, 0.14436740943284443, 0.13045049109091456, 0.8119576865848144, 0.7761928901580412, 0.4197013670855265, 0.4936232039804819, 0.7225632427741331, 0.4390141006813396, 0.8026700991173684, 0.8485206739927376, 0.3994094103449397, 0.4712145792866226, 0.31838550357174733, 0.282125114506541, 0.2678006860840868, 0.3407547814135281, 0.3809182750543535, 0.6261959129919494, 0.47045922507151994, 0.4682366497765471, 0.21503019871267015, 0.21443839850265345, 0.21251455395778862, 0.2019222836968555, 0.2145558508949892, 0.2315289805022298, 0.2124697684238166, 0.2120778451430121, 0.20790474520517832, 0.7892869775502029, 0.25128971002847966, 0.20581486147080108, 0.6083420154361332, 0.25231154157062596, 0.7145605703824078, 0.21494983817051805, 0.2501195360352869, 0.22376237557876133, 0.9507115615520835, 0.18496920367077951, 0.9131858542131166, 0.9212936656009162, 0.1653442953355947, 0.9576890397776002, 0.18372542745508602, 0.8972046237210713, 0.1659955773083257, 0.8416696655016744, 0.21323347483420685, 0.8983861799914095, 0.21193319126108023, 0.7512885777118363, 0.21266340209076484, 0.21214162783104573, 0.2116385818549843, 0.8603049113625599, 0.18317010763965602, 0.19085539918313066, 0.17387187982922292, 0.17637732431624153, 0.17632845933707997, 0.1884036827951514, 0.19214875102536533, 0.20697442927354337, 0.22075360384398823, 0.09069503085155362, 0.10367697478607063, 0.08837474035230009, 0.09265580807392526, 0.08028185531001053, 0.08588014824209678, 0.09834179953994937, 0.09848055270773381, 0.08376085395158439]}, "mutation_prompt": null}
{"id": "ade936f0-0c12-4072-9924-99257c6f2759", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(list(set(idxs) - {i}), self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n                \n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance solution diversity by ensuring unique selection in adaptive neighborhood search.", "configspace": "", "generation": 34, "fitness": 0.38044585665687985, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.9383782400022652, 0.9364774414089616, 0.9387771656664611, 0.9364986311879643, 0.9367090422833017, 0.9396487677482573, 0.9465363295768259, 0.9411113416235134, 0.9350138749927168, 0.9002097082030751, 0.8969561213269716, 0.8798852377903673, 0.8964005632935867, 0.8806369031820682, 0.8926090388750523, 0.8845751851667143, 0.8937796306461254, 0.8993064647047722, 0.18111528901008378, 0.1763239300847259, 0.18195889700108303, 0.7617387375264193, 0.17545562969719175, 0.15164183655050945, 0.7842935974140871, 0.18695436881384087, 0.14112838724340204, 0.11408233119715083, 0.7398231214991755, 0.1164006698329012, 0.13687813713099073, 0.18071916227336082, 0.14335049302281566, 0.11163177471148478, 0.12240889980174685, 0.17558635443616732, 0.9482872263855886, 0.9518542776039643, 0.9283721651205722, 0.9774199684083683, 0.9783508021278648, 0.9405928511314506, 0.9354222368922, 0.9554898221506176, 0.9750570351920549, 0.814511073551172, 0.8148377111803475, 0.8118921935558187, 0.8181644779805792, 0.8151747319331384, 0.858589808608905, 0.8135289754059406, 0.8323817741221295, 0.7882352304652738, 0.39227777216907167, 0.35687578047994517, 0.22588307827244236, 0.9116307029421591, 0.3802489763761234, 0.2810084345097167, 0.3916928876833179, 0.890954481305286, 0.416760553777618, 0.19680550692077392, 0.19131460661924904, 0.2026162891899792, 0.22575401760568292, 0.2037259910559308, 0.18731123532576666, 0.21792954082861205, 0.22934946247280608, 0.2136311806115585, 0.22082804996084449, 0.21880035323859914, 0.21991467418248223, 0.2297326403892097, 0.1349613401374936, 0.22013207341417818, 0.25931431784915027, 0.24173927732370382, 0.26832210021801683, 0.05536072198240871, 0.06387152999982115, 0.07789100392962156, 0.06685775182093134, 0.00022093425437108571, 0.021731871984209228, 0.05735172772340025, 0.050066169720192955, 0.09319818480377762, 0.11318127056120464, 0.14484556030722873, 0.15117951144503006, 0.1052527829387242, 0.12229916213161196, 0.057268788610950305, 0.10215588618605176, 0.1611692126337657, 0.13575133875605894, 0.12656535058344875, 0.2465519915452512, 0.14507875166329942, 0.1111061599120623, 0.10684477734177722, 0.1215875978245462, 0.14065891917531392, 0.09958911562633332, 0.1320344613083495, 0.17604709492554926, 0.3055711498477435, 0.24473263259128097, 0.3675895594323171, 0.27493349374610876, 0.26903574914102923, 0.14190216476879647, 0.2503993574678052, 0.13476361646883028, 0.6341459684767665, 0.6178359428855085, 0.6486618902824568, 0.6197511834015361, 0.6564820361849824, 0.6364245224276225, 0.6006560086880874, 0.6384039578712377, 0.6616775294770298, 0.10661687551000976, 0.1472179428086109, 0.13153321297006082, 0.15692861466528663, 0.1298795822739488, 0.14362512479835277, 0.1514276640190435, 0.11958385391762638, 0.13847818800401457, 0.24639223250107256, 0.12673720552424217, 0.1836053208154339, 0.14803576589441758, 0.151973145900135, 0.1263163976355829, 0.1190879515478167, 0.152890509099759, 0.13942692328694106, 0.5925345982596847, 0.6260316224184612, 0.6590980696669855, 0.519879450940665, 0.7806981339213035, 0.5932246017169549, 0.5495786854021114, 0.6609587381492497, 0.8078737847915071, 0.4688468901097256, 0.39008444954339083, 0.4329563556293168, 0.27600815432070147, 0.35840841560678594, 0.3638692395655414, 0.4789038251029101, 0.4998555153103722, 0.5351450426147506, 0.2333599505245445, 0.1916064094079406, 0.19867594281056367, 0.22495344302877196, 0.2013404799750801, 0.2037878060238747, 0.1999668111943682, 0.22745688353749394, 0.23414387170428952, 0.22530261567162813, 0.205038287273005, 0.7748637516072144, 0.8113206246869284, 0.2238110076291988, 0.22470574341414462, 0.22261032237886225, 0.22428945722592286, 0.2101497506824569, 0.9322748230194896, 0.18502452186990415, 0.15268803476027748, 0.9270347062377782, 0.20044442184280908, 0.17817920337443172, 0.8600123290459154, 0.1671338627881349, 0.1585685520175888, 0.7238172873303613, 0.21285638406126828, 0.21112311394649053, 0.1684294133848505, 0.21198760224418634, 0.864438052396366, 0.11326435565357229, 0.15625786411207332, 0.2130719010059836, 0.18187083592607167, 0.18173634672695893, 0.19658721212744357, 0.1955333333363164, 0.1753423077671219, 0.18549065100323836, 0.1848115170430371, 0.18425016760065005, 0.17637715535643694, 0.08205716076234626, 0.08901916740387428, 0.09291783059423908, 0.08392549385325654, 0.08663990219195317, 0.08247901719141448, 0.08566260601488285, 0.09556103279323358, 0.09697824362675633]}, "mutation_prompt": null}
{"id": "fb30b144-a519-441d-890c-17d5595aaeac", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 35, "fitness": 0.3909108099639801, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.31.", "error": "", "parent_id": "f099664a-158e-4cbe-8fe0-d9598171b0e6", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "850ddf57-cde5-4995-9fb6-342f39a51cd9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "c42e92fb-e318-4673-a147-2ae684802605", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                \n                # Dynamic mutation factor\n                dynamic_mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)\n                \n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a dynamic mutation factor that decreases over time to balance exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.34997169956177815, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9527155602854759, 0.9439213803462676, 0.9444945901653392, 0.939355390395726, 0.9483196623966764, 0.9450321358071692, 0.9485441097236663, 0.9484160520925496, 0.9442202479366673, 0.9085535895834537, 0.9125770019470465, 0.8929334084904651, 0.898795583050605, 0.9091257619316553, 0.9073921634970483, 0.9071864612417356, 0.8992059407596388, 0.8993133788338745, 0.8006786665500941, 0.18720149495996374, 0.1602179603530952, 0.16296069009051084, 0.8375478651896278, 0.1579958980551197, 0.18285282139750847, 0.15757245764191063, 0.18629953861441828, 0.11890771691804025, 0.1065990131157789, 0.15374246238694245, 0.11137239988749392, 0.1191859959060142, 0.1577034468311065, 0.09701365908179505, 0.0851677720143591, 0.09102085673751303, 0.9622506221206691, 0.9847221407423409, 0.9591031423088562, 0.9694923669690657, 0.9589929911645724, 0.987899627026117, 0.9708666912952195, 0.970594428407583, 0.9659168735613727, 0.7974859298841838, 0.44822405229678897, 0.6270253712481942, 0.7599971702834026, 0.6098036247460841, 0.3844970316733346, 0.4574472504733097, 0.618522632753808, 0.5471534711621816, 0.9331965799891371, 0.39182837281599303, 0.39169657980012973, 0.2146864733928091, 0.2144321134322268, 0.28065500186904, 0.4000715551656534, 0.23551087070749765, 0.2463288650979849, 0.16122008325867498, 0.17498497974640048, 0.16990095957099727, 0.17176548450102658, 0.1363663974113819, 0.20753751666807396, 0.1789360565858038, 0.17413900122196047, 0.16802950116085613, 0.15734390733315107, 0.16017255807979514, 0.1290134235047251, 0.13621991621059626, 0.23940165203291364, 0.14555997719611458, 0.10804935221739709, 0.10628966636709503, 0.1774805358656446, 0.21673973295880622, 0.1059531308027244, 0.03964408876922676, 0.053207359499106266, 0.05104903436966757, 0.026594211733239725, 0.06920702567725145, 0.013409782874592158, 0.1370036090497948, 0.03941276356858325, 0.05762972498520791, 0.11389586070938129, 0.08227060683242726, 0.11807486948203438, 0.033806976674911504, 0.22875372993816667, 0.11367879620468102, 0.11363127447388233, 0.2974805513810185, 0.03858633444265491, 0.34026756781798884, 0.11262353231482647, 0.08524586456437233, 0.10363504791816991, 0.10781077236911807, 9.999999999998899e-05, 0.08311875030083316, 0.22588616205787626, 0.07485505173816254, 0.2833357160191383, 0.15734480819422902, 0.14823265677809228, 0.3019649754848881, 0.3347555966453636, 0.08499647285047063, 0.08302669540745733, 0.6815745835152518, 0.5969282065840685, 0.5863802001964409, 0.64434413428288, 0.6183615300734002, 0.6481489870603583, 0.6681962985741368, 0.660952612351608, 0.6520917491480211, 0.13101040704182665, 0.16997489524399512, 0.11592609856378855, 0.1379232204595281, 0.16166547711410695, 0.14245590124179563, 0.14822309738618333, 0.1414531797399584, 0.16752069612206344, 0.2905599742702477, 0.33307234956637344, 0.45559963693511796, 0.21215766014918613, 0.16661328928496644, 0.23969702211482335, 0.250867617142739, 0.2559750652481416, 0.44694785018785876, 0.30022283789463977, 0.6547659166477319, 0.3167299705792197, 0.4582732154750966, 0.557797509968909, 0.4438968424811828, 0.5014189548641144, 0.5307000069137704, 0.8553511029405921, 0.32504689629316685, 0.3379464036471276, 0.29238526923226293, 0.2708959811125313, 0.28785670950688214, 0.36883449928629053, 0.3089881711583997, 0.21739652912557383, 0.2621300427373734, 0.23298934091955248, 0.21954433133284623, 0.18892590204233284, 0.24056676947603617, 0.18638116506123759, 0.235898985844732, 0.21507747131979138, 0.20438184779644852, 0.21826006217416782, 0.21226801066861434, 0.2552119752994919, 0.2548897498259465, 0.22662058174688904, 0.21513394564797939, 0.20298674104941872, 0.22991315547777436, 0.19293900784661921, 0.19459014054689416, 0.953056488226355, 0.16259895904930177, 0.16412282685175794, 0.17263250329266178, 0.17806679894566202, 0.944995272340463, 0.9271011440960113, 0.16830703370292577, 0.16800303266131045, 0.6919314586341718, 0.2141447781836796, 0.7782212254456594, 0.2130047915049147, 0.16756197130134298, 0.21362239066798738, 0.45376501089768084, 0.16810943777555332, 0.15476268047597408, 0.1774725019025396, 0.18828042481605567, 0.18429571526552935, 0.19146690120757504, 0.18038833155008283, 0.18021702077656176, 0.18407861658353175, 0.17896154594933833, 0.17710448703814452, 0.16783883948887246, 0.11001415823647953, 0.09467597551583862, 0.10719603052269977, 0.09250006255767862, 0.0847994748423514, 0.09002164698346737, 0.08724070850157406, 0.0893040075869842]}, "mutation_prompt": null}
{"id": "9e57d11b-ce97-4b86-a3a6-b5853cb6c052", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            dynamic_mutation_factor = 0.5 + 0.3 * (self.budget - self.evaluations) / self.budget  # Dynamic mutation\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Integrate a dynamic mutation factor to enhance exploration during the early stages and intensification later.", "configspace": "", "generation": 38, "fitness": 0.3755276436732065, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9526301467350731, 0.942517815304579, 0.9482743226726881, 0.953540512712535, 0.9451035067638526, 0.945866773489169, 0.9513003051470764, 0.8941761975658719, 0.9454780983584631, 0.9082667270908028, 0.911816577077468, 0.9026956104557611, 0.909119029913467, 0.8616236442819665, 0.9046556778425141, 0.9140113544251789, 0.9008177769296435, 0.908561181092903, 0.15733305956173482, 0.16335365694777393, 0.16116628881429917, 0.12706107290590485, 0.15938255338303187, 0.14446725813798655, 0.19137447581224565, 0.13266976328905233, 0.18599631060515565, 0.14497215663423446, 0.11800663041801596, 0.10637093889969951, 0.18272726025707087, 0.11110988942498101, 0.09674892647742594, 0.13413603353939707, 0.14499144489484572, 0.1251470384905028, 0.9572994874868432, 0.9847249191051097, 0.9659484499252505, 0.9702167446510019, 0.9676213323148068, 0.987918634251662, 0.9708703139292146, 0.9699069355212, 0.9593978770552904, 0.8097335280220456, 0.834135917623633, 0.8256380138704669, 0.8186017087293613, 0.8510114395203302, 0.6000407950132729, 0.860339406365068, 0.8145489257032352, 0.785931109372777, 0.8952412129252988, 0.9311858272375964, 0.39621324761949395, 0.27989749402623965, 0.28242474443739907, 0.3784245314872394, 0.3206841205474218, 0.17800402364698298, 0.8668203491963149, 0.23702828066180814, 0.18486597872344235, 0.19979156406972898, 0.2005719853378407, 0.135922310694103, 0.1780090382758588, 0.18222947591389582, 0.17914763258807798, 0.21074231980036384, 0.16447986452555796, 0.20377370821613283, 0.13583779553568454, 0.13473524256416458, 0.23802337296734455, 0.20392817624937298, 0.1611295521124393, 0.10397405592649611, 0.2609391653484423, 0.13772057754848643, 0.06347818370730984, 0.06708372359708159, 0.1803947768413513, 0.010831081003746634, 0.015099881393970671, 0.15659637585685504, 9.999999999998899e-05, 0.08652658208611286, 0.044406886962675474, 0.13906922651660258, 0.12527306789975823, 0.0994366433931293, 0.16131061307243122, 0.11617101850738587, 0.15756298020019854, 0.2245788136857786, 0.1117969849105317, 0.12482913634017534, 0.1359705832833541, 0.24402692433093232, 0.10957917884404089, 0.0880538952212293, 0.11384374698116351, 0.12761033191430726, 9.999999999998899e-05, 0.0941121953318741, 0.21738038842863894, 0.14221197872100844, 0.2316333493280912, 0.246932120098298, 0.3403959751617929, 0.3392987845769576, 0.23571727716303748, 0.09345006409751166, 0.10350265324440677, 0.6208395933738478, 0.6939569512517103, 0.5365034779875347, 0.6210843920734664, 0.6105296792181246, 0.6893266017070838, 0.6486885304735541, 0.6243383755873239, 0.5900601134756236, 0.1709892139968643, 0.12290723589504615, 0.15258324614529117, 0.11668437108799057, 0.11397264779488336, 0.10427857162019194, 0.1203620185690637, 0.1137258054705933, 0.16194013519049, 0.269234912511888, 0.2339467760047088, 0.3640259804350353, 0.24540792003154444, 0.2310626674364219, 0.2057974105089555, 0.19200189163245818, 0.315108626108378, 0.1693818502808756, 0.5506821529593056, 0.49799422345822775, 0.5051358278152556, 0.5302363824396108, 0.4990376225725289, 0.6437923120761703, 0.2815736356276921, 0.6896869308548511, 0.4811473582180229, 0.33134575633980834, 0.28216051695501276, 0.3435608990186727, 0.3885271450948853, 0.2571472826593454, 0.21247818480894098, 0.27914329574493435, 0.43002179401787555, 0.27461011297249216, 0.19888743733789682, 0.22596083477160134, 0.21113985076253639, 0.2039174581778448, 0.24828663835507836, 0.22127601085545245, 0.20861958660219537, 0.21672855992275397, 0.21551571291699534, 0.25177977553742925, 0.787864401670063, 0.20537925284129577, 0.2258776945540989, 0.22132760587716116, 0.8525642046647577, 0.25069757635471634, 0.21149089791012343, 0.21095048360836544, 0.9355966871317446, 0.9341234526544029, 0.18654548940108662, 0.17263627802635984, 0.16538409081661065, 0.9482189090796362, 0.9224836658416758, 0.9109919334810402, 0.16798639563069429, 0.7371828195918638, 0.2135993011937174, 0.9319068131249939, 0.21207522131648204, 0.16732210845679418, 0.2133277716869414, 0.9236427530038787, 0.1686826374613316, 0.15478659545108042, 0.17929295629602016, 0.18391882250256353, 0.1906799746542922, 0.18927833216672219, 0.18611239427600923, 0.18124034403830747, 0.18918189630155946, 0.17727222488157746, 0.17960826795595386, 0.09570340441463088, 0.0944076048782192, 0.08625972240816793, 0.09207235925463664, 0.10353182333131794, 0.102955187181906, 0.09734820412766787, 0.08688436171493463, 0.09497919175694791]}, "mutation_prompt": null}
{"id": "9eb033de-061a-4d94-82a9-ad4d29ed23b5", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (0.6 + 0.4 * (1 - self.evaluations/self.budget))\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a dynamic mutation factor to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 39, "fitness": 0.37705072828250286, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.951673267519929, 0.9401747696472994, 0.9420133069719021, 0.9485659230341522, 0.9466347865316279, 0.9438422863931467, 0.9389667112488177, 0.9027646778172511, 0.9465157367446647, 0.9034750570592885, 0.9109421326398938, 0.8960593540423036, 0.8999138197365737, 0.906949764483701, 0.8960121322136133, 0.9102307862952144, 0.9043200759495933, 0.8968380670134132, 0.15792955835245048, 0.12656708409510697, 0.15934608937053185, 0.1197392989157825, 0.15579567885788415, 0.1446668762741652, 0.18957790734286228, 0.15922044639012456, 0.18641729566443932, 0.11728286664516285, 0.1437380554083757, 0.1416961754031678, 0.13208867966153393, 0.1423520504444481, 0.14347742524124296, 0.09847206561656618, 0.1299495156455962, 0.1342364562252929, 0.9572653588465457, 0.9847247587253594, 0.9667632625760827, 0.9695556118632407, 0.9681762736181326, 0.9879173318134115, 0.9734107171453776, 0.9699000627804899, 0.9594096061839785, 0.8253884991276175, 0.7520720230972109, 0.7794450560651238, 0.8643494332792929, 0.8603798243248723, 0.8367799427167231, 0.7882861552217211, 0.7713434995841725, 0.745741725983791, 0.2559675440919056, 0.9134397039384694, 0.3593068301983827, 0.3408545264597168, 0.2821515889868783, 0.2145393549192406, 0.9185454358075047, 0.23410718591260382, 0.7236527958021375, 0.21536039465662504, 0.18355206483903175, 0.1682663116388583, 0.1813253813972604, 0.13404597092154513, 0.21787142333259002, 0.22252089588501656, 0.18388361933315656, 0.20287125747764034, 0.1990750043737488, 0.1849238163613306, 0.13588094012300667, 0.15638754814756484, 0.24666168025263613, 0.19905597482726567, 0.17337406002300193, 0.10552405338207083, 0.22286848191625452, 0.15824533087119852, 0.1012723719054609, 0.09910580017710657, 0.08129927871944942, 0.001744308259645333, 0.0538128577872069, 0.06882207479947045, 0.07346768744440413, 0.07898517395796867, 0.04023443806358251, 0.18091824705182125, 0.18038634877804505, 0.12534957613885, 0.12964350808109026, 0.07005463541003787, 0.10139735008483453, 0.14776791771159092, 0.17880734954341282, 0.1799718467338406, 0.08488304625103849, 0.2661185209171214, 0.11408954048621289, 0.08730984221026106, 0.10560091258807625, 0.13209162603780222, 9.999999999998899e-05, 0.07731395764998483, 0.31453203980611555, 0.11298181847230426, 0.27010198402049246, 0.28655767633023244, 0.18307733028616513, 0.2841696522520809, 0.3621252085743988, 0.09042550176584663, 0.10820763129037492, 0.5804426932834805, 0.6428315272008169, 0.5496160050776536, 0.5521469053851418, 0.6422581952741842, 0.5646366152428706, 0.651754120743022, 0.6582332015245965, 0.6909162324495486, 0.09952818647176787, 0.1611951082879175, 0.16032382688214042, 0.11077893874009492, 0.6112986662678155, 0.09448312323808716, 0.1314294265050241, 0.13538944539922193, 0.17026300534845973, 0.23952056689448686, 0.2109874501993596, 0.691043011716596, 0.1440370557491979, 0.2079025920439589, 0.19348319480002163, 0.4230228831346372, 0.2902449382625415, 0.2700409257217482, 0.29433821321642284, 0.7922467419084598, 0.5724449775879671, 0.44052763586082677, 0.36521079205142526, 0.4946965370281732, 0.8279608643484658, 0.5986176800985663, 0.4178658237955416, 0.3629061989388359, 0.47917743537863866, 0.28559641141977, 0.3258994921813847, 0.28029157469078414, 0.33293798500939253, 0.44117328624293317, 0.32887882991788897, 0.21951464876824978, 0.21059500777678464, 0.2164072690439094, 0.2318200084997849, 0.1913701578634065, 0.22537488775527548, 0.20710670367777295, 0.20783906760028803, 0.21180145349331359, 0.20619158610667887, 0.2540453263541872, 0.24708241805900533, 0.2106366262056708, 0.20990397108967151, 0.2092326633346242, 0.25466866943221744, 0.8641694161314412, 0.20369726072611805, 0.22547178339587604, 0.9263054240185459, 0.9344140983311838, 0.18649490078982067, 0.1726312276793095, 0.16537634206957152, 0.9518553920382932, 0.9037275580408857, 0.9076918235872382, 0.16798714187528585, 0.6216990827436342, 0.21359867043938274, 0.9386167373192082, 0.21299643066046736, 0.16732195370383307, 0.21332796614040817, 0.9196517624669628, 0.16869349431015268, 0.15479335417950302, 0.18618789668607794, 0.19381353057874984, 0.21561885875034936, 0.1754844460327799, 0.17904921877232738, 0.21504770685228025, 0.18796782609953955, 0.18356499097690138, 0.19452698710163085, 0.0894671143840764, 0.08778733333468614, 0.08979926134366378, 0.1008366541493313, 0.08519247675856823, 0.08726369052892646, 0.09659816309435809, 0.09398516215009944, 0.09173382488520909]}, "mutation_prompt": null}
{"id": "9aad3cb3-c1fc-49cb-907c-2c569f07e6d0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "ca8d7cbd-4bdc-4735-ac47-e9d171f85ae4", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using comparison-based selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance selection strategy by replacing tournament selection with a more robust comparison-based selection mechanism.", "configspace": "", "generation": 41, "fitness": 0.36464339091583786, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9503559948304945, 0.9468407107717999, 0.9496855496316617, 0.9410983522826362, 0.9438724770737996, 0.9494264165080041, 0.9459443819762333, 0.93962975156221, 0.953311556836096, 0.9199206637608409, 0.9044974842441414, 0.9023902086392348, 0.9154690645502286, 0.9131855731027366, 0.915138833933037, 0.9121110384141176, 0.9145795919626195, 0.9053534354630274, 0.18840805185461673, 0.09628890281192581, 0.805978716362806, 0.1555930527661421, 0.1626315623770881, 0.17936781371545063, 0.17993363960710596, 0.13464754377089083, 0.17857402427178182, 0.14617214191168204, 0.14117289581621806, 0.11808977064958015, 0.13288044440892133, 0.1565637570308911, 0.14646961371243505, 0.10545543703631788, 0.15998879977932678, 0.11740032537053335, 0.9476507910839892, 0.9451602195872487, 0.9278389361883366, 0.9549302889131113, 0.9840746735315199, 0.9608285088690922, 0.9803155170809191, 0.9676925989770783, 0.9592083298696008, 0.7946662806843148, 0.8122935909971852, 0.845037105675337, 0.8448798842052361, 0.8532893737096939, 0.8532382912087121, 0.6426268051687005, 0.8058782385890619, 0.7520751481071662, 0.23077500428429698, 0.38794984998050386, 0.22866998167276464, 0.3883344525190756, 0.938086448612405, 0.941272629623011, 0.23733574474573793, 0.949603516777886, 0.40836600599777917, 0.20147314615135692, 0.16557606396242242, 0.16381413072435935, 0.1704823407678837, 0.20362753455197513, 0.16946770303576109, 0.19401339410261875, 0.17620387132544524, 0.15506141705983978, 0.1794977972178895, 0.24226942825547615, 0.20478913070266225, 0.21458522762038346, 0.18686002949169056, 0.160755197798215, 0.13966634936369737, 0.16503877899199326, 0.24671698500102113, 0.21683462805515075, 0.0969848613459321, 0.11254038911445219, 0.09137050995406226, 0.021228139138686264, 0.09351838406338464, 0.0006686760150612647, 0.05735115261927637, 0.08907996888954639, 0.1244513122739731, 0.10784046228958999, 0.19889716409424418, 0.1124446720654605, 0.05032890650612387, 0.05964884253686664, 0.17307447306942414, 0.16186779255227413, 0.18067991708880804, 0.03982138593000395, 0.056687529793885916, 0.1729463959479659, 0.08527256802585814, 0.13246947148505261, 0.15257644053778807, 0.07868721304678417, 0.14288715224670434, 0.23740477661615578, 0.140615354455486, 0.0998518901291312, 0.11582576518419141, 0.11934399922192662, 0.24316246082452986, 0.1488819832714947, 0.12760715282540935, 0.09038243154693315, 0.10296488530742431, 0.6645569814072148, 0.6887613441822183, 0.6868686315901722, 0.6927796166404572, 0.6507105843898964, 0.6145768393746394, 0.6607724598456045, 0.6465248366135412, 0.649117139556218, 0.112668372782193, 0.15127396987053365, 0.1478619039964788, 0.14974666603042774, 0.12168299659651405, 0.14833155203959492, 0.13430935328098437, 0.14104523309670114, 0.17416397632718017, 0.17744148188553188, 0.23098395489209755, 0.15454163200156434, 0.1786578040867124, 0.13177551478228544, 0.5230481821062241, 0.4319524324358073, 0.19643265250848463, 0.32029941516042226, 0.6689936578377832, 0.3530457764916065, 0.5223469022293539, 0.6741582166906921, 0.5456734578933115, 0.6213245524996852, 0.6433550130821023, 0.5263627295989656, 0.6868512067390016, 0.28417675253781305, 0.34203779128612277, 0.7682252680198375, 0.32364559354981515, 0.42972386633480864, 0.40157818497031017, 0.37176937686428924, 0.3244737062370264, 0.2903672094432098, 0.20477662499414218, 0.21788501524882364, 0.20505088874406507, 0.24517998573700783, 0.21315663993588763, 0.22776263869982827, 0.21093440122585427, 0.2218762890602175, 0.2317139629873357, 0.22743843950421638, 0.22254234049536126, 0.1964650380070534, 0.2252319651281296, 0.22730079942498682, 0.22627692154306256, 0.22435316411130035, 0.2505271230902174, 0.22648818844142393, 0.19996249981773984, 0.18584130788230158, 0.2013455949163504, 0.13131261978670916, 0.2000400282909116, 0.1687033784220472, 0.21241862355990604, 0.8877332986834653, 0.1673177781751125, 0.5414715425057735, 0.8704034619638308, 0.12832089887182696, 0.21188813713712285, 0.16880946145954534, 0.21229244136119174, 0.16826641504843687, 0.9314231600004409, 0.1561953983890182, 0.1974040485426679, 0.18170986790292376, 0.19279350333757983, 0.18356519712506547, 0.1811802748838902, 0.18787535060700633, 0.18645506509104892, 0.18218293049805356, 0.17743697648667445, 0.09753270227083777, 0.09311642615207216, 0.08660389893545739, 0.09466407563937851, 0.0837678307254619, 0.1148522025650256, 0.09480686412401607, 0.09130506022284046, 0.08141547062477239]}, "mutation_prompt": null}
{"id": "3d99a339-e2c2-4286-b199-c38f89c98ad0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamic mutation factor based on evaluations\n                dynamic_mutation_factor = 0.5 + 0.3 * (1 - self.evaluations/self.budget)\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search with dynamic size\n                dynamic_neighborhood_size = max(3, int(self.neighborhood_size * (1 - self.evaluations/self.budget)))\n                neighbors_idx = np.random.choice(self.population_size, dynamic_neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduced dynamic mutation factor and adaptive neighborhood size to balance exploration and exploitation.", "configspace": "", "generation": 42, "fitness": 0.37890266617573215, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9491439815860648, 0.9457359512347904, 0.9383914366003443, 0.9464402592331607, 0.9418219496931118, 0.9424735966332642, 0.9443969771482603, 0.9312593456710527, 0.9411789629327567, 0.8878064674848803, 0.8982943917296822, 0.8892140041504197, 0.8953997875178344, 0.9095003877275079, 0.8900252031188957, 0.904958708582507, 0.8843771422146727, 0.9027923919995504, 0.8706574589231317, 0.16271344569540558, 0.14670594751953536, 0.1588856943842607, 0.17759405175364795, 0.1841145692962205, 0.15931169435548231, 0.14384468305139986, 0.18758382193271117, 0.15590101236041543, 0.16394430797031112, 0.15581735001861874, 0.12518167058413454, 0.13836776897664427, 0.1414339323539261, 0.15751772997476077, 0.13001742325321997, 0.12470520846396871, 0.9602373925796015, 0.9759377586721742, 0.9702651995816126, 0.9788082959204377, 0.9715457593436555, 0.9786455588169428, 0.9690936559641472, 0.9802111473521697, 0.9758610425506951, 0.7274268153783359, 0.6332977588047859, 0.8532295400702783, 0.6405882903677089, 0.8275562204660675, 0.8409739740506944, 0.6063313992792323, 0.5824787788395653, 0.796898371449734, 0.9203678958290354, 0.8992404793539961, 0.23048807461657084, 0.28106626110628696, 0.38442596019360065, 0.3719993340960821, 0.23647303500821315, 0.3631230067828286, 0.8722347194591378, 0.23835429520995166, 0.13382679188436575, 0.17741642832143456, 0.13462346705686667, 0.13580554285250945, 0.17740026250292207, 0.1731152775553101, 0.2016650531941545, 0.1828035726985382, 0.15591240271805784, 0.20441063763184486, 0.13370368163763147, 0.2129682565616715, 0.15709412042796755, 0.22197249349314552, 0.29898078373836945, 0.15835097562733969, 0.22622132790068394, 0.08351222120006585, 0.08635346668778543, 0.08843572474032313, 0.06699267913064955, 0.1749515861902159, 0.03937232537658364, 0.007086745857769361, 0.07599112007916409, 9.999999999998899e-05, 0.15276268964353434, 0.11368750879077694, 0.16148047965200607, 0.09143794699540342, 0.14848522606383763, 0.04150941005739461, 0.20417209327983188, 0.0727674646284251, 0.21204044746961548, 0.08794638375317498, 0.08206511055953747, 0.11828922954063237, 0.197202320349112, 0.0881483299221496, 0.19156010835013637, 0.19564573076244385, 0.15037528568141112, 0.1066770493771535, 0.08826058475870446, 0.2927490256528066, 0.0950272477271148, 0.2311239318018422, 0.12459989806125904, 0.09232177394640784, 0.29842828002442856, 0.07608108929923052, 0.12020219823513056, 0.5481045205541332, 0.5690724544589316, 0.5444511658670323, 0.5399321801317777, 0.6482134511487878, 0.672119972632734, 0.6937610509423011, 0.696270307187699, 0.6734471030088494, 0.11804665484967447, 0.11247213139140877, 0.14730835109013385, 0.13515064574587865, 0.09511539021761961, 0.11683170292868994, 0.14834589724520153, 0.10101870204511965, 0.14476560608554134, 0.3179704549759985, 0.19972979294683868, 0.2739696846914741, 0.259799165654761, 0.1797567764952639, 0.19791940427571075, 0.1850314050620353, 0.14313184206548935, 0.13689797593934094, 0.6136221991608242, 0.3376287511254408, 0.6332688506775205, 0.5174609101535375, 0.3818244123144324, 0.3322016022519788, 0.5686807234002362, 0.5950852035801446, 0.6123400758254158, 0.43146875611871527, 0.3485026024837806, 0.35025273203544716, 0.2585197545588721, 0.4414467347843104, 0.3858851205220617, 0.27056968046896035, 0.4896138639727856, 0.4925185409399, 0.2174017353599914, 0.2191384603366341, 0.19575763186751827, 0.25360241487888047, 0.2260529533642439, 0.20709207933611629, 0.2389763835980533, 0.21771878351879614, 0.20779445344926073, 0.8769536888797368, 0.8989302647418345, 0.2541768464315417, 0.2110453754996694, 0.8787290331959547, 0.8859690684913423, 0.21048720904894502, 0.23139525480026446, 0.1991260002282783, 0.16525643309522586, 0.8730719012644179, 0.18741065571551485, 0.9352004145060173, 0.19923779928338536, 0.9496198331713454, 0.9155493113672926, 0.1618545408384996, 0.9366874752275073, 0.5738635956533271, 0.16971246010509677, 0.8912287417452087, 0.2126661993812592, 0.6798109502956624, 0.21318835666072244, 0.11164370834073911, 0.16739378202599087, 0.11261168573659974, 0.17851237829673905, 0.19528302805337638, 0.17371217591510724, 0.20127000468322842, 0.1877245186378319, 0.19069551682471242, 0.17911150826870348, 0.17187428907318825, 0.18494206440333238, 0.08873316966609457, 0.08967089798011041, 0.08019533204995155, 0.08227233839800951, 0.09660057819636692, 0.0873296814023834, 0.09099996871867211, 0.08958350054843522, 0.0898026306692733]}, "mutation_prompt": null}
{"id": "c9b147a7-6f10-4e50-9551-259dceda5e6a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9  # Line to be changed\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                self.crossover_probability = 0.7 + 0.2 * (self.fitness[i] / np.max(self.fitness))  # Line to be changed\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a dynamic crossover probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.37170181930594104, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.32.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941930711444003, 0.9412574498212204, 0.9426764042820126, 0.948256173086896, 0.9454588690584186, 0.9400759728714361, 0.9341818007502314, 0.9485947354849892, 0.9313687959941725, 0.905805865554067, 0.8920175501111961, 0.9032588167097915, 0.9032327676707629, 0.872249121665525, 0.9044858400923419, 0.9162986397445273, 0.9180232072602517, 0.9035183891786056, 0.1862675018288995, 0.18458243592815848, 0.1821819680798109, 0.18224916684343406, 0.14549882581468532, 0.1797687033340084, 0.13569622340923093, 0.14375327934817395, 0.1903133194825335, 0.13447067386629352, 0.11711070078516495, 0.15280553213480486, 0.10162993095672213, 0.0964569023236771, 0.1597382385045939, 0.15980124612027014, 0.10631552549659395, 0.1114899457241818, 0.9559044930722108, 0.9554862765808746, 0.9565801062093839, 0.9837222320240567, 0.9755640271537467, 0.9873146369973566, 0.9658947585656463, 0.9845701175772615, 0.9806094536997487, 0.8349478696466709, 0.8044948277089887, 0.8443146855838672, 0.8092925752429856, 0.8013290718203829, 0.8652322011414393, 0.8273758285813998, 0.7261271864700674, 0.8548065104988284, 0.8861694940186491, 0.22991049079995896, 0.9053603191274551, 0.21462393058928497, 0.1945483792589966, 0.21474284129883103, 0.1792452199105935, 0.17854722104201426, 0.9267087939315461, 0.24043963479774366, 0.22302675757624857, 0.2685478674401559, 0.2523059231089343, 0.23683365908422704, 0.12777965551724813, 0.2098506016680347, 0.22573262708643582, 0.1365775377953221, 0.23729039520077955, 0.2528703812885471, 0.25014408620833806, 0.26762615724066996, 0.2605824285043511, 0.24230156752393828, 0.13379807290218815, 0.2504512017123993, 0.1908477321958708, 0.07466234626193913, 0.05690453356688796, 0.08608362797106606, 0.043467083939543905, 0.09736056080599087, 0.06349116509789088, 0.11041293024951393, 0.025591403635455978, 0.07971556066202923, 0.10693207888139789, 0.11726463880017546, 0.14036701774674765, 0.12263194324530013, 0.10008199246501281, 0.06668236244884151, 0.1390135774855904, 0.07597626903833354, 0.07803859864391305, 0.08188108609431943, 0.04006378074408656, 0.0795657810008008, 0.15156638774997577, 0.11960106482246824, 0.13516575686158427, 0.2262676753541708, 0.10731079820323008, 0.0927858613384116, 0.13820644991339448, 0.15682038831011358, 0.19506989607614367, 0.12508730493075604, 0.1960919556145584, 0.16357984098313905, 0.17547772097686976, 0.3669254545057591, 0.14138739768213837, 0.6347115729004366, 0.6123479280770185, 0.6783459869369528, 0.6484321937576535, 0.6576527632269511, 0.6756421119592424, 0.6713210570043633, 0.6545678498936192, 0.7274595381354758, 0.1022966852475693, 0.13882210571791342, 0.14819634619106492, 0.14332337164113074, 0.10061373382031158, 0.15679047989367578, 0.11316243331762577, 0.07800299198208016, 0.0980612227575508, 0.23361956303555076, 0.21122089994412585, 0.21706902656926408, 0.3192346092049745, 0.22929388265048656, 0.16525209104295768, 0.26126533858261936, 0.26012978130995745, 0.4643726641530449, 0.33078595153856993, 0.843067330647515, 0.6102331897847206, 0.35134826277818243, 0.680025873297952, 0.7551936444143501, 0.6774389036051811, 0.565269069386305, 0.8196018726975702, 0.1328414823980456, 0.2782286329349599, 0.1490780560894437, 0.3916136388475012, 0.3119880283395713, 0.32849135761006043, 0.28063044468098075, 0.4471707659755426, 0.21773234775556427, 0.21675591869410493, 0.21473667531973284, 0.18667047441305895, 0.19094106786880582, 0.2021513578666544, 0.21435796990844225, 0.20444029533778252, 0.20439146425724652, 0.2121130504094072, 0.22759222198259366, 0.2516752831220763, 0.22863943169106937, 0.22523823103922436, 0.21268693549203221, 0.23027458125633427, 0.2272964819318355, 0.8500935863234614, 0.18939936143221636, 0.200592229097036, 0.16545394865464547, 0.18662471094158894, 0.9281794887553051, 0.20054817264745073, 0.9186183268202972, 0.9385278090510945, 0.1681473359991411, 0.16739216924408462, 0.7926133545477945, 0.21340518746235182, 0.9120456894082227, 0.21336002791658326, 0.16823876546125816, 0.21334007430956947, 0.11333475091696532, 0.7650947593895187, 0.8658496434036653, 0.1861742796671978, 0.19027271427437809, 0.18284214584486247, 0.19211043623695678, 0.18109497459885537, 0.19129148788360562, 0.1941663098737667, 0.17991029418029303, 0.19375172694276677, 0.08933963845754767, 0.08389486520925005, 0.09327427047009984, 0.08776930518610748, 0.10061129219236586, 0.08810128862513589, 0.08555949351333403, 0.07702855220954719, 0.10684862233600267]}, "mutation_prompt": null}
{"id": "9ec86dfe-29e5-4c62-8a21-632581ddecce", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                # Adjust mutation factor dynamically\n                self.mutation_factor = 0.5 + 0.5 * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce dynamic mutation factor adjustment based on evaluation progress to enhance convergence precision.", "configspace": "", "generation": 44, "fitness": 0.37969008186022934, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9301422910074758, 0.9249667608462705, 0.9259920584474899, 0.9396594204768347, 0.9386463223311443, 0.9208149665611776, 0.9316630088288814, 0.9058658721192767, 0.9330159523823367, 0.8739554870310249, 0.8925809912539588, 0.8829942385843004, 0.8631832293807497, 0.8864045120825791, 0.8808650085880237, 0.8869040337352475, 0.8869242468676329, 0.8900805088299447, 0.18156178252159527, 0.15446561089323096, 0.16104618097433943, 0.7730430883750394, 0.15458405616116067, 0.18206663429244996, 0.1256460852420871, 0.15677732541990375, 0.1780984876053222, 0.1435421752713324, 0.14450170639961202, 0.17580183717027298, 0.1152002273931454, 0.139442688193401, 0.12325463016354354, 0.11648924356244039, 0.15660908463268675, 0.14296698792812568, 0.9859613335244518, 0.9835150893231382, 0.9722005512530907, 0.9678815385675474, 0.9791256139832751, 0.9895801277722382, 0.98299159213114, 0.9882218079645436, 0.9756297683600609, 0.8076712932949002, 0.7988472631602644, 0.7860315293085189, 0.8071546628455453, 0.8594831719244997, 0.7954423179679282, 0.8100808732280848, 0.8133527899354892, 0.7983554492230944, 0.884521985980655, 0.7456756848066264, 0.8996940868711509, 0.21325997065363422, 0.27626907007692647, 0.8822033400814238, 0.9163177870851115, 0.2445832636389237, 0.9218541376456103, 0.2997046970358741, 0.2200801471004794, 0.2212592295782818, 0.23996934888911758, 0.13532402655969, 0.24379126452043764, 0.25807536387062824, 0.23113473978866927, 0.3308398750965561, 0.13476372340750875, 0.26322692660218194, 0.23755470558400815, 0.2742518437654682, 0.34042755716721995, 0.25396796623270257, 0.29453190725141554, 0.24539692585766337, 0.28670171409622025, 0.05553911338535822, 0.029378516529484644, 0.04603510053934423, 0.06831768531386229, 0.10189020065905241, 0.07655149368944625, 0.009795943580149125, 0.007297431628132789, 0.116218535295748, 0.12742118271617275, 0.14343654408557327, 0.13880604106966277, 0.032652762462054286, 0.11224919649994158, 0.12230806942540384, 0.13088407639731703, 0.05381846116696176, 0.16702853965667996, 0.14775644647367792, 0.09630505464703343, 0.09546777568976073, 0.08575056588733354, 0.10224287789454378, 0.08620201273939743, 0.13313458043557624, 0.10720128217781788, 0.1221868131724555, 0.19404522775708655, 0.26376261884605035, 0.141352062652206, 0.10340001679013078, 0.18598933063024892, 0.2618748023390003, 0.18450206816024795, 0.06190074346548913, 0.13286125848295283, 0.6292719836152185, 0.6619245348011535, 0.6457528483810151, 0.6587109137011131, 0.653223311670171, 0.6876145144447139, 0.675370676415716, 0.669107170925658, 0.6506609039197305, 0.5132125175909203, 0.1435372466076137, 0.12881864248938857, 0.16174033935953924, 0.13604169191919024, 0.11763995035918762, 0.15000146684895388, 0.11173665221607698, 0.13592904617274582, 0.14773496078561488, 0.20601736106849478, 0.24110378960671752, 0.2521618117977379, 0.14332089464807884, 0.19232000857498166, 0.18195112564895832, 0.1555440386318978, 0.21971714853506785, 0.6361148442848545, 0.26013050004544525, 0.7802858027300644, 0.35614901706818014, 0.4098005215821994, 0.43534839537471937, 0.759875700331728, 0.38038088674844595, 0.6195438598056141, 0.40365580421564207, 0.3727754375539487, 0.5519759663503971, 0.2917736555938498, 0.3890224528866407, 0.5294161864164999, 0.5165225707614239, 0.4168231064119976, 0.563794175018061, 0.2156624234765543, 0.21311894508770346, 0.19857733813143308, 0.20196368497704553, 0.19582231878716427, 0.2317540892771882, 0.2146834953199277, 0.21354717909572718, 0.20724450367653036, 0.22773449756475106, 0.24965903408147105, 0.24945167042634908, 0.2106515066564667, 0.22500325283446276, 0.857720791665699, 0.20354186669020935, 0.222906464021424, 0.2401805505535367, 0.9287501591038659, 0.18740786465250348, 0.16120206621637168, 0.9520359430890128, 0.910952709192066, 0.18629598836147132, 0.1637680602337045, 0.16679130900113814, 0.16542676617731122, 0.15611352369033427, 0.2136270533666461, 0.9039631246263318, 0.8600254423381538, 0.21261921411076812, 0.1691476858187032, 0.11308392664378175, 0.1281200807954156, 0.2119212046158322, 0.1803933629149418, 0.18871747344641276, 0.1829727794664775, 0.19338816087749378, 0.17889540769349555, 0.17987278083502423, 0.18068761855844384, 0.19333898357004298, 0.18498572242708056, 0.08930675915990072, 0.07731713561543752, 0.08421222441938914, 0.08569493760949376, 0.08615655495357655, 0.09016593614718471, 0.08929662338459876, 0.09049667123813865, 0.08089914431259682]}, "mutation_prompt": null}
{"id": "a5baf2d6-a6ae-4c5d-92f0-aefe9f4b9143", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "dba3fd0c-ab4b-4f02-a0f9-13a8a807db8b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.5 * (1 - self.evaluations / self.budget) # Dynamic mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance the exploration by updating the mutation factor dynamically based on the function evaluations.", "configspace": "", "generation": 46, "fitness": 0.37969008186022934, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9301422910074758, 0.9249667608462705, 0.9259920584474899, 0.9396594204768347, 0.9386463223311443, 0.9208149665611776, 0.9316630088288814, 0.9058658721192767, 0.9330159523823367, 0.8739554870310249, 0.8925809912539588, 0.8829942385843004, 0.8631832293807497, 0.8864045120825791, 0.8808650085880237, 0.8869040337352475, 0.8869242468676329, 0.8900805088299447, 0.18156178252159527, 0.15446561089323096, 0.16104618097433943, 0.7730430883750394, 0.15458405616116067, 0.18206663429244996, 0.1256460852420871, 0.15677732541990375, 0.1780984876053222, 0.1435421752713324, 0.14450170639961202, 0.17580183717027298, 0.1152002273931454, 0.139442688193401, 0.12325463016354354, 0.11648924356244039, 0.15660908463268675, 0.14296698792812568, 0.9859613335244518, 0.9835150893231382, 0.9722005512530907, 0.9678815385675474, 0.9791256139832751, 0.9895801277722382, 0.98299159213114, 0.9882218079645436, 0.9756297683600609, 0.8076712932949002, 0.7988472631602644, 0.7860315293085189, 0.8071546628455453, 0.8594831719244997, 0.7954423179679282, 0.8100808732280848, 0.8133527899354892, 0.7983554492230944, 0.884521985980655, 0.7456756848066264, 0.8996940868711509, 0.21325997065363422, 0.27626907007692647, 0.8822033400814238, 0.9163177870851115, 0.2445832636389237, 0.9218541376456103, 0.2997046970358741, 0.2200801471004794, 0.2212592295782818, 0.23996934888911758, 0.13532402655969, 0.24379126452043764, 0.25807536387062824, 0.23113473978866927, 0.3308398750965561, 0.13476372340750875, 0.26322692660218194, 0.23755470558400815, 0.2742518437654682, 0.34042755716721995, 0.25396796623270257, 0.29453190725141554, 0.24539692585766337, 0.28670171409622025, 0.05553911338535822, 0.029378516529484644, 0.04603510053934423, 0.06831768531386229, 0.10189020065905241, 0.07655149368944625, 0.009795943580149125, 0.007297431628132789, 0.116218535295748, 0.12742118271617275, 0.14343654408557327, 0.13880604106966277, 0.032652762462054286, 0.11224919649994158, 0.12230806942540384, 0.13088407639731703, 0.05381846116696176, 0.16702853965667996, 0.14775644647367792, 0.09630505464703343, 0.09546777568976073, 0.08575056588733354, 0.10224287789454378, 0.08620201273939743, 0.13313458043557624, 0.10720128217781788, 0.1221868131724555, 0.19404522775708655, 0.26376261884605035, 0.141352062652206, 0.10340001679013078, 0.18598933063024892, 0.2618748023390003, 0.18450206816024795, 0.06190074346548913, 0.13286125848295283, 0.6292719836152185, 0.6619245348011535, 0.6457528483810151, 0.6587109137011131, 0.653223311670171, 0.6876145144447139, 0.675370676415716, 0.669107170925658, 0.6506609039197305, 0.5132125175909203, 0.1435372466076137, 0.12881864248938857, 0.16174033935953924, 0.13604169191919024, 0.11763995035918762, 0.15000146684895388, 0.11173665221607698, 0.13592904617274582, 0.14773496078561488, 0.20601736106849478, 0.24110378960671752, 0.2521618117977379, 0.14332089464807884, 0.19232000857498166, 0.18195112564895832, 0.1555440386318978, 0.21971714853506785, 0.6361148442848545, 0.26013050004544525, 0.7802858027300644, 0.35614901706818014, 0.4098005215821994, 0.43534839537471937, 0.759875700331728, 0.38038088674844595, 0.6195438598056141, 0.40365580421564207, 0.3727754375539487, 0.5519759663503971, 0.2917736555938498, 0.3890224528866407, 0.5294161864164999, 0.5165225707614239, 0.4168231064119976, 0.563794175018061, 0.2156624234765543, 0.21311894508770346, 0.19857733813143308, 0.20196368497704553, 0.19582231878716427, 0.2317540892771882, 0.2146834953199277, 0.21354717909572718, 0.20724450367653036, 0.22773449756475106, 0.24965903408147105, 0.24945167042634908, 0.2106515066564667, 0.22500325283446276, 0.857720791665699, 0.20354186669020935, 0.222906464021424, 0.2401805505535367, 0.9287501591038659, 0.18740786465250348, 0.16120206621637168, 0.9520359430890128, 0.910952709192066, 0.18629598836147132, 0.1637680602337045, 0.16679130900113814, 0.16542676617731122, 0.15611352369033427, 0.2136270533666461, 0.9039631246263318, 0.8600254423381538, 0.21261921411076812, 0.1691476858187032, 0.11308392664378175, 0.1281200807954156, 0.2119212046158322, 0.1803933629149418, 0.18871747344641276, 0.1829727794664775, 0.19338816087749378, 0.17889540769349555, 0.17987278083502423, 0.18068761855844384, 0.19333898357004298, 0.18498572242708056, 0.08930675915990072, 0.07731713561543752, 0.08421222441938914, 0.08569493760949376, 0.08615655495357655, 0.09016593614718471, 0.08929662338459876, 0.09049667123813865, 0.08089914431259682]}, "mutation_prompt": null}
{"id": "cb0f0ecf-8ed9-4b75-a1fc-a9e122382a71", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "45ce746b-1f8d-425c-b7de-48297ee6d1e7", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Randomly reset the worst individual to improve diversity\n            worst_idx = np.argmax(self.fitness)  # Change: identify and reset the worst individual\n            self.population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.fitness[worst_idx] = func(self.population[worst_idx])\n            self.evaluations += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance population diversity by implementing a random reset of the individual with the worst fitness.", "configspace": "", "generation": 48, "fitness": 0.3754910141906208, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.940791360427057, 0.9250490592647714, 0.9334810227446232, 0.9448210593443347, 0.9337972157099993, 0.9348132470162723, 0.9412945472038772, 0.9403221544001357, 0.9339587043553731, 0.90186243991794, 0.886548021106605, 0.899648116713013, 0.9003304258972407, 0.9065791453534938, 0.877956042017612, 0.895807882886362, 0.903672947507302, 0.8799299964035625, 0.1871861930745371, 0.4194559005902956, 0.18137387544736883, 0.16193640946547516, 0.15708853461561556, 0.1442101872509396, 0.182464601887538, 0.14968304569080793, 0.17252984187138187, 0.11712053937307387, 0.1079728879821481, 0.1400686339132159, 0.13699370237790065, 0.127176222109894, 0.15641141665071867, 0.14185002649885337, 0.11646839773971074, 0.14599469766687667, 0.9889425678243825, 0.977247893321097, 0.9802059022957563, 0.9685256378334539, 0.9770548405387175, 0.9868701478557328, 0.9818387854963723, 0.9604953387943104, 0.9627860652520601, 0.8504926608739194, 0.8319658966947772, 0.7459888096693439, 0.83155282342733, 0.7923098308220166, 0.7966118618765894, 0.7999401737641704, 0.8224156909465009, 0.8236870182500731, 0.3936783258211912, 0.3469801268525805, 0.8937260705720543, 0.28130045527239944, 0.2814718225556343, 0.9194050827490801, 0.1793439256971071, 0.4033434231523464, 0.9335867161725534, 0.22561848618856706, 0.17656303646023297, 0.19610190980859488, 0.19199315123020722, 0.2137812478577248, 0.18868975554754064, 0.20429602799256352, 0.21917349146614984, 0.18988302284435354, 0.20579904899061152, 0.2392654935428764, 0.1867673263891777, 0.19283547113162047, 0.20030979737049304, 0.27210435160126933, 0.2653721987304861, 0.2890195437150158, 0.22532161888441027, 0.1533233330334095, 0.005536259137695065, 0.10072142241291582, 0.07160182347727118, 0.1299162592150669, 0.00011630372695503599, 0.18147756002871507, 0.08781027050163726, 0.16570095194226175, 0.13691423262113678, 0.14494379927075374, 0.1520333441630728, 0.115221720550292, 0.12042871405302102, 0.06748405268512758, 0.17759378812636717, 0.14304945604050667, 0.08672502897901391, 0.16608366947282138, 0.2581349671061792, 0.14446847158825782, 0.15448025965376455, 0.13185043113437567, 0.08612296435554823, 0.11014745946311699, 0.0794417060204391, 0.24359139944992136, 0.24316355393702493, 0.1749910801741431, 0.1072608554796185, 0.14222610755139176, 0.07462178409815279, 0.1374116016415322, 0.15303862410053803, 0.08938991674253216, 0.10054524070252668, 0.6318912444671083, 0.657084166537695, 0.6823274832457971, 0.6565840506526903, 0.627836585930436, 0.6289492319594567, 0.6388692843868146, 0.6075150241191443, 0.661929754891093, 0.12461818432471283, 0.14110494961850817, 0.12214626672159934, 0.12865168789207582, 0.1425304443187022, 0.15017263027863392, 0.09709304947278885, 0.14893012374685333, 0.12651719288336793, 0.22154599688906151, 0.2761410047481331, 0.2599082767190375, 0.14371465481876444, 0.1276029732592615, 0.22711640601878935, 0.18171694644349623, 0.14372079660386838, 0.17843337956011873, 0.46394892349621364, 0.612736321054294, 0.3288058571802096, 0.5148867009322396, 0.5955943132039976, 0.6583410850802358, 0.5715101131484206, 0.5126923479961085, 0.8444863068691254, 0.2730842913042022, 0.38670425017296217, 0.3822308119951633, 0.29675939277395535, 0.23713645890850732, 0.41732195437734954, 0.21053569322937338, 0.5556112418921317, 0.24186931828310065, 0.19539553612248728, 0.2043529672268002, 0.20172475082625219, 0.22011765556543061, 0.20339895581696654, 0.2221446352299008, 0.21546529320044705, 0.22854015394390093, 0.22310177196986547, 0.25223363696198053, 0.22495364320356626, 0.22989703476985568, 0.22573063263487003, 0.20956614511965332, 0.20917442543411402, 0.21706937393421621, 0.8024674966611053, 0.2467483718526935, 0.8827291015827425, 0.1534031184468837, 0.1860980924871768, 0.1997117409940099, 0.5918862572177834, 0.9075639772801967, 0.21654149036908243, 0.9299655297345271, 0.919019502220054, 0.8059624246216105, 0.21322682850841257, 0.9197610775487064, 0.41410057491502306, 0.2689953257582691, 0.21362364226329578, 0.4621471311574482, 0.15430962626008327, 0.16594072066128507, 0.17974072155729914, 0.18752558366427252, 0.18047429564091777, 0.18912501621738576, 0.18309990402791088, 0.18486704528167064, 0.1909617383523894, 0.1822919678969218, 0.17281790578422407, 0.09388169735516516, 0.09081122706990574, 0.08632480864883951, 0.08795946171665259, 0.08559101571610028, 0.09289146374857249, 0.0998241382277314, 0.07955755376413765, 0.1034579163512157]}, "mutation_prompt": null}
{"id": "030e4a56-4307-4eca-9ab3-f55aea91dfbf", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "626967b1-4a3d-4d52-82a3-fcae6944df31", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "ce98a7d9-e85c-4911-aaf6-e41fe7ce0dd3", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation with annealing-inspired adjustment\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce annealing-inspired adaptive mutation to improve exploration and convergence.", "configspace": "", "generation": 51, "fitness": 0.34997169956177815, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9527155602854759, 0.9439213803462676, 0.9444945901653392, 0.939355390395726, 0.9483196623966764, 0.9450321358071692, 0.9485441097236663, 0.9484160520925496, 0.9442202479366673, 0.9085535895834537, 0.9125770019470465, 0.8929334084904651, 0.898795583050605, 0.9091257619316553, 0.9073921634970483, 0.9071864612417356, 0.8992059407596388, 0.8993133788338745, 0.8006786665500941, 0.18720149495996374, 0.1602179603530952, 0.16296069009051084, 0.8375478651896278, 0.1579958980551197, 0.18285282139750847, 0.15757245764191063, 0.18629953861441828, 0.11890771691804025, 0.1065990131157789, 0.15374246238694245, 0.11137239988749392, 0.1191859959060142, 0.1577034468311065, 0.09701365908179505, 0.0851677720143591, 0.09102085673751303, 0.9622506221206691, 0.9847221407423409, 0.9591031423088562, 0.9694923669690657, 0.9589929911645724, 0.987899627026117, 0.9708666912952195, 0.970594428407583, 0.9659168735613727, 0.7974859298841838, 0.44822405229678897, 0.6270253712481942, 0.7599971702834026, 0.6098036247460841, 0.3844970316733346, 0.4574472504733097, 0.618522632753808, 0.5471534711621816, 0.9331965799891371, 0.39182837281599303, 0.39169657980012973, 0.2146864733928091, 0.2144321134322268, 0.28065500186904, 0.4000715551656534, 0.23551087070749765, 0.2463288650979849, 0.16122008325867498, 0.17498497974640048, 0.16990095957099727, 0.17176548450102658, 0.1363663974113819, 0.20753751666807396, 0.1789360565858038, 0.17413900122196047, 0.16802950116085613, 0.15734390733315107, 0.16017255807979514, 0.1290134235047251, 0.13621991621059626, 0.23940165203291364, 0.14555997719611458, 0.10804935221739709, 0.10628966636709503, 0.1774805358656446, 0.21673973295880622, 0.1059531308027244, 0.03964408876922676, 0.053207359499106266, 0.05104903436966757, 0.026594211733239725, 0.06920702567725145, 0.013409782874592158, 0.1370036090497948, 0.03941276356858325, 0.05762972498520791, 0.11389586070938129, 0.08227060683242726, 0.11807486948203438, 0.033806976674911504, 0.22875372993816667, 0.11367879620468102, 0.11363127447388233, 0.2974805513810185, 0.03858633444265491, 0.34026756781798884, 0.11262353231482647, 0.08524586456437233, 0.10363504791816991, 0.10781077236911807, 9.999999999998899e-05, 0.08311875030083316, 0.22588616205787626, 0.07485505173816254, 0.2833357160191383, 0.15734480819422902, 0.14823265677809228, 0.3019649754848881, 0.3347555966453636, 0.08499647285047063, 0.08302669540745733, 0.6815745835152518, 0.5969282065840685, 0.5863802001964409, 0.64434413428288, 0.6183615300734002, 0.6481489870603583, 0.6681962985741368, 0.660952612351608, 0.6520917491480211, 0.13101040704182665, 0.16997489524399512, 0.11592609856378855, 0.1379232204595281, 0.16166547711410695, 0.14245590124179563, 0.14822309738618333, 0.1414531797399584, 0.16752069612206344, 0.2905599742702477, 0.33307234956637344, 0.45559963693511796, 0.21215766014918613, 0.16661328928496644, 0.23969702211482335, 0.250867617142739, 0.2559750652481416, 0.44694785018785876, 0.30022283789463977, 0.6547659166477319, 0.3167299705792197, 0.4582732154750966, 0.557797509968909, 0.4438968424811828, 0.5014189548641144, 0.5307000069137704, 0.8553511029405921, 0.32504689629316685, 0.3379464036471276, 0.29238526923226293, 0.2708959811125313, 0.28785670950688214, 0.36883449928629053, 0.3089881711583997, 0.21739652912557383, 0.2621300427373734, 0.23298934091955248, 0.21954433133284623, 0.18892590204233284, 0.24056676947603617, 0.18638116506123759, 0.235898985844732, 0.21507747131979138, 0.20438184779644852, 0.21826006217416782, 0.21226801066861434, 0.2552119752994919, 0.2548897498259465, 0.22662058174688904, 0.21513394564797939, 0.20298674104941872, 0.22991315547777436, 0.19293900784661921, 0.19459014054689416, 0.953056488226355, 0.16259895904930177, 0.16412282685175794, 0.17263250329266178, 0.17806679894566202, 0.944995272340463, 0.9271011440960113, 0.16830703370292577, 0.16800303266131045, 0.6919314586341718, 0.2141447781836796, 0.7782212254456594, 0.2130047915049147, 0.16756197130134298, 0.21362239066798738, 0.45376501089768084, 0.16810943777555332, 0.15476268047597408, 0.1774725019025396, 0.18828042481605567, 0.18429571526552935, 0.19146690120757504, 0.18038833155008283, 0.18021702077656176, 0.18407861658353175, 0.17896154594933833, 0.17710448703814452, 0.16783883948887246, 0.11001415823647953, 0.09467597551583862, 0.10719603052269977, 0.09250006255767862, 0.0847994748423514, 0.09002164698346737, 0.08724070850157406, 0.0893040075869842]}, "mutation_prompt": null}
{"id": "ccd42777-925d-4526-acf0-c462771f1abc", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Dynamic mutation factor\n                dynamic_mutation_factor = self.mutation_factor * (1 - (self.evaluations / self.budget))\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration by incorporating a dynamic mutation factor that adapts over the evaluation budget.", "configspace": "", "generation": 52, "fitness": 0.34997169956177815, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9527155602854759, 0.9439213803462676, 0.9444945901653392, 0.939355390395726, 0.9483196623966764, 0.9450321358071692, 0.9485441097236663, 0.9484160520925496, 0.9442202479366673, 0.9085535895834537, 0.9125770019470465, 0.8929334084904651, 0.898795583050605, 0.9091257619316553, 0.9073921634970483, 0.9071864612417356, 0.8992059407596388, 0.8993133788338745, 0.8006786665500941, 0.18720149495996374, 0.1602179603530952, 0.16296069009051084, 0.8375478651896278, 0.1579958980551197, 0.18285282139750847, 0.15757245764191063, 0.18629953861441828, 0.11890771691804025, 0.1065990131157789, 0.15374246238694245, 0.11137239988749392, 0.1191859959060142, 0.1577034468311065, 0.09701365908179505, 0.0851677720143591, 0.09102085673751303, 0.9622506221206691, 0.9847221407423409, 0.9591031423088562, 0.9694923669690657, 0.9589929911645724, 0.987899627026117, 0.9708666912952195, 0.970594428407583, 0.9659168735613727, 0.7974859298841838, 0.44822405229678897, 0.6270253712481942, 0.7599971702834026, 0.6098036247460841, 0.3844970316733346, 0.4574472504733097, 0.618522632753808, 0.5471534711621816, 0.9331965799891371, 0.39182837281599303, 0.39169657980012973, 0.2146864733928091, 0.2144321134322268, 0.28065500186904, 0.4000715551656534, 0.23551087070749765, 0.2463288650979849, 0.16122008325867498, 0.17498497974640048, 0.16990095957099727, 0.17176548450102658, 0.1363663974113819, 0.20753751666807396, 0.1789360565858038, 0.17413900122196047, 0.16802950116085613, 0.15734390733315107, 0.16017255807979514, 0.1290134235047251, 0.13621991621059626, 0.23940165203291364, 0.14555997719611458, 0.10804935221739709, 0.10628966636709503, 0.1774805358656446, 0.21673973295880622, 0.1059531308027244, 0.03964408876922676, 0.053207359499106266, 0.05104903436966757, 0.026594211733239725, 0.06920702567725145, 0.013409782874592158, 0.1370036090497948, 0.03941276356858325, 0.05762972498520791, 0.11389586070938129, 0.08227060683242726, 0.11807486948203438, 0.033806976674911504, 0.22875372993816667, 0.11367879620468102, 0.11363127447388233, 0.2974805513810185, 0.03858633444265491, 0.34026756781798884, 0.11262353231482647, 0.08524586456437233, 0.10363504791816991, 0.10781077236911807, 9.999999999998899e-05, 0.08311875030083316, 0.22588616205787626, 0.07485505173816254, 0.2833357160191383, 0.15734480819422902, 0.14823265677809228, 0.3019649754848881, 0.3347555966453636, 0.08499647285047063, 0.08302669540745733, 0.6815745835152518, 0.5969282065840685, 0.5863802001964409, 0.64434413428288, 0.6183615300734002, 0.6481489870603583, 0.6681962985741368, 0.660952612351608, 0.6520917491480211, 0.13101040704182665, 0.16997489524399512, 0.11592609856378855, 0.1379232204595281, 0.16166547711410695, 0.14245590124179563, 0.14822309738618333, 0.1414531797399584, 0.16752069612206344, 0.2905599742702477, 0.33307234956637344, 0.45559963693511796, 0.21215766014918613, 0.16661328928496644, 0.23969702211482335, 0.250867617142739, 0.2559750652481416, 0.44694785018785876, 0.30022283789463977, 0.6547659166477319, 0.3167299705792197, 0.4582732154750966, 0.557797509968909, 0.4438968424811828, 0.5014189548641144, 0.5307000069137704, 0.8553511029405921, 0.32504689629316685, 0.3379464036471276, 0.29238526923226293, 0.2708959811125313, 0.28785670950688214, 0.36883449928629053, 0.3089881711583997, 0.21739652912557383, 0.2621300427373734, 0.23298934091955248, 0.21954433133284623, 0.18892590204233284, 0.24056676947603617, 0.18638116506123759, 0.235898985844732, 0.21507747131979138, 0.20438184779644852, 0.21826006217416782, 0.21226801066861434, 0.2552119752994919, 0.2548897498259465, 0.22662058174688904, 0.21513394564797939, 0.20298674104941872, 0.22991315547777436, 0.19293900784661921, 0.19459014054689416, 0.953056488226355, 0.16259895904930177, 0.16412282685175794, 0.17263250329266178, 0.17806679894566202, 0.944995272340463, 0.9271011440960113, 0.16830703370292577, 0.16800303266131045, 0.6919314586341718, 0.2141447781836796, 0.7782212254456594, 0.2130047915049147, 0.16756197130134298, 0.21362239066798738, 0.45376501089768084, 0.16810943777555332, 0.15476268047597408, 0.1774725019025396, 0.18828042481605567, 0.18429571526552935, 0.19146690120757504, 0.18038833155008283, 0.18021702077656176, 0.18407861658353175, 0.17896154594933833, 0.17710448703814452, 0.16783883948887246, 0.11001415823647953, 0.09467597551583862, 0.10719603052269977, 0.09250006255767862, 0.0847994748423514, 0.09002164698346737, 0.08724070850157406, 0.0893040075869842]}, "mutation_prompt": null}
{"id": "b441376f-a3d5-465e-90f1-45a12ad164c9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            \n            # Update mutation factor based on diversity\n            diversity = np.std(self.population, axis=0).mean()\n            self.mutation_factor = 0.5 + 0.3 * diversity\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a dynamic mutation factor that updates based on the population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.27723802544562043, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9519384845785996, 0.953623256247397, 0.9416518591112519, 0.9500568103323392, 0.6206449371019679, 0.9509223491566221, 0.9496757421949416, 0.8738681389472034, 0.9457241412571854, 0.7124933102165383, 0.2761835985350374, 9.999999999998899e-05, 0.14548068668147007, 0.9137425531190604, 0.9062866175526721, 9.999999999998899e-05, 0.02052611629200507, 0.9076960416829721, 0.14390467625994263, 0.12418171026425984, 0.15817795022118697, 0.13338944751147974, 0.1181609220412072, 0.18780494995037855, 0.18236598256418501, 0.5903252936734871, 0.15857024941187303, 0.15961716722426844, 0.14132293775004034, 0.11595068449100798, 0.14364586657698164, 0.1011954982174258, 0.13459862610137696, 0.11714540863376566, 0.1434819181798519, 0.1096086944524377, 0.9838740733526924, 0.9859775568746227, 0.9635762276892351, 0.9582370917541304, 0.9916764002768012, 0.9896700277302555, 0.5980394906880765, 0.9789597270263674, 0.9541883016043345, 0.1359417671119818, 0.1787848075549351, 0.377751164635583, 0.2419417010681475, 0.32103980956310985, 0.3197404485290929, 0.1362681056761419, 0.09057874989887915, 0.12310372801687774, 0.2266364270939083, 0.24128971401703736, 0.2158866165085197, 0.28103203570151936, 0.21212139881010295, 0.22060268738510946, 0.16759924563655781, 0.358908400080616, 0.23729597912583567, 0.14464703618914065, 0.13523441030790673, 0.17108271338428205, 0.12896425554051982, 0.15763618088526787, 0.15382656233382497, 0.1554480933959983, 0.16685513549432562, 0.14142745089288622, 0.1252756911966615, 0.13753266549547627, 0.1301017471935627, 0.18451816466543858, 0.17435840039317485, 0.1514373481070861, 0.14750724770864398, 0.16191267014579824, 0.13074396075861427, 0.06723228098933565, 0.05979005097793111, 0.12255101028721693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07945590769355892, 0.10158488297553303, 0.09099914013905197, 0.07198228844550936, 0.010061246517426792, 0.06073451895784543, 0.10440320689231408, 0.007913451788752135, 0.09133319658048644, 0.27337916409521634, 0.053636660515109735, 0.11814213427724318, 0.26582595084872584, 0.10834049697421066, 0.1068344402748671, 0.2764380059913223, 0.08159519663653159, 0.20372667415832568, 0.0010310524623375894, 0.16455190742977976, 0.3073789702820823, 0.05420765295824659, 0.0139640146530845, 0.09890722821529763, 0.11807824594356875, 0.137984702870398, 0.23169870098674206, 0.4609320204307069, 0.5447432014574323, 0.5283210562068424, 0.4198262145873629, 0.5163512541312476, 0.5250124424612992, 0.465686015593367, 0.5771565439766726, 0.6700489246287126, 0.1455561809882856, 0.13129742714967418, 0.15742294374919985, 0.14269973198405683, 0.12156518011915085, 0.13425866438755618, 0.17269364191421355, 0.15076514511269212, 0.1235013930160127, 0.14225676241200325, 0.1709121351203634, 0.12638304323555405, 0.20538303804734204, 0.17265580938787484, 0.1416267353554167, 0.130882923474143, 0.40094300502872904, 0.16346918122190168, 0.3926237862503694, 0.3036431670183285, 0.4902722965821982, 0.3356522833731074, 0.2440135284909527, 0.4536977119555843, 0.3005350974379781, 0.3268047601248666, 0.4322928871140319, 0.25220504708784064, 0.2545879546610349, 0.3603690969018184, 0.30891095876741903, 0.21011278332465533, 0.3106797892363744, 0.272767228089015, 0.3433992675498928, 0.28692018461995006, 0.21534600203912035, 0.20595811035564293, 0.1996818296240428, 0.1878371846670247, 0.19679320014999402, 0.20915447395126485, 0.18735604075542955, 0.21621014964111418, 0.20991031612295064, 0.8946066537937021, 0.23039393583606993, 0.22847957397545005, 0.45991112626275277, 0.20149738867013867, 0.19373786545726301, 0.19390890363385038, 0.20942921495995281, 0.20730159928940972, 0.16525529544499318, 0.9129586128500803, 0.2629770115966852, 0.1780166925846528, 0.1771566524459467, 0.18762049907634082, 0.9291935614264822, 0.16965600102668454, 0.18763069152591838, 0.46445718751153187, 0.16978223878794996, 0.19535802470880692, 0.16664714298069938, 0.21062325138277682, 0.20613064794353175, 0.11315663420258315, 0.5552614161530802, 0.2746170743917774, 0.18175324457982212, 0.1840197534191682, 0.17884689263885611, 0.16961086384622936, 0.19107424052368438, 0.1793884714135986, 0.20164321987688905, 0.2168680235117102, 0.18133892357299897, 0.09304576828121303, 0.09334285396159525, 0.08215839424958704, 0.08049725820339282, 0.08594785370111224, 0.12302612477955133, 0.08896604492706428, 0.10179693638506382, 0.09648155354400312]}, "mutation_prompt": null}
{"id": "939712e2-c2a3-4e10-a7cf-a6430e86c47d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adaptive Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce adaptive mutation factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.34997169956177815, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9527155602854759, 0.9439213803462676, 0.9444945901653392, 0.939355390395726, 0.9483196623966764, 0.9450321358071692, 0.9485441097236663, 0.9484160520925496, 0.9442202479366673, 0.9085535895834537, 0.9125770019470465, 0.8929334084904651, 0.898795583050605, 0.9091257619316553, 0.9073921634970483, 0.9071864612417356, 0.8992059407596388, 0.8993133788338745, 0.8006786665500941, 0.18720149495996374, 0.1602179603530952, 0.16296069009051084, 0.8375478651896278, 0.1579958980551197, 0.18285282139750847, 0.15757245764191063, 0.18629953861441828, 0.11890771691804025, 0.1065990131157789, 0.15374246238694245, 0.11137239988749392, 0.1191859959060142, 0.1577034468311065, 0.09701365908179505, 0.0851677720143591, 0.09102085673751303, 0.9622506221206691, 0.9847221407423409, 0.9591031423088562, 0.9694923669690657, 0.9589929911645724, 0.987899627026117, 0.9708666912952195, 0.970594428407583, 0.9659168735613727, 0.7974859298841838, 0.44822405229678897, 0.6270253712481942, 0.7599971702834026, 0.6098036247460841, 0.3844970316733346, 0.4574472504733097, 0.618522632753808, 0.5471534711621816, 0.9331965799891371, 0.39182837281599303, 0.39169657980012973, 0.2146864733928091, 0.2144321134322268, 0.28065500186904, 0.4000715551656534, 0.23551087070749765, 0.2463288650979849, 0.16122008325867498, 0.17498497974640048, 0.16990095957099727, 0.17176548450102658, 0.1363663974113819, 0.20753751666807396, 0.1789360565858038, 0.17413900122196047, 0.16802950116085613, 0.15734390733315107, 0.16017255807979514, 0.1290134235047251, 0.13621991621059626, 0.23940165203291364, 0.14555997719611458, 0.10804935221739709, 0.10628966636709503, 0.1774805358656446, 0.21673973295880622, 0.1059531308027244, 0.03964408876922676, 0.053207359499106266, 0.05104903436966757, 0.026594211733239725, 0.06920702567725145, 0.013409782874592158, 0.1370036090497948, 0.03941276356858325, 0.05762972498520791, 0.11389586070938129, 0.08227060683242726, 0.11807486948203438, 0.033806976674911504, 0.22875372993816667, 0.11367879620468102, 0.11363127447388233, 0.2974805513810185, 0.03858633444265491, 0.34026756781798884, 0.11262353231482647, 0.08524586456437233, 0.10363504791816991, 0.10781077236911807, 9.999999999998899e-05, 0.08311875030083316, 0.22588616205787626, 0.07485505173816254, 0.2833357160191383, 0.15734480819422902, 0.14823265677809228, 0.3019649754848881, 0.3347555966453636, 0.08499647285047063, 0.08302669540745733, 0.6815745835152518, 0.5969282065840685, 0.5863802001964409, 0.64434413428288, 0.6183615300734002, 0.6481489870603583, 0.6681962985741368, 0.660952612351608, 0.6520917491480211, 0.13101040704182665, 0.16997489524399512, 0.11592609856378855, 0.1379232204595281, 0.16166547711410695, 0.14245590124179563, 0.14822309738618333, 0.1414531797399584, 0.16752069612206344, 0.2905599742702477, 0.33307234956637344, 0.45559963693511796, 0.21215766014918613, 0.16661328928496644, 0.23969702211482335, 0.250867617142739, 0.2559750652481416, 0.44694785018785876, 0.30022283789463977, 0.6547659166477319, 0.3167299705792197, 0.4582732154750966, 0.557797509968909, 0.4438968424811828, 0.5014189548641144, 0.5307000069137704, 0.8553511029405921, 0.32504689629316685, 0.3379464036471276, 0.29238526923226293, 0.2708959811125313, 0.28785670950688214, 0.36883449928629053, 0.3089881711583997, 0.21739652912557383, 0.2621300427373734, 0.23298934091955248, 0.21954433133284623, 0.18892590204233284, 0.24056676947603617, 0.18638116506123759, 0.235898985844732, 0.21507747131979138, 0.20438184779644852, 0.21826006217416782, 0.21226801066861434, 0.2552119752994919, 0.2548897498259465, 0.22662058174688904, 0.21513394564797939, 0.20298674104941872, 0.22991315547777436, 0.19293900784661921, 0.19459014054689416, 0.953056488226355, 0.16259895904930177, 0.16412282685175794, 0.17263250329266178, 0.17806679894566202, 0.944995272340463, 0.9271011440960113, 0.16830703370292577, 0.16800303266131045, 0.6919314586341718, 0.2141447781836796, 0.7782212254456594, 0.2130047915049147, 0.16756197130134298, 0.21362239066798738, 0.45376501089768084, 0.16810943777555332, 0.15476268047597408, 0.1774725019025396, 0.18828042481605567, 0.18429571526552935, 0.19146690120757504, 0.18038833155008283, 0.18021702077656176, 0.18407861658353175, 0.17896154594933833, 0.17710448703814452, 0.16783883948887246, 0.11001415823647953, 0.09467597551583862, 0.10719603052269977, 0.09250006255767862, 0.0847994748423514, 0.09002164698346737, 0.08724070850157406, 0.0893040075869842]}, "mutation_prompt": null}
{"id": "01858c3d-6e10-47ab-9466-12f2e0169d00", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "b4e35772-3c17-4fa3-ad6e-2771ae8cf68e", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adaptive Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                progress = self.evaluations / self.budget\n                adaptive_mutation_factor = self.mutation_factor * (1 - progress) + 0.4 * progress\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce adaptive mutation factor scaling based on evaluation progress to enhance convergence speed.", "configspace": "", "generation": 56, "fitness": 0.3605788320574949, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9521131360998305, 0.9416502539113281, 0.9464130919717068, 0.9537593156924937, 0.9461515324172052, 0.9469766927066908, 0.944339934978957, 0.9209479246872067, 0.9477545173012194, 0.9076876731704786, 0.9168493562939676, 0.8972518345420837, 0.8974407079079422, 0.9114438366072165, 0.9097046438388288, 0.9092098789512704, 0.9114135645581511, 0.9054594590061977, 0.15780723547179842, 0.16116258109661452, 0.14625392190415365, 0.15942468933546294, 0.1885927222423136, 0.18205287048974872, 0.15762811494897, 0.1337341835024366, 0.16099956620969225, 0.14060589388561806, 0.1847237868574637, 0.15757743122005996, 0.1390979827582498, 0.1568705662705061, 0.14082161764106316, 0.13470803757985905, 0.11327622315070673, 0.11009349836540805, 0.9439240962525702, 0.9847241289765228, 0.9667339963629975, 0.9695369454551785, 0.9681709818000153, 0.9879141748510263, 0.9708390668874448, 0.969907888428573, 0.9592772183458608, 0.8248962624096889, 0.8530543943840865, 0.38094600872808504, 0.7959522338555686, 0.5356484424283636, 0.8084057497375494, 0.864990613789832, 0.5436551143836217, 0.7966287711606432, 0.39525973973603046, 0.3956460487337857, 0.22860740498382615, 0.28039399383826535, 0.2827113529568688, 0.3837207060550779, 0.9355434406701066, 0.1781041893283133, 0.2362893935763103, 0.27569669633874516, 0.18354202643877482, 0.17506384474041803, 0.21517187280995986, 0.13627114984642774, 0.21667530696773618, 0.18762838076160393, 0.17299482111433429, 0.21233439471266125, 0.1816457914020735, 0.2001872038102691, 0.1359883948472841, 0.1354351209430139, 0.22114843398344164, 0.21977748407386866, 0.18171289186304862, 0.10536025461259801, 0.24027794122418622, 0.13225659894654618, 0.08878696951954423, 0.08934882437936664, 0.1460246189774309, 0.023158483386087947, 0.0007316794592241438, 0.06260192452201885, 0.09906560531654507, 0.0544741480457035, 0.03825065132851868, 0.21000327860700596, 0.14624465296499733, 0.10206800787750636, 0.15675393609904076, 0.19504854034301133, 0.13613520487386288, 0.1410836088423275, 0.09440943044542183, 0.21214856761636547, 0.0588527381409909, 0.17144336988310294, 0.12299605553014203, 0.08796069708457854, 0.10432066430763953, 0.130727629121127, 9.999999999998899e-05, 0.07859940459535175, 0.20924454804041737, 0.07678904501391515, 0.12177502862242295, 0.20165052227801172, 0.23396103851221228, 0.2905190928245729, 0.37327150697866585, 0.09394602684774833, 0.10044881966574282, 0.5718757734903357, 0.5866089712797897, 0.5969539027701651, 0.6850145451288332, 0.6001732481419852, 0.6332432595187646, 0.5127267592407219, 0.6414481436557189, 0.6631912943283385, 0.15575310870411108, 0.1459613427434464, 0.1183699460435268, 0.17259104969313144, 0.17143303513321828, 0.14774589292490725, 0.15558503836618287, 0.08589022670366597, 0.12724921447961957, 0.2657946600994947, 0.16264557906526678, 0.3147471343916616, 0.2572429511633333, 0.6997154189468271, 0.2551255884160315, 0.15781820646846534, 0.3035175373690374, 0.24859324357847967, 0.33453067606073883, 0.6880656625801422, 0.32862532100061936, 0.4145966621001087, 0.3473621145068626, 0.5845432382870008, 0.45897264784017366, 0.8637440082504326, 0.29573491538748853, 0.31521865573914576, 0.386891097373934, 0.4991528347503381, 0.2639950997210443, 0.3582555622294753, 0.37283520921668223, 0.4256896526148214, 0.46687941466188154, 0.2794393405021659, 0.25194607686545, 0.22238160401631313, 0.20954420720146427, 0.22291842093297232, 0.19166620842405602, 0.20712080863158122, 0.26030561915929906, 0.19732439670124235, 0.22292932048226444, 0.21241608264270295, 0.21019096916733138, 0.2534671803910922, 0.22573792367221346, 0.2004002543653064, 0.25444854924394067, 0.1981834135551227, 0.2043657065989336, 0.21049102946976772, 0.9296135363818828, 0.9337206916075984, 0.18648969094604195, 0.17263559159026065, 0.16538247813404827, 0.95192013955931, 0.9327850182420202, 0.9106765118093638, 0.16799514045670128, 0.40530399452582566, 0.21360727912793886, 0.7271744247528893, 0.21298629286259352, 0.16766376078438883, 0.21329801464735743, 0.9009509161414343, 0.16867158046348396, 0.15479474727937126, 0.1844483222631591, 0.16890604946717236, 0.1838278408627212, 0.2041842430500722, 0.18206606447302842, 0.17656725943250917, 0.18748853732355075, 0.18335070508845253, 0.18352201971596438, 0.09534555104514197, 0.11093806475016876, 0.09013474660979459, 0.08886060450661903, 0.08774677778787521, 0.08953889999691478, 0.09365184674286431, 0.0778791348782335, 0.08792272574625204]}, "mutation_prompt": null}
{"id": "1471e17b-4f56-4127-b037-b045a4b84211", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "1deb493c-267b-40de-9586-5dedc6d42a2b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "7bfb5d4c-5d5a-482c-b535-4a45b4e219da", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)  # Change here\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a dynamic mutation factor that decreases over time to balance exploration and exploitation.", "configspace": "", "generation": 59, "fitness": 0.34997169956177815, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9527155602854759, 0.9439213803462676, 0.9444945901653392, 0.939355390395726, 0.9483196623966764, 0.9450321358071692, 0.9485441097236663, 0.9484160520925496, 0.9442202479366673, 0.9085535895834537, 0.9125770019470465, 0.8929334084904651, 0.898795583050605, 0.9091257619316553, 0.9073921634970483, 0.9071864612417356, 0.8992059407596388, 0.8993133788338745, 0.8006786665500941, 0.18720149495996374, 0.1602179603530952, 0.16296069009051084, 0.8375478651896278, 0.1579958980551197, 0.18285282139750847, 0.15757245764191063, 0.18629953861441828, 0.11890771691804025, 0.1065990131157789, 0.15374246238694245, 0.11137239988749392, 0.1191859959060142, 0.1577034468311065, 0.09701365908179505, 0.0851677720143591, 0.09102085673751303, 0.9622506221206691, 0.9847221407423409, 0.9591031423088562, 0.9694923669690657, 0.9589929911645724, 0.987899627026117, 0.9708666912952195, 0.970594428407583, 0.9659168735613727, 0.7974859298841838, 0.44822405229678897, 0.6270253712481942, 0.7599971702834026, 0.6098036247460841, 0.3844970316733346, 0.4574472504733097, 0.618522632753808, 0.5471534711621816, 0.9331965799891371, 0.39182837281599303, 0.39169657980012973, 0.2146864733928091, 0.2144321134322268, 0.28065500186904, 0.4000715551656534, 0.23551087070749765, 0.2463288650979849, 0.16122008325867498, 0.17498497974640048, 0.16990095957099727, 0.17176548450102658, 0.1363663974113819, 0.20753751666807396, 0.1789360565858038, 0.17413900122196047, 0.16802950116085613, 0.15734390733315107, 0.16017255807979514, 0.1290134235047251, 0.13621991621059626, 0.23940165203291364, 0.14555997719611458, 0.10804935221739709, 0.10628966636709503, 0.1774805358656446, 0.21673973295880622, 0.1059531308027244, 0.03964408876922676, 0.053207359499106266, 0.05104903436966757, 0.026594211733239725, 0.06920702567725145, 0.013409782874592158, 0.1370036090497948, 0.03941276356858325, 0.05762972498520791, 0.11389586070938129, 0.08227060683242726, 0.11807486948203438, 0.033806976674911504, 0.22875372993816667, 0.11367879620468102, 0.11363127447388233, 0.2974805513810185, 0.03858633444265491, 0.34026756781798884, 0.11262353231482647, 0.08524586456437233, 0.10363504791816991, 0.10781077236911807, 9.999999999998899e-05, 0.08311875030083316, 0.22588616205787626, 0.07485505173816254, 0.2833357160191383, 0.15734480819422902, 0.14823265677809228, 0.3019649754848881, 0.3347555966453636, 0.08499647285047063, 0.08302669540745733, 0.6815745835152518, 0.5969282065840685, 0.5863802001964409, 0.64434413428288, 0.6183615300734002, 0.6481489870603583, 0.6681962985741368, 0.660952612351608, 0.6520917491480211, 0.13101040704182665, 0.16997489524399512, 0.11592609856378855, 0.1379232204595281, 0.16166547711410695, 0.14245590124179563, 0.14822309738618333, 0.1414531797399584, 0.16752069612206344, 0.2905599742702477, 0.33307234956637344, 0.45559963693511796, 0.21215766014918613, 0.16661328928496644, 0.23969702211482335, 0.250867617142739, 0.2559750652481416, 0.44694785018785876, 0.30022283789463977, 0.6547659166477319, 0.3167299705792197, 0.4582732154750966, 0.557797509968909, 0.4438968424811828, 0.5014189548641144, 0.5307000069137704, 0.8553511029405921, 0.32504689629316685, 0.3379464036471276, 0.29238526923226293, 0.2708959811125313, 0.28785670950688214, 0.36883449928629053, 0.3089881711583997, 0.21739652912557383, 0.2621300427373734, 0.23298934091955248, 0.21954433133284623, 0.18892590204233284, 0.24056676947603617, 0.18638116506123759, 0.235898985844732, 0.21507747131979138, 0.20438184779644852, 0.21826006217416782, 0.21226801066861434, 0.2552119752994919, 0.2548897498259465, 0.22662058174688904, 0.21513394564797939, 0.20298674104941872, 0.22991315547777436, 0.19293900784661921, 0.19459014054689416, 0.953056488226355, 0.16259895904930177, 0.16412282685175794, 0.17263250329266178, 0.17806679894566202, 0.944995272340463, 0.9271011440960113, 0.16830703370292577, 0.16800303266131045, 0.6919314586341718, 0.2141447781836796, 0.7782212254456594, 0.2130047915049147, 0.16756197130134298, 0.21362239066798738, 0.45376501089768084, 0.16810943777555332, 0.15476268047597408, 0.1774725019025396, 0.18828042481605567, 0.18429571526552935, 0.19146690120757504, 0.18038833155008283, 0.18021702077656176, 0.18407861658353175, 0.17896154594933833, 0.17710448703814452, 0.16783883948887246, 0.11001415823647953, 0.09467597551583862, 0.10719603052269977, 0.09250006255767862, 0.0847994748423514, 0.09002164698346737, 0.08724070850157406, 0.0893040075869842]}, "mutation_prompt": null}
{"id": "bfdf6db9-1994-46a8-b8a0-8ac4e25d5a25", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            best_solution = self.population[best_idx]  # Track the best solution\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, best_solution + np.random.rand(self.dim) * (trial - best_solution))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploitation by modifying the neighborhood search to use the best-so-far solution, improving convergence.", "configspace": "", "generation": 60, "fitness": 0.36455255231106326, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.942336363803506, 0.9522076023741564, 0.9532619575651861, 0.9477830205072082, 0.9429752055432828, 0.9551097175460519, 0.9480539848249045, 0.9330772982695281, 0.9442909672245116, 0.9028181822821596, 0.9039731570597094, 0.8758764589163756, 0.8910347231112842, 0.9088325571560294, 0.9176574135155429, 0.9053005053390871, 0.8975680344775882, 0.8988863353185823, 0.12474283663345964, 0.18734590638399062, 0.11693796316428595, 0.07322352196187443, 0.1455209246422593, 0.14575393496777211, 0.825818331542439, 0.14580617599001178, 0.15865361705316883, 0.1809623004796892, 0.0934516961389239, 0.11842582203838736, 0.11862008699375948, 0.13421218634342036, 0.10277375753437223, 0.13172840233090954, 0.1123357303047895, 0.08097613178622831, 0.9614203992571785, 0.9869431208364132, 0.9793135157280667, 0.9903407481459262, 0.9664051926057009, 0.983209418886774, 0.9785259344991784, 0.9565790240457356, 0.9582490918355531, 0.850754884595274, 0.8454699880099505, 0.8582061255890506, 0.8633705884645392, 0.8337880301423809, 0.8286476765634995, 0.8502840898011372, 0.7449840990662, 0.8189249787175219, 0.21764213098187557, 0.17208606992999143, 0.22722822421162248, 0.2211024268539713, 0.21487539066822703, 0.3639662118722289, 0.23596070234238298, 0.3659097392947974, 0.242482735886135, 0.2570119161600294, 0.259986288048514, 0.21965349335339235, 0.2488713522835292, 0.2981528838547004, 0.3476012225202262, 0.2624624298150433, 0.24128547991169502, 0.36518038667384833, 0.23919366028055022, 0.13285384473202233, 0.13566547885179425, 0.36012906955084345, 0.201401101296936, 0.24454808031305064, 0.2665242851864542, 0.26406271466804987, 0.2706375276709503, 0.21029704388692438, 0.007586986152362418, 0.09481747990734346, 0.046521817807131494, 0.0753566934932669, 0.06291642780923123, 0.15673183230237886, 0.09197002932897358, 0.13292654279941785, 0.14297225487543241, 0.24978203957837564, 0.2006002848701206, 0.12500796994695518, 0.08166303776426342, 0.06183614525762826, 0.14849148841014703, 0.15064957586682903, 0.04237200168727373, 0.13956031621294096, 0.08598566967430066, 0.21163451807701983, 0.16096592451643066, 0.1333521077527663, 0.21693481961532357, 0.08035045092872128, 0.13812982777313887, 0.22054038742202764, 0.12936774908742732, 0.05850960275150208, 0.059418957494334235, 0.045160886329249306, 0.13056112694337207, 0.08898627343197063, 0.10269152889977573, 0.18366838205535163, 0.15454846138583922, 0.669672685363837, 0.7234288815732863, 0.6714340734095235, 0.6613255127457149, 0.624923298242779, 0.6276815062137588, 0.66639413400206, 0.7009674576725755, 0.6560487321670372, 0.11812904774084054, 0.1429745903059274, 0.09319833495772623, 0.13383822871262596, 0.132885908962196, 0.14599233273862433, 0.1641537105930142, 0.1569595182312825, 0.1368261145808487, 0.1867578882796459, 0.5142388999216287, 0.6751595111471311, 0.15005144617967492, 0.3379979654394396, 0.8067862821107346, 0.2502300492939227, 0.24846755133887732, 0.17694403065039477, 0.5674974317068013, 0.39504804736265775, 0.3796021625034782, 0.41736024868701893, 0.4959811576689419, 0.28507858006717535, 0.6409188957581281, 0.5731922614097911, 0.2643914973261583, 0.26382166308186716, 0.35451583443089696, 0.21428842424940198, 0.23202531068163268, 0.22022190095371008, 0.27824018527630356, 0.4805244420362418, 0.22966376132346633, 0.24063277870401, 0.2555515553010599, 0.21108173433927913, 0.19349563658343427, 0.21174690586529665, 0.21162304121912, 0.218918318865712, 0.2434956948032032, 0.24921439034319148, 0.23899835010854087, 0.20023166129466774, 0.20990076190642237, 0.17916399193843446, 0.19821996816199894, 0.2562352154119161, 0.19439678067224408, 0.227423780262222, 0.19754672719501887, 0.2332625304769924, 0.1657674347839012, 0.9519887223961494, 0.1541604102940839, 0.9440592911951795, 0.20151328563069204, 0.17306451793232014, 0.09994382687287529, 0.1689794387920177, 0.9543121184667779, 0.16953157021516307, 0.21228408277883615, 0.7954780952784523, 0.8552104577741511, 0.21367554666969146, 0.906171802208583, 0.1052822369817995, 0.15719391314921272, 0.8390094881577053, 0.19370197721346272, 0.1713357282161334, 0.20857563386653732, 0.17939805682805798, 0.18343449937631218, 0.17426452061856434, 0.1766951107295054, 0.18309855800804897, 0.1964431815833213, 0.09096362155259963, 0.09540565267590972, 0.0894365929635178, 0.08895679748771124, 0.08588534759161337, 0.08959089447271695, 0.09014350398314741, 0.088465069341082, 0.07985978532936788]}, "mutation_prompt": null}
{"id": "b456f209-c37e-4e3c-97f7-c3bdbfb533b2", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                \n                # Adjust mutation factor dynamically\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                \n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance mutation variability by dynamically adjusting the mutation factor based on the iteration progress.", "configspace": "", "generation": 61, "fitness": 0.27777100063242655, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.6496963243120333, 0.6275748996852961, 0.901446983359629, 0.8375712234876997, 0.961212551462799, 0.9549871241446029, 0.7326075937999947, 0.9643284312642078, 0.7793118006510122, 0.9268409598001099, 0.4436412270790494, 0.8846885332497165, 0.6537970773688628, 0.6002824568755831, 0.6188338236064159, 0.49774025466758853, 0.19319837472434576, 0.49940618892399624, 0.10573054604933385, 0.16573410953019097, 0.11163337435284448, 0.16211556307618424, 0.10255045204084601, 0.18728500642555723, 0.13509226226220872, 0.1356073635180154, 0.16674661712526762, 0.1120413961982566, 0.13467680538615945, 0.09723280247926291, 0.1018181566811085, 0.11263804154362655, 0.08108466005931114, 0.06659238402623846, 0.1353641224456582, 0.14671468598842863, 0.9845847532462714, 0.9673233521463218, 0.6434039239012561, 0.9158894143410364, 0.36564305465852254, 0.9852226675643545, 0.9478216937377847, 0.3861300011984453, 0.9468008830397245, 0.19770738900648555, 0.12383369290202317, 0.3478088462709791, 0.28496781686866124, 0.17644346016787826, 0.1454525304503098, 0.2625844480191858, 0.19264920744388925, 0.14947201548371303, 0.3625362675087579, 0.17222197564185593, 0.22999148408886394, 0.28319341993630853, 0.3909876349095832, 0.3669419144012863, 0.22812973847022655, 0.17961285518057846, 0.1573394698907723, 0.15102383733423852, 0.2025661474192777, 0.14276136662634942, 0.12053758678485571, 0.13677221021774644, 0.19967951944235118, 0.1693555879522779, 0.1611859120928446, 0.24272200647169895, 0.13654929427777207, 0.1466271778155286, 0.16720084936310686, 0.16614207233365286, 0.13427532118336327, 0.15603063657460137, 0.16657466374359975, 0.09180914622785508, 0.13577720785890723, 0.07949453917783289, 0.006720183652638156, 0.12489966483516624, 0.025410400872347916, 0.028386145634933913, 9.999999999998899e-05, 0.07719344898256153, 0.015860560474318497, 9.999999999998899e-05, 0.06736473726854142, 0.08581025007686804, 0.13800820456516816, 0.1247574913104178, 0.0956430178588824, 0.11523507122233934, 0.19714524699197278, 0.10787674602379993, 0.07425024506702249, 0.14590316692619565, 0.06602077824739738, 0.33491635493086147, 0.09776025376728648, 0.10470512212868632, 0.11725831634966377, 0.4021489441575822, 0.050291692119573184, 0.17863970520296735, 0.17025117457168926, 0.12164881342482459, 0.4681546914802214, 0.13533466519099457, 0.13518064098860905, 0.4007587697804862, 0.20835459627279085, 0.024807933902381563, 0.19569526579077012, 0.5140678075514007, 0.43122159707042174, 0.48919123544742504, 0.4305468445950692, 0.4977436074891224, 0.46117545725689957, 0.5020491657076278, 0.638994402446217, 0.5145308675752497, 0.15977747376436802, 0.11678817175869971, 0.09102668126629943, 0.18260178450507425, 0.18980350262622325, 0.12478335910953409, 0.13424403191287493, 0.089403405611159, 0.12523902582838886, 0.22803410990511852, 0.1762772315147324, 0.2393981404346841, 0.2187675830602448, 0.3564817752022489, 0.17136389211303393, 0.20095043604662655, 0.3216569972333255, 0.24556749929601418, 0.46382302245353624, 0.21852285956662854, 0.4243675821600563, 0.4256948233606598, 0.26705039885433435, 0.6380950798064211, 0.35364615998470295, 0.2974938136406472, 0.23790397983915712, 0.2514670085867723, 0.3123726437956359, 0.26173302869457815, 0.3264176887835768, 0.25212664674514007, 0.3644047354613843, 0.2843042928303521, 0.23948229422246659, 0.265413648682733, 0.21266287348050894, 0.2520584678493093, 0.2223756201263405, 0.2292900710899124, 0.23482712530581829, 0.23376577534934606, 0.23051781148216366, 0.22552994375089475, 0.26260513856781964, 0.21097764007854636, 0.1989351590911479, 0.22922251882377076, 0.9166494340034581, 0.18802603726774791, 0.25702259826643703, 0.19254657943526432, 0.18436420733918968, 0.17762465550779927, 0.1868814580569108, 0.18799831535305433, 0.18813985115230147, 0.17376586695946827, 0.17024255845705938, 0.8726864354231407, 0.16205633150220433, 0.13705284454032485, 0.16779091100845267, 0.4446409724165412, 0.2137932218533234, 0.4283086659712627, 0.21399438002688942, 0.16903872494901862, 0.21326062726409956, 0.1134462889952843, 0.3882680253354094, 0.630939387394129, 0.18847930567596272, 0.19010248595402568, 0.18129387506598627, 0.1886599474095486, 0.17775934794493764, 0.2049706965338035, 0.1795911949670408, 0.19852797430891767, 0.20401765872046473, 0.09547364614752973, 0.1083575696401331, 0.08635691005130808, 0.09235086921031965, 0.09311582598547052, 0.08505192175919385, 0.09361110138922779, 0.1444387940900549, 0.0968692233846501]}, "mutation_prompt": null}
{"id": "efefc166-cadc-4ceb-8dce-d2c9d580705a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8  # This will be dynamically adjusted\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            progress = (self.budget - self.evaluations) / self.budget\n            self.mutation_factor = 0.5 + 0.3 * progress  # Dynamic mutation factor\n            \n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce dynamic adaptation of mutation factor based on progress, enhancing exploration-exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.3755276443830637, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9526301467350824, 0.9425178153045943, 0.9482743226726892, 0.9535405127125259, 0.9451035067638919, 0.9458667734891698, 0.9513003051470732, 0.8941761975658573, 0.9454780983584639, 0.9082667270907864, 0.9118165770773385, 0.9026956104557207, 0.9091190299134532, 0.8616236442839533, 0.9046556778434552, 0.9140113544245303, 0.9008177769296485, 0.9085611810933917, 0.15733305956173482, 0.16335365694777393, 0.16116628881429917, 0.12706107290590485, 0.15938255338303187, 0.14446725813798655, 0.19137447581224565, 0.13266976328905233, 0.18599631060515565, 0.14497215663423446, 0.11800663041801596, 0.10637093889969951, 0.18272726025707087, 0.11110988942498101, 0.09674892647742594, 0.13413603353939707, 0.14499144489484572, 0.1251470384905028, 0.9572994874868432, 0.9847249191051097, 0.9659484499252505, 0.9702167446510019, 0.9676213323148068, 0.987918634251662, 0.9708703139292146, 0.9699069355212, 0.9593978770552904, 0.80973352815482, 0.8341359176244114, 0.8256380138697631, 0.8186017087269729, 0.8510114395210622, 0.6000407950120126, 0.8603394063650964, 0.814548925706869, 0.785931109373688, 0.8952412129252988, 0.9311858272375964, 0.39621324761949395, 0.27989749402623965, 0.28242474443739907, 0.3784245314872394, 0.3206841205474218, 0.17800402364698298, 0.8668203491963149, 0.23702828066184567, 0.18486597872344923, 0.1997915640697494, 0.2005719853378416, 0.135922310694103, 0.1780090382758468, 0.18222947591389804, 0.17914763258808575, 0.21074231980037406, 0.16447986452554963, 0.20377370821613716, 0.13583779553568454, 0.13473524256416458, 0.23802337296734422, 0.2039281762493632, 0.16112955211238134, 0.10397405592649611, 0.2609391653484583, 0.13772057754848643, 0.06347818370730984, 0.06708372359707082, 0.1803947768413129, 0.010831081003745413, 0.015099881393969006, 0.1565963758568525, 9.999999999998899e-05, 0.08652658208611286, 0.044406886962675474, 0.13906922651660258, 0.12527306789987647, 0.0994366433931293, 0.16131061307222316, 0.11617101850738587, 0.15756298020019877, 0.224578813685676, 0.1117969849105317, 0.12482913634017734, 0.13597058328335987, 0.2440269243309262, 0.10957917884404089, 0.0880538952212293, 0.1138437469811634, 0.1276103319143067, 9.999999999998899e-05, 0.09411219533187798, 0.21738038842862084, 0.1422119787210131, 0.23163334932807733, 0.24693212009835175, 0.34039597516173814, 0.3392987845770412, 0.23571727716307178, 0.09345006409751166, 0.10350265324442831, 0.6208395933700791, 0.6939569512674342, 0.5365034779875986, 0.6210843920733427, 0.610529679217529, 0.6893266017061136, 0.6486885304739208, 0.6243383755873848, 0.5900601134755744, 0.1709892139968643, 0.12290723589504615, 0.15258324614528795, 0.11668437108799057, 0.11397264779488336, 0.10427857162019194, 0.1203620185690637, 0.1137258054705933, 0.16194013519049, 0.2692349125118798, 0.23394677600470892, 0.3640259804350353, 0.2454079200317627, 0.23106266743642467, 0.20579741050697542, 0.1920018916324474, 0.315108626108378, 0.1693818502808756, 0.5506821615919613, 0.4979942234672984, 0.5051358278435079, 0.5302363836161479, 0.4990376344165012, 0.6437924753797559, 0.28157365165923465, 0.6896868921998445, 0.48114735820218857, 0.3313457563386656, 0.2821605169655895, 0.3435608879212797, 0.38852714748982, 0.25714728119560537, 0.2124781847956776, 0.27914329580335584, 0.43002179401999263, 0.274610113913043, 0.19888743733789682, 0.22596083477160134, 0.21113985076253983, 0.2039174581778448, 0.2482866383550788, 0.22127601085545245, 0.20861958660219537, 0.21672855992275397, 0.21551571291699512, 0.25177977553742925, 0.7878644016676742, 0.20537925284129577, 0.2258776945540989, 0.22132760587716116, 0.8525642046646547, 0.25069757635471634, 0.21149089791012343, 0.21095048360836544, 0.9355966871317446, 0.9341234526544029, 0.18654548940108662, 0.17263627802635984, 0.16538409081661065, 0.9482189090796362, 0.9224836658416762, 0.9109919334810402, 0.16798639563069429, 0.7371828195917076, 0.2135993011937174, 0.9319068131249939, 0.21207522131648204, 0.16732210845679418, 0.2133277716869414, 0.9236427530038787, 0.1686826374613316, 0.15478659545108042, 0.17929295629602016, 0.18391882250256353, 0.1906799746542922, 0.18927833216672807, 0.18611239427600923, 0.18124034403830747, 0.18918189630155946, 0.17727222488157746, 0.17960826795595386, 0.09570340441463088, 0.0944076048782192, 0.08625972240816793, 0.09207235925463664, 0.10353182333131794, 0.102955187181906, 0.09734820412766787, 0.08688436171493452, 0.09497919175694791]}, "mutation_prompt": null}
{"id": "c6d3f0bc-add6-419f-85eb-55a61a4ce1f0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "6097b3b2-5c8e-44f2-891f-3e3a8d2750a4", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "b8fc1097-0dce-4c49-a38e-ed6aecdf8d29", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "e618a169-4cc9-479c-bd4a-66d7c1462447", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "648d0cf6-2368-4fa1-8df3-523eb1306b8b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Apply a small random perturbation for exploration\n                trial += np.random.normal(0, 0.001, self.dim)\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration by adding a small random perturbation to the trial vector.", "configspace": "", "generation": 67, "fitness": 0.3516022081426769, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.8661387232875862, 0.8714591269784088, 0.8252932899968896, 0.8372467676373159, 0.8346812192244675, 0.8659481642256526, 0.8628325758624091, 0.8616032577781758, 0.8503841775708734, 0.42836451566858935, 0.44821661765542564, 0.482826580524929, 0.4246924680211054, 0.353432387741616, 0.430843283701558, 0.42846566889744964, 0.4743566038610998, 0.4278340860469161, 0.18597045289981418, 0.18568769813398944, 0.18612407977362877, 0.18509845953211945, 0.1828894766596456, 0.5260163974274217, 0.18458927674423575, 0.1882013438297061, 0.08920312926795904, 0.13063291122659826, 0.14578130350769514, 0.09682545807910847, 0.12210034197849995, 0.1330875117198046, 0.14592061267822176, 0.1413291765110689, 0.14418474482281896, 0.18444429697542508, 0.9584797002068386, 0.9522996102193186, 0.942323770273338, 0.974562807459628, 0.9536573166029083, 0.9610062794165684, 0.976796372405689, 0.9701257330630306, 0.9462114997260668, 0.6397482798530033, 0.6604711159496516, 0.6301085479387223, 0.6218262339614753, 0.6438529166630846, 0.6275231733289054, 0.5939120162566678, 0.6337167330370264, 0.6107980357762133, 0.22921141017311064, 0.22877984842716126, 0.9237330978412368, 0.3844660845478648, 0.2825064927584112, 0.3829942283630885, 0.2380572549686365, 0.23928888561997141, 0.9193409467453366, 0.30748049743222683, 0.1345219903172734, 0.35557799111018085, 0.25820622920050196, 0.13494043627323848, 0.2763973164139838, 0.2452034952394141, 0.26732086075549555, 0.2801692207153005, 0.13601740238663984, 0.12756843859890687, 0.2471947909898824, 0.3952198392902404, 0.2959055260261876, 0.3184337215846784, 0.136086477380559, 0.28117387895264745, 0.29987300524332494, 0.09738209818007648, 0.030797416660821586, 0.05065101514744752, 0.13469428892775936, 0.10880777200842473, 0.034185177953003576, 0.1340672734853373, 0.06018457671797328, 0.0837099066295488, 0.14324209397272658, 0.14150331349177048, 0.096150125788667, 0.08900969395845038, 0.045937710026442424, 0.05747716986636875, 0.1385722722985926, 0.13470774996108426, 0.1348582511153229, 0.12369529147245595, 0.0482638231303949, 0.11343993231880833, 0.08642766363065979, 0.09877194539327461, 0.200632137971112, 0.26860899185268505, 0.1814755143758946, 0.080336807259482, 0.2891018730827313, 0.1813737997678163, 0.24731628043797615, 0.08766364880895694, 0.12142751372120841, 0.2850672592431399, 0.10853823934487539, 0.22556541409649988, 0.10254913217602957, 0.6260498660921318, 0.6533039348217187, 0.6214422823375338, 0.6059515061888858, 0.6025212722658986, 0.5829848107732643, 0.6408303577122096, 0.6179216826447056, 0.6393218088651532, 0.18346526417443698, 0.14483883572321843, 0.12447059566281127, 0.4766750045065281, 0.17087289102591907, 0.17960225232904647, 0.13270453128686188, 0.10053925224739435, 0.1207077759590145, 0.4670428240724691, 0.2742753517146388, 0.30714244525744705, 0.4268490976434599, 0.1423619977658067, 0.19046194402008398, 0.17347402174350923, 0.25301039556586136, 0.20092885469667876, 0.3986113988767326, 0.4604304803050788, 0.47577362314363203, 0.4851519822055218, 0.4758411118815632, 0.47554121389342185, 0.24315469672617496, 0.4861389642859274, 0.4795519208564829, 0.3760288109864045, 0.29257764051717183, 0.25970527173391156, 0.34675283852233607, 0.2686871710335974, 0.4252095384278015, 0.28938648124969046, 0.4540206312684619, 0.4332721110543487, 0.22671115452697088, 0.2056720353372452, 0.19830827848451793, 0.23706103192313865, 0.20310506069440437, 0.22566063441245288, 0.21824173714318496, 0.2800456513716092, 0.19793093756465685, 0.2523287480299734, 0.21362173088269043, 0.6599683593236392, 0.19021627825297904, 0.6046979723241155, 0.6469978845010591, 0.2321006390277277, 0.2546174442052629, 0.6963974233745039, 0.18825048703910618, 0.16570062819032827, 0.9296547715957164, 0.9420178990251048, 0.9520954856520617, 0.9397435368838862, 0.16116326268852177, 0.9187811948448409, 0.16633848743391022, 0.86936684279097, 0.1695561992211635, 0.8798478044677479, 0.1630990803699749, 0.8774398284895778, 0.21262828260194833, 0.20883815125648675, 0.1254237154851524, 0.1131142012110582, 0.1885476483424623, 0.18248345902134566, 0.17613808048446278, 0.18499501601572033, 0.2048439313079653, 0.18300598355667486, 0.18567937863295214, 0.1961201999749942, 0.1878243188502895, 0.08518518267149633, 0.09085333975213072, 0.08837245344380229, 0.08829932593227363, 0.08993123571306749, 0.08652127051955327, 0.09079480916366589, 0.10541760265156486, 0.09674524787546179]}, "mutation_prompt": null}
{"id": "0de6a305-0796-4fa9-b0f4-9d74f9c01eb8", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n            # Occasionally replace the worst individual with a new random solution\n            if np.random.rand() < 0.1:\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[worst_idx] = func(self.population[worst_idx])\n                self.evaluations += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Improve exploitation by replacing the worst individual with a new random solution occasionally.", "configspace": "", "generation": 68, "fitness": 0.3783190614301686, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9393693810215346, 0.942381472583132, 0.9429148909465913, 0.9372327302280576, 0.9472025446310751, 0.9337436571881588, 0.9500222021492267, 0.9467623265336509, 0.931630522361269, 0.8995978880562351, 0.8859595071497705, 0.9013688406937509, 0.8963414405702272, 0.9130274789976165, 0.9082919713379379, 0.9010995908569954, 0.8846848915574598, 0.8998502009697016, 0.18976997337641877, 0.1801620736832238, 0.1559146251581931, 0.14019561628642419, 0.1613448814473979, 0.1601227936234041, 0.1722279285720688, 0.12401172046566966, 0.12470201020943927, 0.16002491954144393, 0.14049941288655154, 0.09678575274043688, 0.15536567004093682, 0.11689251136030487, 0.10058866059783045, 0.10117196945259854, 0.1554734018919267, 0.1239052818445765, 0.9836070919079345, 0.9919600319139793, 0.9698941944417254, 0.9901936025091803, 0.9456755460450772, 0.9885372141472856, 0.9622841950748913, 0.9520987432639093, 0.9567316863134688, 0.8500425199792996, 0.8562749575131157, 0.8439211570453098, 0.7744200837691573, 0.8598296049049912, 0.8523817079928712, 0.8350217545554113, 0.8611289949411827, 0.8100232225457309, 0.909007668087736, 0.22627867779794653, 0.1969292063003104, 0.2150072505917081, 0.38926409199042267, 0.2824266327389944, 0.3345013625393226, 0.9389577069480944, 0.40065990574500465, 0.23279754365280336, 0.22576109845135206, 0.23129011936599586, 0.24851765883142107, 0.22032242925706136, 0.1988628536859075, 0.291466460245142, 0.26485956740699945, 0.20588404480025713, 0.215454747428371, 0.2376124691524788, 0.1998177290033687, 0.19687644938254478, 0.1913545674080096, 0.26162706848164785, 0.25461269415669485, 0.27227490061712345, 0.2515198538642178, 0.16309544845545965, 0.12212251395973073, 0.06438048563191678, 0.2339470032574783, 0.02299598364805766, 0.07972359825103725, 0.02463830794559929, 0.004974080262155844, 0.03214473789812422, 0.02521194855124087, 0.14840195543336343, 0.17877490521066008, 0.06035171449776555, 0.11195067932887481, 0.09946437458010438, 0.16333408556997675, 0.16543092514376911, 0.164720817414736, 0.2109627310922053, 0.05112722171479023, 0.32513367933831683, 0.12826732243843475, 0.08450977017402261, 0.1697075834601166, 0.3082676298755863, 0.4463163949786888, 0.08067176932799502, 0.11598957196794035, 0.10952926211653025, 0.10967876012063449, 0.46940039431233993, 0.12460166023993602, 0.26530462021834644, 0.2372357928839377, 0.27838227566857787, 0.08425836055841207, 0.6412138972432275, 0.6691651644158989, 0.6683757435450517, 0.6417593993169913, 0.6715920263418651, 0.6990843440971103, 0.6600026851477727, 0.6898840193488337, 0.6681405089131491, 0.14394434933497757, 0.13549421954739027, 0.14677497846967302, 0.11548879497622888, 0.10537826874411438, 0.1447835455148252, 0.10430254029353381, 0.168448172570836, 0.10400290568656712, 0.6273225621767275, 0.17680954964101003, 0.34682609677560083, 0.3065423719245266, 0.15627547868400637, 0.4996682839576809, 0.1386767341958024, 0.1845871666953932, 0.2458509472113476, 0.5245326375362904, 0.6073081228549091, 0.6604234149603923, 0.521813858275421, 0.3920626091583649, 0.3819792228037827, 0.7950407413732847, 0.44302855071402725, 0.5213845629008145, 0.34639634732277946, 0.5184127137525039, 0.27241955815735086, 0.34230754608171987, 0.21458635981959195, 0.24243736447022723, 0.36258895095188715, 0.44144648251996776, 0.23340132812813807, 0.20134882401000354, 0.22531381181403354, 0.1971489998747188, 0.22034103417608852, 0.2303785648807426, 0.20710133807867814, 0.19519312200956018, 0.19953362713338474, 0.2261450713219304, 0.8204407140681053, 0.18924087196932338, 0.1902359390002918, 0.25357652619031046, 0.1895631888361985, 0.870846403466292, 0.21031815186510483, 0.19819607624256974, 0.22261947445160302, 0.9260159516771684, 0.21067319738824752, 0.19709183822557053, 0.17242566872027487, 0.9324520053135424, 0.9533617256585819, 0.16139902835787945, 0.21309011795275734, 0.9231331169567397, 0.9032271519422022, 0.21374256162686966, 0.6700666859171609, 0.21259225087782618, 0.21236300196714297, 0.21259770078622664, 0.11322484468867278, 0.19382053939959076, 0.11290424331691706, 0.1958009234175031, 0.19715600781406006, 0.17131174111696257, 0.1808072377480363, 0.18357981848819283, 0.182286935497306, 0.18248844678247167, 0.17369447527520188, 0.19628537028106585, 0.08651922750638918, 0.0916344997855606, 0.11938165815230273, 0.09143343887045663, 0.09273633228223899, 0.08757126871500076, 0.08114245718432633, 0.08502302579532983, 0.0907557341565518]}, "mutation_prompt": null}
{"id": "9c9c7aa3-cd4d-4110-a2a5-b1536a451ee5", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            best_in_population_idx = np.argmin(self.fitness)\n            if self.fitness[best_in_population_idx] < self.fitness[best_idx]:  # Change 1\n                self.population[best_idx], self.fitness[best_idx] = self.population[best_in_population_idx], self.fitness[best_in_population_idx]  # Change 2\n            else:  # Change 3\n                self.population[best_in_population_idx], self.fitness[best_in_population_idx] = self.population[best_idx], self.fitness[best_idx]  # Change 3\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Incorporate tournament selection with elitism preservation to enhance the algorithm's exploitation capabilities.", "configspace": "", "generation": 69, "fitness": 0.3909108099639801, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "e9e5c7f5-d596-4099-af56-ca9f3743036a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            centroid = np.mean(self.population, axis=0)  # Calculate centroid of the population\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(centroid + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)  # Use centroid\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Leverage centroid-based mutation to enhance exploration and maintain diversity in the solution space.", "configspace": "", "generation": 70, "fitness": 0.19773990317410406, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.39047212699224443, 0.957030208529878, 0.7099110888204332, 0.180531601554778, 0.5976830442726901, 0.4927494631674265, 0.6803915476081795, 0.7446721603401947, 0.6981864969789208, 0.2637387350440463, 0.298968472611417, 9.999999999998899e-05, 0.5252533432157422, 0.1374152671212756, 0.16826514356040878, 9.999999999998899e-05, 0.1107901062532004, 9.999999999998899e-05, 0.15254051938820645, 0.16338699337877627, 0.1590194153541652, 0.19206708011010754, 0.17064703034096906, 0.14721221610914703, 0.12507333792835051, 0.11680010442751443, 0.1394932789040031, 0.07924566200458616, 0.06680030834622053, 0.09622561072909575, 0.11248861749494277, 0.07494961641159048, 0.08206973193663125, 0.07353772001416747, 0.10614094503520277, 0.09730162656901453, 0.22625356543933073, 0.11082249740799321, 0.13153052719796687, 0.16623617366971177, 0.13068320058617755, 0.1337034225870093, 0.13112201315143557, 0.29488498455673395, 0.15235876270810345, 0.06861828198379094, 0.0628749616739922, 0.25233963026871464, 0.13339864609445717, 0.08752610149790385, 0.14666077136727396, 0.1784986704032524, 0.10715240407202165, 0.1204625841882907, 0.23078785062068619, 0.21605629526160208, 0.4044110238324079, 0.3936691615943353, 0.3693351205118661, 0.26857291148578766, 0.17919861946589466, 0.1801083037562652, 0.15878616461902983, 0.11581027166883018, 0.018745291101951667, 0.03432812187064738, 0.16645269399662155, 0.16086126144654844, 0.09437653498090026, 0.3079599935151196, 0.053472665552108056, 0.17507326786467203, 0.13832913101794164, 0.16429784756400623, 0.23449409794664022, 0.1319568317699502, 0.42162977851215133, 0.13713054225503185, 0.1494266027161848, 0.138221905480862, 0.1647147180697679, 0.015645092285343387, 0.004017057283006387, 9.999999999998899e-05, 0.05365756474359773, 9.999999999998899e-05, 9.999999999998899e-05, 0.12820004802314267, 0.05012977479263969, 9.999999999998899e-05, 0.18093967619055296, 0.14622042736079366, 0.20504263787176213, 0.114601267647363, 0.09151171417362747, 0.06762101958416622, 0.15091687078852867, 0.15819892258187485, 0.05044929411506405, 9.999999999998899e-05, 9.999999999998899e-05, 0.11423772758786233, 9.999999999998899e-05, 0.09493193216328777, 0.09685329732056802, 9.999999999998899e-05, 0.2247197247479955, 0.11956015697372935, 0.13626583579896723, 0.03660317489197895, 0.010255704912516594, 9.999999999998899e-05, 0.08211027604236665, 9.999999999998899e-05, 0.2201936203710828, 9.999999999998899e-05, 0.07679107671653307, 0.449199546998696, 0.3959394018699103, 0.3902373662057247, 0.278360609500097, 0.41564313450726287, 0.405940588612959, 0.4109182359722867, 0.3010605108182399, 0.38577699720185754, 0.12540759648036692, 0.09357864260340232, 0.11781886748282244, 0.1614675612396793, 0.07816167882629621, 0.1466372035126282, 0.07579062817324378, 0.11287812465261138, 0.13309563177813455, 0.21806310211552005, 0.29362305026817326, 0.15932624007282847, 0.14071994614579786, 0.2120036017747603, 0.3435557149100438, 0.19830974579332517, 0.26042587096151937, 0.21434099106174542, 0.4359525003257054, 0.2719368356227011, 0.19657793959485093, 0.3999460855925848, 0.25221962573452894, 0.29093567548429533, 0.31941449131839417, 0.33055478176118946, 0.2368249829256217, 0.19771892929638835, 0.3554526225258985, 0.15848070954752347, 0.2060393016495503, 0.28844742135510004, 0.2582484780892137, 0.23840037595795494, 0.2104202504583743, 0.23619905457754053, 0.20977685528010692, 0.27496049978134984, 0.20898150061840726, 0.20300813484882818, 0.2101653239950182, 0.22366890188829136, 0.23014331667751176, 0.2309831721675415, 0.26667850464902054, 0.22347135597735335, 0.25586589317740005, 0.21959230886847847, 0.25365960752817174, 0.1957026712750357, 0.19413077602382933, 0.17799112295212582, 0.18450478345732568, 0.18215508307254713, 0.18831370540615933, 0.18700107578117509, 0.18850144132276048, 0.17173754260497842, 0.2001809663553319, 0.17450300464191604, 0.18600140073282279, 0.3944977167390209, 0.16290234064710152, 0.8813377213666546, 0.2143042112902248, 0.20860628804414172, 0.9529069897901943, 0.16985327619421076, 0.1824528031770939, 0.1131593429377552, 0.35428779833365176, 0.27285987623959507, 0.19045022250264854, 0.18478715719034977, 0.18203319569185594, 0.18311925142855667, 0.18164121042937353, 0.1706723187084601, 0.20126080082664544, 0.19372779768358384, 0.18010445522899787, 0.10047637064485793, 0.10036592293925473, 0.09910397209849398, 0.09740747680680484, 0.08595633852900941, 0.13303192803836883, 0.0960119651016128, 0.09358178759782698, 0.10172222610544246]}, "mutation_prompt": null}
{"id": "8199be8f-0646-46f0-ab4d-4a3bae386a34", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "49ec7e56-9bf5-4757-bbc7-2c31f7a5ba59", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity_factor = np.std(self.fitness) / np.mean(self.fitness)  # Adaptive mutation factor\n                mutant = np.clip(a + diversity_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Utilize adaptive mutation factor based on population diversity to improve search efficiency.", "configspace": "", "generation": 72, "fitness": 0.1537418125474501, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.12.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.15363026918566425, 0.2992283251960083, 0.2663235527030068, 0.16966136633693274, 0.09080125882295431, 0.20153512025333864, 0.26362740403729257, 0.19180969905660827, 0.1120054743629918, 0.2498600837835966, 0.35086245556824835, 0.2093077639621922, 0.2376233397625157, 0.20434844588751977, 0.16774639096952215, 0.24457655058963867, 0.1957282417876668, 0.21721714483149523, 0.06136661758874984, 0.09090423850429685, 0.07705889655728038, 0.10535111041774836, 0.08544183707069064, 0.14676451224112375, 0.09304868364405317, 0.1245689383460522, 0.11947411460716506, 0.04442908088723074, 0.02679648812341151, 0.07956480309685143, 0.10224079931347774, 0.15916159810047392, 0.07207978043562913, 0.09109278926788034, 0.03589481394304772, 0.09026324167319377, 0.9844995303746523, 0.9850898921663553, 0.46730313856193406, 0.08122019578089201, 0.07245029508865641, 0.07310459755726717, 0.08013043596661062, 0.10433588345051414, 0.12786599562389234, 0.08650116082523451, 0.05839647593009645, 0.08942597698107002, 0.06202686886527464, 0.029237377420069932, 0.043669339698592546, 0.1073880037373176, 0.10971457149938446, 0.054638056325661655, 0.2308184751144724, 0.18195304030709836, 0.15237789276944713, 0.19430938802694941, 0.17384312381998202, 0.3508222086499958, 0.1516471430555375, 0.13397558110191954, 0.23823926544635532, 0.13221748653569798, 0.07245261477481835, 0.14135984916220135, 0.11465127322115354, 0.15730538226182766, 0.10621212529876867, 0.19040158219821102, 0.1319071795215392, 0.1329804226790149, 0.16392451518246887, 0.12731044524255597, 0.06941704479408961, 0.14486655468154241, 0.17608199224433552, 0.1537387631905549, 0.0248344060935779, 0.13878407809052662, 0.1406938568809375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06746802634600135, 0.09149154014343674, 0.05235892618432969, 0.04132376871673982, 0.0013612893277233917, 0.021626194240884966, 0.1143487227112866, 0.08014622918506797, 0.06409456170751215, 0.08368735112857939, 0.11530702770830581, 0.05763403136381928, 0.09459292788295315, 0.08704457475239413, 0.08295427048878301, 0.0393436046950395, 0.050124995494154945, 0.032593035604799425, 0.17837975607303613, 0.1732209306233673, 0.22621517798591517, 0.07180331921785421, 0.1461371358261675, 0.07894273504673233, 0.108363928568731, 0.07628046218115525, 0.11711835268345983, 0.10235651494836806, 0.1082250866267288, 9.999999999998899e-05, 0.07146501086849744, 9.999999999998899e-05, 0.06142858087200298, 0.2954470942502083, 0.18920237649830385, 0.17993431691947548, 0.1442033490215071, 0.23414041396090501, 0.3028353288358584, 0.19999231213914914, 0.2241116350608101, 0.3281770413536049, 0.0756727769164578, 0.06223169984791488, 0.011624821489302994, 0.1444622181282541, 0.08413963681329295, 0.05940353971265444, 0.13481580351154876, 0.0956347198809977, 0.11559617497965169, 0.18057771501969222, 0.142160229150204, 0.15464872592386858, 0.1579699963320167, 0.22394091573350083, 0.12115644199500075, 0.17675350438203408, 0.22075080258121849, 0.1739555505046978, 0.18613042508833932, 0.20461164675684662, 0.20518061137313437, 0.17111614169523293, 0.20281801431204027, 0.18603982587442325, 0.15795392002599473, 0.22690546883186735, 0.1210383412614634, 0.19821501880457582, 0.20262163889357876, 0.17392606986871362, 0.19871756726744705, 0.15860187970577844, 0.18294965946449815, 0.15564411524878374, 0.15432286989110977, 0.05299472955697093, 0.23070130984670023, 0.26072866778540604, 0.1859809974395752, 0.1945630881927667, 0.22619242803429696, 0.3072022026271587, 0.2605794543424065, 0.19184749048889693, 0.26741366873920525, 0.17738017333802547, 0.19317135156108212, 0.17004336301326384, 0.18026209487716893, 0.17883333645658295, 0.1790702767042931, 0.16952524488996168, 0.19263488218869984, 0.17148941702697573, 0.18627675151181278, 0.11627096577257812, 0.18704724575945164, 0.1734568740187098, 0.19972858975874253, 0.7445097852611846, 0.0828047875729393, 0.13649073127791123, 0.08632418662891139, 0.29604790979435325, 0.10530741754072592, 0.1922772170323115, 0.12657960381152278, 0.16774650629545973, 0.09705045968949211, 0.22977106736152542, 0.16407759947191247, 0.12244278971500766, 0.179674030196332, 0.1774942671767179, 0.2335615592062008, 0.19411998288752108, 0.1770456933547081, 0.2059457328933736, 0.20193158509266906, 0.21211092139769783, 0.207997446592872, 0.07565047139933068, 0.08783874604205588, 0.06819370573291839, 0.08942287667035487, 0.0950062226244982, 0.11140583164895068, 0.10222034717951067, 0.09207044479180726, 0.09792783835331809]}, "mutation_prompt": null}
{"id": "5c1e75e6-8a06-4d29-af82-c46cfa8c7af4", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "aaf720da-3955-4c7b-887b-7a321cdc71de", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adjust mutation factor based on fitness variance\n                self.mutation_factor = 0.5 + 0.5 * np.std(self.fitness) / np.mean(self.fitness)\n                \n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance diversity and maintain exploitation by dynamically adjusting mutation factor based on population's fitness variance.", "configspace": "", "generation": 74, "fitness": 0.2674530728523537, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.7243344697854177, 0.954321678596867, 0.9561575588090797, 0.9363939513340935, 0.9573341119592476, 0.6896235200436074, 0.9643465726122332, 0.8963097675723293, 0.3785453225761206, 0.5845758143327018, 0.8135002797592533, 0.8171942471190176, 0.1271937016773318, 0.5655459890623964, 0.6348309156257375, 0.7522627836555457, 0.4678729117118271, 0.40754817464185755, 0.14935635592455843, 0.1645899065206473, 0.11119351954151657, 0.18798386873191142, 0.11180583185837623, 0.14711445570260717, 0.19072915410392433, 0.14691616172026023, 0.186789732327722, 0.08532922608967619, 0.08768500940026935, 0.1229465185206624, 0.14545442756379523, 0.030237407344585465, 0.09310689675542294, 0.09808866867255095, 0.09254015376183411, 0.11859332724134597, 0.95639101460115, 0.5520548514906227, 0.9818363552990835, 0.9231287181607697, 0.20970413300211665, 0.985238751299808, 0.9883222435067793, 0.28793810167603406, 0.9497567870332605, 0.14299489533198817, 0.23667120758458748, 0.3674254239125825, 0.3142255947995849, 0.23736643285714576, 0.15721912893573475, 0.15082669330526988, 0.14546377144303047, 0.35568278964538236, 0.21171947690533655, 0.36242099953339624, 0.21489949641800898, 0.214727248137903, 0.21412789476767513, 0.3881553589191884, 0.2347502127513611, 0.23760049401138217, 0.22504717519648076, 0.11713936999726215, 0.12996142287287415, 0.14604931062286342, 0.12595738505965381, 0.13191412939627445, 0.3265905293835871, 0.14597965869542873, 0.17410852523656872, 0.14714656759453904, 0.16220993793617888, 0.13145376392136987, 0.1584590470876701, 0.14438891468884008, 0.1384697418460753, 0.1446204123232423, 0.13214085295571698, 0.2429810838692532, 0.15394474316197682, 0.055258276367320835, 0.08132271200210017, 0.021026676295565094, 0.02913393984240542, 0.08484127711112965, 0.040759713995706215, 0.0014429901498419495, 9.999999999998899e-05, 0.008578596028647523, 0.03874936309743293, 0.08049867178404602, 0.0972620749300529, 0.08189558716473877, 0.0814538802142657, 0.07262061392769714, 0.04300136407277422, 0.10225868872928601, 0.11694920090945671, 0.03245690775825749, 0.05532411326608799, 0.18495525627164167, 0.10237887233610987, 0.050128618712481865, 0.08807767098019192, 0.2423141907257106, 0.07566063315555949, 0.10843150707355453, 0.1789542646267801, 0.18149001876364723, 0.18917821056438455, 0.19023627181745417, 0.13740219079585003, 0.07598093999563227, 0.4167649658196759, 0.1553962790607828, 0.36578833018839385, 0.4351016656634048, 0.33901174467520245, 0.48966978618279544, 0.5860604820602898, 0.16859082579513984, 0.48575773696893265, 0.32737683148605223, 0.5592624279892278, 0.5448741817417658, 0.13622143347278182, 0.12563332436310137, 0.14197004355107035, 0.7269461247666705, 0.24554598661873028, 0.15953078638530493, 0.10089998289540003, 0.1233990207349781, 0.31535828451871817, 0.24614834860738732, 0.31889660511698537, 0.29388392790940565, 0.37444923091038007, 0.3073372473439384, 0.2877720045479195, 0.1397579141135793, 0.34537900860245396, 0.2094086384160624, 0.19095300270701931, 0.23306255198804993, 0.2641464696824436, 0.28792502706724077, 0.32959983104621415, 0.3195528129376942, 0.3101850681507008, 0.3982506462569101, 0.2728124098014708, 0.35492397585744306, 0.25291260180452924, 0.31058135772577966, 0.22745054946875376, 0.24138576462896133, 0.17007275056783144, 0.29213477966218593, 0.2405081619042979, 0.24633103140216406, 0.23938622591319492, 0.20950960691034848, 0.23437360809962648, 0.21561777709893548, 0.2555878677001313, 0.21890384405031005, 0.27670711605859455, 0.20629140461501583, 0.2375274427235795, 0.17633431026117197, 0.18724987322863118, 0.211166385760866, 0.25349173327811636, 0.20008550036617723, 0.1936683679690565, 0.20247603269451064, 0.17919926415709997, 0.20296585667369338, 0.3698142723296496, 0.18758428949317418, 0.18827904893610226, 0.1316044068119363, 0.533542126924198, 0.6681130136801938, 0.1232180289471917, 0.13725312470654683, 0.16776090508401298, 0.3686254877246884, 0.2140589136966392, 0.6980301864179329, 0.2140472119161233, 0.16937542087402946, 0.21251615818360658, 0.11274492177415052, 0.20990461230271817, 0.11278389814317047, 0.20344797907271395, 0.18829162711502967, 0.1754541152562621, 0.18846503609652443, 0.19109783080674092, 0.1701245960922566, 0.18301128169334258, 0.20209983349612692, 0.20043182127603032, 0.22163143951435826, 0.10175260609257364, 0.10412304684549545, 0.10342081387822888, 0.08969501126433932, 0.0955609817510985, 0.09765023299216102, 0.09864790671587431, 0.0924910341807248]}, "mutation_prompt": null}
{"id": "368ac764-1c4f-4c47-af3c-3d9f618babdc", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "740c8940-a892-4e3a-bf75-8a8adc06e013", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Introduce Gaussian noise for diversity\n                trial += np.random.normal(0, 0.1, self.dim)\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce diversity by adding small Gaussian noise to trial solutions before evaluation, enhancing exploration capabilities.", "configspace": "", "generation": 76, "fitness": 0.25083996479132326, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.5048605644331975, 0.5028275209394764, 0.4726900274436524, 0.4708202612064105, 0.4837501937543529, 0.47612583156262045, 0.4761037634230558, 0.4715549651328341, 0.4670811350417904, 0.06127925993480443, 0.0888574701915732, 0.06928146461190576, 0.0743396061010646, 0.0745550569758654, 0.06622216660732683, 0.06267276210134354, 0.09635067601130409, 0.10297614911145248, 0.11028268127096563, 0.13819406371459808, 0.15281004972238788, 0.12319781490540249, 0.12437728918791724, 0.14985939593819253, 0.1719717020524968, 0.14323210602903713, 0.1487670618625312, 0.11824441764331806, 0.1134007333208148, 0.10944156185211873, 0.10607682118009998, 0.1251947310670949, 0.1036282298125687, 0.12678624630576285, 0.10168734082947417, 0.10733976599625838, 0.9737900534959558, 0.9824198066251782, 0.9751465018045934, 0.9712674872314309, 0.960212351974254, 0.9581065556028856, 0.9778983382280291, 0.9739852842962585, 0.9337223948547014, 0.3151542035385252, 0.31105711112878653, 0.3339796897116589, 0.34321243852658123, 0.3238329220024835, 0.3509773302414302, 0.32190281250263575, 0.32568894266024595, 0.3286258265414884, 0.668381968391939, 0.675338285872827, 0.6847449757506499, 0.9063936792914026, 0.39137920039197105, 0.21509885453404654, 0.36954225691652887, 0.4175926280240425, 0.6906008936367395, 0.24438604390962737, 0.16442317881306445, 0.13257490921130233, 0.19927391886485457, 0.13374530113149263, 0.16220441438937083, 0.17347760293183057, 0.19003444792034108, 0.202525754258164, 0.18596823927253303, 0.12265796312161925, 0.1986716475376149, 0.1777898636813552, 0.19313505775528828, 0.23527641443537428, 0.20806062575328543, 0.20496752455570455, 0.19731929500204393, 0.026198484201423677, 9.999999999998899e-05, 0.05038790344514943, 0.011400775473420999, 9.999999999998899e-05, 0.020412676462663093, 9.999999999998899e-05, 0.02286657900878286, 0.07389671830666178, 0.15334564619732194, 0.08065750635868862, 0.0878128835733969, 0.05487743285241942, 0.020261324423536453, 0.04617432681182565, 0.13481026512378436, 0.10189319719490231, 0.1034872702684444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13153940386830476, 0.1012588618306145, 0.10346287188951386, 0.1255364511105801, 0.10541607283457921, 0.12087678576445193, 0.11240372951714195, 0.1108023029798958, 0.10052817623160204, 0.470543511653817, 0.4276018400998538, 0.44161155551633424, 0.4397364318141216, 0.4349045320660472, 0.45044613315913107, 0.41833202793766733, 0.44476918819599287, 0.4414159911648742, 0.12085379500005033, 0.1439723009237257, 0.12058220739618497, 0.11143317576993539, 0.10767691412875757, 0.12828561395745675, 0.09788850818392236, 0.12287790418655709, 0.12186252681228982, 0.1564994855235009, 0.18992751064453595, 0.13936616590502438, 0.2468842168812604, 0.223109570076377, 0.19733693053326296, 0.1691006909848325, 0.2519028893294081, 0.1955940173716515, 0.32817990333979363, 0.3084828599163656, 0.32048640876499224, 0.3137824259058878, 0.3081928503142204, 0.30329995113557817, 0.22970183498491892, 0.31715346851321924, 0.31209229129695515, 0.24406622288828428, 0.2591693555208011, 0.1940920141392608, 0.2666067910259635, 0.18729506606618052, 0.2664353462910428, 0.19485306263933866, 0.26570643453236686, 0.24106811244686677, 0.19830858467559542, 0.1977256330860696, 0.1940016026416399, 0.19660000024584479, 0.2105358783186747, 0.21749448244351277, 0.23798311422092422, 0.2987471975479924, 0.2215835101499366, 0.2175435087001184, 0.21462173496506476, 0.21650591514295014, 0.2358276101021981, 0.23121942984958943, 0.22191067755822036, 0.2385210434661491, 0.24270979365289136, 0.2309988846798957, 0.18790342248880398, 0.16613254334368122, 0.14288504237224808, 0.7594765713662087, 0.6840402720746225, 0.1993675764019427, 0.7368684445867597, 0.17014677471763318, 0.17625512503333562, 0.6535320690946496, 0.16983860151765384, 0.5985558570368794, 0.6755888756078506, 0.21094910625430907, 0.615150917545735, 0.1278752064681823, 0.15576240520879614, 0.21306530471627028, 0.18517012484112105, 0.19383204142648414, 0.17703488091184116, 0.19522108705431984, 0.17635973367889024, 0.18851529560121394, 0.17800319785444974, 0.19639439994800256, 0.17892185465936128, 0.09846952328712144, 0.09093504515319928, 0.08867336533163417, 0.09505057217314716, 0.09561841200624621, 0.12152132664291315, 0.09406841726181336, 0.0932746102593448, 0.08806222528697327]}, "mutation_prompt": null}
{"id": "c78eaea6-b1ba-4ab7-ae89-cf548e505ebd", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            self.mutation_factor = 0.5 + 0.3 * (np.std(self.population) / (self.upper_bound - self.lower_bound))  # Adjust mutation factor dynamically\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a dynamic mutation factor adjustment based on population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.3044177425159751, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9536799842930593, 0.9670449630904602, 0.9593549028269424, 0.9619700033022965, 0.9440802415022225, 0.9525301127403483, 0.9509291185250028, 0.2350614583823979, 0.9541073359872021, 0.9191940391432141, 0.5226021844722251, 0.9067530285506706, 0.9106924686733926, 0.8728781287412305, 0.7364217037173793, 0.8689966987899207, 0.15114611248243603, 0.8941031310027365, 0.12664255867343488, 0.13692930562358452, 0.16234429350635715, 0.12654278297390087, 0.13428395610123933, 0.8965708536669521, 0.8888855604455411, 0.1262422890551741, 0.1442081443558303, 0.11157188886866565, 0.10167402693858008, 0.13209681415564012, 0.11903176991132036, 0.0665517843949679, 0.13560999343901825, 0.07108219507821234, 0.12463657653241722, 0.09003844918081905, 0.9875498558926524, 0.9804581047115116, 0.9345993634518589, 0.9562410775947097, 0.9550602572023511, 0.9851432299976236, 0.9882980475180996, 0.9753914456817909, 0.9493358835871465, 0.18379028391206043, 0.11112184637084777, 0.1640280422572601, 0.2273401877596325, 0.29312280967785753, 0.37347227806722993, 0.15672603860446144, 0.1654506796672438, 0.27520729749228645, 0.23063555592906426, 0.18503857562024428, 0.14155188564023813, 0.3680852022956921, 0.17221521696033038, 0.19424148066199487, 0.23915224408059632, 0.23034077384932272, 0.23909560754573034, 0.15227913139237748, 0.15088528383464894, 0.3456735166975071, 0.16701708889856692, 0.13679443707707284, 0.03264053262821054, 0.30386855738200624, 0.1461801624992679, 0.1303194292539851, 0.1377054358464911, 0.1465461671834275, 0.13126255496351336, 0.14793352656047687, 0.1452734643519743, 0.15889957197191706, 0.15992453852695176, 0.1381800677997802, 0.14205131616708933, 0.09294137439392958, 0.08267311086377871, 9.999999999998899e-05, 0.0022796160754849915, 0.01724789684139083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00758230163806306, 0.1950087432176102, 0.1411751629958402, 0.15474167011060747, 0.1532802837094025, 0.13638976616280707, 0.18149649423435332, 0.2198579980333969, 0.14913885425325113, 0.2935458985188075, 0.1926725931947071, 0.13713847763646003, 0.2020933018695127, 0.12828556915580935, 0.09202323208014185, 0.21307781827204375, 0.1489347503776216, 0.12631404473813967, 0.11068216006673426, 0.08998886774567927, 0.11330844850942556, 0.14375596029227578, 0.1944089554665126, 0.10604098086215308, 0.28890993530064557, 0.09464766156218773, 0.1862667954271663, 0.12302366755760308, 0.49082120797262474, 0.4218527895597558, 0.5145253943451735, 0.4255552231125439, 0.5456565250545776, 0.43339872606261776, 0.3828186591376834, 0.40084942160345693, 0.6896323064711667, 0.11504660511555065, 0.09653259583077911, 0.15942250316248918, 0.15926316470410928, 0.1451447892405202, 0.16160252257131635, 0.09398679955259992, 0.13395870108694474, 0.1600992939667074, 0.24354975925976774, 0.2300698781338436, 0.7398821174787307, 0.20308915293398344, 0.2728715793276467, 0.3612176159674938, 0.34554717904514776, 0.2245339726822112, 0.34828335319715953, 0.2823359473661894, 0.3048142666824134, 0.4315459421569603, 0.370470838406581, 0.35157088781693246, 0.42169795006021593, 0.4047856656771639, 0.3552515279235896, 0.21770124623860077, 0.4294416378313164, 0.25435789720251256, 0.3100653295637318, 0.22958929555163565, 0.32819337272114657, 0.2747063513717287, 0.21543967946583586, 0.2568287946053851, 0.3169822893180976, 0.2808101532416929, 0.20795742937818917, 0.21478357556180394, 0.20558774216520137, 0.22976306732717588, 0.19794984952306627, 0.21220986430803135, 0.19624027290656376, 0.21433265829530512, 0.21203373189025043, 0.20420300973354022, 0.1920823550088585, 0.9100334639775689, 0.1896644951095089, 0.2177318442098214, 0.18635224796981265, 0.19946656409548136, 0.22653077436190838, 0.9607416551954239, 0.16562125597038324, 0.18846679802616373, 0.11509470509237685, 0.16935559189069027, 0.9682403948145257, 0.16337484975304428, 0.3342542800518097, 0.1679469275475245, 0.6138494470918259, 0.2141090670974416, 0.4311016076198001, 0.21349091716023494, 0.21188368539185476, 0.212547791943553, 0.11345171978891211, 0.6417668407534372, 0.16773623021945627, 0.17940972813281353, 0.18981263886163136, 0.18271791303618945, 0.18893047862123935, 0.19281867436437117, 0.17530312682156546, 0.18200062127424788, 0.18443725551255474, 0.19804611090556945, 0.11318569363345088, 0.08261157732166136, 0.09246849570433058, 0.09593921348528056, 0.099638975527651, 0.0909127064680848, 0.10200633839708118, 0.0913383391003304, 0.09494756992023445]}, "mutation_prompt": null}
{"id": "5edcdf12-a633-4107-a47a-5948fe368ff0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            # Adjust mutation factor based on the variance of fitness\n            self.mutation_factor = 0.5 + 0.5 * (np.var(self.fitness) / (np.var(self.fitness) + 0.1))\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration by modifying mutation factor based on fitness variance to improve convergence.", "configspace": "", "generation": 78, "fitness": 0.33487655617344675, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.816264099690857, 0.9410205731612067, 0.9449664724837665, 0.595962741553419, 0.9490780075564845, 0.9286481774849734, 0.9481070525136811, 0.19183733111230572, 0.5136491745176377, 0.8934679016978962, 0.8871470016175057, 0.8911439437884576, 0.8818140906776902, 0.8967080647777762, 0.8885155114220231, 0.7509704475721443, 0.9020304278105179, 0.6488179743754421, 0.776177803273624, 0.17550858708427497, 0.18499577248488897, 0.18654027365561343, 0.7981693769940954, 0.18349422892139078, 0.17578351456559504, 0.7606285128262752, 0.6920177909748013, 0.1394923509923356, 0.174274592538333, 0.1422250099037181, 0.16057247725547463, 0.06007681316569402, 0.1443244972696237, 0.14283337877905355, 0.1500401228870074, 0.13918995718699312, 0.9503782614245493, 0.9835110008871457, 0.9790480742698895, 0.7486883113646179, 0.9783533056791499, 0.9895808702511458, 0.9829918370419222, 0.9882312554516461, 0.9756288419371919, 0.3601045521369568, 0.3415951582511726, 0.3383725188328707, 0.3862227492442891, 0.28991272687732483, 0.39349284561584563, 0.40181800139741786, 0.3514997645219726, 0.33827344653488267, 0.39292468884967635, 0.9046698706388487, 0.9110488730435848, 0.21982003858444077, 0.3384502722277801, 0.19407748200964603, 0.40295089155304553, 0.712570411178181, 0.244616698939932, 0.16630463039065946, 0.1405653129149963, 0.1469527235996133, 0.15370138176871717, 0.18960325652014653, 0.1180709894412616, 0.16523626200634223, 0.16466516887200378, 0.1938487592877114, 0.13949469627775357, 0.18637343169822496, 0.1295807036606158, 0.13919295376732166, 0.17046510991149366, 0.15021032709461635, 0.27106994782534644, 0.18520461767314267, 0.18278977623247594, 0.018919099097513437, 0.04093598824930811, 0.10531193194258215, 0.10010139904359516, 0.05373277983915903, 0.030030078220597, 0.005759538562374988, 9.999999999998899e-05, 0.0005595117588415022, 0.09963770743117784, 0.16667672677974466, 0.13714180826277933, 0.08248414520796943, 0.1108787523835626, 0.12151035705887203, 0.06566525408751744, 0.13200985988076086, 0.10881829419384381, 0.12125088764517167, 0.04267882905968767, 0.18997528194972135, 0.086449376369235, 0.08332780011900554, 0.09663159109531594, 0.25481141149250086, 0.12125342397787153, 0.08551498434384297, 0.13964803089716227, 0.37143669431863013, 0.1297139681168108, 0.1795672728908113, 0.5150848745586923, 0.11694635927765662, 0.17289553255826196, 0.08956844501046235, 0.08099010190014266, 0.6032423200959665, 0.5091428966085316, 0.47718567122351674, 0.5266098931896928, 0.5099854586967383, 0.6870098948866887, 0.630295641706256, 0.40474601201318705, 0.5080796997508825, 0.1570797024368198, 0.1562279652655818, 0.1253183442943946, 0.12303498878280184, 0.1514853464113166, 0.1394732526814052, 0.15741992374134062, 0.11352155977314327, 0.1080661410622481, 0.37445113232673355, 0.3169954106348517, 0.21716880037400166, 0.28825613356342106, 0.30581273738484116, 0.20283056389098042, 0.48829649990611357, 0.3768064374170018, 0.16711651635313196, 0.45919479745602754, 0.3090379330803389, 0.5456179314660521, 0.362863628221321, 0.3105752165684823, 0.42983933935645247, 0.33252207599737715, 0.3592508674369981, 0.4146376201741404, 0.46705853834356814, 0.30468226532780696, 0.28672038326417837, 0.2217100187691573, 0.34416103288223, 0.21948852165377553, 0.25604767477567436, 0.3967203370403557, 0.35319962929731585, 0.21315053203881784, 0.2180482552755163, 0.18171224774527295, 0.18114253959729543, 0.2361296324121127, 0.2302883033564087, 0.20972592395987244, 0.2406165337451036, 0.22007382377556883, 0.22787146851996265, 0.8834890259708541, 0.21467841171483204, 0.22404093922907986, 0.7437072974797354, 0.22895807614828378, 0.249229064829959, 0.19870951852983498, 0.2231449911197103, 0.9399984835382639, 0.18743367595145644, 0.2126664119059467, 0.9512038426155371, 0.9344909586705421, 0.16880396408924625, 0.16131236188048625, 0.1678432696527058, 0.14700510448870185, 0.7187075038131427, 0.21367336002285842, 0.5305418431051624, 0.2850055929530264, 0.21268609590338883, 0.1693460610128683, 0.11308097717273213, 0.11835126503385529, 0.21187859072960258, 0.20047019991735482, 0.18157623136413747, 0.17996470016784427, 0.17951247165706097, 0.19002212864552637, 0.17756641084047897, 0.19002773317338606, 0.2495059352942408, 0.1807905671348088, 0.101292747824419, 0.08883923719019926, 0.09488587377648838, 0.10299816584310406, 0.09130047597295776, 0.08996070270406198, 0.08564545909309296, 0.08624436366772803, 0.0883250757856957]}, "mutation_prompt": null}
{"id": "2e08b0e9-8145-4a96-b595-63ec3176132e", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity = np.std(self.population, axis=0)  # Calculate population diversity\n                self.mutation_factor = 0.5 + 0.5 * diversity.mean()  # Dynamic mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Improve convergence by dynamically adjusting the mutation factor based on population diversity.", "configspace": "", "generation": 79, "fitness": 0.271933316771689, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9407712434768034, 0.9450969455175042, 0.9374806110262849, 0.9502378248791676, 0.6695901150323271, 0.9457319929701785, 0.7754415285218346, 0.5607467063937625, 0.6887187022322141, 0.4644872427895197, 0.6948968681722199, 0.8891270235631682, 0.87774202600686, 0.41199868922250193, 0.6428084035731547, 0.7096971512060043, 0.6822708228093822, 0.5731965271015352, 0.16305097312489503, 0.12533614110240177, 0.14233035067429645, 0.1563959959759038, 0.137707645853971, 0.1847836617798414, 0.123320127047162, 0.16104072108522083, 0.17991015022240187, 0.14064979252908616, 0.11456836671609383, 0.13098730999313524, 0.14417818264095716, 0.12710062468743177, 0.1227784861296084, 0.11628559497395596, 0.14029191722591894, 0.13550953304727442, 0.9890421343007088, 0.9824323031862335, 0.9729553760170572, 0.9800212399583496, 0.9917915884776427, 0.9880720656566557, 0.9554122093547841, 0.9644509825320844, 0.9808763755394523, 0.2686755354005955, 0.06173978999359209, 0.3103271191865855, 0.37147549062557095, 0.3106443770207218, 0.17777998054880895, 0.11155051741592781, 0.19122428057729934, 0.08843264253294403, 0.22309584927098913, 0.3435796367644772, 0.2134549971961196, 0.2133471619001429, 0.3749953303050598, 0.2763055762622715, 0.17215021380086093, 0.15093728290059605, 0.17619714977795342, 0.16152954633157768, 0.0997604317187204, 0.1709911761753048, 0.14289438419909917, 0.1837133501891547, 0.12752449721446812, 0.16361208436278885, 0.18986989976759283, 0.15166395533606625, 0.009938305023833527, 0.22744232170003742, 0.009935150234867463, 0.1441006143549043, 0.2559584955196891, 0.17228559335443738, 0.08294493458493557, 9.999999999998899e-05, 0.17432184866667888, 0.0476920339996848, 0.08670693546912756, 9.999999999998899e-05, 9.999999999998899e-05, 0.0724479225801169, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03192355462420515, 0.05490864010360674, 0.08214136958486362, 0.15600841143435062, 0.007572081997420321, 0.032105548582592736, 0.13746719704892185, 0.0887676173455173, 0.10264296421665786, 0.2409287589621808, 0.08336682811548779, 0.1587780457533059, 0.12077177689732121, 0.5405357393200548, 0.1405681876482704, 0.1256872037152098, 0.3015780796563162, 0.1311132539547556, 0.15211488067481715, 0.1564217502760834, 0.08870281295231286, 0.13022249217642512, 0.0535639819895376, 0.11427174689015884, 0.11865401397648401, 0.06132685163923346, 0.19498674768396818, 0.4777268506239528, 0.4868142824845749, 0.4899878064251343, 0.5312551623030363, 0.4426917670299104, 0.4618538833623739, 0.41191927264921024, 0.5696773617161661, 0.48259799638142364, 0.11347821480506104, 0.1290640259958813, 0.18453789614405358, 0.3647192940902486, 0.17240277624012945, 0.10257554922775403, 0.12964718427278343, 0.14911694286613697, 0.11200611653361014, 0.15101983276803965, 0.1463925591516123, 0.14478534462601367, 0.1685945075840124, 0.17599836691177284, 0.1430548283772538, 0.215828267621184, 0.175121922984397, 0.22880441281781172, 0.3119148098280111, 0.35126850112967556, 0.4378641466650677, 0.5417846761504344, 0.2543627595643334, 0.45120222721304426, 0.4035829376191771, 0.2922708231463085, 0.6231956485357321, 0.29276069024204776, 0.23849866774579254, 0.35388338108048867, 0.21881596965822914, 0.38454374140438885, 0.20093753186916496, 0.26108110642601645, 0.3237258636074546, 0.35445940321762615, 0.18445582273355976, 0.19708890478016006, 0.18432694366662572, 0.20601077237126064, 0.19603644119122143, 0.2011119560544774, 0.18947111089452018, 0.19453583740467817, 0.18669887917765748, 0.1911418432242169, 0.22434786411452579, 0.20534863294078165, 0.19718132882809225, 0.20134378618465854, 0.3332747229648988, 0.252097663313508, 0.2067550585034339, 0.22109346572541755, 0.16476383357474222, 0.1715328460685539, 0.16696004705935463, 0.18256552025113681, 0.19666310890757754, 0.11953975645463011, 0.17032650992973086, 0.13479494920360724, 0.18777197978007554, 0.1664123833092752, 0.2111245613927144, 0.16795457573828065, 0.122148898248435, 0.5509679273507451, 0.21105093809916942, 0.15753168593176037, 0.4775201411612491, 0.1936209796110493, 0.194835083821423, 0.20862484338260523, 0.1772306009971718, 0.21194340588205873, 0.19583444128134087, 0.17412834841125746, 0.1904203202443926, 0.19265147606095978, 0.18244235923542096, 0.08343738947475943, 0.09385295368602853, 0.08494743966585916, 0.09766611375385315, 0.09082495663913437, 0.07868126057024016, 0.09146721253376233, 0.08540693597247173, 0.08940707001916759]}, "mutation_prompt": null}
{"id": "3824ef5e-4786-42e0-84d8-6c16ca49a1da", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Update mutation factor dynamically\n                mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)\n                \n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance convergence by incorporating a dynamic mutation factor that decreases as the budget is consumed.", "configspace": "", "generation": 80, "fitness": 0.34997169956177815, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9527155602854759, 0.9439213803462676, 0.9444945901653392, 0.939355390395726, 0.9483196623966764, 0.9450321358071692, 0.9485441097236663, 0.9484160520925496, 0.9442202479366673, 0.9085535895834537, 0.9125770019470465, 0.8929334084904651, 0.898795583050605, 0.9091257619316553, 0.9073921634970483, 0.9071864612417356, 0.8992059407596388, 0.8993133788338745, 0.8006786665500941, 0.18720149495996374, 0.1602179603530952, 0.16296069009051084, 0.8375478651896278, 0.1579958980551197, 0.18285282139750847, 0.15757245764191063, 0.18629953861441828, 0.11890771691804025, 0.1065990131157789, 0.15374246238694245, 0.11137239988749392, 0.1191859959060142, 0.1577034468311065, 0.09701365908179505, 0.0851677720143591, 0.09102085673751303, 0.9622506221206691, 0.9847221407423409, 0.9591031423088562, 0.9694923669690657, 0.9589929911645724, 0.987899627026117, 0.9708666912952195, 0.970594428407583, 0.9659168735613727, 0.7974859298841838, 0.44822405229678897, 0.6270253712481942, 0.7599971702834026, 0.6098036247460841, 0.3844970316733346, 0.4574472504733097, 0.618522632753808, 0.5471534711621816, 0.9331965799891371, 0.39182837281599303, 0.39169657980012973, 0.2146864733928091, 0.2144321134322268, 0.28065500186904, 0.4000715551656534, 0.23551087070749765, 0.2463288650979849, 0.16122008325867498, 0.17498497974640048, 0.16990095957099727, 0.17176548450102658, 0.1363663974113819, 0.20753751666807396, 0.1789360565858038, 0.17413900122196047, 0.16802950116085613, 0.15734390733315107, 0.16017255807979514, 0.1290134235047251, 0.13621991621059626, 0.23940165203291364, 0.14555997719611458, 0.10804935221739709, 0.10628966636709503, 0.1774805358656446, 0.21673973295880622, 0.1059531308027244, 0.03964408876922676, 0.053207359499106266, 0.05104903436966757, 0.026594211733239725, 0.06920702567725145, 0.013409782874592158, 0.1370036090497948, 0.03941276356858325, 0.05762972498520791, 0.11389586070938129, 0.08227060683242726, 0.11807486948203438, 0.033806976674911504, 0.22875372993816667, 0.11367879620468102, 0.11363127447388233, 0.2974805513810185, 0.03858633444265491, 0.34026756781798884, 0.11262353231482647, 0.08524586456437233, 0.10363504791816991, 0.10781077236911807, 9.999999999998899e-05, 0.08311875030083316, 0.22588616205787626, 0.07485505173816254, 0.2833357160191383, 0.15734480819422902, 0.14823265677809228, 0.3019649754848881, 0.3347555966453636, 0.08499647285047063, 0.08302669540745733, 0.6815745835152518, 0.5969282065840685, 0.5863802001964409, 0.64434413428288, 0.6183615300734002, 0.6481489870603583, 0.6681962985741368, 0.660952612351608, 0.6520917491480211, 0.13101040704182665, 0.16997489524399512, 0.11592609856378855, 0.1379232204595281, 0.16166547711410695, 0.14245590124179563, 0.14822309738618333, 0.1414531797399584, 0.16752069612206344, 0.2905599742702477, 0.33307234956637344, 0.45559963693511796, 0.21215766014918613, 0.16661328928496644, 0.23969702211482335, 0.250867617142739, 0.2559750652481416, 0.44694785018785876, 0.30022283789463977, 0.6547659166477319, 0.3167299705792197, 0.4582732154750966, 0.557797509968909, 0.4438968424811828, 0.5014189548641144, 0.5307000069137704, 0.8553511029405921, 0.32504689629316685, 0.3379464036471276, 0.29238526923226293, 0.2708959811125313, 0.28785670950688214, 0.36883449928629053, 0.3089881711583997, 0.21739652912557383, 0.2621300427373734, 0.23298934091955248, 0.21954433133284623, 0.18892590204233284, 0.24056676947603617, 0.18638116506123759, 0.235898985844732, 0.21507747131979138, 0.20438184779644852, 0.21826006217416782, 0.21226801066861434, 0.2552119752994919, 0.2548897498259465, 0.22662058174688904, 0.21513394564797939, 0.20298674104941872, 0.22991315547777436, 0.19293900784661921, 0.19459014054689416, 0.953056488226355, 0.16259895904930177, 0.16412282685175794, 0.17263250329266178, 0.17806679894566202, 0.944995272340463, 0.9271011440960113, 0.16830703370292577, 0.16800303266131045, 0.6919314586341718, 0.2141447781836796, 0.7782212254456594, 0.2130047915049147, 0.16756197130134298, 0.21362239066798738, 0.45376501089768084, 0.16810943777555332, 0.15476268047597408, 0.1774725019025396, 0.18828042481605567, 0.18429571526552935, 0.19146690120757504, 0.18038833155008283, 0.18021702077656176, 0.18407861658353175, 0.17896154594933833, 0.17710448703814452, 0.16783883948887246, 0.11001415823647953, 0.09467597551583862, 0.10719603052269977, 0.09250006255767862, 0.0847994748423514, 0.09002164698346737, 0.08724070850157406, 0.0893040075869842]}, "mutation_prompt": null}
{"id": "ffa3cd17-9a8d-4473-a6ad-ec87f9ea4134", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adaptive Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity = np.std(self.population, axis=0)\n                adaptive_factor = self.mutation_factor * (1 + np.mean(diversity))  # Adaptive mutation scaling\n                mutant = np.clip(a + adaptive_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Incorporate adaptive mutation scaling based on population diversity to enhance exploration capabilities.", "configspace": "", "generation": 81, "fitness": 0.34766302493250384, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9120053368024443, 0.9034710313382386, 0.8992503191586916, 0.9281724651297077, 0.924765223883395, 0.9190266130550455, 0.915681879619065, 0.9242302702220443, 0.9111111071917786, 0.8438299236315852, 0.8529308995843273, 0.8373303336201949, 0.8007747641651635, 0.8376012423029442, 0.819347609409382, 0.8577268684891921, 0.8440952869282065, 0.8261755998335332, 0.16004269126159765, 0.7302067085034804, 0.4379894123110052, 0.6132914656185513, 0.15628819322285503, 0.16551307548134297, 0.575641844600934, 0.1623364090259538, 0.5284735301674616, 0.3519520263568712, 0.1324916694714453, 0.13216774126680175, 0.13897002382111, 0.1434990177886981, 0.13705802946599432, 0.1155789390862283, 0.1632368702545829, 0.5238381695157244, 0.9963087469707348, 0.985974267390778, 0.9963505147264055, 0.9883762506656911, 0.9921694879576217, 0.995233327217213, 0.9789988937263203, 0.9945935054597698, 0.9878546156863919, 0.81553433410456, 0.05964428473292971, 0.7979777538210473, 0.7932106466605239, 0.7657695372634981, 0.7144057341829085, 0.7819029112494459, 0.7981824175521065, 0.7821671265586815, 0.21801691638850407, 0.7867024075622341, 0.7443540445093043, 0.8371410937771293, 0.8325871976590078, 0.8413968182722212, 0.22760524569532092, 0.8632912832055435, 0.34161748284745386, 0.20555526814794378, 0.23326266709784227, 0.208328223917427, 0.23118567896792408, 0.2645711708793189, 0.2273240224160995, 0.24937865132786996, 0.21990790824918416, 0.1260706246714477, 0.022203580721586902, 0.12343189374005181, 0.021951890170695876, 0.2688736449556772, 0.18941377205632903, 0.2064838647554582, 0.14384900812190993, 0.22207156959928842, 0.23697141804207666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00040357580846517305, 9.999999999998899e-05, 0.0366815144369399, 0.006514389842964929, 0.0031961244580388515, 9.999999999998899e-05, 0.04978315192887861, 0.024889776896296456, 0.038750107848037674, 0.06663953654840549, 0.05351170462464472, 0.05046160664045651, 0.019903595940789498, 0.057801749563322624, 0.013488060566079207, 0.03139677478510061, 0.21238340957607638, 0.11652967067989628, 0.11013644696668912, 0.346171842722077, 0.08777813307763505, 0.11330554637107504, 0.08787294750862362, 0.11023635829708311, 0.24034714110216404, 0.13460569370856879, 0.03951350851624991, 0.1147823775242115, 0.22905904110012787, 0.20627360449762056, 0.06135410235833372, 0.2269216816415658, 0.16995781856057124, 0.5785280641071343, 0.5942416959319443, 0.6258165081975827, 0.6524615537252619, 0.6482743557209336, 0.6091908911763573, 0.5784081740797062, 0.6562652952994517, 0.6284443120767019, 0.10306489941521324, 0.10260907883277903, 0.13382840472802304, 0.2713375113231138, 0.1514732016403626, 0.09291871555388664, 0.11254752986633498, 0.0976567017180141, 0.1095735253316179, 0.13958170531418723, 0.1495741929905653, 0.17814934571638918, 0.18080020420311904, 0.1770971842303023, 0.2087198459210804, 0.17412418831138166, 0.1454446932856145, 0.17736613718122185, 0.47887836060615585, 0.45655596401730314, 0.3494063745334812, 0.5435657513836303, 0.5213668789907066, 0.4507013072894869, 0.6813575021563901, 0.5023358843242823, 0.5210401760712661, 0.3403762571063459, 0.3979067104136611, 0.23383672742846318, 0.20499652967172932, 0.21420123492260823, 0.2110872709102104, 0.39279774223284614, 0.35530392634747276, 0.3894238889930465, 0.17536473870673708, 0.16757725565634496, 0.1794058099112985, 0.16344934826485336, 0.17412601574721653, 0.16975839035684315, 0.16953335743927367, 0.18186425020607033, 0.18566350039722834, 0.20054838098981653, 0.7622257614956036, 0.19635872230611007, 0.2047074629442035, 0.21734716554610678, 0.23503781059803408, 0.7590070761978336, 0.7485895673471809, 0.21766552447018583, 0.1814796852195032, 0.1547542455188483, 0.15414451401587537, 0.1871558693249108, 0.18273035067142462, 0.18580823622434128, 0.1476987814919668, 0.1797539536755849, 0.19176640116336507, 0.20891089969444443, 0.20921537141472668, 0.15257785347117137, 0.12393151116520473, 0.1991838902863513, 0.20365402635825847, 0.6250709892719784, 0.20681540431827894, 0.20492886748909245, 0.18075215410969248, 0.18326382830844978, 0.17527540602133884, 0.16514193496438223, 0.17893569877155313, 0.20381833774645097, 0.18445727790935784, 0.1847395570623701, 0.17908805350277668, 0.06756549631229702, 0.06728420607390939, 0.06876072745739781, 0.07771196269711944, 0.06591819064695625, 0.07248862655934185, 0.07035765570135355, 0.07753542907372757, 0.056216160504680035]}, "mutation_prompt": null}
{"id": "5a871054-4b15-4ec6-9ad6-c3d288ccdc8c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            diversity_factor = np.std(self.population, axis=0).mean() / (self.upper_bound - self.lower_bound)  # Change 1\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1 + diversity_factor)  # Change 2\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce adaptive mutation factor based on population diversity to enhance exploration.", "configspace": "", "generation": 82, "fitness": 0.3802133765477819, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.32.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9324035325013647, 0.9380797637422728, 0.9341195155814939, 0.9284937748564305, 0.9491613047564339, 0.9380166443736555, 0.9410949825677212, 0.9414473181870904, 0.9307393892215753, 0.8877246029458178, 0.8976261122199263, 0.8884438171773366, 0.8906485384804705, 0.8897231905885472, 0.8963600911020524, 0.9053973792388337, 0.8966079079333856, 0.8979118221945499, 0.1266515839952419, 0.178937830462505, 0.1588589532838467, 0.15212206279224194, 0.18165727776435492, 0.8301263210430426, 0.16215862397617298, 0.15626296420765406, 0.18216241291181867, 0.11048014151708052, 0.14427845537336492, 0.1161003084701211, 0.1594213232289372, 0.11623539387659443, 0.1415401492843681, 0.14558381050923253, 0.14333464557194497, 0.1228265156747631, 0.9539051646712459, 0.9837396148756276, 0.9712400501442505, 0.9713608810397639, 0.9782412569487939, 0.98957919140473, 0.9785726815454556, 0.9882785531816373, 0.9763781605143376, 0.8120493348484317, 0.8235826398690073, 0.8098331525296727, 0.8662403795447755, 0.8639160730599633, 0.8424664176493409, 0.7979253721653572, 0.833889105064984, 0.8436009548501919, 0.2274894115160584, 0.22946771661483523, 0.34875729752522056, 0.27833338572834065, 0.9046284260001614, 0.21349010305576344, 0.39890562215685876, 0.8042995016024719, 0.8877283115684479, 0.2395617549626865, 0.2188758351305965, 0.2572270532467351, 0.2443988443604892, 0.31564123522090826, 0.21935520099105976, 0.2552022074213335, 0.2205194746082102, 0.21583356456450142, 0.24389461141352975, 0.25987027468152546, 0.27144737427428767, 0.2362833588696287, 0.24522042274665035, 0.18624929431820414, 0.2626233514360373, 0.12683182285344552, 0.2886244633406668, 0.06421279151912551, 0.15065011902132808, 0.05421196063026423, 0.04954740593313123, 0.060294162692580366, 0.008439186627383077, 0.017686854260052898, 9.999999999998899e-05, 0.029161769184347985, 0.04052536351532143, 0.11000310589508477, 0.09315364559748474, 0.048020290118540476, 0.10703349423256592, 0.06452590520039247, 0.15054819533576624, 0.132837878021265, 0.1486216157143252, 0.04179716909554243, 0.1541294019340952, 0.08222616481778278, 0.08736886571452973, 0.08941380710707403, 0.08421821469190749, 0.17260940022214966, 0.11815084170532897, 0.11498161958408581, 0.11330563575722408, 0.09648300962565137, 0.20966072913868727, 0.13340436646118092, 0.23096597005328146, 0.19942146716257103, 0.17443208151415324, 0.09434079455744737, 0.20664165179906135, 0.6505740184428372, 0.7015091485106366, 0.6572182374299693, 0.6407473610122413, 0.6293048415971689, 0.6567573258151218, 0.6510865963056967, 0.6502072985060796, 0.68056299955855, 0.14387693165484727, 0.14135482808060207, 0.07450628395589176, 0.1565745868192251, 0.11803229794951808, 0.08563166442038872, 0.10748804666489764, 0.1414642941068731, 0.15783628639197977, 0.1714289194152745, 0.4544097073912904, 0.12482984521455909, 0.3989498794433691, 0.19475945437240516, 0.2640351316394588, 0.20062424833274162, 0.21346456017165283, 0.16670525226679134, 0.4211033706377725, 0.4520322699380721, 0.6139419523917954, 0.4108809496909477, 0.48446469027545747, 0.3153322755435942, 0.627177228790111, 0.8256360825486002, 0.6354479507129874, 0.4217691687131192, 0.2852029779100379, 0.511573792036503, 0.3253562629686577, 0.26080030974855317, 0.3947232065035092, 0.33487895020218605, 0.47617702901455927, 0.33771690274986765, 0.2091390454156703, 0.19720368421778356, 0.2200187446482682, 0.20693367480242297, 0.20606376920893155, 0.2180633825445285, 0.24799121333411056, 0.20740223881647935, 0.19043294435106195, 0.1961062089666612, 0.22663490168212896, 0.8085447658971578, 0.25342803672621317, 0.22277804469599582, 0.8874455623249231, 0.2519889048003847, 0.8745346982808997, 0.20880394178883444, 0.9163487492047022, 0.1869914720718714, 0.21103424754099542, 0.9143250190336081, 0.9138840443806645, 0.18644790296484814, 0.16420660496532513, 0.1708637325285467, 0.16673242005002975, 0.8218345570690921, 0.21382348458814404, 0.8636709055116681, 0.82329373953, 0.886520871071879, 0.1689340514952855, 0.11334175433123017, 0.11241937808390035, 0.16629101911467148, 0.1766736933189209, 0.1898696955111202, 0.17963316165614018, 0.17483001834319023, 0.186169050497497, 0.18199186037832038, 0.1743377665338387, 0.19469819505129804, 0.1888697490846456, 0.10483239309526304, 0.09445415295622295, 0.09286406433994909, 0.08944869614927375, 0.09407504456413951, 0.09136811482810481, 0.09467176217348461, 0.09529315477388645, 0.08795332901110509]}, "mutation_prompt": null}
{"id": "4d9741e3-8ced-4c41-8a55-9895dc6a5a7f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "7865522e-ceba-43d0-ba48-ec4d29b99a5b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                diversity = np.std(self.population)  # Calculate diversity\n                adaptive_factor = self.mutation_factor * (1 + diversity / np.std(self.population))\n                mutant = np.clip(a + adaptive_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce adaptive mutation factor scaling based on population diversity to enhance exploration-exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.32392900258309304, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.8145697620367469, 0.8195047375535798, 0.8327127240872675, 0.8571223156545639, 0.8544153438954136, 0.8276624848948182, 0.8422099726772536, 0.8741111330167316, 0.8642813728377231, 0.7048368294395672, 0.738383839026064, 0.7491420925786278, 0.7170238497956358, 0.7093651138996964, 0.7293294698724555, 0.7727057233753245, 0.7682215879364193, 0.7197817934937013, 0.15869156537233653, 0.13291012523696044, 0.1387710271287873, 0.12719924717975173, 0.1683260464341647, 0.11468769684708546, 0.29626204019822544, 0.14690098545711894, 0.13561026478649385, 0.11860989136747035, 0.1301032837466608, 0.11914149647760497, 0.10858083092370929, 0.1394820755488767, 0.10338054006374264, 0.13318638903188362, 0.13791047233458054, 0.13978433769483056, 0.9864555910250766, 0.9848314015834916, 0.9806508660477756, 0.974264348423558, 0.9915836627034909, 0.9898751889085942, 0.9896035533445767, 0.9909942122838021, 0.9797658211048159, 0.5650353945120692, 0.6577610072752262, 0.11297593569034381, 0.5032801814497048, 0.6315897358817428, 0.54207013158256, 0.5520013310563834, 0.5947220026680617, 0.5597550892098311, 0.6986076100401692, 0.7148724463372182, 0.6886677808495011, 0.7623643489306259, 0.7231633829190796, 0.648767165858454, 0.6497263648820419, 0.6509281222533728, 0.3577652346478043, 0.27072257884681816, 0.270194023514165, 0.2675872981812728, 0.1978306703619701, 0.28788282334378323, 0.30323030355370717, 0.29569443382186944, 0.2672035346163507, 0.26311887978523896, 0.14441862046687926, 0.016806359836241458, 0.13494732274874444, 0.27967186906261887, 0.2896683192436883, 0.28908261542373237, 0.2732366691924416, 0.27716362964167207, 0.2706977981387717, 0.0024164404405906392, 0.014618957805790478, 0.007089628348722399, 0.05255022089321082, 0.005765062868219317, 9.999999999998899e-05, 0.0007583639809712883, 0.008885921019763932, 0.0006223449967120986, 0.05605977546277263, 0.05258808520347824, 0.03737534897732098, 0.08560640315183177, 0.03315827504390423, 9.999999999998899e-05, 0.08001749095179489, 0.04754240624959216, 0.04399849072837281, 0.05453022757872328, 0.047795534378050064, 0.18491156679060172, 0.13683278863256032, 0.10185955554337034, 0.06109731573522381, 0.1170220737114882, 0.06466748981331127, 0.16885411178014142, 0.12984017536744163, 0.1233058825148643, 0.17091162081519762, 0.17603132241399944, 0.18886926335898302, 0.2622646628779651, 0.18269119438634118, 0.1438424816719467, 0.13411657149856915, 0.5325478314385712, 0.5025805453486722, 0.4977109219746957, 0.5154733977488426, 0.5432911659428102, 0.535285666873597, 0.5154272956912392, 0.5181487171628871, 0.5477570371307823, 0.1174729314115146, 0.1305513564948485, 0.12472694541648421, 0.09706118063754998, 0.13023654148985264, 0.08770414949351779, 0.09965287745576856, 0.09673225189361978, 0.1077205890436086, 0.18313397019342326, 0.16499004890598312, 0.32086691170791926, 0.2694120750337399, 0.18609777858230525, 0.24011599076655077, 0.21976254709756338, 0.16685874305104897, 0.15061563673998413, 0.4133574995450675, 0.4131964875995272, 0.4641669421321639, 0.42786720166193326, 0.21519131587877127, 0.4313429619403649, 0.41424767371496485, 0.4801904540217965, 0.47532038502732243, 0.2993034331096216, 0.34599775650153375, 0.33001456167878007, 0.17879829351898557, 0.28124717492010975, 0.2738405509096047, 0.3566105879781887, 0.3157377421528056, 0.2750430338191475, 0.1882380244301608, 0.17914983393223916, 0.17535063561690256, 0.20073175320322567, 0.17807931084447648, 0.1751196091552507, 0.18224620374184486, 0.19265481632171078, 0.17917644363844187, 0.5321091296274565, 0.5245607081536884, 0.21218018086576407, 0.6919828398118129, 0.21867972331937313, 0.26742856851530883, 0.5669039187411612, 0.21199452237297922, 0.21974432638130115, 0.16504655062232398, 0.16828050375240766, 0.1542365286739783, 0.17496700633368634, 0.16322741847257916, 0.18387118876249164, 0.18471827260002005, 0.1663340850642182, 0.20456260485267785, 0.2094846281861874, 0.211648509505317, 0.20808381725070668, 0.6286123065509399, 0.2078795847518139, 0.6919472432385959, 0.7929386949350399, 0.12728095363054615, 0.20965855978207715, 0.18220625305965, 0.19353050336695332, 0.19209986722484684, 0.18106106691974788, 0.19319665056123447, 0.19452912967194214, 0.18739895168680432, 0.18557212305008364, 0.2269493681582908, 0.06805282348614616, 0.0799858218072661, 0.07463976050470211, 0.08205465616708318, 0.07045875737545015, 0.07162559744894481, 0.06714372691738768, 0.08579320538451085, 0.08499695053724321]}, "mutation_prompt": null}
{"id": "263146e0-b8d9-475c-bc3c-2a18f1d30a52", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            fitness_variance = np.var(self.fitness)  # Calculate fitness variance\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.5 * (fitness_variance / (fitness_variance + 1e-9))  # Adaptive mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance diversity and convergence by adjusting mutation factor adaptively based on fitness variance.", "configspace": "", "generation": 85, "fitness": 0.3906818469235606, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9305000685390681, 0.9239546294643263, 0.8843096913095146, 0.9368864570143853, 0.9257867050141334, 0.9254263369046779, 0.938775091108989, 0.906241583667527, 0.9286382753342988, 0.8881488161483804, 0.8759725559786941, 0.8781252800603034, 0.8812238102277451, 0.8890048291391055, 0.8792067789672267, 0.8811229239478768, 0.8787383929461909, 0.8651890927811043, 0.7871018726601682, 0.18079426463228665, 0.6979990207776412, 0.17668353335537246, 0.77690266545634, 0.7931604772700765, 0.16005103473679394, 0.17939707942185212, 0.14374906456461634, 0.17645676827816636, 0.13815174197079427, 0.13179752404131018, 0.1451165446923658, 0.06724273205345288, 0.15769806174850687, 0.13221178153186242, 0.17292488238313686, 0.1546217940853044, 0.9631250995782422, 0.9835114148133449, 0.9790479015269303, 0.9678743917878254, 0.9790779552113967, 0.9895808858550394, 0.9829918270022924, 0.9882313982394444, 0.9756205415266768, 0.6191106606018627, 0.6745654673893415, 0.6959095424747253, 0.6654545521378772, 0.6068575192616003, 0.6639994072196964, 0.6235030977755677, 0.652919269950121, 0.5726615111312742, 0.35550099806545177, 0.8787939829989592, 0.38931147278768974, 0.21958273818380325, 0.21372012669799456, 0.213278399590493, 0.9005761631302895, 0.8831631624263443, 0.9209439563629909, 0.31321435966236, 0.3365548391715615, 0.34062582886592474, 0.29582065099249355, 0.4005686751192198, 0.127105809858594, 0.36493606125455424, 0.35614746455634705, 0.37937304108311054, 0.26501923646876957, 0.3098415090092085, 0.1355319075965068, 0.3556171000385723, 0.37660210976768926, 0.35464863984700434, 0.34875835406793343, 0.3284973587848007, 0.3390480065945901, 0.03779317023439821, 0.043538591546613326, 0.10582273452542068, 0.11346011375575382, 0.05450805585506857, 0.03002951446425073, 0.008567175385861048, 9.999999999998899e-05, 0.002142010097154312, 0.09750978846856784, 0.15654027966327544, 0.13694970926912664, 0.08082216975371614, 0.11653172346470897, 0.12703900245921973, 0.06570258441907173, 0.13290001067007562, 0.10630864695884579, 0.12144196596125767, 0.04314080945221099, 0.19014559297514755, 0.08647652239389159, 0.08352931611005676, 0.09676315833127214, 0.25490784091256513, 0.12148343670751294, 0.08577930387609833, 0.14278255100077164, 0.3648641620095575, 0.1291119953788582, 0.19856886684884767, 0.28183657627893177, 0.1650221269391201, 0.16545394693140347, 0.09399488226560282, 0.08440082163961038, 0.6396268134537018, 0.6273641880577743, 0.663259631600595, 0.6036547339061158, 0.6149949985742589, 0.6959070576979025, 0.595574080163525, 0.5972688522997227, 0.7115378419577562, 0.11945124953837927, 0.12192679870481149, 0.1552060612150049, 0.11590255289240903, 0.12648699841691835, 0.13267328557174407, 0.11160914193834526, 0.1336044972480266, 0.1081820558813058, 0.16589785751129604, 0.23023031905539337, 0.1550658072596447, 0.1735076446484909, 0.1874899334747382, 0.5846885222573731, 0.47000071576841207, 0.1607497085552202, 0.15564406844029743, 0.4148285041822144, 0.6353800071488159, 0.5718947378317665, 0.6454363748493596, 0.6120511561343701, 0.6214174785323073, 0.7711812869293942, 0.6208983999641234, 0.5554231995174497, 0.5336966191355352, 0.28243609515840173, 0.2763478540180119, 0.21755735609276394, 0.36251583847803903, 0.3132277640446971, 0.36131002234662524, 0.5119343608173361, 0.39455124879352965, 0.20334365252356446, 0.1927329622725943, 0.19531745073693763, 0.2068995809818549, 0.1855693138527944, 0.21365569065695023, 0.2082514192003454, 0.22253072980330513, 0.212837510040484, 0.21004102669154667, 0.8590536174158515, 0.24414364965097723, 0.2228492243546374, 0.22140204935596453, 0.24926955954729968, 0.7558220431834395, 0.7803626206806893, 0.8370662569682119, 0.9297483882566357, 0.18746775501283797, 0.21275199719856264, 0.948566790667733, 0.9110950053713449, 0.18600242657496668, 0.16148502240877638, 0.16751176880151775, 0.14710056847652797, 0.8597196876087575, 0.21359786441241768, 0.7369814417099876, 0.6028092235573024, 0.21267621899727962, 0.1693462542690486, 0.11309784040370163, 0.1277143889610961, 0.2118721996434083, 0.18031031925704555, 0.18460907597184084, 0.18988674484178958, 0.17466039897416485, 0.17875468043404474, 0.18374477218812402, 0.18385573287289603, 0.18560008387999483, 0.18879572782654652, 0.08666138826824044, 0.08225596530732182, 0.08629208201396288, 0.08255146478413822, 0.08591682327388572, 0.07958921632869875, 0.08053513402619972, 0.08233985284228817, 0.08852683640069847]}, "mutation_prompt": null}
{"id": "c509492d-eaa5-4bf9-b32d-9d19e7716583", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9  # Initial crossover probability\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                self.crossover_probability = 0.5 + 0.5 * np.random.rand()  # Self-adaptive crossover probability\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce a self-adaptive crossover probability to balance exploration and exploitation dynamically.", "configspace": "", "generation": 86, "fitness": 0.35802111785688623, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.31.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.944409526232179, 0.9574323908652783, 0.9453510509720706, 0.9474156604611005, 0.9425486160697364, 0.9454995129665101, 0.9390696304635371, 0.9506264140172314, 0.9461099449633545, 0.9110240436859514, 0.9118344427681263, 0.87755950080797, 0.9155022358231918, 0.8946344925444342, 0.9084520152186256, 0.8848842248030911, 0.9085501338105053, 0.9165050209818341, 0.1453651115410406, 0.1902099879930037, 0.16184657249479883, 0.11284738886878809, 0.16356753320789263, 0.12445921728833931, 0.19235654975120875, 0.11856047710780071, 0.14451561412400482, 0.1350233410977495, 0.09389909518356798, 0.13466031232753628, 0.11261048104271776, 0.10221021087342963, 0.0811145033101015, 0.12573886698036008, 0.1256043809263543, 0.08923187013000766, 0.9454769256080047, 0.95335777829577, 0.962174910298881, 0.9549089263451696, 0.9721534161744028, 0.9684421754132164, 0.9587514497998059, 0.967767860951744, 0.9603282470921637, 0.6665604723482974, 0.8222887726847196, 0.8227354415218731, 0.665587352453926, 0.7459090972170499, 0.8333028180035963, 0.7662274572542209, 0.6812966239897353, 0.486829584880372, 0.2277426119250926, 0.2275438779564677, 0.18136017469853616, 0.2222581003012336, 0.3908565781039852, 0.21532574166275065, 0.23687437253962085, 0.2345770408407658, 0.18055879612445747, 0.16742673121494778, 0.20903132290290194, 0.19633072506845006, 0.1837988340334652, 0.17708587017285105, 0.25586596295423725, 0.22186634718913067, 0.1872707808781202, 0.16188270706738472, 0.1697284309764997, 0.13912144559185313, 0.13285308671922869, 0.23020387340603643, 0.21146914234659975, 0.16915028871655646, 0.26179810263473036, 0.22815085194430484, 0.17938080714558124, 0.09510791376965211, 0.0861526672106473, 0.10328286027543654, 0.15936327045365817, 0.0005735507644658577, 0.002988576217845762, 0.00986021275556992, 0.016609114742307085, 0.06271780921865322, 0.054778235552051635, 0.14190329022099324, 0.0611860735093922, 0.031541171772439536, 0.0853342105752789, 0.051072965973708806, 0.14432875006802404, 0.09755732884133517, 0.12558250486874134, 0.0650098564048649, 0.2746207467173455, 0.11024903021466215, 0.17764162382039672, 0.14143789858265443, 0.09240941900874389, 0.07879531706796206, 0.16519652857250622, 0.1498362864890943, 0.14304267289607164, 0.19407499441414333, 0.24578011042616665, 0.2611862892097362, 0.12298033833041444, 0.2504681673069662, 0.2539354072030078, 0.12796282098034406, 0.09325917462162703, 0.6390247778877103, 0.541744609972557, 0.6424640317767601, 0.569396996113312, 0.6505434037078182, 0.5892825941753783, 0.6306642902381422, 0.6249871206122988, 0.6410275868388634, 0.15838534391120063, 0.14003780499908058, 0.1400748901871448, 0.13753727206107946, 0.12926432491697182, 0.13173139968783676, 0.12451480630158218, 0.13078882806065661, 0.11843052634757589, 0.20870265491396633, 0.20094757537669428, 0.480380390812545, 0.4327852852340651, 0.5357716921349256, 0.25492075322699415, 0.2027713420834213, 0.31105340035687357, 0.15338712818446165, 0.281203034351285, 0.5411486864281457, 0.6227905248351393, 0.4446296770574968, 0.3591934771274461, 0.47271699859618854, 0.5236933130213577, 0.41228759522613523, 0.6879798563748996, 0.26745443098509947, 0.3344545323971033, 0.29591681894119215, 0.2927394488709326, 0.24046526630898601, 0.2389079003959318, 0.46828338616989107, 0.3759656156693685, 0.2512664732913168, 0.21586501846748507, 0.22444216030300035, 0.22333756869776855, 0.20382299375772017, 0.18145088391129915, 0.23895385637440714, 0.2137362452816135, 0.2555379089970987, 0.25732494254572447, 0.21188957620744964, 0.21328976730530413, 0.22807210201815187, 0.21768590939436805, 0.8918352891679993, 0.21358708700397677, 0.20056323229669837, 0.8977564300021464, 0.22512956373641224, 0.15963972592260123, 0.9327305461972165, 0.18818078841310848, 0.1794751129206612, 0.9327717947139924, 0.17826815058280832, 0.20873973756388164, 0.9387737547462446, 0.17880219999756386, 0.874844046053042, 0.929350802210046, 0.8917320387547097, 0.2106092140316198, 0.16886553083577893, 0.2131333610424747, 0.7983431686767004, 0.7779430878605367, 0.1564888785810281, 0.18931744649312177, 0.17502455346782864, 0.17836287645949145, 0.16978414706054334, 0.2043568476119394, 0.19610970792035953, 0.18973312793675023, 0.17184741647337176, 0.17733301377838218, 0.08393637277772958, 0.08980617922766665, 0.0884727349212735, 0.08940673083431916, 0.0924004581228075, 0.09314162493977451, 0.08755011576530447, 0.09124601993926862, 0.08737226640793727]}, "mutation_prompt": null}
{"id": "a0766901-cb0c-49fb-80de-c9f658309876", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Apply elitism to retain the best individual across generations, enhancing convergence reliability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.941274146751778, 0.9365358359161502, 0.9448094840562923, 0.9501590858062607, 0.9408234147830575, 0.9385448416245712, 0.9436735408978718, 0.9065182369872543, 0.9364576095058686, 0.9128164263934959, 0.9091541102539997, 0.9042278147603561, 0.8890009713589082, 0.8991700717997639, 0.896614095012116, 0.9137850039682933, 0.9075939810721138, 0.895971754305451, 0.13822644218591484, 0.15594501581774456, 0.18147337782866169, 0.18122091064778012, 0.160944861053824, 0.17989790120531812, 0.17717255487860872, 0.18296764105534757, 0.1564987380403019, 0.15875618474431574, 0.1449728979776933, 0.12535685653504547, 0.16199626429311886, 0.10804913473733546, 0.12592098795687523, 0.1585731723499466, 0.09593161475597045, 0.14041035788016598, 0.9628916823560384, 0.984727289216779, 0.9601812248559861, 0.9688567000681872, 0.9685164820661862, 0.9879309625960011, 0.9788967702305994, 0.9711130838511471, 0.9608158502544345, 0.8149431587713117, 0.8315652869522074, 0.7646349836773205, 0.8498037142875781, 0.793314400596964, 0.8133746262028088, 0.8317549550009717, 0.8480327282086785, 0.7882322315181941, 0.9112409556090874, 0.2386089706432848, 0.36124998106755524, 0.9132917898598203, 0.340413698213364, 0.3815369414257701, 0.2388522633741107, 0.17787012315438133, 0.9119661446091606, 0.2858293221793118, 0.22934978236635706, 0.20798410068208883, 0.253719780432623, 0.13599753081387422, 0.24028566305506704, 0.2400244897171161, 0.20277973343530464, 0.22786485017794056, 0.24538464416842964, 0.23323859820213289, 0.33715228623583315, 0.2430684047099545, 0.220383320891259, 0.24380501162211665, 0.24306992157896923, 0.22533503680497724, 0.23998317439083372, 0.13799383662510734, 0.03405680623622043, 0.10717672828285651, 0.11353184673879257, 0.05671848164278703, 0.09353125997711409, 0.10849825420840042, 0.02217832615874815, 0.04946852326978135, 0.07025987222514318, 0.14897481338364027, 0.11821292033165265, 0.05000447686993503, 0.14196566936785382, 0.07631016624128573, 0.12478500049988783, 0.19755012260669524, 0.16619285796637084, 0.18009925312093344, 0.15187558286353364, 0.27966499268248435, 0.09554556678834503, 0.09130328802988374, 0.6710780917962108, 0.12368110357894568, 9.999999999998899e-05, 0.0892612005260025, 0.24326852912602914, 0.12580735400627108, 0.3162955902632256, 0.17487764337044442, 0.18590117155209485, 0.25192377653816833, 0.2342339065688821, 0.11036220031061272, 0.10473043734184795, 0.589831283096617, 0.6274379881172545, 0.6173635579709378, 0.6468201860048439, 0.6636270486318078, 0.6208517050078295, 0.6787784092147429, 0.689654814014794, 0.6399593193697881, 0.1160600645092329, 0.15725353136013054, 0.14097817821695258, 0.1531481673143077, 0.13685952237875554, 0.11796535527535801, 0.1341077555543314, 0.13952770102529632, 0.14229996162954617, 0.47020052499595955, 0.41981778816535975, 0.3368828103736907, 0.20510369773121995, 0.14152149330434627, 0.5089150433472283, 0.31938231016130436, 0.19731432460373222, 0.27202145605230166, 0.7466369664011502, 0.7579986955646967, 0.3953202614341713, 0.4207869418982163, 0.3472022089077713, 0.4758874757286391, 0.46265084835519843, 0.5874012142531504, 0.8466763427946209, 0.33548658357003647, 0.3937738944923863, 0.3196043543945367, 0.3417589110333429, 0.32264125465613513, 0.3275461631467257, 0.3848806395472967, 0.49069463214016773, 0.46809143534319164, 0.21932712375591168, 0.208071609616036, 0.21173713852283216, 0.20760998405574038, 0.17738286197336328, 0.21412235684363823, 0.21794019848501867, 0.21520986877376314, 0.21108854278259137, 0.21993021053450046, 0.2548583816046175, 0.2558932640767767, 0.2106477825142654, 0.19383166520867967, 0.8279651484549937, 0.8777371538229364, 0.19451125986970208, 0.19090519181829224, 0.9444075799517451, 0.9286140050365329, 0.18544466601515175, 0.17259826066337902, 0.16535138016373552, 0.9540136735543469, 0.934333445047824, 0.9271473991264819, 0.16798029611746224, 0.7926133545477945, 0.2138893958577861, 0.936537860618737, 0.21223442034679463, 0.16798537217075993, 0.2133098746918024, 0.8985535167996375, 0.1686847453944068, 0.15477766945618443, 0.1863959013203389, 0.1857983312620901, 0.17172112296294528, 0.20859343661771135, 0.1943761100781154, 0.18550229412720887, 0.17566439655265154, 0.20204573003077964, 0.20042457673135128, 0.09643921005007738, 0.0895400364150788, 0.08814301858469842, 0.0854822162752773, 0.0977927360167683, 0.0818784689663189, 0.09224203472252157, 0.08952169601424498, 0.09046651570232467]}, "mutation_prompt": null}
{"id": "a418362d-490d-450a-999b-854c6e83f121", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < 0.5:\n                    step_size = self.levy_flight()\n                    mutant = a + step_size * (b - c)\n                else:\n                    mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_rate = 0.9 if self.evaluations < self.budget / 2 else 0.6\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n                \n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        return u / np.abs(v) ** (1 / beta)", "name": "HybridGADE", "description": "Enhance mutation with Lévy flights and integrate a dynamic crossover strategy for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {}, "mutation_prompt": null}
{"id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce random restarts to escape local optima and enhance exploration capabilities.", "configspace": "", "generation": 89, "fitness": 0.3940648930061635, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.32.", "error": "", "parent_id": "fb30b144-a519-441d-890c-17d5595aaeac", "metadata": {"aucs": [0.9343979379489952, 0.930372153798787, 0.9342421404637472, 0.9405862152273745, 0.9348475715432558, 0.9313995136401356, 0.9401851720153613, 0.9350727134160601, 0.9334428604094748, 0.897712177945186, 0.8890967989089439, 0.8833539140489091, 0.8933665225885332, 0.882769321793307, 0.9048847611230567, 0.9003123926858702, 0.8840431587393371, 0.8890668350993021, 0.1647605896812303, 0.16222059270179545, 0.12102475223700426, 0.1604711977111436, 0.14319741547538178, 0.1555266964192752, 0.774722817305591, 0.14345327574547484, 0.7729126042265636, 0.13168335186118674, 0.138518830848819, 0.11904338301882966, 0.14234336383494206, 0.12457110048155551, 0.12813305817674936, 0.15001251407011573, 0.1386363539543649, 0.10419445865941457, 0.980983265103341, 0.9780019952724864, 0.9807354957279043, 0.9901936025091803, 0.9690959245569248, 0.9824054567684151, 0.9783138841156395, 0.9657067995108791, 0.9583365037400495, 0.8073543461460173, 0.8219474668340621, 0.7935353082817399, 0.7936675419902771, 0.810534239543909, 0.79599446173564, 0.8152428766331135, 0.8088092619820287, 0.7580906325713156, 0.8984301301714885, 0.19362449929807635, 0.228481855843784, 0.2102349491029737, 0.2784283513298972, 0.908669201364649, 0.269479857465181, 0.23285758296569037, 0.8926051435099893, 0.27036266926142427, 0.20532820996533063, 0.2354093740120793, 0.22843028147750188, 0.20607528787574014, 0.21192137916366638, 0.25721058744028624, 0.20949797188392139, 0.23579242678311518, 0.2194774352202934, 0.21150201640699928, 0.13368883495070494, 0.2549554305227941, 0.2293347063648178, 0.21178523420923168, 0.24718887359486863, 0.13158389621905264, 0.2368958146004515, 0.04643354686526602, 0.06975599967608614, 0.0820582250484384, 0.05459570859689322, 0.09337382151558582, 0.06489112099304295, 0.08599068588285885, 0.030637941277298353, 0.10359415818612738, 0.05616168015221468, 0.11330580431432369, 0.1115578935966487, 0.08279333228100716, 0.02984155996868665, 0.06536807653044074, 0.17182711422767627, 0.08638017648377605, 0.12505521550806442, 0.14908083912887393, 0.25907121127121957, 0.05842592562680804, 0.12262396118535857, 0.14430444741288284, 0.17639262664573618, 0.20114642181957254, 0.5264598487473222, 0.07889235335547506, 0.09731804880249306, 0.23966142418395409, 0.19071790290969115, 0.21790360855374125, 0.10432756873802196, 0.0920663497391726, 0.3619787511526893, 0.16767560447543006, 0.07363537205800075, 0.6278930346880629, 0.5978756551878623, 0.6194258779481321, 0.6413766420616778, 0.6455064589940549, 0.6302014188839127, 0.6029802525368195, 0.6540060104087994, 0.6231076547348269, 0.1378290759098203, 0.11622605263803254, 0.10336388831448529, 0.12912463816746145, 0.13185057522972654, 0.14202228283110652, 0.1129790383652246, 0.15582720329788902, 0.14702202148314647, 0.18672823791816096, 0.1425125042208667, 0.34480035795299935, 0.24583863561022012, 0.16089751260715024, 0.5304276143286517, 0.16655735215462208, 0.15145626495628817, 0.5609564450990258, 0.3466768355883969, 0.4760715569850017, 0.5429950363703386, 0.4506115099972463, 0.7523301938159234, 0.5451033099529756, 0.6322699544187926, 0.5520005078551125, 0.4967519097989336, 0.42432753869571294, 0.3019013823821731, 0.24564281807815347, 0.45112854341513053, 0.24289168986402665, 0.23613525187967366, 0.26364077812581144, 0.467439219329844, 0.23493068703578113, 0.2267230259768298, 0.22433667856662565, 0.204966080791661, 0.23025376468691583, 0.21683830243420044, 0.20796081181723614, 0.21764879741719556, 0.21971711037738328, 0.20757725907288238, 0.8664156744690896, 0.22279589854824988, 0.19019408941627858, 0.8148833439964032, 0.8463531394589567, 0.8212575892529782, 0.23043362792191024, 0.25122698824779477, 0.20995662048186758, 0.9458959269932219, 0.17057060813958846, 0.9345802438716206, 0.8975240448326207, 0.1996167299579622, 0.954246660191271, 0.1521460075878709, 0.8600305051084134, 0.8935605639608368, 0.9017667217254961, 0.2128018499063522, 0.9085796718093058, 0.2114018842437556, 0.6676549260575604, 0.2122035157586345, 0.11317937257294763, 0.8908562561558926, 0.11294912849282823, 0.18778330563627754, 0.18816471878119734, 0.18785466031837927, 0.17418232234738884, 0.19917613014325608, 0.1762843756620206, 0.17599504851047476, 0.20728256460465166, 0.2002679044777389, 0.08856598352454126, 0.0908387396102589, 0.08095603010649177, 0.09646197230398612, 0.09384679399216023, 0.09544820869896697, 0.07908328988511404, 0.08790949740883136, 0.09908658415800708]}, "mutation_prompt": null}
{"id": "a953516b-c3f3-48e0-b248-65b8e6d6940a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Adaptive Differential Evolution mutation\n                dynamic_mutation_factor = self.mutation_factor + 0.2 * (np.random.rand() - 0.5)  # Line changed\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)  # Line changed\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Dynamic random restart mechanism\n            convergence_metric = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)  # Line changed\n            dynamic_restart_prob = 0.05 + 0.1 * (1 - convergence_metric)  # Line changed\n            if np.random.rand() < dynamic_restart_prob:  # Line changed\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration by introducing adaptive mutation factor and dynamic restart probability based on convergence.", "configspace": "", "generation": 90, "fitness": 0.3676392768202774, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9261120150362933, 0.9349345283172423, 0.9319291948148825, 0.8982287340212515, 0.9325043324444573, 0.9282571448633894, 0.9281297844075876, 0.9148528916490609, 0.915441193577059, 0.8579279044870016, 0.8604576103799405, 0.8891287816877702, 0.8871987158388966, 0.8817693045355807, 0.8766064765883801, 0.8793166934398102, 0.8801778387090092, 0.889575175994228, 0.13509170114999647, 0.5838841156279937, 0.47100106993161694, 0.14323267522848582, 0.8308244056677938, 0.14297822628970536, 0.1698557359371462, 0.18068469498651596, 0.1408561970555844, 0.1561337831529812, 0.15439814315322598, 0.14569728371080415, 0.12204203431125094, 0.1400396809819049, 0.16885088185773345, 0.13202062311392215, 0.09452527713513648, 0.11163596217204597, 0.9676072666670992, 0.9684173545396697, 0.9728722705610579, 0.9638570636004299, 0.9529275594672244, 0.9729032870226507, 0.9556679875533305, 0.9549533903338286, 0.9714002695742601, 0.7877557040842471, 0.8158836601330932, 0.8308046780987319, 0.8193468596223044, 0.7308306124984859, 0.7952172930189179, 0.7843039182306533, 0.7888145736988474, 0.7821615072715905, 0.8635413453927225, 0.8727827149204235, 0.17294073476959038, 0.38086734198013306, 0.21327567511234025, 0.21387595412681792, 0.22323491479700008, 0.24153095232064337, 0.9105390653426179, 0.23801132066814257, 0.2194364092167289, 0.1905645374082745, 0.21326363616828226, 0.22753568730871332, 0.1913288052665283, 0.24789967695370418, 0.1986961510068317, 0.22752914983304295, 0.21925574120417146, 0.22489906921277647, 0.1346806966165317, 0.24261264139166738, 0.2304568681021878, 0.31071717266988386, 0.13256017439520607, 0.23174884616799796, 0.26743811758035707, 0.11959081398110138, 0.03211046069592627, 0.10769636447359499, 0.16241921733401665, 0.1284394754078224, 0.06253690232219411, 0.05403892905865104, 0.06470054600144393, 0.11326134905318008, 0.10683561111670059, 0.10687125615896298, 0.11137722066324973, 0.11594714679874418, 0.11981660442857811, 0.055507733007855165, 0.11920489806696566, 0.14149723882346754, 0.06918509695942399, 0.13750488525440818, 0.04991318537208822, 0.14770509992854208, 0.10677618333371952, 0.1676277440313284, 0.08147745136870399, 0.2551960940263812, 0.2055506134227456, 0.09077304993395696, 0.11814211219962767, 0.32009632291950985, 0.13588028971980237, 0.28832673512316287, 0.06405098858911096, 0.3037150988537971, 0.08828601832523164, 0.08726039250576756, 0.11415852168361484, 0.5869895928559661, 0.5757471778593434, 0.5481723765900981, 0.6335345720450689, 0.5910444774672078, 0.6192883628616023, 0.5957787073777567, 0.6143136681631551, 0.6241090310597242, 0.11172793954847515, 0.1293546966346325, 0.10283409383899433, 0.1473132774491418, 0.15792980273713042, 0.10163994318667424, 0.10405204400211987, 0.10704567293660217, 0.10261893880145145, 0.13512059327583703, 0.1727517465551437, 0.13355439214805775, 0.1473817481293117, 0.14317159831007542, 0.1437084321719132, 0.14451985180952454, 0.13153635492057636, 0.1770912665686385, 0.3948328390853256, 0.7069804752102908, 0.3032181920438428, 0.2882146694098163, 0.2569452886092566, 0.5349908894605426, 0.5821588819441643, 0.47092874777414095, 0.5335110423925239, 0.3979094320571258, 0.2680295878340101, 0.25175344158728363, 0.3195285309400251, 0.24456594468166182, 0.2835188182593933, 0.38917484558897697, 0.45848862135494806, 0.5097916191049553, 0.2020632034464016, 0.21887632752706887, 0.1952213739841555, 0.2236544396123913, 0.19392798245366516, 0.18961747898126247, 0.20672812341596014, 0.1869445400723725, 0.1915334598218147, 0.20900301258099963, 0.7167652875581751, 0.21278902066320393, 0.25523276083691604, 0.20810271616591858, 0.8700419576343623, 0.25125516169488304, 0.2035048941534341, 0.20892181249150632, 0.8771006676275237, 0.1870259953363247, 0.18751370530009137, 0.17429185191971464, 0.21107097668420594, 0.8753290130636846, 0.9263855247471094, 0.20522032331224016, 0.9292348913379815, 0.764503145146582, 0.21295295481058352, 0.8680887911981277, 0.21107185767802128, 0.16756966767410741, 0.7525116344969168, 0.21251941855552425, 0.2083693916589655, 0.3774943004589494, 0.18775304690113814, 0.1795670570470873, 0.18249149999140257, 0.18983862249628336, 0.1736210294765944, 0.18384387392112844, 0.18572844130231492, 0.20628403309402243, 0.2007036311614655, 0.08695244235480182, 0.09148784669117216, 0.08704184357860245, 0.08831206892139032, 0.08992378366980958, 0.08907441020472728, 0.08964526933102313, 0.09187628339976306, 0.08990159978474477]}, "mutation_prompt": null}
{"id": "e4b53fbc-a7d4-45f7-850b-ddb0b290117d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mut_factor = np.random.uniform(0.5, 1.0)  # Adaptive mutation factor\n                mutant = np.clip(a + adaptive_mut_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            if np.random.rand() < 0.05:\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)\n            \n            elite_preservation_idx = np.argmin(self.fitness)\n            self.population[elite_preservation_idx] = self.population[np.argmin(self.fitness)]\n            self.fitness[elite_preservation_idx] = np.min(self.fitness)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration using adaptive parameter tuning and elite preservation.", "configspace": "", "generation": 91, "fitness": 0.3659989470732362, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9342983244261062, 0.9379631058662199, 0.9406248916650232, 0.9379473952060271, 0.9349246869026184, 0.94899308380906, 0.9298377871106818, 0.9441031102792501, 0.9404857818661286, 0.9123172653446494, 0.9013591415210447, 0.8888433799827011, 0.8910944336728094, 0.8771991598169926, 0.885890788291935, 0.9106590513178561, 0.8934758429852335, 0.9044365377380013, 0.17401004624030425, 0.1600193213977007, 0.18693979514972825, 0.18458494515748503, 0.16316284562245287, 0.18647542552790897, 0.1631142052377872, 0.8299938119201475, 0.12459910787999817, 0.12470232458245645, 0.1713108603166834, 0.14094820713936573, 0.14667377050385189, 0.1427904754188496, 0.11001370974776414, 0.14987450528579993, 0.1748044448014905, 0.11080011176591453, 0.9745311725585448, 0.9874334284405717, 0.9771679801070423, 0.9482804987193081, 0.9858926427662229, 0.9743669251422993, 0.9718721070492944, 0.9811276008523663, 0.9439981896009834, 0.7032796088674091, 0.7774217538365286, 0.84290717334978, 0.8303487408958472, 0.7054415539424783, 0.8403394883445529, 0.8370181320689968, 0.7603733859613764, 0.8148536910858151, 0.9396056049592671, 0.9067799276005404, 0.8101262154988669, 0.2145371351544566, 0.16957286124674864, 0.27740433810426623, 0.16812102924399985, 0.15152172378496476, 0.37783320028498424, 0.20118016684334805, 0.1820720332243686, 0.1914660727861951, 0.22113354810020325, 0.19086462152052197, 0.19704647224398264, 0.21896388374663844, 0.13209562173164702, 0.23140595286629606, 0.12999064935595683, 0.19547813116567958, 0.21527538927693324, 0.2114586744614385, 0.38331501679769586, 0.20888885206912722, 0.2236143015021259, 0.21052591681932653, 0.2970831917575252, 0.1099326833635409, 0.10196330177555646, 0.13011793538150518, 0.040251319621873005, 0.01260755802477831, 0.04296953174568274, 0.09712860238861776, 0.056932685031592656, 0.12284546422424503, 0.060236129454098064, 0.1100849504371223, 0.12425835313321054, 0.06652268155662333, 0.1224794573143152, 0.04499194303414078, 0.07453774983440653, 0.10032656719150113, 0.1093511921551058, 0.11718423587294913, 0.04082438112010933, 0.2265975762722091, 0.1058964866089509, 0.24564268204775142, 0.3050339282611422, 0.12431497215554643, 0.21191335142759327, 0.21046113915878972, 0.07827083067156926, 0.09687218229080441, 0.3544521055836227, 0.13695648423438667, 0.14731916927662092, 0.03111062273937293, 0.4021094129861603, 0.1452980316420226, 0.09739615732018991, 0.5814753435325024, 0.6238927665447926, 0.6382595574686174, 0.5873754080599858, 0.6391271233740272, 0.6806561902189036, 0.6764535542336442, 0.6426923981711424, 0.6506220956882693, 0.18567986993523655, 0.18178705077569357, 0.150928518682365, 0.16043847126146826, 0.14048335673033818, 0.14578323715798192, 0.1160790915206189, 0.13953909652411367, 0.1227779261413412, 0.2426162276990006, 0.17743921864229417, 0.231867572021348, 0.21899757267348374, 0.13458648863178513, 0.3836570712523366, 0.1858405759370777, 0.313009098860757, 0.19166591244905662, 0.6876002785197628, 0.31785261542367427, 0.3466110088422465, 0.492149358333849, 0.591763904816744, 0.35606870938487845, 0.43532381573755585, 0.7983454551156686, 0.5647098503519867, 0.2635200051116402, 0.46720921647714686, 0.17795247965113226, 0.26321404523243885, 0.28244624335856683, 0.49442817833268426, 0.36541256130496724, 0.32567306037575205, 0.3781238419378593, 0.2290361688177892, 0.24583591583759545, 0.23032991728930308, 0.21896323326222122, 0.22251959037804137, 0.22442074378268229, 0.2260856420236721, 0.18473086198009459, 0.23943958023805023, 0.21258020797571298, 0.2477227812365107, 0.20846738513729057, 0.23143745498660206, 0.830054027580517, 0.1857543525978238, 0.250303909157212, 0.856677235714087, 0.19743564278884174, 0.15770963572228025, 0.9098742984236172, 0.18552109261267613, 0.17930677202990142, 0.9301236789497869, 0.20060943783288354, 0.931939239057027, 0.1681538733119301, 0.1624766549861626, 0.1692896352150045, 0.9053843403412808, 0.16789113737269568, 0.21255339941191276, 0.21023528133744585, 0.21112935840998248, 0.2128032563765515, 0.21343856495307756, 0.16463081267394286, 0.17891273416219478, 0.20995908110988848, 0.18124358769799487, 0.1756145740689683, 0.18627809499387882, 0.18759124664121518, 0.1758840149020663, 0.1786612399204398, 0.192838593827644, 0.08727185191773257, 0.08816322528787313, 0.0966487555224026, 0.09978970782789165, 0.09698522327834835, 0.08173646191117878, 0.09043544032971063, 0.0939362676700064, 0.08834378187838543]}, "mutation_prompt": null}
{"id": "e2ed8d51-b948-4696-ae2a-86982074cc09", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                dynamic_crossover_prob = 0.5 + 0.4 * np.random.rand()  # Dynamic crossover probability\n                trial = np.where(np.random.rand(self.dim) < dynamic_crossover_prob, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Adjust crossover probability dynamically to enhance exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.3517796160597307, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9466732661756709, 0.9430013754803769, 0.950372066320687, 0.9450451448874873, 0.9451971534345368, 0.9472367245238315, 0.9414452659717241, 0.9402203150780655, 0.9416032359418739, 0.9078612126496178, 0.8937243332235273, 0.883451978467439, 0.8774496562833232, 0.8948095080017147, 0.8924714051148732, 0.9185792394734509, 0.9023461925443518, 0.8997016266324595, 0.09455094186866775, 0.17974687471486228, 0.12764764862330213, 0.19158329946263875, 0.7997411413273656, 0.1562984688061162, 0.18160488385995743, 0.17765032288096294, 0.149789792514625, 0.13839535775839307, 0.14368359185830393, 0.14123067327806582, 0.13720000721913728, 0.1268809060401771, 0.14580131467647184, 0.1353915047678501, 0.11307708538302996, 0.12446073815729053, 0.9755078546099331, 0.9699390374967471, 0.953590582855039, 0.9771104279992401, 0.9715601768897254, 0.971554067729554, 0.9673947217961698, 0.9698638868556466, 0.9610596791038162, 0.8274608600779253, 0.686950438632828, 0.6894851702572701, 0.7896744820223847, 0.7249927532638186, 0.7307554054669536, 0.5960496654938506, 0.770860881979614, 0.4619618238913554, 0.22786720629544, 0.29779628358318877, 0.1406493156385612, 0.21585651213634405, 0.9574859883164716, 0.21383966053242587, 0.3299532070712293, 0.2325278544203525, 0.23470812613581715, 0.16695155772112213, 0.16178519449594186, 0.16904717019426974, 0.17802756208211212, 0.18880961441242394, 0.17340104358555875, 0.14728333564045037, 0.17085518458840254, 0.16164347606329998, 0.1498603664833691, 0.20423463863751945, 0.13516929531693245, 0.182512628045297, 0.15547697108674896, 0.1555927471627383, 0.16592689877620082, 0.20643514018354692, 0.18144721304294065, 0.012628582858618786, 9.999999999998899e-05, 0.0685604199740335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06822559363599012, 0.01613561729719626, 0.11377815669356472, 0.13307025436644493, 0.13973788028396816, 0.08586870547961356, 0.08280964417891046, 0.0633324211895766, 0.10043447400300354, 0.08926699916127856, 0.10288024063669621, 0.06065552950269115, 0.07220689209690623, 0.2889866596366082, 0.17834143563473082, 0.19896577009898542, 0.12599962062703562, 0.25453628949369045, 0.09065458867397813, 0.22331851589059548, 0.20497829721280136, 0.16883788457711058, 0.18616379262797067, 0.1222744352973254, 0.12307316240347499, 0.35613271483754794, 0.16291536240477145, 0.08480644492935063, 0.2935416874726844, 0.5683630445403742, 0.5697507659090207, 0.5310147024072331, 0.6124495787465272, 0.5940423508090794, 0.6138884216797185, 0.6059162744620465, 0.6346850613493946, 0.598296660020061, 0.11779199544757102, 0.11695956103404392, 0.18101213675141758, 0.12823379284014047, 0.13417606604175836, 0.10979113791095663, 0.1806667980174409, 0.11726169778399975, 0.12415567254503035, 0.13390840966719375, 0.6907382917337936, 0.6546958570439018, 0.18245199347055419, 0.169058426433481, 0.36004675932625463, 0.19084795301389745, 0.1707912256504711, 0.1607461885343151, 0.5208126189422082, 0.399529669148568, 0.3956362424679114, 0.28213493648085763, 0.30009188539266574, 0.5644697927798956, 0.5238293030700241, 0.5503454748349581, 0.3872626249364438, 0.5058923053409277, 0.3656132117338138, 0.2967236563950397, 0.2401871336447784, 0.23027189816047688, 0.27353116850048365, 0.3008683998203888, 0.4313959167254662, 0.21515692234258665, 0.26718753382544624, 0.2108450188517289, 0.2002775598804728, 0.2172719455604697, 0.22524333396920382, 0.19620276279997884, 0.22965570180663364, 0.1899094868442387, 0.20475947024168495, 0.8103146403351904, 0.2541011382690682, 0.22877807061922384, 0.1992077978913972, 0.21064174344075715, 0.2125106656854373, 0.24990120838887642, 0.18309274320564195, 0.17832452708415059, 0.15949799206816773, 0.18833445639665025, 0.1125854909815387, 0.17939682187756756, 0.17065771165357668, 0.2375283969709524, 0.9171340106138068, 0.8940465073346937, 0.9253450118125115, 0.9105796488444898, 0.21172809401698622, 0.21224304866616983, 0.21084900699723286, 0.21170783138081684, 0.6899525754544573, 0.41692348977131055, 0.35462831609350876, 0.8743428266225471, 0.19626774752876341, 0.20060443837204966, 0.18629166278893727, 0.17744545958790037, 0.17840239899635113, 0.17970674135587905, 0.20273695134693337, 0.20479293370947127, 0.19643393627896089, 0.0890696612477142, 0.09788411952103038, 0.10511098162034338, 0.1070657546655992, 0.0922766570489102, 0.09732910814557161, 0.10028679488172854, 0.09522477354863201, 0.08580794346334042]}, "mutation_prompt": null}
{"id": "e8e1c0b3-246c-447c-b579-da19baa6ebbf", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover with adaptive probability\n                dynamic_crossover_probability = 0.9 * (1 - self.evaluations / self.budget)\n                trial = np.where(np.random.rand(self.dim) < dynamic_crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Improve exploration by altering crossover probability adaptively based on function evaluations.", "configspace": "", "generation": 93, "fitness": 0.36302556908803857, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.30.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9315308391299351, 0.9319503310245908, 0.9388539574678044, 0.9397309366372363, 0.9340779970285931, 0.9424209975607255, 0.9410663610723244, 0.9300465129534755, 0.9351640232176371, 0.9048209677572953, 0.893744634204941, 0.8703425542308109, 0.8859463726341579, 0.8850287060615061, 0.9071751338580895, 0.9064577295244401, 0.8816087212390091, 0.894685810580665, 0.16026373053981346, 0.18594959262323185, 0.16000601062345354, 0.15584788396133298, 0.5006021483719318, 0.18030245877350748, 0.7592491165101416, 0.520368865184993, 0.18773130691952378, 0.1650020423470553, 0.10483853960081924, 0.1520856839783784, 0.13552194185808253, 0.18225221776306055, 0.142024298466357, 0.7828507049237212, 0.1422688882512757, 0.1263284768515769, 0.9698347293077029, 0.9750821754547336, 0.9807354957279043, 0.9901934848621368, 0.9611007745535595, 0.9825502386270193, 0.9785321092466923, 0.9777141176134335, 0.9644713302988092, 0.8049791052409456, 0.6477535596024462, 0.8569399262706782, 0.5262309195950421, 0.3598373966408548, 0.679627114125142, 0.4055289442692479, 0.5985171432763357, 0.4808526622842534, 0.8923994019993176, 0.16946109922691122, 0.25460579161187624, 0.1944970637648996, 0.2803873724399989, 0.28333473472709025, 0.8846257412788945, 0.24034659335215236, 0.7958405775100471, 0.17895296621910128, 0.16660274241539008, 0.20591521466203067, 0.17875776851042624, 0.1782030625455049, 0.17205019967256918, 0.17209056637546472, 0.15476807464286668, 0.17972506462986515, 0.18557446825308554, 0.20747713115073763, 0.15542147213093527, 0.3304899733349089, 0.13258725082163236, 0.16171290256366633, 0.1345434931963333, 0.2090380740121669, 0.21463055232418615, 0.05839755535519564, 9.999999999998899e-05, 0.08491984214508397, 0.0782480520126484, 0.01480688387776885, 0.039000463004797536, 0.06337803765001027, 9.999999999998899e-05, 0.07623251197144476, 0.08097654443557423, 0.08514633771998192, 0.08056888076852098, 0.019090705265273233, 0.04723575790375034, 0.05481380893723986, 0.038708848465451084, 0.1519202502806083, 0.04500364370419829, 0.21615874742753383, 0.17565405946329993, 0.07588503670358537, 0.08431108345524485, 0.16113095076238138, 0.10478197451795201, 0.1074591182214415, 0.24536020369695022, 0.0999059781460836, 0.27191914651517957, 0.20221551810713922, 0.3189660894658557, 0.16161900664877826, 0.2176248379142115, 0.06061549099625485, 0.18619927471588993, 0.1239383843535341, 0.06781023847237988, 0.5698380397356071, 0.5732931396055705, 0.687305487304826, 0.6762141799761003, 0.5508654639929335, 0.6325009554758774, 0.6127119695051232, 0.5972062822979023, 0.6563000080568353, 0.11520214500425896, 0.108462177825009, 0.14022630588511764, 0.15723161063445767, 0.1496857495049475, 0.15879026043675382, 0.13002620700002898, 0.5948229491107754, 0.12010400601762516, 0.27447453989592174, 0.1904188627076554, 0.2426513631446684, 0.252089999342783, 0.20019534777689763, 0.261499939502159, 0.1974902923089552, 0.25350585053746544, 0.1828228144940458, 0.5058956156164607, 0.40532191004801044, 0.41402134014377256, 0.5225425539267967, 0.5330715942326388, 0.5757308496951878, 0.5732574542692789, 0.5071159959571183, 0.4392746765416202, 0.30255092380656223, 0.4803554601578657, 0.25878325519478007, 0.46641649686670916, 0.30499469337794083, 0.23689688288670052, 0.4406572764559781, 0.2775166796694448, 0.30500725542394536, 0.21754872553276905, 0.23009314357415633, 0.20107405990065896, 0.1955969450771199, 0.21347331224981003, 0.24937184778576127, 0.22223817980763783, 0.20207643944669906, 0.21081657583151592, 0.8781582287652088, 0.22420667848870135, 0.25026182526979057, 0.25407142228973434, 0.23059792406131974, 0.20184928913254463, 0.22534347098381413, 0.2513246273845523, 0.21034458438706594, 0.9412362342745922, 0.16570222585592675, 0.925308888810104, 0.9387201843362487, 0.17010963721681782, 0.955120377405453, 0.1531687060230148, 0.16941744256750457, 0.9144467807279492, 0.1563151368513782, 0.21259887244326692, 0.5715105657810369, 0.21316008993047708, 0.47442053081996716, 0.21270371488479456, 0.1131941850732221, 0.396371357974038, 0.11295606992695006, 0.18249315091136586, 0.18416682023514974, 0.17739808297856963, 0.18236415739546785, 0.1869985033020407, 0.1783416378913506, 0.19393558382983123, 0.18134873151219844, 0.20370341256764157, 0.10080915768252596, 0.08900609337895582, 0.128700674735714, 0.0973915582710857, 0.09292367190417494, 0.09347014529655284, 0.10377628984657261, 0.09441984688671456, 0.08914992498597762]}, "mutation_prompt": null}
{"id": "125c9a63-6f65-40b0-8a33-f4f44808beca", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            fitness_variance = np.var(self.fitness)  # Compute fitness variance\n            adaptive_mutation_factor = self.mutation_factor * (1 + fitness_variance)  # Adaptive mutation scaling\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Incorporate adaptive mutation scaling based on fitness variance to improve convergence.", "configspace": "", "generation": 94, "fitness": 0.14565753342333818, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.22.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.1507497361292699, 0.16440186646382948, 0.14429228400133065, 0.8096340757300897, 0.6043267935828553, 0.7791847146534634, 0.7317917970712098, 0.20161439292565242, 0.20943993636678493, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03624896345843631, 0.031865498008044724, 0.04004411534518404, 0.034919548378021914, 0.031917162644767294, 0.03740619563285452, 0.03771031816416015, 0.05613699571792585, 0.05265915735912152, 0.03324886667681326, 0.026185934483228257, 0.02374407413790136, 0.03769730623886558, 0.04300723925768746, 0.016266293251024355, 0.012788520390040192, 0.024897646478470037, 0.024629759206934998, 0.9963069860450116, 0.9865325974075194, 0.9963744065986014, 0.9896275176525152, 0.9843423747095361, 0.9958762624919663, 0.9925668400676066, 0.9961002232733426, 0.9921743129780434, 0.05867420582935867, 0.0711926664692093, 0.04531132763380863, 0.031888523751847586, 0.07772136095542992, 0.03935932997829017, 0.052675836127150766, 0.08791098110607831, 0.07769718810610082, 0.12278174496226824, 0.08731631464314016, 0.10434191645755786, 0.11289765867817225, 0.11936812906363592, 0.09674269256772028, 0.09611760936807567, 0.11244876883514188, 0.10570165246176477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011086463096530164, 9.999999999998899e-05, 0.00356044974209746, 9.999999999998899e-05, 0.003149332925581616, 0.02010448186522551, 0.035017416615528596, 0.015792784839076757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006997574860708733, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031848322181981525, 0.028219304978870374, 9.999999999998899e-05, 0.03204697628494746, 0.0625367853260217, 0.0329202184770333, 0.038503416391485024, 0.03675006924406987, 0.007786805456908352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009652872076392205, 9.999999999998899e-05, 9.999999999998899e-05, 0.013990570739044084, 9.999999999998899e-05, 9.999999999998899e-05, 0.006793503782205668, 0.00039867271166071916, 0.0020383036839706214, 0.43969100715904497, 0.18283466595806108, 0.24465773628865062, 0.4452318849701604, 0.2061039777277569, 0.36014332364430546, 0.5522395370785121, 0.27353132474459907, 0.23446038992326146, 0.05225595716792142, 0.04160108908722471, 0.05401577048094819, 0.055607674243341676, 0.03002237834947974, 0.04825518271980456, 0.060485876119865445, 0.048304786257436505, 0.032342035319406603, 0.15739438986811582, 0.1510058709439318, 0.14475594247168355, 0.14883516460573287, 0.15296505874781596, 0.14610201313816984, 0.23697935280382643, 0.11650485052050297, 0.17680190031798138, 0.5969480599780218, 0.18721241762791163, 0.21703161249650038, 0.2132151034797487, 0.17605557563507845, 0.16779769546267886, 0.6234698091665701, 0.20844451594974966, 0.4915338517023834, 0.11063094417335828, 0.10178565687020236, 0.07854995442132817, 0.09943101073984895, 0.12479608897400396, 0.11198072088947897, 0.10749164520039411, 0.11274277005431299, 0.11364643225685411, 0.16299175272333977, 0.16625394803256843, 0.14637271665747376, 0.15148665846831122, 0.16108363428802808, 0.1404803901267716, 0.13718685066313918, 0.14685059494055608, 0.1519382236869089, 0.12090167224630166, 0.1143669525690657, 0.050258507739803226, 0.14562814711794003, 0.1304729117087552, 0.0915387703699404, 0.06570043979028506, 0.09693178028133898, 0.1372830029881299, 0.1126310594751112, 0.15356677291142518, 0.12926040603402456, 0.5977324844618227, 0.1207914665021157, 0.2554070285243012, 0.17568031343504698, 0.15083963142740797, 0.1730272215297215, 0.14903492199974822, 0.1632710452462206, 0.14287348359014773, 0.10763966890038823, 0.15715297829741848, 0.09775731181195024, 0.19278841659193724, 0.19190828252255554, 0.20247774310990974, 0.18209555283504464, 0.2005168112849679, 0.1718420252370646, 0.17691327827489878, 0.17803189815406606, 0.20291858443923416, 0.19228815969160984, 0.1725730863732604, 0.179904249835396, 0.029536049661563313, 0.032106616630188545, 0.04732340588151818, 0.04319430232610577, 0.04354138814939179, 0.04973650986338385, 0.04002487036358471, 0.04427628113782045, 0.04235422657414545]}, "mutation_prompt": null}
{"id": "d6fb2aa3-bfbc-49ee-8796-37933355d685", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using crowding distance to maintain diversity\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Integrate crowding distance and diversity maintenance to enhance exploration and solution spread.", "configspace": "", "generation": 95, "fitness": 0.3940648930061635, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.32.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9343979379489952, 0.930372153798787, 0.9342421404637472, 0.9405862152273745, 0.9348475715432558, 0.9313995136401356, 0.9401851720153613, 0.9350727134160601, 0.9334428604094748, 0.897712177945186, 0.8890967989089439, 0.8833539140489091, 0.8933665225885332, 0.882769321793307, 0.9048847611230567, 0.9003123926858702, 0.8840431587393371, 0.8890668350993021, 0.1647605896812303, 0.16222059270179545, 0.12102475223700426, 0.1604711977111436, 0.14319741547538178, 0.1555266964192752, 0.774722817305591, 0.14345327574547484, 0.7729126042265636, 0.13168335186118674, 0.138518830848819, 0.11904338301882966, 0.14234336383494206, 0.12457110048155551, 0.12813305817674936, 0.15001251407011573, 0.1386363539543649, 0.10419445865941457, 0.980983265103341, 0.9780019952724864, 0.9807354957279043, 0.9901936025091803, 0.9690959245569248, 0.9824054567684151, 0.9783138841156395, 0.9657067995108791, 0.9583365037400495, 0.8073543461460173, 0.8219474668340621, 0.7935353082817399, 0.7936675419902771, 0.810534239543909, 0.79599446173564, 0.8152428766331135, 0.8088092619820287, 0.7580906325713156, 0.8984301301714885, 0.19362449929807635, 0.228481855843784, 0.2102349491029737, 0.2784283513298972, 0.908669201364649, 0.269479857465181, 0.23285758296569037, 0.8926051435099893, 0.27036266926142427, 0.20532820996533063, 0.2354093740120793, 0.22843028147750188, 0.20607528787574014, 0.21192137916366638, 0.25721058744028624, 0.20949797188392139, 0.23579242678311518, 0.2194774352202934, 0.21150201640699928, 0.13368883495070494, 0.2549554305227941, 0.2293347063648178, 0.21178523420923168, 0.24718887359486863, 0.13158389621905264, 0.2368958146004515, 0.04643354686526602, 0.06975599967608614, 0.0820582250484384, 0.05459570859689322, 0.09337382151558582, 0.06489112099304295, 0.08599068588285885, 0.030637941277298353, 0.10359415818612738, 0.05616168015221468, 0.11330580431432369, 0.1115578935966487, 0.08279333228100716, 0.02984155996868665, 0.06536807653044074, 0.17182711422767627, 0.08638017648377605, 0.12505521550806442, 0.14908083912887393, 0.25907121127121957, 0.05842592562680804, 0.12262396118535857, 0.14430444741288284, 0.17639262664573618, 0.20114642181957254, 0.5264598487473222, 0.07889235335547506, 0.09731804880249306, 0.23966142418395409, 0.19071790290969115, 0.21790360855374125, 0.10432756873802196, 0.0920663497391726, 0.3619787511526893, 0.16767560447543006, 0.07363537205800075, 0.6278930346880629, 0.5978756551878623, 0.6194258779481321, 0.6413766420616778, 0.6455064589940549, 0.6302014188839127, 0.6029802525368195, 0.6540060104087994, 0.6231076547348269, 0.1378290759098203, 0.11622605263803254, 0.10336388831448529, 0.12912463816746145, 0.13185057522972654, 0.14202228283110652, 0.1129790383652246, 0.15582720329788902, 0.14702202148314647, 0.18672823791816096, 0.1425125042208667, 0.34480035795299935, 0.24583863561022012, 0.16089751260715024, 0.5304276143286517, 0.16655735215462208, 0.15145626495628817, 0.5609564450990258, 0.3466768355883969, 0.4760715569850017, 0.5429950363703386, 0.4506115099972463, 0.7523301938159234, 0.5451033099529756, 0.6322699544187926, 0.5520005078551125, 0.4967519097989336, 0.42432753869571294, 0.3019013823821731, 0.24564281807815347, 0.45112854341513053, 0.24289168986402665, 0.23613525187967366, 0.26364077812581144, 0.467439219329844, 0.23493068703578113, 0.2267230259768298, 0.22433667856662565, 0.204966080791661, 0.23025376468691583, 0.21683830243420044, 0.20796081181723614, 0.21764879741719556, 0.21971711037738328, 0.20757725907288238, 0.8664156744690896, 0.22279589854824988, 0.19019408941627858, 0.8148833439964032, 0.8463531394589567, 0.8212575892529782, 0.23043362792191024, 0.25122698824779477, 0.20995662048186758, 0.9458959269932219, 0.17057060813958846, 0.9345802438716206, 0.8975240448326207, 0.1996167299579622, 0.954246660191271, 0.1521460075878709, 0.8600305051084134, 0.8935605639608368, 0.9017667217254961, 0.2128018499063522, 0.9085796718093058, 0.2114018842437556, 0.6676549260575604, 0.2122035157586345, 0.11317937257294763, 0.8908562561558926, 0.11294912849282823, 0.18778330563627754, 0.18816471878119734, 0.18785466031837927, 0.17418232234738884, 0.19917613014325608, 0.1762843756620206, 0.17599504851047476, 0.20728256460465166, 0.2002679044777389, 0.08856598352454126, 0.0908387396102589, 0.08095603010649177, 0.09646197230398612, 0.09384679399216023, 0.09544820869896697, 0.07908328988511404, 0.08790949740883136, 0.09908658415800708]}, "mutation_prompt": null}
{"id": "9f7b4f22-9da6-485d-b730-048ceaca0f78", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.7  # Changed from 0.8 for dynamic adaptability\n        self.crossover_probability = 0.95  # Changed from 0.9 for increased crossover diversity\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            if np.random.rand() < 0.05:\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Incorporate dynamic mutation and crossover strategies to enhance diversity and convergence speed.", "configspace": "", "generation": 96, "fitness": 0.35349498475416435, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9457222903624771, 0.9478857745556488, 0.9430194327878615, 0.949245797493862, 0.945899763937584, 0.9469845881305395, 0.9478744932942136, 0.9424280235071238, 0.9444848025773275, 0.9088737833057189, 0.8865323193790008, 0.8937029672091898, 0.9001428680176224, 0.8654992925000566, 0.8913523092796181, 0.9018395785220081, 0.8895517465430586, 0.8785400668379454, 0.14389781785643374, 0.15372108600558332, 0.1831989744156297, 0.16208134304344024, 0.15667992870286307, 0.1750120651913708, 0.1307359529819152, 0.15982666454727645, 0.17146258097259726, 0.11058534062031089, 0.1307776566906943, 0.16122904929901982, 0.14885685857631892, 0.10953098074774148, 0.13048836171577383, 0.14874148703178924, 0.10880862342420494, 0.13285506398240376, 0.9875619655918103, 0.9660007768838105, 0.9510921211047277, 0.9802239449600229, 0.995559872065897, 0.9924988772947996, 0.9456939182945316, 0.9669197791369001, 0.9451398023021289, 0.7617131227320567, 0.45601704119838693, 0.784515260765868, 0.8432818320765229, 0.631977091048002, 0.8024533431619449, 0.7782040565440598, 0.6628924865686242, 0.8340455609973361, 0.1417277406053976, 0.16540243790140996, 0.17157420142565183, 0.28252092835477227, 0.22226962106260284, 0.21513809129536032, 0.7343585246312627, 0.2294136840133102, 0.9110451570355924, 0.17626728886751475, 0.17407330809897525, 0.19009911657190826, 0.17863866320477373, 0.13516807618474524, 0.23195394961604654, 0.13305105323180288, 0.18409775539856377, 0.1995798176909389, 0.24914923877522177, 0.18845535061893715, 0.236421128699018, 0.1833749363326147, 0.1579915918160234, 0.17473345351166447, 0.24970935818094087, 0.21497231722992005, 0.13501065174235305, 0.11174315267724233, 0.034983817925148264, 0.08921545630087624, 0.06774386868153748, 0.11388840246026899, 0.07622844989568767, 0.17480734675103105, 0.0954135704870972, 0.07702756073966155, 0.1349277717211591, 0.14099110159802708, 0.1235497405020538, 0.16620365822066308, 0.11628033868196308, 0.11069303250267581, 0.10627877837466548, 0.17071787737146282, 0.1517815905024852, 0.1918806112208976, 0.1068997761621373, 0.24792538497245487, 0.2541036039731275, 0.13222890138717014, 0.11115271710022057, 0.23152846840583097, 0.13950059663411452, 0.08056672497404016, 0.11849949964843853, 0.12021455690453697, 0.16886546293156157, 0.21533409279540616, 0.3598829035006269, 0.09669617838226041, 0.34095229538698557, 0.12136011751676923, 0.08901956401041222, 0.5648651645009644, 0.578097532017828, 0.7015374456318373, 0.5770606216853594, 0.6750768466579937, 0.7131226098112973, 0.670997681766069, 0.6665072579991244, 0.6408752530765751, 0.09407416591094064, 0.13466300186299995, 0.132599867536087, 0.12476020167173574, 0.12402456437213838, 0.11108078789972753, 0.13430432086404254, 0.13989115981667632, 0.1502318822954556, 0.1346042309695218, 0.12508976546269246, 0.14874661187545413, 0.13078280723349123, 0.1406845617190151, 0.2317516259199347, 0.13541675105666362, 0.2262074146514148, 0.2562099261113234, 0.36151743679379367, 0.5864350820472851, 0.34589082614951616, 0.3339361860063277, 0.43884872844952183, 0.4618137394939956, 0.3840056235474829, 0.4429161406403951, 0.3194091795763846, 0.33483854059954576, 0.2818486188303525, 0.24033337141567734, 0.375452592112854, 0.3139156026022313, 0.2553147207646447, 0.519897885173785, 0.552320102299465, 0.21968205116402317, 0.2269926382748566, 0.22836012698309682, 0.21154096030442404, 0.22304228358868305, 0.21211163255871635, 0.21959312470314052, 0.22436185266028763, 0.20681675713029568, 0.20384830306969848, 0.22300268550480906, 0.2470825925036213, 0.1941952212544733, 0.23005963320982237, 0.19076330181188528, 0.19889126396566303, 0.20362888619508146, 0.25239037608542936, 0.20365704345596924, 0.9276663539030112, 0.1655166412913993, 0.15306325361260498, 0.9386387553339733, 0.17802135257663665, 0.20048926908346576, 0.15307068116552613, 0.9273252727361377, 0.8998596065682397, 0.9018899318610697, 0.1699107882047305, 0.8003030682277037, 0.2117107685232572, 0.16842164634828982, 0.21173247920876848, 0.11348610571057449, 0.6166306170118803, 0.9033036682259087, 0.17311460645801235, 0.19841874718988473, 0.17650718444881108, 0.17539003816329457, 0.19095672305846434, 0.191868587257789, 0.17960453188629966, 0.18535352386231863, 0.1751064978865381, 0.09144492712868546, 0.08557802854951391, 0.08910829350544447, 0.08595535580712876, 0.09214794219675682, 0.1154609841366433, 0.0979174869659255, 0.09433227088534624, 0.09448654644419585]}, "mutation_prompt": null}
{"id": "26b39ee4-1ea7-4bdd-b23a-85e1575b726f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce random restarts to escape local optima and enhance exploration capabilities.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9343979379489952, 0.930372153798787, 0.9342421404637472, 0.9405862152273745, 0.9348475715432558, 0.9313995136401356, 0.9401851720153613, 0.9350727134160601, 0.9334428604094748, 0.897712177945186, 0.8890967989089439, 0.8833539140489091, 0.8933665225885332, 0.882769321793307, 0.9048847611230567, 0.9003123926858702, 0.8840431587393371, 0.8890668350993021, 0.1647605896812303, 0.16222059270179545, 0.12102475223700426, 0.1604711977111436, 0.14319741547538178, 0.1555266964192752, 0.774722817305591, 0.14345327574547484, 0.7729126042265636, 0.13168335186118674, 0.138518830848819, 0.11904338301882966, 0.14234336383494206, 0.12457110048155551, 0.12813305817674936, 0.15001251407011573, 0.1386363539543649, 0.10419445865941457, 0.980983265103341, 0.9780019952724864, 0.9807354957279043, 0.9901936025091803, 0.9690959245569248, 0.9824054567684151, 0.9783138841156395, 0.9657067995108791, 0.9583365037400495, 0.8073543461460173, 0.8219474668340621, 0.7935353082817399, 0.7936675419902771, 0.810534239543909, 0.79599446173564, 0.8152428766331135, 0.8088092619820287, 0.7580906325713156, 0.8984301301714885, 0.19362449929807635, 0.228481855843784, 0.2102349491029737, 0.2784283513298972, 0.908669201364649, 0.269479857465181, 0.23285758296569037, 0.8926051435099893, 0.27036266926142427, 0.20532820996533063, 0.2354093740120793, 0.22843028147750188, 0.20607528787574014, 0.21192137916366638, 0.25721058744028624, 0.20949797188392139, 0.23579242678311518, 0.2194774352202934, 0.21150201640699928, 0.13368883495070494, 0.2549554305227941, 0.2293347063648178, 0.21178523420923168, 0.24718887359486863, 0.13158389621905264, 0.2368958146004515, 0.04643354686526602, 0.06975599967608614, 0.0820582250484384, 0.05459570859689322, 0.09337382151558582, 0.06489112099304295, 0.08599068588285885, 0.030637941277298353, 0.10359415818612738, 0.05616168015221468, 0.11330580431432369, 0.1115578935966487, 0.08279333228100716, 0.02984155996868665, 0.06536807653044074, 0.17182711422767627, 0.08638017648377605, 0.12505521550806442, 0.14908083912887393, 0.25907121127121957, 0.05842592562680804, 0.12262396118535857, 0.14430444741288284, 0.17639262664573618, 0.20114642181957254, 0.5264598487473222, 0.07889235335547506, 0.09731804880249306, 0.23966142418395409, 0.19071790290969115, 0.21790360855374125, 0.10432756873802196, 0.0920663497391726, 0.3619787511526893, 0.16767560447543006, 0.07363537205800075, 0.6278930346880629, 0.5978756551878623, 0.6194258779481321, 0.6413766420616778, 0.6455064589940549, 0.6302014188839127, 0.6029802525368195, 0.6540060104087994, 0.6231076547348269, 0.1378290759098203, 0.11622605263803254, 0.10336388831448529, 0.12912463816746145, 0.13185057522972654, 0.14202228283110652, 0.1129790383652246, 0.15582720329788902, 0.14702202148314647, 0.18672823791816096, 0.1425125042208667, 0.34480035795299935, 0.24583863561022012, 0.16089751260715024, 0.5304276143286517, 0.16655735215462208, 0.15145626495628817, 0.5609564450990258, 0.3466768355883969, 0.4760715569850017, 0.5429950363703386, 0.4506115099972463, 0.7523301938159234, 0.5451033099529756, 0.6322699544187926, 0.5520005078551125, 0.4967519097989336, 0.42432753869571294, 0.3019013823821731, 0.24564281807815347, 0.45112854341513053, 0.24289168986402665, 0.23613525187967366, 0.26364077812581144, 0.467439219329844, 0.23493068703578113, 0.2267230259768298, 0.22433667856662565, 0.204966080791661, 0.23025376468691583, 0.21683830243420044, 0.20796081181723614, 0.21764879741719556, 0.21971711037738328, 0.20757725907288238, 0.8664156744690896, 0.22279589854824988, 0.19019408941627858, 0.8148833439964032, 0.8463531394589567, 0.8212575892529782, 0.23043362792191024, 0.25122698824779477, 0.20995662048186758, 0.9458959269932219, 0.17057060813958846, 0.9345802438716206, 0.8975240448326207, 0.1996167299579622, 0.954246660191271, 0.1521460075878709, 0.8600305051084134, 0.8935605639608368, 0.9017667217254961, 0.2128018499063522, 0.9085796718093058, 0.2114018842437556, 0.6676549260575604, 0.2122035157586345, 0.11317937257294763, 0.8908562561558926, 0.11294912849282823, 0.18778330563627754, 0.18816471878119734, 0.18785466031837927, 0.17418232234738884, 0.19917613014325608, 0.1762843756620206, 0.17599504851047476, 0.20728256460465166, 0.2002679044777389, 0.08856598352454126, 0.0908387396102589, 0.08095603010649177, 0.09646197230398612, 0.09384679399216023, 0.09544820869896697, 0.07908328988511404, 0.08790949740883136, 0.09908658415800708]}, "mutation_prompt": null}
{"id": "b7b0cd75-1468-4bd0-be0d-a22d639883d1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                diversity = np.std(self.population)\n                adaptive_crossover_prob = min(1.0, max(0.1, self.crossover_probability * (1 + diversity)))  # Change line\n                trial = np.where(np.random.rand(self.dim) < adaptive_crossover_prob, mutant, self.population[i])  # Change line\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Enhance exploration by adapting crossover probability dynamically based on diversity.", "configspace": "", "generation": 98, "fitness": 0.39010760197295263, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.31.", "error": "", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9281502402857434, 0.9151185141349589, 0.9282922826169183, 0.9279506138298454, 0.9328969550699242, 0.935448564957643, 0.9310618292192556, 0.9312194689821055, 0.9334117171340393, 0.8864440697668695, 0.8757200393159696, 0.8774265108591558, 0.8816206822661621, 0.8836891246733704, 0.8663189045055089, 0.8991729533257157, 0.8890572994113031, 0.8433471412613357, 0.12258605786711363, 0.18110619922150217, 0.7444185648521786, 0.14448061027166947, 0.12612140345121226, 0.1812364649668563, 0.13089916692833525, 0.7594661826484626, 0.15821107989037697, 0.09658248269936265, 0.10866204640870669, 0.12463554826715428, 0.15852751399801268, 0.15021125300330818, 0.12364650938232846, 0.10942446662471661, 0.14786472220882896, 0.13691550911493866, 0.9878871826970603, 0.9689717025887511, 0.9712520872652847, 0.9811821500914611, 0.9955844505971343, 0.9873986810675202, 0.944292089970753, 0.9688175324025219, 0.9555330124019936, 0.8064563786500479, 0.8170612386103513, 0.779924775987399, 0.7972286821635863, 0.8222381648658336, 0.8273830311109605, 0.7629190541491551, 0.834630051050344, 0.7991981274003988, 0.9213021782643603, 0.168419078681324, 0.9427988878228348, 0.9047164171700116, 0.2813424785433787, 0.2814271049433904, 0.9211239831810494, 0.9195636439313571, 0.23757625903910784, 0.30761516460717564, 0.3056357802800762, 0.3054728038878657, 0.12405201130394705, 0.48912379050857024, 0.27915411561067416, 0.30718962269503336, 0.26583404059243154, 0.28596216379792627, 0.2976048941054906, 0.3040688901015871, 0.25007674392834667, 0.32922511889414063, 0.3462272689111392, 0.3114880335957044, 0.33679387390562787, 0.2952664334035081, 0.2819435189690477, 0.08584380521854817, 0.08131808003676921, 0.09734809493026131, 0.17569224366307157, 0.059035725743929124, 0.05365252223435091, 0.0933566739144529, 0.01591762150032061, 0.10649459419039209, 0.11828650756726589, 0.12699552744468567, 0.15369425948172089, 0.12021470349919816, 0.06733718822426671, 0.09010187802439473, 0.1407564189648921, 0.15915575631395973, 0.13391825188991058, 0.04441751505561009, 0.1302142094205908, 0.12663390890894133, 0.12500640858615464, 0.14783329748151408, 0.265072012346663, 0.09373521558428288, 0.2474717254103561, 0.132710856524627, 0.05321868750235659, 0.14363011531863956, 0.21340308889515636, 0.16971517174041506, 0.1336265701409035, 0.25960471915872907, 0.10517191567642259, 0.06220018854571552, 0.3049507537022791, 0.6544315080189973, 0.6595689138883827, 0.64852438701382, 0.6533190966422642, 0.7034046822938601, 0.6549808286081653, 0.6929849056316064, 0.6838912410007905, 0.6832844720097919, 0.15792439037773764, 0.10951556889608349, 0.13537835996340797, 0.13045192557052598, 0.11600277883631516, 0.15369869677510417, 0.564160353742404, 0.13837246817600657, 0.11688969051209575, 0.27620833055837657, 0.4224499017883966, 0.13813118793096257, 0.584049155609163, 0.14686383762448663, 0.16406581075929494, 0.15586731487740668, 0.14866366848177692, 0.28631943895179157, 0.3588467114587074, 0.45907548800213094, 0.44614799286904705, 0.8288729210831416, 0.4946721362959986, 0.592304087667656, 0.8253234758629323, 0.7880198222855263, 0.6680894310436661, 0.4111989562844508, 0.30009367622460437, 0.4124510433772762, 0.2627088702033128, 0.3402111765164032, 0.6762548449171224, 0.5257990027310049, 0.3080516831856417, 0.3189625522184525, 0.1857061695149509, 0.22661606462839523, 0.19006159655188004, 0.2053557084677322, 0.21950946031476393, 0.21213908622933675, 0.206575624900312, 0.20105936234759714, 0.19061937715209798, 0.22076172812602413, 0.24697393437369042, 0.22686023154492674, 0.2541085190015526, 0.25294854442308223, 0.2422142667981778, 0.865454817182525, 0.22395201755273442, 0.2080412478328736, 0.18625893870011545, 0.16492723099215223, 0.15386888466340953, 0.9211114434600164, 0.18844926980171772, 0.16988964928422556, 0.46196688076454406, 0.8987225268289252, 0.16736528960780028, 0.8617713807075275, 0.7353765638351712, 0.8334728550930446, 0.167757433985402, 0.1670867971139094, 0.167122517611772, 0.15712081796266464, 0.1282864637943283, 0.1050016583749046, 0.18673713567115324, 0.18033976547283204, 0.1835025896743787, 0.17631884764108785, 0.1780364442179413, 0.17581501516290776, 0.18588246129896102, 0.17993739659911256, 0.18970782075659098, 0.09108249638191357, 0.08170710736275555, 0.08825108326310294, 0.09022529904157894, 0.09560121869415128, 0.08163283032673829, 0.0832373779806681, 0.0957059443064483, 0.09047844600676547]}, "mutation_prompt": null}
{"id": "527a6ab7-ff91-4a9c-8e84-5d55efe5e663", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.restart_threshold = 0.2 * self.population_size  # Allow some room for random restarts\n\n    def __call__(self, func):\n        # Initialize population fitness\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)  # Track the best individual\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_probability, mutant, self.population[i])\n                \n                # Adaptive neighborhood search\n                neighbors_idx = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                local_best = self.population[neighbors_idx[np.argmin(self.fitness[neighbors_idx])]]\n                trial = np.where(np.random.rand(self.dim) < 0.5, trial, local_best + np.random.rand(self.dim) * (trial - local_best))\n                \n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                # Selection using tournament selection\n                opponent_idx = np.random.randint(self.population_size)\n                if trial_fitness < self.fitness[opponent_idx]:\n                    self.population[opponent_idx] = trial\n                    self.fitness[opponent_idx] = trial_fitness\n            \n            # Ensure the best individual is retained\n            if np.min(self.fitness) < self.fitness[best_idx]:\n                self.population[best_idx], self.fitness[best_idx] = self.population[np.argmin(self.fitness)], np.min(self.fitness)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.05:  # 5% chance to randomly restart a part of the population\n                restart_indices = np.random.choice(self.population_size, int(self.restart_threshold), replace=False)\n                self.population[restart_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(restart_indices), self.dim))\n                self.evaluate_population(func)  # Re-evaluate those individuals\n\n        # Return the best solution found\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "HybridGADE", "description": "Introduce random restarts to escape local optima and enhance exploration capabilities.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6d8f8b4-0a93-4a62-8c7f-9ac83b9385fc", "metadata": {"aucs": [0.9343979379489952, 0.930372153798787, 0.9342421404637472, 0.9405862152273745, 0.9348475715432558, 0.9313995136401356, 0.9401851720153613, 0.9350727134160601, 0.9334428604094748, 0.897712177945186, 0.8890967989089439, 0.8833539140489091, 0.8933665225885332, 0.882769321793307, 0.9048847611230567, 0.9003123926858702, 0.8840431587393371, 0.8890668350993021, 0.1647605896812303, 0.16222059270179545, 0.12102475223700426, 0.1604711977111436, 0.14319741547538178, 0.1555266964192752, 0.774722817305591, 0.14345327574547484, 0.7729126042265636, 0.13168335186118674, 0.138518830848819, 0.11904338301882966, 0.14234336383494206, 0.12457110048155551, 0.12813305817674936, 0.15001251407011573, 0.1386363539543649, 0.10419445865941457, 0.980983265103341, 0.9780019952724864, 0.9807354957279043, 0.9901936025091803, 0.9690959245569248, 0.9824054567684151, 0.9783138841156395, 0.9657067995108791, 0.9583365037400495, 0.8073543461460173, 0.8219474668340621, 0.7935353082817399, 0.7936675419902771, 0.810534239543909, 0.79599446173564, 0.8152428766331135, 0.8088092619820287, 0.7580906325713156, 0.8984301301714885, 0.19362449929807635, 0.228481855843784, 0.2102349491029737, 0.2784283513298972, 0.908669201364649, 0.269479857465181, 0.23285758296569037, 0.8926051435099893, 0.27036266926142427, 0.20532820996533063, 0.2354093740120793, 0.22843028147750188, 0.20607528787574014, 0.21192137916366638, 0.25721058744028624, 0.20949797188392139, 0.23579242678311518, 0.2194774352202934, 0.21150201640699928, 0.13368883495070494, 0.2549554305227941, 0.2293347063648178, 0.21178523420923168, 0.24718887359486863, 0.13158389621905264, 0.2368958146004515, 0.04643354686526602, 0.06975599967608614, 0.0820582250484384, 0.05459570859689322, 0.09337382151558582, 0.06489112099304295, 0.08599068588285885, 0.030637941277298353, 0.10359415818612738, 0.05616168015221468, 0.11330580431432369, 0.1115578935966487, 0.08279333228100716, 0.02984155996868665, 0.06536807653044074, 0.17182711422767627, 0.08638017648377605, 0.12505521550806442, 0.14908083912887393, 0.25907121127121957, 0.05842592562680804, 0.12262396118535857, 0.14430444741288284, 0.17639262664573618, 0.20114642181957254, 0.5264598487473222, 0.07889235335547506, 0.09731804880249306, 0.23966142418395409, 0.19071790290969115, 0.21790360855374125, 0.10432756873802196, 0.0920663497391726, 0.3619787511526893, 0.16767560447543006, 0.07363537205800075, 0.6278930346880629, 0.5978756551878623, 0.6194258779481321, 0.6413766420616778, 0.6455064589940549, 0.6302014188839127, 0.6029802525368195, 0.6540060104087994, 0.6231076547348269, 0.1378290759098203, 0.11622605263803254, 0.10336388831448529, 0.12912463816746145, 0.13185057522972654, 0.14202228283110652, 0.1129790383652246, 0.15582720329788902, 0.14702202148314647, 0.18672823791816096, 0.1425125042208667, 0.34480035795299935, 0.24583863561022012, 0.16089751260715024, 0.5304276143286517, 0.16655735215462208, 0.15145626495628817, 0.5609564450990258, 0.3466768355883969, 0.4760715569850017, 0.5429950363703386, 0.4506115099972463, 0.7523301938159234, 0.5451033099529756, 0.6322699544187926, 0.5520005078551125, 0.4967519097989336, 0.42432753869571294, 0.3019013823821731, 0.24564281807815347, 0.45112854341513053, 0.24289168986402665, 0.23613525187967366, 0.26364077812581144, 0.467439219329844, 0.23493068703578113, 0.2267230259768298, 0.22433667856662565, 0.204966080791661, 0.23025376468691583, 0.21683830243420044, 0.20796081181723614, 0.21764879741719556, 0.21971711037738328, 0.20757725907288238, 0.8664156744690896, 0.22279589854824988, 0.19019408941627858, 0.8148833439964032, 0.8463531394589567, 0.8212575892529782, 0.23043362792191024, 0.25122698824779477, 0.20995662048186758, 0.9458959269932219, 0.17057060813958846, 0.9345802438716206, 0.8975240448326207, 0.1996167299579622, 0.954246660191271, 0.1521460075878709, 0.8600305051084134, 0.8935605639608368, 0.9017667217254961, 0.2128018499063522, 0.9085796718093058, 0.2114018842437556, 0.6676549260575604, 0.2122035157586345, 0.11317937257294763, 0.8908562561558926, 0.11294912849282823, 0.18778330563627754, 0.18816471878119734, 0.18785466031837927, 0.17418232234738884, 0.19917613014325608, 0.1762843756620206, 0.17599504851047476, 0.20728256460465166, 0.2002679044777389, 0.08856598352454126, 0.0908387396102589, 0.08095603010649177, 0.09646197230398612, 0.09384679399216023, 0.09544820869896697, 0.07908328988511404, 0.08790949740883136, 0.09908658415800708]}, "mutation_prompt": null}
