{"id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.2566151625515662, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "f89189e7-25ee-49b2-b3a8-5f36f9658d68", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        inertia_weight = 0.9 - 0.5 * (self.current_evaluations / self.budget)  # Dynamic inertia weight\n        velocities = inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced a dynamic inertia weight adjustment to enhance convergence speed and avoid local optima.", "configspace": "", "generation": 1, "fitness": 0.24369413774230708, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.6259514055986111, 0.6000943191868451, 0.636851819377833, 0.18224606401562082, 0.6818584873197633, 0.6602160777317412, 0.6441639695387902, 0.6392273387775014, 0.6290279929434357, 0.0531126174200246, 0.032496092375372654, 0.3821484117365841, 0.27616025461749083, 0.3283242250268815, 0.35943187502027063, 0.2098522363619595, 0.35212459014154474, 0.033658546554795055, 0.09629694549429424, 0.08739834167676785, 0.11416662648347553, 0.11332434495045651, 0.10126227779737162, 0.1164437617013444, 0.10542421686497017, 0.12481109015433889, 0.0973544160879859, 0.09082905891642801, 0.09468526697729562, 0.09230022585237363, 0.0916421947803292, 0.09694988641964886, 0.10376616462028232, 0.12727200115404502, 0.11097575050831587, 0.09860506725377494, 0.9876512823995681, 0.9833030802668493, 0.9861423397045546, 0.9685398814760723, 0.9820360449571339, 0.9813262500563722, 0.9846161098602986, 0.9841621990880127, 0.9819647393766691, 0.32228886758012243, 0.32351206177429803, 0.20925274560177431, 0.30772199242054143, 0.34359993992562754, 0.3289709567357455, 0.22197982259287996, 0.314986774145657, 0.08889092236470919, 0.41726304133022285, 0.41076030674741815, 0.4963660362478155, 0.5129326105879405, 0.20315950230668745, 0.23904423812651066, 0.45457641769158774, 0.32134497286798847, 0.37249172613526105, 0.15787077133097505, 0.1450370057978727, 0.1478302091574435, 0.08905423437051063, 0.16553229235264066, 0.1557833036569809, 0.1518970697596742, 0.16921323653123999, 0.15772526788296382, 0.09030995400101871, 0.18208858163057884, 0.18012837017867056, 0.19381160056136493, 0.149019195368982, 0.16676111323087028, 0.16127234070292706, 0.026520841164150655, 0.15960308620554042, 0.008793805446896452, 0.007403843695945711, 0.012774053791241968, 0.03479897160233436, 0.0006374201473070551, 0.0014032401325928534, 0.008132191767990293, 0.00199690743380343, 0.026207071401033732, 0.08368944779865928, 0.09399947277954035, 0.0912288702751759, 0.08890768614529987, 0.016410050441124757, 0.0855268645573195, 0.0694157546845241, 0.12040813698189778, 0.09260299878340994, 9.999999999998899e-05, 9.999999999998899e-05, 0.028936401291666525, 0.043720505580611135, 0.04797416772748697, 0.04362149787653702, 0.059593838136364874, 0.0567463629946755, 0.052351462791278, 0.10129358124478871, 0.14872096937929713, 0.08385711230973758, 0.005123564401890546, 0.08464302112392819, 0.14976094562229514, 0.1038395228912199, 0.07064851401563133, 0.07281288523779272, 0.47178263627121664, 0.4572473219249956, 0.4707311636730188, 0.4631657222481257, 0.4769738926538346, 0.4508861014336074, 0.46835911330011404, 0.4649255381704559, 0.46356545725566034, 0.08052587892407215, 0.0970647242956596, 0.11749622664013804, 0.10153738735410078, 0.09451490573225785, 0.09571458889076656, 0.08955543912691233, 0.0766229413187588, 0.10793751152241327, 0.18071710113963468, 0.1730609165596767, 0.28098848850776015, 0.21313523665287182, 0.2084517391851104, 0.184735287060951, 0.297725762346279, 0.16883159957309213, 0.18313487108833337, 0.28928688987254114, 0.3678675724619005, 0.3469918991505837, 0.29127412782890627, 0.3065001273530008, 0.28112980280531386, 0.36533524534263007, 0.3831651084266574, 0.3578057956201014, 0.22358008058100898, 0.20413266786126005, 0.2003231198959161, 0.2301852279639578, 0.2693713534983423, 0.21557743638864668, 0.20948672758058196, 0.2790805869247929, 0.29956088299684125, 0.19615374812189568, 0.20062029936964876, 0.21676635108135756, 0.19130043390602336, 0.20250630156617666, 0.18860718073557592, 0.19526477730969094, 0.18345535404400304, 0.170689041330788, 0.1869002534509273, 0.20253407873671558, 0.1838101340164362, 0.21863596163949206, 0.19459904021125551, 0.20012208297654877, 0.2245658082303038, 0.2043149705239118, 0.3222198997899772, 0.6635878052102197, 0.164821268668932, 0.15065744779393575, 0.18079088345507277, 0.6254272366137272, 0.1298917832397929, 0.18813187035226042, 0.6043666028523845, 0.6504191025350472, 0.473467872573052, 0.20900761508445753, 0.5746500518881134, 0.20030632291893347, 0.4989370569647281, 0.14992298457434827, 0.19841993532422475, 0.18688602823604283, 0.14845707445931766, 0.18363162531627242, 0.18642199636467627, 0.17716076082593957, 0.1705970380415518, 0.18759119754305142, 0.17320403904213855, 0.17858893536359122, 0.1877693364649914, 0.18974066021015912, 0.07185768393117764, 0.08111996020412093, 0.08199758298771143, 0.08003271765374442, 0.07356813552995067, 0.07614790621581835, 0.0802135602561852, 0.06799116314970799, 0.08206414986683463]}, "mutation_prompt": null}
{"id": "5719140e-73a8-4bc8-aa41-fc56e365347c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "34017215-0f24-4b3a-81ed-2eadfd352a2a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "6c182f3f-7cfc-4ce7-833e-db6f2194842e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "1f7b3230-f02e-4557-bbc8-0ecda47f0a26", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "3f2524c0-d126-4bad-98f0-ae27930a08d9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.1 + 0.4 * (1 - self.current_evaluations / self.budget)\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:  # Adaptive mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduce adaptive mutation probability to balance exploration and exploitation dynamically.", "configspace": "", "generation": 6, "fitness": 0.2246497535318469, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.5556477907170132, 0.5105519469088173, 0.5365601667112991, 0.5607896019246335, 0.5555714430367277, 0.5811701031637169, 0.5509244653587273, 0.5185924273905889, 0.5411602331431362, 0.2417561560904654, 0.2999234790322932, 0.22947224625970164, 0.26799837923925274, 0.26344952906559793, 0.2405855232999614, 0.24505623166870827, 0.24594766789368627, 0.24697656797453105, 0.1038814640486444, 0.0925099968271954, 0.08582540337870692, 0.08428554462747251, 0.08339944289891954, 0.07915424386269898, 0.09322613474203922, 0.08059706515168186, 0.08100645296833175, 0.08399959499262455, 0.0876363548307505, 0.0833426094398263, 0.09832768904316724, 0.08092371815209776, 0.07036652005889987, 0.09058380891670659, 0.07655879189583792, 0.07726548858310966, 0.9856572059940228, 0.9762811458286035, 0.983061526740314, 0.9857616529389733, 0.985662785207099, 0.9851240851416174, 0.9847519403528622, 0.9806605917117719, 0.9833535012718585, 0.22610817305691766, 0.23100593505948575, 0.23857690572546264, 0.2472742564146484, 0.2380574948640326, 0.23369797350028143, 0.2637414172745073, 0.28017556547469136, 0.2705374307599894, 0.3803924579603819, 0.39872922756792417, 0.2707108855497651, 0.4390908794364262, 0.3161903097897514, 0.3136551026698505, 0.3874009682772708, 0.41179050682912954, 0.355845704050205, 0.12682106838419127, 0.13636635117215934, 0.14230352213812258, 0.1147509764536071, 0.15556235584970202, 0.12936925861694526, 0.13764085906939594, 0.134846285035098, 0.13366758042559246, 0.11156682878865976, 0.1154842293374222, 0.13237077889908266, 0.1288283760943938, 0.13111065414529133, 0.11666896788299674, 0.14684409151859112, 0.11802787760552036, 0.13916323944212838, 0.0520667553042915, 0.02096356449832315, 0.055560192768056904, 0.05251251472739571, 0.038057921565199826, 0.016925828166226675, 0.009742919545407847, 0.030099470409172824, 0.02478166141788929, 0.21128202443663746, 0.15610029304974304, 0.15764669610239201, 0.16657772039270535, 0.12216691911242183, 0.1713298828951858, 0.17017510012111248, 0.17578433843232633, 0.16928669422041676, 9.999999999998899e-05, 0.011235838032003787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003133528121217033, 9.999999999998899e-05, 0.0012404059297456138, 9.999999999998899e-05, 0.08964812613174367, 0.09436066553104139, 0.08276434836506685, 0.08623708112808892, 0.09186003269476128, 0.12093008272568839, 0.09811705655021341, 0.09108542469589642, 0.09460607952306543, 0.40248575289206434, 0.41040554549092945, 0.40628868570422494, 0.43834487945543066, 0.38404554120924517, 0.4412104646275885, 0.41697518095855657, 0.3932901740440561, 0.3990315838711713, 0.0866421271537714, 0.08654075163233665, 0.09769441421209035, 0.09402101316306999, 0.10915112684218187, 0.08924583213121606, 0.0757581840119328, 0.08073333620517442, 0.07614893230798914, 0.16908328402743356, 0.2061421831607364, 0.14683357005298803, 0.12772435088111467, 0.15040342283922348, 0.150910359786958, 0.19451591520874467, 0.17865772211498065, 0.14133304295416782, 0.25646808523652675, 0.23827822226288964, 0.28107610183685183, 0.2376856633478025, 0.2446120283324229, 0.25412200639611904, 0.29623844645022335, 0.2909188337299796, 0.28717972093285593, 0.17991008627917038, 0.19627269172066986, 0.18183859738412445, 0.19712170259093464, 0.16182803810592417, 0.1751863862636276, 0.18003452534940878, 0.2039828316585035, 0.2005857357855637, 0.1880478425528268, 0.18644232961965002, 0.17726857146046404, 0.18915760258987313, 0.18615231845713154, 0.195050011284983, 0.2035446793063167, 0.17351861730715823, 0.1907840358933971, 0.18300876691600265, 0.17619282680838566, 0.1726338892708954, 0.17207284502885245, 0.1740391870738799, 0.1679762574055187, 0.17618254369665343, 0.19040523475433713, 0.17574823216227398, 0.5038311465573628, 0.18018748436357312, 0.15302530803878622, 0.5103360357714938, 0.17735125762381465, 0.18974070628374684, 0.13975666535731546, 0.17651701682086673, 0.341910535685903, 0.3214861366473045, 0.20261904921970442, 0.20049261211716374, 0.27740362637699023, 0.4250261409058532, 0.3879357168909301, 0.19533343497509048, 0.20935614310314032, 0.19619235974173455, 0.18528037406581177, 0.20022905805417734, 0.1933021313667742, 0.19240029836698191, 0.1976784237298208, 0.20072325423214565, 0.17724964885344052, 0.17787104930255904, 0.19244876655041132, 0.07399047648547763, 0.07002369456589386, 0.07024863256197422, 0.07052561669371737, 0.0733731146361617, 0.06813692037287034, 0.06297949957944549, 0.07371701381134976, 0.06389216077981741]}, "mutation_prompt": null}
{"id": "325eaa7c-daa8-42b4-a6ee-aed598ace7c3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "d7485ca6-0dcd-4720-9a1b-8736bdeaf168", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "9275d6d0-a92f-4f21-ab48-699b4c140a1d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "97e5c237-ef2a-4349-ac8f-c9d7cbcc3094", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance the mutation probability to improve exploration in HybridPSO_DE.", "configspace": "", "generation": 10, "fitness": 0.2516815737718722, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7300457191112666, 0.6352633743758872, 0.6901002087004695, 0.7332446154066141, 0.7226970148882768, 0.7151070481941021, 0.7143432345864896, 0.6860996819375629, 0.686581953550135, 0.3560737221621023, 0.3361814560778472, 0.2930482104333918, 0.04081325463700558, 0.31561115838492837, 0.23178817738064317, 0.34536487376189784, 0.3527986815510078, 0.3291460241580382, 0.10608326610119034, 0.10949833060612602, 0.11847368078860909, 0.10078653712792618, 0.08831402376286301, 0.07075644620192778, 0.11808298870825984, 0.1045942697169796, 0.10781749401149898, 0.10695595152778936, 0.10561602456514407, 0.10112145907274739, 0.11694045088075478, 0.09964107632283381, 0.10792766691062572, 0.11389764103033828, 0.10356160747213505, 0.0978121063453562, 0.9858558861308651, 0.9813857967461007, 0.9869977023214821, 0.9772550019932351, 0.9805643524045881, 0.981051807126685, 0.981641939380214, 0.9857086781017548, 0.9810135648734604, 0.3410450971562763, 0.2931960347949262, 0.2813065058380688, 0.3287809448011825, 0.32085677071035945, 0.14795260071077154, 0.30983201584842135, 0.2859158992079037, 0.3261343973782468, 0.17013222929177796, 0.1722737566344984, 0.47940540134305654, 0.20463249992204524, 0.2813372799694197, 0.21097701562446536, 0.6331843257881995, 0.5792653148208635, 0.6566616104510667, 0.17298015973705383, 0.10200831883643535, 0.18719385595602112, 0.10374388051541339, 0.1770090954446818, 0.1378609623432141, 0.16640864113657683, 0.25285214094702146, 0.1800844802739463, 0.16851965712986694, 0.12250167556214997, 0.17725919295173131, 0.17120975702867802, 0.12119755538694776, 0.2000983182966043, 0.18511150470246374, 0.10779856242889707, 0.1954322514738137, 9.999999999998899e-05, 0.01864743452562212, 0.010389936509426434, 9.999999999998899e-05, 0.01607559544453485, 0.011314074072777291, 0.00159168704295376, 0.020328503296328515, 0.027073973628320536, 0.12567722401008685, 0.11199335397861432, 0.11869962976982318, 0.11330576737701281, 0.10698629015893946, 0.08578315547386284, 0.148502905506113, 0.126967343556042, 0.09618199470804378, 0.04128771427278588, 9.999999999998899e-05, 0.03867322062121026, 0.09397419283933228, 0.05738172841233391, 0.04388087262960749, 0.07067219788369039, 0.027730688881320353, 0.041744566649766, 0.11722903874199841, 0.03823325904079733, 0.10565776553897888, 0.13672215978988822, 0.13318711394503369, 0.08505343628966056, 0.05123867173968499, 0.05501678136773658, 0.07753659752391595, 0.5195308403860919, 0.4612295783408855, 0.5000983271150897, 0.5157466257735068, 0.45987725263915913, 0.20684777554338907, 0.49838046536633096, 0.47618522016780096, 0.483212583645671, 0.10203454668810596, 0.13713586805706457, 0.09786031354901747, 0.09156088914306348, 0.11571141806626384, 0.09719985963207478, 0.0940660518599189, 0.07740642606055337, 0.07385703741823524, 0.14782546450431566, 0.20657017576009762, 0.2182666217887409, 0.21075523099098425, 0.2087293811379275, 0.18400953194937497, 0.33662811330608367, 0.22142440618425652, 0.17811397221947523, 0.31240175998556874, 0.3332697791718874, 0.25699993051848957, 0.23198320483597812, 0.29766623476985465, 0.3259808460799384, 0.3509236423197397, 0.38422183115183584, 0.26961064437095106, 0.2305509768826276, 0.23092757183091572, 0.22710672388455666, 0.23609266164927944, 0.1839366863983155, 0.19473525254554336, 0.24608101380348957, 0.25215850860565847, 0.23533420565504093, 0.2188240955589924, 0.2001740055900646, 0.19434653794809542, 0.20890914535058613, 0.1888096540248928, 0.18036368771981848, 0.19014528735173708, 0.17042793570497328, 0.19627512922641177, 0.22411090933707534, 0.20823050183192682, 0.18018300920192154, 0.1749844447413218, 0.26897049453344557, 0.18513686440667165, 0.20462608974874352, 0.1937880134804849, 0.20073335154423033, 0.4540291540078194, 0.12498531731736062, 0.15356996060769157, 0.7888657699927484, 0.199036775029099, 0.1972897993382171, 0.6844423501092953, 0.1648017026006039, 0.20925399837676606, 0.5181399450997708, 0.2107804095583652, 0.4566432314671952, 0.20458894708702202, 0.4158505262720311, 0.15188774694725127, 0.10316795290474978, 0.4896548740918142, 0.1806993434821096, 0.18631449585104087, 0.18084812191727684, 0.17532634677620318, 0.19300619445420497, 0.18414650561787815, 0.17793376767300528, 0.19208510516719168, 0.2044535941714184, 0.189354923073352, 0.08214727756684281, 0.08006016502771018, 0.0744322665896654, 0.07540287121671296, 0.07836901106681415, 0.08015191464729854, 0.08270355558313114, 0.08287618469240843, 0.08577247508932484]}, "mutation_prompt": null}
{"id": "1f2bbfed-6f42-4451-80d9-4cefb8336282", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.9 * (b - c)  # Slight change in differential weight\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Increased mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance exploration by adjusting mutation probability and differential weight for improved diversity in solutions.", "configspace": "", "generation": 11, "fitness": 0.23420096062147838, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.6244991707669039, 0.5863614883435453, 0.5671489791326865, 0.18955533044165018, 0.6638280661347751, 0.6155751150443103, 0.6414109836946269, 0.6031930408110219, 0.6285732059599853, 0.2667708653383779, 0.2665097947472056, 0.22492666170132358, 0.2713103521172171, 0.2283991140036834, 0.23549474380869784, 0.2570190058900014, 0.267884602795607, 0.25841571650431105, 0.09982175153939676, 0.1084529185040588, 0.08970512434770517, 0.09270014371471247, 0.0844091649771177, 0.09255703928110448, 0.09891085251218157, 0.10810694604995519, 0.10856907136092886, 0.08789600644515905, 0.0918325895543729, 0.07415981836780228, 0.09318239075827628, 0.0793692866504696, 0.10043378082735288, 0.09808837284158001, 0.0917680286247401, 0.09431580170850717, 0.9835747111547573, 0.9822766563456587, 0.9854921950420379, 0.9771638176786722, 0.9737112133112298, 0.9769918411017137, 0.9825050743700435, 0.9857844419960098, 0.9803682998525193, 0.2659903550979278, 0.3226294168472116, 0.2572938064374951, 0.2850430878243565, 0.25633785776270934, 0.2567631256949734, 0.2186675256492484, 0.2529493094168368, 0.26297705407384364, 0.2790970213748937, 0.35754978605834575, 0.34423962445352285, 0.20084155632940548, 0.278318924118802, 0.19205981859515497, 0.27939821033358425, 0.26673722517392484, 0.28456660149238455, 0.14822681083426392, 0.15095455505606026, 0.1599989882750653, 0.11175374899567792, 0.11753362182600247, 0.11377420517310677, 0.16095616367470522, 0.16460306834463767, 0.16282410487197363, 0.15594787454813064, 0.14711229691975236, 0.13201198293388716, 0.15750829066844385, 0.14103060071057827, 0.17628896691205953, 0.1714810777649347, 0.10531864574834848, 0.12245105819352775, 0.005749395695072268, 0.01885797230418662, 0.02659867534197624, 0.0005460050460253107, 0.009086386257790235, 9.999999999998899e-05, 0.0028342259024133343, 0.005847951455952183, 9.999999999998899e-05, 0.14243773517497826, 0.11120100357940632, 0.09040691479817109, 0.12179533343522453, 0.07912835033587107, 0.09669663960874586, 0.12998092939403172, 0.12812798916513735, 0.10618257107954654, 0.024271042142225085, 0.01006709737695588, 9.999999999998899e-05, 0.0020206369085981057, 0.0012577194209385523, 0.033782811304893356, 0.06915886200071508, 9.999999999998899e-05, 0.050685476589381495, 0.10836153788621561, 0.07771741616835803, 0.08859658153950678, 0.09237124967297072, 0.104681304960765, 0.08333160261268513, 0.05263737880638475, 0.10433160481609105, 0.07524799870390309, 0.4285220920871041, 0.42525654391073253, 0.43977346167657805, 0.465733772962742, 0.436056867086528, 0.45019856452377094, 0.4292299529588357, 0.435616994993977, 0.42759431511424373, 0.10338588739269783, 0.09163077361909033, 0.0918460953210175, 0.08647148951544992, 0.08337958592601102, 0.10079627236299404, 0.08045115003261294, 0.08977929042368415, 0.09837278507431879, 0.1829915452879265, 0.24948852980579883, 0.15125793073280636, 0.2020125105690178, 0.1645893101064294, 0.14812344388905307, 0.2430513898026213, 0.14724083833749158, 0.17889106270306254, 0.2764519125131214, 0.2225452607132523, 0.29834646866431136, 0.2626666569486755, 0.2820675420854142, 0.2911561168133793, 0.31685345558569955, 0.33627087798644273, 0.311958957062883, 0.21399449404581372, 0.17683241123314963, 0.20497955601076057, 0.19094443404884676, 0.1721191223369256, 0.17466547192714676, 0.2193474909374722, 0.2487003526265823, 0.24172191814085475, 0.2012555217632901, 0.17961241130858596, 0.19537972417793148, 0.19549158512354192, 0.23673595180509066, 0.1901873426420687, 0.23874874940352064, 0.17320972515365518, 0.18458611149660875, 0.18286908869972296, 0.21167544069134714, 0.19723496573376542, 0.18342430995490167, 0.17544558109223685, 0.17774768650685768, 0.18446637958953271, 0.17913801527390694, 0.17644480689872288, 0.5233950322376355, 0.17409754719787218, 0.1243982256482854, 0.7589849463220637, 0.1986918665091778, 0.19873889880122086, 0.19830079717233307, 0.3961065869923447, 0.623679267312804, 0.48027125429150197, 0.20752116496643302, 0.28861971082748517, 0.4374588620306352, 0.3491403336009351, 0.2580816489962826, 0.34261312575069447, 0.3494031535313301, 0.5217724225528291, 0.16879621812630852, 0.188469598819049, 0.18377461046325905, 0.20312526049846769, 0.18542047382838778, 0.19570279877598395, 0.19321800214996143, 0.1928838200360653, 0.19527144969072008, 0.0781362382417683, 0.07573173633073182, 0.07493459150186876, 0.07007828521341031, 0.06721250862196138, 0.07427275195112559, 0.06746457701461872, 0.0708034678684355, 0.0991595633278386]}, "mutation_prompt": null}
{"id": "4804c619-cbbe-44ed-b3a9-78b4164a6ffa", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "2f8049e0-c97b-4067-a753-cdc37f20fe5b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "60f9be12-118b-47b9-8f24-9a460b94194f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "db988f8e-7f9a-4563-bedd-2dd5ce5d72cb", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        self.inertia_weight = 0.9 - 0.5 * (self.current_evaluations / self.budget)  # Adaptive inertia weight\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight to improve convergence speed by dynamically adjusting exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.24369413774230708, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.6259514055986111, 0.6000943191868451, 0.636851819377833, 0.18224606401562082, 0.6818584873197633, 0.6602160777317412, 0.6441639695387902, 0.6392273387775014, 0.6290279929434357, 0.0531126174200246, 0.032496092375372654, 0.3821484117365841, 0.27616025461749083, 0.3283242250268815, 0.35943187502027063, 0.2098522363619595, 0.35212459014154474, 0.033658546554795055, 0.09629694549429424, 0.08739834167676785, 0.11416662648347553, 0.11332434495045651, 0.10126227779737162, 0.1164437617013444, 0.10542421686497017, 0.12481109015433889, 0.0973544160879859, 0.09082905891642801, 0.09468526697729562, 0.09230022585237363, 0.0916421947803292, 0.09694988641964886, 0.10376616462028232, 0.12727200115404502, 0.11097575050831587, 0.09860506725377494, 0.9876512823995681, 0.9833030802668493, 0.9861423397045546, 0.9685398814760723, 0.9820360449571339, 0.9813262500563722, 0.9846161098602986, 0.9841621990880127, 0.9819647393766691, 0.32228886758012243, 0.32351206177429803, 0.20925274560177431, 0.30772199242054143, 0.34359993992562754, 0.3289709567357455, 0.22197982259287996, 0.314986774145657, 0.08889092236470919, 0.41726304133022285, 0.41076030674741815, 0.4963660362478155, 0.5129326105879405, 0.20315950230668745, 0.23904423812651066, 0.45457641769158774, 0.32134497286798847, 0.37249172613526105, 0.15787077133097505, 0.1450370057978727, 0.1478302091574435, 0.08905423437051063, 0.16553229235264066, 0.1557833036569809, 0.1518970697596742, 0.16921323653123999, 0.15772526788296382, 0.09030995400101871, 0.18208858163057884, 0.18012837017867056, 0.19381160056136493, 0.149019195368982, 0.16676111323087028, 0.16127234070292706, 0.026520841164150655, 0.15960308620554042, 0.008793805446896452, 0.007403843695945711, 0.012774053791241968, 0.03479897160233436, 0.0006374201473070551, 0.0014032401325928534, 0.008132191767990293, 0.00199690743380343, 0.026207071401033732, 0.08368944779865928, 0.09399947277954035, 0.0912288702751759, 0.08890768614529987, 0.016410050441124757, 0.0855268645573195, 0.0694157546845241, 0.12040813698189778, 0.09260299878340994, 9.999999999998899e-05, 9.999999999998899e-05, 0.028936401291666525, 0.043720505580611135, 0.04797416772748697, 0.04362149787653702, 0.059593838136364874, 0.0567463629946755, 0.052351462791278, 0.10129358124478871, 0.14872096937929713, 0.08385711230973758, 0.005123564401890546, 0.08464302112392819, 0.14976094562229514, 0.1038395228912199, 0.07064851401563133, 0.07281288523779272, 0.47178263627121664, 0.4572473219249956, 0.4707311636730188, 0.4631657222481257, 0.4769738926538346, 0.4508861014336074, 0.46835911330011404, 0.4649255381704559, 0.46356545725566034, 0.08052587892407215, 0.0970647242956596, 0.11749622664013804, 0.10153738735410078, 0.09451490573225785, 0.09571458889076656, 0.08955543912691233, 0.0766229413187588, 0.10793751152241327, 0.18071710113963468, 0.1730609165596767, 0.28098848850776015, 0.21313523665287182, 0.2084517391851104, 0.184735287060951, 0.297725762346279, 0.16883159957309213, 0.18313487108833337, 0.28928688987254114, 0.3678675724619005, 0.3469918991505837, 0.29127412782890627, 0.3065001273530008, 0.28112980280531386, 0.36533524534263007, 0.3831651084266574, 0.3578057956201014, 0.22358008058100898, 0.20413266786126005, 0.2003231198959161, 0.2301852279639578, 0.2693713534983423, 0.21557743638864668, 0.20948672758058196, 0.2790805869247929, 0.29956088299684125, 0.19615374812189568, 0.20062029936964876, 0.21676635108135756, 0.19130043390602336, 0.20250630156617666, 0.18860718073557592, 0.19526477730969094, 0.18345535404400304, 0.170689041330788, 0.1869002534509273, 0.20253407873671558, 0.1838101340164362, 0.21863596163949206, 0.19459904021125551, 0.20012208297654877, 0.2245658082303038, 0.2043149705239118, 0.3222198997899772, 0.6635878052102197, 0.164821268668932, 0.15065744779393575, 0.18079088345507277, 0.6254272366137272, 0.1298917832397929, 0.18813187035226042, 0.6043666028523845, 0.6504191025350472, 0.473467872573052, 0.20900761508445753, 0.5746500518881134, 0.20030632291893347, 0.4989370569647281, 0.14992298457434827, 0.19841993532422475, 0.18688602823604283, 0.14845707445931766, 0.18363162531627242, 0.18642199636467627, 0.17716076082593957, 0.1705970380415518, 0.18759119754305142, 0.17320403904213855, 0.17858893536359122, 0.1877693364649914, 0.18974066021015912, 0.07185768393117764, 0.08111996020412093, 0.08199758298771143, 0.08003271765374442, 0.07356813552995067, 0.07614790621581835, 0.0802135602561852, 0.06799116314970799, 0.08206414986683463]}, "mutation_prompt": null}
{"id": "c7ff27d6-ac4a-402d-ae49-55003faca194", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "54f708c4-14cf-4a4c-8ad4-245f0efa91e9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "088dac96-9fb6-4b42-b6f9-06e046b97bd3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "8ae5144a-88e7-4fcd-aa9b-6658b33b640d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "The algorithm combines Particle Swarm Optimization (PSO) with a Differential Evolution-inspired mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.7257807650322683, 0.7195670966997219, 0.7269135945875851, 0.7401693256383917, 0.7633961345457584, 0.7325084276770081, 0.7286219143084938, 0.7555011376882788, 0.7301077757468354, 0.4229086069304957, 0.366258232168693, 0.06566068545837755, 0.40759961945272893, 0.34499463064591995, 0.3810948810750471, 0.37721274742202127, 0.3982921912702502, 0.3626010222779946, 0.20252818854208254, 0.10851281717580719, 0.12061969590873545, 0.14489473186212165, 0.07065938693039786, 0.14442317943062755, 0.12584678251497772, 0.13755863242567046, 0.12496760991310418, 0.10522594949176056, 0.12107554415327582, 0.12119994426004832, 0.09821779612844017, 0.14220312016294157, 0.11923697199932759, 0.11058763971273278, 0.11486358627213034, 0.10113995456567482, 0.9863133960362155, 0.9817936794411222, 0.9861510896760066, 0.9715186167273517, 0.9800421490476166, 0.979505896829848, 0.9826545361383343, 0.9847329566711454, 0.9810019281800244, 0.3653109638494121, 0.36454330558443426, 0.05900422211816769, 0.3603224166056953, 0.1501831165099653, 0.3540536974352885, 0.12585945818538857, 0.08846417406173734, 0.3356745040941205, 0.4717071460160136, 0.3423350948327194, 0.3505764938355447, 0.20393184344178295, 0.2041821948956286, 0.20760754374288104, 0.5970699965182344, 0.33771774187403536, 0.3297967716870106, 0.18994948134464917, 0.1062531147608583, 0.1762462700182983, 0.09927224181487104, 0.12786408139510042, 0.17277756547090617, 0.1908438433077213, 0.17908089060342314, 0.18692665693114852, 0.18093496797912556, 0.16868961135996074, 0.19292604662971558, 0.19485552764484582, 0.14254122688135562, 0.12383883356413461, 0.14071700209189275, 9.999999999998899e-05, 0.2088344676523901, 9.999999999998899e-05, 0.026697065422344846, 9.999999999998899e-05, 0.034521539445595995, 0.025922501345298055, 0.009625528120582927, 0.016667136916757364, 0.01541263586706243, 0.003284704046947473, 0.09125659661717322, 0.07228310826418805, 0.10554442406822673, 0.11911293982218663, 0.04016182099623655, 0.019852183666673184, 0.11931084673565695, 0.10299852075858218, 0.10816212999027974, 0.03416683222301786, 0.08085552736995427, 0.040397645159707785, 0.06286535296204421, 0.059232681465986925, 0.05962222855020283, 0.08743567328762891, 0.06272772302552798, 0.05790622358171882, 0.16536038643451068, 0.11532917541998322, 0.18941017935084237, 0.07957276836675886, 0.17459374554974072, 0.1125572651863882, 0.12619660033212365, 0.07761694177869882, 0.07974416887767599, 0.46839404719108246, 0.526676919054538, 0.4717250132006775, 0.4927688509131928, 0.517607761415795, 0.4690438094373096, 0.5198520033238772, 0.505995888043485, 0.5133648606811667, 0.08537457678178073, 0.09683654009614673, 0.08458492150901997, 0.08824646358190547, 0.09674929958958112, 0.11256864661308552, 0.09624779890810276, 0.09760758065847785, 0.0994564038490855, 0.2196978758595154, 0.17969117064193973, 0.16940182176159235, 0.3065591446602077, 0.22087408624850102, 0.18403001405564923, 0.3677456529858145, 0.15364045497837886, 0.2222730020782322, 0.30762588544593406, 0.25044962041881724, 0.3149037186259377, 0.3510258208844217, 0.37520453377121965, 0.3601933448175676, 0.3745026354398404, 0.4083987459324251, 0.36437087233410104, 0.27503575120170665, 0.2532863125434692, 0.20816392425327102, 0.19115702028408466, 0.1690105513267932, 0.18591728623965753, 0.20443221285488622, 0.2567241878910198, 0.2664539182433595, 0.2346680842349922, 0.1840231951527268, 0.19360324909337623, 0.18915760258987313, 0.19029132357149725, 0.21208034196925574, 0.2145147365116482, 0.18721970607582095, 0.1971890039684301, 0.3781971883465428, 0.20349783884170325, 0.27154390890496694, 0.2267855317879115, 0.17610492855842985, 0.20111245380614462, 0.21641658578472445, 0.35708463676257085, 0.19455785221250443, 0.7742238671614882, 0.15346162921728645, 0.15338077998424282, 0.1722189584683843, 0.19917260328284425, 0.18890456512724885, 0.16145739502963063, 0.16372509209445907, 0.7134709717390735, 0.6623125126166238, 0.20914953504031908, 0.557821564860739, 0.20294801082144753, 0.22091794774300955, 0.16416359180195617, 0.1043059217613369, 0.105205292116613, 0.15452326525684767, 0.18670753719165845, 0.18370286174250516, 0.1896278944037596, 0.19376846442352558, 0.19630027581812315, 0.18472290652911283, 0.18814606257451905, 0.18491215196170718, 0.17352277714136854, 0.08579898121884577, 0.08389544709133678, 0.08176766865043061, 0.0880659225408934, 0.08839323541417521, 0.08455940612163826, 0.09854330115262377, 0.07950633643840721, 0.07938937323219342]}, "mutation_prompt": null}
{"id": "101f75f9-5c6c-49d1-b4f8-3cc83db3ab86", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduce a slight modification in the inertia weight for adaptive velocity update to enhance convergence speed.", "configspace": "", "generation": 20, "fitness": 0.3180892691850783, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "10fe6020-f105-45ff-a5c7-e71f5e73d015", "metadata": {"aucs": [0.8810075109746817, 0.8781587471827508, 0.8690297148627626, 0.885638359675085, 0.8852126023084167, 0.8765006477249404, 0.8738633581098512, 0.8863135613716706, 0.8764453518466582, 0.7281990207719155, 0.6610041766987439, 0.7016257409731594, 0.6913603247295108, 0.7377394571115171, 0.741642816832742, 0.6975275728024262, 0.7463167741082676, 0.7241371384951191, 0.1203982089213328, 0.17538316418260746, 0.1558883488986128, 0.14156122418107864, 0.14414631074840112, 0.0745246888984109, 0.12456606706674977, 0.352491474864316, 0.15655130482876867, 0.12420193508639854, 0.12914013420092074, 0.14319308577740686, 0.14961942923312022, 0.13529259677390015, 0.10669626827061385, 0.14061252505293775, 0.13876107721121644, 0.15265904994663504, 0.9855557594650598, 0.9813157825063363, 0.9860180334671823, 0.9685415061558665, 0.9761176583549984, 0.9793250211293529, 0.9817042770148426, 0.9847193983679611, 0.973483923583177, 0.6412870805890803, 0.6482410444369171, 0.518180438026444, 0.6381916300178372, 0.15303158332041078, 0.6553564367690241, 0.12599516676089118, 0.6103774595788467, 0.618638296821004, 0.22528756283535478, 0.21958693700676257, 0.22625643217545943, 0.19437825607748405, 0.37151475354022045, 0.7139174107686161, 0.8567552219476977, 0.23585660217451865, 0.2415049908269371, 0.3539278908427216, 0.12661755481376002, 0.11974190267035223, 0.10249500640081388, 0.13436950793366864, 0.1268529639181818, 0.13350825645171494, 0.220863872411574, 0.23904589298820822, 0.20954336585153222, 0.24142055979142008, 0.233082578867993, 0.24456905267991458, 0.22786201733448053, 0.2760374290035652, 0.24825185097731062, 9.999999999998899e-05, 0.11949798768797393, 0.038048794378612416, 0.016737667942516077, 0.027384408306839192, 0.03381799602349744, 0.055043631134301885, 0.015462808280427676, 0.05424302402306325, 0.06647214525314571, 0.11995487383383152, 0.1266300232007599, 0.09930421765867703, 0.14794686708572902, 0.11788199651986286, 0.07146498977135085, 0.09847294109193849, 0.11745838558172583, 0.14789640736266885, 0.14349394973827223, 0.15418370603093412, 0.18028553136827863, 0.04944982601731407, 0.17158882924165375, 0.0918805151015144, 0.09842707447017784, 0.09877089487861013, 0.11549883838898245, 0.1395898275902302, 0.1643352146472684, 0.10007093380214171, 0.16634649100396492, 0.006519113140848298, 0.18797159279278652, 0.1452221541376948, 0.09139287835844012, 0.1425020493976683, 0.1050534396031142, 0.5971133603702738, 0.5797600789364519, 0.5737735123220438, 0.6184054372856611, 0.5918316795291467, 0.6419650807731198, 0.6200862886424361, 0.5957569933550204, 0.6434631449052345, 0.06875636924390749, 0.08874515927875892, 0.0797971601088584, 0.11622014108541423, 0.15194256166990983, 0.10935753476122612, 0.09437527667544421, 0.15485233409832488, 0.11078765803035062, 0.1965602912373282, 0.5037887772824451, 0.201076195862542, 0.4002002839633535, 0.19368470482343558, 0.15495701210614676, 0.40423447227577813, 0.39201404776233406, 0.2317090140014486, 0.3658753385591772, 0.24252700357846002, 0.4346046737854874, 0.3960216032262486, 0.21861380119183427, 0.2862674367914111, 0.46826801773934235, 0.4008287702038633, 0.31848941987700363, 0.2814882678292534, 0.2441452106889912, 0.32961853119526574, 0.18725048363250774, 0.21546259207920826, 0.31476122248586, 0.27718578730626664, 0.2586296400094522, 0.3011775707908344, 0.21689165892190998, 0.2034738600042162, 0.21173206566030678, 0.22661118497742228, 0.22347858064541992, 0.2357285265593848, 0.226167523509194, 0.21806677454525547, 0.2682569223464001, 0.24254665122953445, 0.19847992149883797, 0.2155513424911326, 0.21909198320494538, 0.19137183312173678, 0.2425852658678197, 0.24921570410138127, 0.22336755957529886, 0.2490674315598529, 0.9063079476877292, 0.17708365819873428, 0.1535625619063241, 0.9204932431576217, 0.20060693491756398, 0.16172991259387925, 0.20008420334221755, 0.16480789435311705, 0.21241255485545973, 0.7875274953533529, 0.21157850304013293, 0.2074696151984059, 0.7931736997185542, 0.6722404052869926, 0.15591402120472397, 0.10492803081269741, 0.5101036007274813, 0.15521513211012383, 0.20214646489780874, 0.1940767891421995, 0.1848400656524316, 0.18337255116362738, 0.19142677979202027, 0.19909529199439469, 0.18219963546746099, 0.19756675304825644, 0.17798196721664694, 0.08465964075790267, 0.08962699969254462, 0.08020608022289089, 0.09059463052513184, 0.07783346456777107, 0.10535391448906162, 0.0926480487754372, 0.09104562074211686, 0.08611313796121789]}, "mutation_prompt": null}
{"id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced global exploration by introducing a dynamic social coefficient in the velocity update formula.", "configspace": "", "generation": 21, "fitness": 0.326971389679258, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "101f75f9-5c6c-49d1-b4f8-3cc83db3ab86", "metadata": {"aucs": [0.867692253434374, 0.8815003195765088, 0.8771471721995272, 0.8631086744923118, 0.8757277262423746, 0.862984182308518, 0.8723568141657483, 0.8791619152060851, 0.8899852011827959, 0.6294646036147387, 0.6926664627697631, 0.7193686321199451, 0.6709636130373958, 0.7271454686505168, 0.7147927600210987, 0.7186130124111565, 0.6942402238036153, 0.7218723415408133, 0.11157108607638166, 0.13091229375445912, 0.1763816524327898, 0.16561286243083284, 0.14822019505354112, 0.1597290270833388, 0.16280946101637472, 0.14092811445963438, 0.14204864182950117, 0.11840274621942082, 0.1083016099682853, 0.13952765426406388, 0.1177448048429176, 0.14362278851159882, 0.1738281786570871, 0.13031622475353055, 0.1395687451204698, 0.13601472262932135, 0.986435840851201, 0.9554816498870008, 0.9772804437014444, 0.9676574271955675, 0.9859929806278122, 0.985974046755495, 0.9860246998420932, 0.9849358588041021, 0.9768310147518549, 0.6020508895462866, 0.6352378721631113, 0.6050664233556488, 0.5301762279495041, 0.6526406952738802, 0.4857977535988425, 0.5759055300871989, 0.6617021259940367, 0.6237227157946708, 0.6484004124729457, 0.2262746496956073, 0.21979792475488336, 0.9328702442575547, 0.7258117454234334, 0.19326945584752042, 0.23972496526542775, 0.8230492180668337, 0.8170160689830076, 0.12613888923820837, 0.24215653582997243, 0.282006411502568, 0.24721748820761058, 0.22778036908015742, 0.13260865406487043, 0.21768441901739066, 0.2361941616641996, 0.22513162597718384, 0.12558261560777095, 0.12916302847439387, 0.2537973632648878, 0.2429153154352902, 0.13711336471014424, 0.12955519114152103, 0.123751677294211, 0.2763879856367495, 0.2794545436888559, 0.05838490304291333, 0.028760824617761305, 0.009696455787594593, 0.07567389637355337, 0.00663502112498171, 0.021129577402529853, 0.0014884622994846275, 0.021969516071864148, 0.09136331265089159, 0.12354081936476236, 0.1316769201750314, 0.1349962204715477, 0.1562140565823129, 0.12443004855436246, 0.09058352779204992, 0.1463659586746231, 0.10356454369212786, 0.1700283015936589, 0.03455195917643594, 0.2046170649652902, 0.03375893475413572, 0.10603131617400707, 0.07835611714400692, 0.09429029264218514, 0.19717528971216003, 0.06967745819264837, 0.13969804612922876, 0.17046048123424629, 0.08396122036307097, 0.14938930130457084, 0.3249685020861893, 0.18765418417296698, 0.10527388989436637, 0.1090988123894211, 0.08288285557791808, 0.05640723922799151, 0.5687337087622124, 0.5472278964161547, 0.5949172510171744, 0.5910391687655674, 0.6136609670826076, 0.6024631660955947, 0.5803089445491798, 0.6600003785923159, 0.5925339643448435, 0.07454953452043811, 0.0892707162138866, 0.1214920277991074, 0.13101366638463274, 0.13179142890842777, 0.12301981330485745, 0.0858518944750043, 0.14251207859555182, 0.0928832569006991, 0.2642761477176665, 0.288139017509921, 0.1975107503483724, 0.26905658878776373, 0.1902957930738306, 0.18347221739969377, 0.1530066644119693, 0.23146138725867405, 0.2075095278521879, 0.3888282955024349, 0.5424079148723329, 0.30604498345608977, 0.3660208924734394, 0.6005834665894929, 0.22899081702667912, 0.5717975708735401, 0.5758305235728691, 0.43092197785526676, 0.1593626674829779, 0.2769860261595277, 0.2523290283149461, 0.28367046834048026, 0.355642476742406, 0.30129006329792996, 0.14022511563727713, 0.24218544462826697, 0.32563201863309144, 0.23799105941584153, 0.21538468353665208, 0.21205007127847897, 0.20876876296129898, 0.22509365504005285, 0.23376370158146698, 0.19689620293118237, 0.19730783537802177, 0.21756284718550156, 0.19284201963104708, 0.19999135214763275, 0.2526235886227223, 0.20722030960530224, 0.22324954420542364, 0.21053801411395456, 0.2400669958790863, 0.24623230416242792, 0.2248061502557268, 0.11896609019032822, 0.9102692755335844, 0.17268544824857834, 0.16522343427542963, 0.9015075508039732, 0.1768007535669911, 0.12283703919387212, 0.17567720209423188, 0.9030123290004761, 0.19972114120084017, 0.16826304337164655, 0.21108875398825544, 0.10515996891212198, 0.16905145192496862, 0.1692860523790254, 0.796335395738414, 0.7829770365847333, 0.10478503612262069, 0.18574019904926764, 0.21759779159483228, 0.18773181928850335, 0.20377239513050216, 0.17978679652432217, 0.19362944677917593, 0.1780978784910392, 0.1862173516366088, 0.1782817631618675, 0.10903853898933324, 0.08421603946048872, 0.0807988495203219, 0.11442911876965278, 0.08033637792124682, 0.09373435630620697, 0.1341947962397153, 0.08736046927911378, 0.08921633489154779]}, "mutation_prompt": null}
{"id": "c2d330af-5083-49fe-9ad5-14b4ac8a3d93", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.15:  # Mutation probability adjusted from 0.1 to 0.15\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved convergence by adjusting mutation probability.", "configspace": "", "generation": 22, "fitness": 0.3221183928328304, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.857946840314286, 0.8684034258926485, 0.8740791321787597, 0.8642188193487124, 0.8703361619605737, 0.8729012099289576, 0.850513688508849, 0.8760287615861473, 0.8784643958577734, 0.6681224491993529, 0.681680367636048, 0.7291862813422927, 0.6930370489347724, 0.689521160758273, 0.7138563325832623, 0.6855207673231407, 0.700352425383765, 0.6804428695055227, 0.15743968924596863, 0.1199412276764471, 0.14568210899266265, 0.11660342296222115, 0.15177134814740312, 0.17804931188043338, 0.12421350427655087, 0.12028523259161028, 0.13644846892381024, 0.12939545317237422, 0.13964063552767236, 0.14710407892844435, 0.12403915519881503, 0.1082855828643784, 0.12032714043890935, 0.12369379383690116, 0.11692732147487528, 0.14776777316936895, 0.9848762991933229, 0.9550034456649565, 0.9725564818668769, 0.9767904985625221, 0.9851585074131501, 0.9850390157562987, 0.9835581509322583, 0.9844782442049224, 0.981739486934167, 0.6087785136107772, 0.5564866113499718, 0.5472361336494791, 0.5563989401459659, 0.5390436964142413, 0.5509717681234189, 0.5475999172026271, 0.5388043954950914, 0.5673736845040455, 0.749617721268501, 0.6954121743177362, 0.6421522336114043, 0.8942935810532333, 0.16194792132315727, 0.26937137948324175, 0.23981671249774594, 0.24563679980451325, 0.7234027352680886, 0.12699386212272734, 0.295184598515719, 0.12982425718687685, 0.1307170937493447, 0.2661493759821144, 0.2297804206378441, 0.2278719201861309, 0.2657570724541052, 0.23857944079043358, 0.053706435663643415, 0.25796646521932587, 0.2451191364119787, 0.2460847661214589, 0.13703945150031427, 0.267690526662244, 0.2334510801930746, 0.28057410163552565, 0.2823567827436756, 0.054231437426122686, 0.02215648703639439, 0.04406109685654214, 0.023950273894682184, 0.07052772102826055, 0.07538033536407729, 0.022337750045740568, 0.07051691592929199, 0.06365869145268022, 0.15889745518239395, 0.1364146420938026, 0.14078767316935048, 0.08830408521301925, 0.1035380399116621, 0.1454555183380566, 0.14101409120540542, 0.13754627733137947, 0.18572548447265025, 9.999999999998899e-05, 0.08156217096332807, 9.999999999998899e-05, 0.07217318335207679, 0.07493579304100606, 0.17209603780025828, 0.16855223781729511, 0.06714925745090639, 0.12951731579535464, 0.14021099274659532, 0.042426394545872825, 0.043588768626983465, 0.15072969383175483, 0.1778197805125452, 0.18342504913383573, 0.13932661198221807, 0.12308863032028128, 0.12401353880329513, 0.5884181434832374, 0.5819350213014881, 0.6053114693390683, 0.6201149243455839, 0.6090019161160117, 0.6040635811426567, 0.5794319718775176, 0.5805628095730742, 0.5889020431183416, 0.1126344447990486, 0.12039521820362953, 0.11241209018604514, 0.1473354386546143, 0.1341254774850661, 0.11631047479955847, 0.07935628310541576, 0.11426335307460045, 0.08600527093191612, 0.26042754800913737, 0.2733470697927006, 0.4501909738456057, 0.1482008888740407, 0.22843579738939213, 0.28245063109405444, 0.18790209860783602, 0.3080356507461235, 0.18565054605363396, 0.29246208231100734, 0.42666057744521635, 0.20385367438484214, 0.5807641074378473, 0.421666376804289, 0.2403930226668025, 0.18468456730768534, 0.4181140514739966, 0.5466978008818093, 0.2664112450735041, 0.30595084899967173, 0.21228492518041708, 0.25780612205929787, 0.306553058619657, 0.24581893072903716, 0.3023375808705787, 0.31957951950183283, 0.2864159724814179, 0.19306840611756493, 0.2176070025978878, 0.2057756512475375, 0.2050206644074074, 0.23320065095921394, 0.20378111367535223, 0.20306599829691863, 0.21428348743663128, 0.21361953384236732, 0.22817336051323622, 0.2123130651616908, 0.22968348172153952, 0.2440566967443738, 0.22330410396345302, 0.24926718565468386, 0.21423379237352003, 0.23883313554054275, 0.2401163979259855, 0.16491399825545872, 0.9078159662380405, 0.16907095372052905, 0.16592008409477244, 0.9150468504313136, 0.1403379307552617, 0.1358501985528484, 0.17855660945357799, 0.16994801189012942, 0.5866579109174046, 0.16822595123991357, 0.21177978395232533, 0.20145160451120514, 0.16925478394399485, 0.16854561646427735, 0.6770471343708093, 0.7869641602900256, 0.20491547735933868, 0.21901435872612196, 0.2077225796766078, 0.1919796372044854, 0.1949912968141605, 0.1933484008922033, 0.18579304101106786, 0.19053913533705535, 0.17267914634557635, 0.18218034096640967, 0.08237918287179835, 0.09817957512503384, 0.08820973661534737, 0.10060807603890931, 0.09269730050870872, 0.09125194714474805, 0.12114566207294752, 0.08278252316778012, 0.07074989891759831]}, "mutation_prompt": null}
{"id": "5bb5079a-9726-48f5-997a-e79972256920", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for exploration\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        # Adaptive inertia based on progress\n        self.inertia_weight = 0.9 - 0.7 * (self.current_evaluations / self.budget)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Augmented exploration by adaptive inertia weight adjustment based on evaluation progress.", "configspace": "", "generation": 23, "fitness": 0.2655496150744834, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.6705762451618298, 0.6915381129530209, 0.6924125737400488, 0.6963167657847965, 0.7114762611260101, 0.7129111646957611, 0.6850254003012728, 0.7009501685956299, 0.7173739343271135, 0.424373226106764, 0.45458297615045673, 0.029988792047227264, 0.47066348039156114, 0.48033253197851555, 0.439386877983014, 0.4556960607950522, 0.4844333707418451, 0.46148594543362853, 0.11709192227215603, 0.13126630266059514, 0.1084232949492574, 0.23040760638015279, 0.12281634140167719, 0.133123521174073, 0.12244233343873911, 0.12084243702209152, 0.15403808528742224, 0.09976430093316557, 0.13009224636824823, 0.1001609510206587, 0.10745194033411432, 0.09895886218032013, 0.11254202333762242, 0.10662690716424383, 0.11033600324774084, 0.10407102307034621, 0.9891570326155618, 0.972729481988545, 0.9856567559031362, 0.9726605325491865, 0.9848938867686434, 0.986607139524194, 0.9873691822724548, 0.9864042574374781, 0.9815023902090484, 0.4302876665982769, 0.4373317190377767, 0.43169348175566535, 0.43738155784149346, 0.14156625476300777, 0.14729714396882954, 0.3900910558605468, 0.43734940171565717, 0.08831151555578509, 0.43384924814750336, 0.3123373877873932, 0.4614916720280783, 0.5872057297906365, 0.20211893064907915, 0.2108299036751765, 0.5642566630644456, 0.6167615435130879, 0.5327283479891765, 0.1263833560311861, 0.16853598570400385, 0.18393853774305513, 0.17993771209412246, 0.1607143976502846, 0.11845654244535431, 0.1534554964113548, 0.19302973098942333, 0.19938649178727352, 0.05140483506114979, 0.2806943372415789, 0.12986226027081105, 0.11181185696783813, 0.16956123208711482, 0.17638780326673875, 0.18556004606603582, 0.21133906347713538, 0.16074172657833008, 0.010470916793121399, 0.008796733383021671, 0.028550939180768342, 0.0022205394497183395, 0.035357032112695586, 9.999999999998899e-05, 0.02314446918945834, 0.005902317441457083, 0.02714690375083062, 0.046538110954878364, 0.1136539251910541, 0.11951040772089672, 0.09920250421707766, 0.0682224101311103, 0.10309487977761289, 0.08857588909346614, 0.0954398066697717, 0.11385421061002488, 9.999999999998899e-05, 0.0359260249993657, 9.999999999998899e-05, 0.05152934656550734, 0.07119819943810257, 0.0655398442949463, 0.1579737555374533, 0.07353605235318339, 0.04822957810760653, 0.17363405011016453, 0.03818295967980989, 0.10777317299906175, 0.09613087094993222, 0.11780654555809145, 0.18707729814404306, 0.07028980849326694, 0.13652069539349354, 0.05063936558769222, 0.48443038497648505, 0.48946731739989546, 0.475474738986134, 0.4879741184677462, 0.5151440044385802, 0.49075990104685974, 0.47155298266192525, 0.4999815547480927, 0.5246996364726306, 0.08068219197469406, 0.10206491608303381, 0.08028369165145799, 0.09697605260362141, 0.09623009933206539, 0.1128759386618794, 0.08428899260798173, 0.0993850824534156, 0.10971636795552964, 0.17495869497310412, 0.19127522900360638, 0.2229293724960315, 0.21111452281445275, 0.14263389999908382, 0.19693534210664443, 0.13736355036318804, 0.2858404273860684, 0.19122684796109202, 0.223272806619625, 0.3341676498630095, 0.25152788225843925, 0.2912574663735735, 0.3652334489075272, 0.38160175635747196, 0.2665763389246295, 0.4149733994670618, 0.4606632723704642, 0.1291643894549025, 0.2295065166377277, 0.26287492041981764, 0.22450186936553895, 0.21912213717443096, 0.23435023430651225, 0.13132789909313192, 0.24541879815303824, 0.2277978872197972, 0.18568363158561896, 0.18920841219827833, 0.22350995650866612, 0.21170018875296093, 0.21499638446331382, 0.19167787751180054, 0.21476078523244646, 0.15631627255967506, 0.194922329736258, 0.21591719161614675, 0.21321318779210374, 0.4496204165182289, 0.22326148771188115, 0.3786401501595196, 0.1852537158056523, 0.1942906745305304, 0.19658314629202767, 0.19173252738662305, 0.16202399696397374, 0.7677152067912997, 0.17071440320191544, 0.18064272480373822, 0.728457846172629, 0.17527595953691832, 0.16937178811677367, 0.17429801150196722, 0.6403828680679396, 0.1266459946594538, 0.16623155418234603, 0.20778049900617335, 0.19481751349963228, 0.1667514520440907, 0.48158171910254355, 0.19920239397911177, 0.6179883355256648, 0.20304599811380852, 0.17964071533950043, 0.18539341100958795, 0.18156346499566056, 0.19556796151114952, 0.18782878400861613, 0.18731894840610508, 0.2041525744928685, 0.19008351751263386, 0.1874211662926929, 0.08250026272597466, 0.09793332536622146, 0.09542774092088735, 0.09958047354898159, 0.07288621614442292, 0.08738443124806416, 0.1007194093399767, 0.09999557410476279, 0.07647689557907866]}, "mutation_prompt": null}
{"id": "f188af0d-0546-401a-a237-8aee174bbfb4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.6  # Modified from 0.5 to 0.6 for improved balance\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance convergence by adjusting the inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.3127651759627901, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.8236783027653084, 0.8473824588317171, 0.8197469405797579, 0.8342862533035378, 0.8448458006209497, 0.8194464839908598, 0.8418564834366395, 0.833219953921512, 0.8485714055721818, 0.5565639800209876, 0.07132839472675101, 0.604210327819146, 0.542791458803985, 0.6380975646270477, 0.46978272900898266, 0.5895705484988127, 0.05139106273990457, 0.6006029874142027, 0.20341636704338795, 0.1656571314563413, 0.17459110522005306, 0.12237014309863303, 0.15117439072300698, 0.1434348874413256, 0.09779304154485513, 0.148893129895042, 0.16600145902831187, 0.11565771878907549, 0.12489163413747628, 0.13563255812718977, 0.1180316811867278, 0.1272858779922209, 0.10332531360097796, 0.15026819513843626, 0.10886629329952535, 0.13873444932766654, 0.9864153672464038, 0.959433677935996, 0.9772746301429163, 0.9681021128407903, 0.9851624766551675, 0.9860549865235053, 0.9861338159771836, 0.9864393080173827, 0.9772374101516351, 0.49895628683400106, 0.5143981699757075, 0.48555444310529183, 0.48998025514644283, 0.4155456731214372, 0.3850204325481249, 0.4757895154806604, 0.48949684765008117, 0.482541985471172, 0.6771941094750338, 0.6579623380576602, 0.7453539373183895, 0.8321989559831732, 0.21192851902784837, 0.20657651611050742, 0.7572961365729928, 0.7467324511806264, 0.7068939710284594, 0.11307584971902085, 0.1312719347314263, 0.2068254232873329, 0.13118155123286246, 0.26198281810032253, 0.2143499032242493, 0.18843265781380747, 0.21166068679604688, 0.21924674195683347, 0.0527425213485212, 0.12960227704843308, 0.23575619530080671, 0.2124862906696403, 0.1351868778081674, 0.20714672672068624, 0.2206153557757975, 0.12617675123260597, 0.25965210454908405, 0.04061679432243959, 0.034855675490842786, 0.023991192939972983, 0.0015017562635836201, 0.02887650455394164, 0.014400913527853998, 0.03013915331632744, 0.04257900967361461, 0.11546221666163548, 0.11889301765189864, 0.14075839029584836, 0.11519398350474075, 0.08597325129955369, 0.1599577548347494, 0.09637669992241915, 0.12437853730869486, 0.13190314490231303, 0.13928655903472487, 9.999999999998899e-05, 0.17332590026701078, 0.03331702935890368, 0.07250633995356348, 0.07157252940910475, 0.09252347033116293, 0.09553434330561938, 0.11699300972680904, 0.20907294507693186, 0.17882110311324484, 0.10001253285482903, 0.04373811162305685, 0.13391072529470582, 0.2652995055186843, 0.1323094000253312, 0.08092133006330182, 0.33244160552085855, 0.05656468149660088, 0.5457815800692414, 0.5588541143667145, 0.5670709826247031, 0.5539458026600129, 0.5574530539733815, 0.5562800613280842, 0.5566692488140694, 0.5922056852675208, 0.5730957628863111, 0.08065941038952185, 0.07726041158195929, 0.1154257980438782, 0.12470197609526001, 0.11747907182821726, 0.12422141170354062, 0.09484675750140437, 0.07681533028623233, 0.0931567003823871, 0.2406334161064554, 0.191239586368811, 0.1627714296870172, 0.29498060718391894, 0.24468668490460643, 0.3524646177937, 0.16186136169996657, 0.2893941764792196, 0.2505056657878384, 0.24585697716756705, 0.31392998278801376, 0.41052048411465847, 0.36097254451635785, 0.39877930580692644, 0.24985339769546022, 0.21752045322303404, 0.3937099001754425, 0.5004121014018084, 0.24577285719406694, 0.29133689178220934, 0.3329829891356867, 0.3281904515333386, 0.2676212408445503, 0.3003714596765089, 0.14105068140104415, 0.2734660216657816, 0.3553752655108986, 0.21724493075357698, 0.22968268360024513, 0.21213909576622447, 0.2305455432704797, 0.21297006983764977, 0.2151076085114353, 0.19762869062974708, 0.16245226409860247, 0.22557119584617813, 0.22363093192754502, 0.20990047746506513, 0.20922199552380993, 0.21349792068426776, 0.24923791783343674, 0.20926139221878126, 0.23981401324651608, 0.21694916556294996, 0.515298968073969, 0.1197587449698545, 0.9132700262768326, 0.1728204343711932, 0.8380833619428969, 0.8783185702658499, 0.17835721968581497, 0.12296594861121668, 0.178682601953295, 0.8588503371663556, 0.42166213244166684, 0.16146309061601172, 0.21249546111189266, 0.35539011099271056, 0.16899300816535945, 0.1689850521100652, 0.7247973428156957, 0.7771470697013678, 0.1037107359775824, 0.1869920847217168, 0.20383994470892142, 0.20634314013178812, 0.2048421872082702, 0.19368402960158737, 0.17953454347923548, 0.19260671598582413, 0.17714387355150318, 0.1868918096151515, 0.0833163937509569, 0.11947217321054049, 0.12438720419997551, 0.09085903187820255, 0.0804421470991421, 0.08877789025332972, 0.11916246217295268, 0.08722248793728649, 0.08709543391115782]}, "mutation_prompt": null}
{"id": "6d5c50fe-979f-406d-8fa8-b2f856ec255f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.7  # Increased from 1.5 to 1.7 to enhance cognitive influence\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance convergence by increasing cognitive influence on particle dynamics.", "configspace": "", "generation": 25, "fitness": 0.32457024645721216, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.8643255461135707, 0.8724809834914921, 0.8660358136724676, 0.8606406265913138, 0.8719469734017088, 0.8809805288088132, 0.8630755581679688, 0.871507698059137, 0.866503864029734, 0.6756093271043675, 0.6974356236427199, 0.6953366411481663, 0.6935083227533887, 0.7064282599715056, 0.04652058692801453, 0.6940713286118758, 0.7038704150620572, 0.7036431053258903, 0.13541205556677505, 0.14359120902432498, 0.14912325593501885, 0.15252293688451024, 0.179557390553726, 0.16532101129201582, 0.15849426319941062, 0.11389406028135285, 0.17994151863482943, 0.1082956213571068, 0.11142802653527761, 0.15513450604989043, 0.09799680246529774, 0.11368076290870754, 0.12483690630579714, 0.10904505429576294, 0.15139416998808664, 0.10722086560176414, 0.9865308064543826, 0.9559525828167548, 0.9772881859617272, 0.9685622441658119, 0.9889495794296739, 0.985974046755495, 0.9860189904327491, 0.9849353746565502, 0.976861395175667, 0.5452175869815942, 0.6015274224620994, 0.5657104279346792, 0.6075363461122423, 0.5667335013604378, 0.6103032885634871, 0.5153056002401828, 0.5720186063320498, 0.5181773038136258, 0.6874374607736229, 0.22744803393603064, 0.22510769903224448, 0.8935893654060093, 0.2113350456889802, 0.21107644288110294, 0.48273166992142147, 0.6583896053531288, 0.23564495840611488, 0.11322580423303663, 0.22253505279893115, 0.2611177570854989, 0.1295183061650954, 0.2419566500224838, 0.13139759528030592, 0.24105270899238473, 0.22890526243977893, 0.21791902011287623, 0.12394688429491307, 0.18543575954738412, 0.2182310588971016, 0.23192648988168618, 0.13404200546004652, 0.2739273466826112, 0.2626005124437213, 0.27410655544737283, 0.2840999807902349, 0.022940954256670976, 0.014426602817328216, 0.0029484033853657277, 0.06497876346024956, 0.0009329758300956614, 0.04749455331247043, 0.043867907246844196, 0.049054255646515554, 0.10220881883279542, 0.119741089089209, 0.12672208383436467, 0.17584689305269663, 0.1378841785924727, 0.08690994765459525, 0.1486692860952844, 0.18469012846828414, 0.10970308713174348, 0.15256073582623153, 0.03245934770378245, 0.17010518632440141, 0.03921733015703266, 0.07266096102169173, 0.07719342266014517, 9.999999999998899e-05, 0.16635866081433248, 0.11077863042881786, 0.14261926218226162, 0.10993951857339002, 0.04323115006501155, 0.15075528232641833, 0.3427352885103212, 0.21416897607330443, 0.1881824438781905, 0.1375872148545373, 0.1031084931056011, 0.05707932611728028, 0.5521211287403478, 0.6104574567275856, 0.5459854759583107, 0.6292396722416604, 0.5821342439466708, 0.5832298951732575, 0.5592811299620796, 0.6063424846047962, 0.5895000582697595, 0.076886573204203, 0.1246460122039047, 0.09986709527539428, 0.10245956055881711, 0.1586671540883462, 0.14992754264698038, 0.06522850704914018, 0.14336065892916483, 0.07735816951652574, 0.21303630912498905, 0.1855970916255043, 0.21542815687686045, 0.22835433742240419, 0.324125157942045, 0.2521340529191196, 0.2139749905710171, 0.1698843189452809, 0.20085478831158443, 0.38016681549230114, 0.44010984243758944, 0.26291208784082887, 0.29886225535138966, 0.35143802036840144, 0.23428344261563327, 0.3999498584238508, 0.26602156733162396, 0.5573014473606375, 0.14701851410268174, 0.2181217037761627, 0.16039151720049505, 0.2137948135058121, 0.2980449103237848, 0.29941864522946204, 0.2910017133757493, 0.2717002061197663, 0.390490590012343, 0.22208152746252585, 0.20656391208615432, 0.24283160052142205, 0.19146908232952764, 0.1971784217465663, 0.2334908888311883, 0.20895082534910692, 0.2328966768888261, 0.22600624910214162, 0.21616019735883552, 0.21263667726977487, 0.6846278268652731, 0.22425997960700672, 0.20797834058817544, 0.2106461782090867, 0.21692141142482013, 0.2156682462612327, 0.654628585512268, 0.1906528141279017, 0.9310829984039195, 0.17243374982569826, 0.14809713524241108, 0.913613678397893, 0.6945228371054575, 0.12281207352795864, 0.1785067143389022, 0.8686686136091841, 0.1279410572263432, 0.16806177075996098, 0.211323401740229, 0.5542793731584317, 0.1690872111367353, 0.1691714225986316, 0.7576531109392721, 0.74861499769866, 0.6727675136207095, 0.1843861227285365, 0.1761798818681073, 0.17721150703993116, 0.18521302111144333, 0.19882013711836877, 0.18309266980445382, 0.17554794511751426, 0.18155293362029035, 0.21342994432884876, 0.16030291378739003, 0.08575164054296636, 0.08317275461163043, 0.1044290632793703, 0.09418471360312974, 0.10540881113523648, 0.13446357277134247, 0.07210833495289115, 0.08353909204295928]}, "mutation_prompt": null}
{"id": "115fae8c-9290-47f8-a3e3-d09c25312c0d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            diversity = np.std(positions)  # Calculate population diversity\n            mutation_probability = min(0.1 + diversity / 5.0, 0.3)  # Adjust mutation probability based on diversity\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:  # Updated mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved mutation strategy by varying the mutation probability based on population diversity.", "configspace": "", "generation": 26, "fitness": 0.3070277271337046, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.7664865924447604, 0.8106809590211141, 0.7940556817432004, 0.7947093310856782, 0.8087075039300905, 0.7908171691849054, 0.7749841462582032, 0.81475700469796, 0.8011476009872822, 0.5824666981835983, 0.5763587619253703, 0.42638107662111724, 0.5112594294032675, 0.595629645775282, 0.5913641007589892, 0.05614877853699085, 0.6149899046694944, 0.5422353613318137, 0.10859621174528078, 0.13451613562955222, 0.18697545353436185, 0.11110445940353586, 0.13351633584501665, 0.1329948964826856, 0.09716754357854496, 0.12409761882759462, 0.13247130885168734, 0.11783847251100321, 0.11327878099833522, 0.10683008694986906, 0.09211956701944113, 0.0999683203020193, 0.11018850042088812, 0.1368396580855018, 0.12075580100872996, 0.11328651609253448, 0.9827984160271674, 0.9761038032738866, 0.9783470250809738, 0.9745520076703766, 0.9814724122127448, 0.9848051975196065, 0.985589149806654, 0.9879684503104937, 0.9726180685378841, 0.4184634924069862, 0.47214825853831777, 0.40344373228932107, 0.40557419973964226, 0.4312091708422847, 0.4242226879621951, 0.4303668883272934, 0.4315681999135691, 0.39919706788923814, 0.6874352887943563, 0.6054911838029444, 0.5800765527766245, 0.5960956180971576, 0.6398243114316206, 0.7348895342979856, 0.6105186873704402, 0.6429288656239461, 0.6206204302427127, 0.22767495793513348, 0.19406819091881045, 0.23446105465304556, 0.20023477939346734, 0.20982487210292344, 0.24673118180281894, 0.23729768135352547, 0.15307255058486913, 0.23390261827476133, 0.05235054540109774, 0.12443030884729867, 0.23566966334510564, 0.24298002417283926, 0.25036758727106956, 0.2952037669069376, 0.2266587436434061, 0.23473192582961522, 0.32164304838898217, 0.0628013721405678, 0.049102349526392364, 0.08455797823066447, 0.05627095247745584, 0.07054399205589856, 0.03688915294284456, 0.039128323892508754, 0.0724046610836051, 0.04147022599420125, 0.17748448048202392, 0.20754453213205748, 0.18399672813771617, 0.14271597075590814, 0.1325103386136549, 0.19162238963241185, 0.1506104159475814, 0.171315697752495, 0.15344769350122844, 0.03036092418485714, 0.046813608513907146, 0.12313347098453964, 0.0681723993307205, 0.12759957483398687, 0.07166485219081076, 0.03745667569535749, 0.09175038881112718, 0.06210580682341349, 0.1332251097111028, 0.15068431170072527, 0.16647057853532932, 0.1471880676536843, 0.19998768053829585, 0.1706948288651301, 0.14887543860843122, 0.13566986892310817, 0.05555890624160342, 0.561895888975353, 0.5542554167971545, 0.5313792762506553, 0.5227140790232463, 0.5382776784373883, 0.5593088781698067, 0.5488469050248501, 0.5572408214582816, 0.5376840642803357, 0.08622284790856571, 0.09904545004619392, 0.09173093732966298, 0.095718213368298, 0.09366365103581298, 0.1340232804361432, 0.08843129530522387, 0.10956689057276614, 0.10454454995827123, 0.14596208177225545, 0.23996248262022368, 0.2844970219906068, 0.1729107060132865, 0.20397180741651733, 0.17287434320205008, 0.21070839748546955, 0.19304781473859967, 0.21160325919682632, 0.37223573633164375, 0.37337571945856785, 0.4340336540681554, 0.32075046679341734, 0.3636009745865505, 0.3982728742061621, 0.40383433682578196, 0.4276769457395577, 0.4461742781133363, 0.26981137097032737, 0.23865267189827355, 0.18810596069026275, 0.25760361828176914, 0.2502229362191537, 0.25568375382612396, 0.27349814548575613, 0.19946556809582405, 0.2706858636003321, 0.20372541208949124, 0.20671133919154694, 0.19953234923423613, 0.21120969688302738, 0.21306821192280823, 0.2137799495269368, 0.19847983570646144, 0.19804600646825543, 0.2161809139272518, 0.21602144949309676, 0.2109826534377265, 0.1821582079964864, 0.2038221894592782, 0.2030618963050277, 0.20062939879654218, 0.19095325607396396, 0.18330750675895646, 0.21632932599078125, 0.5989828659550271, 0.8483190277154152, 0.19008575103248748, 0.1644683293731568, 0.8342033003384715, 0.19209980545170702, 0.5352579395977866, 0.17810748454394998, 0.1692118261144404, 0.19224209089909094, 0.16818599175163929, 0.210236750250677, 0.6445010892223475, 0.16802723214954363, 0.6365380314123652, 0.20228388688312005, 0.7086876080213194, 0.15403418461896767, 0.18385045840428405, 0.17739445992999192, 0.18310075826023398, 0.19985888906206295, 0.18443793010644383, 0.1811642886071806, 0.18385791776386406, 0.1814578076062061, 0.19270092645867776, 0.07646854219240051, 0.07063145490122147, 0.08086984352760374, 0.07072840606836217, 0.07369648783262506, 0.08052853787809422, 0.08326206412058523, 0.08174154292310598, 0.07780567373583724]}, "mutation_prompt": null}
{"id": "ffe84c11-36eb-4d43-a2b6-23578428f69b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:  # Mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced global exploration by introducing a dynamic social coefficient in the velocity update formula.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.867692253434374, 0.8815003195765088, 0.8771471721995272, 0.8631086744923118, 0.8757277262423746, 0.862984182308518, 0.8723568141657483, 0.8791619152060851, 0.8899852011827959, 0.6294646036147387, 0.6926664627697631, 0.7193686321199451, 0.6709636130373958, 0.7271454686505168, 0.7147927600210987, 0.7186130124111565, 0.6942402238036153, 0.7218723415408133, 0.11157108607638166, 0.13091229375445912, 0.1763816524327898, 0.16561286243083284, 0.14822019505354112, 0.1597290270833388, 0.16280946101637472, 0.14092811445963438, 0.14204864182950117, 0.11840274621942082, 0.1083016099682853, 0.13952765426406388, 0.1177448048429176, 0.14362278851159882, 0.1738281786570871, 0.13031622475353055, 0.1395687451204698, 0.13601472262932135, 0.986435840851201, 0.9554816498870008, 0.9772804437014444, 0.9676574271955675, 0.9859929806278122, 0.985974046755495, 0.9860246998420932, 0.9849358588041021, 0.9768310147518549, 0.6020508895462866, 0.6352378721631113, 0.6050664233556488, 0.5301762279495041, 0.6526406952738802, 0.4857977535988425, 0.5759055300871989, 0.6617021259940367, 0.6237227157946708, 0.6484004124729457, 0.2262746496956073, 0.21979792475488336, 0.9328702442575547, 0.7258117454234334, 0.19326945584752042, 0.23972496526542775, 0.8230492180668337, 0.8170160689830076, 0.12613888923820837, 0.24215653582997243, 0.282006411502568, 0.24721748820761058, 0.22778036908015742, 0.13260865406487043, 0.21768441901739066, 0.2361941616641996, 0.22513162597718384, 0.12558261560777095, 0.12916302847439387, 0.2537973632648878, 0.2429153154352902, 0.13711336471014424, 0.12955519114152103, 0.123751677294211, 0.2763879856367495, 0.2794545436888559, 0.05838490304291333, 0.028760824617761305, 0.009696455787594593, 0.07567389637355337, 0.00663502112498171, 0.021129577402529853, 0.0014884622994846275, 0.021969516071864148, 0.09136331265089159, 0.12354081936476236, 0.1316769201750314, 0.1349962204715477, 0.1562140565823129, 0.12443004855436246, 0.09058352779204992, 0.1463659586746231, 0.10356454369212786, 0.1700283015936589, 0.03455195917643594, 0.2046170649652902, 0.03375893475413572, 0.10603131617400707, 0.07835611714400692, 0.09429029264218514, 0.19717528971216003, 0.06967745819264837, 0.13969804612922876, 0.17046048123424629, 0.08396122036307097, 0.14938930130457084, 0.3249685020861893, 0.18765418417296698, 0.10527388989436637, 0.1090988123894211, 0.08288285557791808, 0.05640723922799151, 0.5687337087622124, 0.5472278964161547, 0.5949172510171744, 0.5910391687655674, 0.6136609670826076, 0.6024631660955947, 0.5803089445491798, 0.6600003785923159, 0.5925339643448435, 0.07454953452043811, 0.0892707162138866, 0.1214920277991074, 0.13101366638463274, 0.13179142890842777, 0.12301981330485745, 0.0858518944750043, 0.14251207859555182, 0.0928832569006991, 0.2642761477176665, 0.288139017509921, 0.1975107503483724, 0.26905658878776373, 0.1902957930738306, 0.18347221739969377, 0.1530066644119693, 0.23146138725867405, 0.2075095278521879, 0.3888282955024349, 0.5424079148723329, 0.30604498345608977, 0.3660208924734394, 0.6005834665894929, 0.22899081702667912, 0.5717975708735401, 0.5758305235728691, 0.43092197785526676, 0.1593626674829779, 0.2769860261595277, 0.2523290283149461, 0.28367046834048026, 0.355642476742406, 0.30129006329792996, 0.14022511563727713, 0.24218544462826697, 0.32563201863309144, 0.23799105941584153, 0.21538468353665208, 0.21205007127847897, 0.20876876296129898, 0.22509365504005285, 0.23376370158146698, 0.19689620293118237, 0.19730783537802177, 0.21756284718550156, 0.19284201963104708, 0.19999135214763275, 0.2526235886227223, 0.20722030960530224, 0.22324954420542364, 0.21053801411395456, 0.2400669958790863, 0.24623230416242792, 0.2248061502557268, 0.11896609019032822, 0.9102692755335844, 0.17268544824857834, 0.16522343427542963, 0.9015075508039732, 0.1768007535669911, 0.12283703919387212, 0.17567720209423188, 0.9030123290004761, 0.19972114120084017, 0.16826304337164655, 0.21108875398825544, 0.10515996891212198, 0.16905145192496862, 0.1692860523790254, 0.796335395738414, 0.7829770365847333, 0.10478503612262069, 0.18574019904926764, 0.21759779159483228, 0.18773181928850335, 0.20377239513050216, 0.17978679652432217, 0.19362944677917593, 0.1780978784910392, 0.1862173516366088, 0.1782817631618675, 0.10903853898933324, 0.08421603946048872, 0.0807988495203219, 0.11442911876965278, 0.08033637792124682, 0.09373435630620697, 0.1341947962397153, 0.08736046927911378, 0.08921633489154779]}, "mutation_prompt": null}
{"id": "0a49ff71-2d74-4ec5-8c75-bf69e4855adf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.1 * (1 - self.current_evaluations / self.budget)  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:  # Adaptive mutation probability\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced diversity by introducing adaptive mutation probability based on iteration progress.", "configspace": "", "generation": 28, "fitness": 0.32238263759434765, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.8650043087772205, 0.8746860121525318, 0.8805003053092303, 0.8711214774318004, 0.8858452719337967, 0.8862800197238767, 0.8819018945894359, 0.8811715617384742, 0.8835506704463517, 0.07685736572377266, 0.6963169422829167, 0.7241518771567487, 0.7028534215570297, 0.7321059159292197, 0.7315055959257022, 0.740301192208596, 0.7338323512647045, 0.7455631756244849, 0.5140119828115398, 0.14041194210576613, 0.12272834840475699, 0.07518183849478699, 0.14133734291496713, 0.14032216179194112, 0.07282168344344353, 0.13916313363138177, 0.12146254204619944, 0.12209427033391307, 0.1751126484392247, 0.1094648879914425, 0.12884140195869553, 0.1436335531983245, 0.10367329109990386, 0.11723277101337448, 0.11332357178411279, 0.11339929886780042, 0.986435840851201, 0.9554816498870008, 0.9772831651876075, 0.9676574271955675, 0.9859929806278122, 0.985974046755495, 0.9860246998420932, 0.9849358588041021, 0.9710602176246441, 0.6523448394740112, 0.5973944124715846, 0.5709853205227149, 0.6169389969215949, 0.6821508165429211, 0.4845451143481989, 0.6507294570871882, 0.6671616871137562, 0.6754779312908257, 0.35081068794848014, 0.21585418952168656, 0.22713880558910982, 0.916842177864341, 0.19208968603880305, 0.21251816561598158, 0.2495807061185592, 0.23605121489494685, 0.7580337919683013, 0.130696948883107, 0.2269450117724927, 0.22312074309199492, 0.20852730208612802, 0.1738698758755436, 0.21133108760506525, 0.20963670249570443, 0.2463024753007167, 0.22220314955021936, 0.1305428926360399, 0.13260070882713626, 0.2347443440554915, 0.22876100304198188, 0.1371679774692528, 0.27226960537479394, 0.12858085765548222, 0.27296468930450224, 0.24134721523218072, 0.049115213288582704, 0.03650432205263365, 0.04059381580012489, 0.014486727870387961, 9.999999999998899e-05, 0.003227327726693874, 0.009241018247655663, 0.03158609475930518, 0.08295770629590882, 0.06764705142987115, 0.0972263529667825, 0.08496512771010767, 0.08281916053821226, 0.1250955555201657, 0.09695770866555309, 0.14983814071419788, 0.08599902178417984, 0.192964676779108, 0.035165773158587266, 0.22064745461945034, 0.060340428178577876, 0.10588003226557485, 0.07881302464236906, 0.23873265196935123, 0.14813393537345543, 0.07136232596678604, 0.13412793784298815, 0.241058719072747, 0.04340951567282825, 0.054478591156850276, 0.3260006312402497, 0.2252864772039257, 0.18222097024983996, 0.10291534466178731, 0.08272717915958694, 0.04963902259023545, 0.549581157950172, 0.584161819757657, 0.5728406751254331, 0.5461887981645919, 0.5746725231147964, 0.6488794063165679, 0.5985232007620562, 0.609568442176353, 0.5971816000751774, 0.06185484187403123, 0.08859175432577082, 0.13605997364396372, 0.11929801154958408, 0.11032470277413253, 0.16508785545896498, 0.08036378899457541, 0.14237187764646242, 0.11420852583330865, 0.2428033590276224, 0.21823375059840866, 0.2928821805629326, 0.2651808449011682, 0.2145076897420507, 0.15918636042010326, 0.20823839174506598, 0.18259355980929481, 0.43114550171153876, 0.34055577927023795, 0.46332588816867015, 0.2802079109919581, 0.41258973414091105, 0.33738161942008693, 0.22478968298477175, 0.5737348364088088, 0.5145467029529913, 0.3635256122752314, 0.15702714178360944, 0.2697924617894307, 0.235114105864618, 0.27185130086696185, 0.476955855923496, 0.25759539051949376, 0.14384264609233033, 0.4233329864567571, 0.23178544680418978, 0.25077184369644634, 0.2212693342974198, 0.19671498333005866, 0.23761232670214671, 0.22248907892792535, 0.24571748817841377, 0.2239924013394311, 0.19063575230806595, 0.22512635284041704, 0.19727466477469513, 0.22470198388660556, 0.2522119159046933, 0.5869246430968595, 0.24690080703467898, 0.22623864611776257, 0.21733500811574136, 0.20793219810568053, 0.25255257853122015, 0.08865318627553553, 0.9129648451460101, 0.17259035263760047, 0.14823401194861874, 0.8956273299908931, 0.1772885428017098, 0.12288558156410923, 0.17864389027298277, 0.8857881288784928, 0.12799871410085017, 0.16827163956154634, 0.21224228843554283, 0.10524530525564901, 0.16904640311055386, 0.5881882094168396, 0.7190432574008925, 0.8271897095910686, 0.10485736446322791, 0.18475442430185907, 0.21458648552595672, 0.1976708874986166, 0.18096165940937137, 0.18652986891094137, 0.18310446377082013, 0.19007957856116653, 0.17418368086071445, 0.2007286605096743, 0.11970416108387216, 0.09521663179118711, 0.09819604213055666, 0.13992561426413175, 0.09459048985624507, 0.10103955621340388, 0.13400858071822497, 0.0834378826614709, 0.10314704184565815]}, "mutation_prompt": null}
{"id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)  # Dynamically adjust mutation probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved exploration by adjusting the mutation probability dynamically based on the current evaluation ratio.", "configspace": "", "generation": 29, "fitness": 0.3322865008741697, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "41fbe9ec-c51b-42fd-bedd-e7c728271623", "metadata": {"aucs": [0.8386806500719317, 0.8658928128651482, 0.8476316404603792, 0.8688241989304849, 0.8643162627796306, 0.8562490761539097, 0.8507738697298557, 0.866210978290186, 0.8583437161911046, 0.6809064072559248, 0.6138426093622579, 0.6949239854760586, 0.6766978681471112, 0.6967471169082622, 0.684248345654435, 0.6854469873329156, 0.6767256195098372, 0.7112958317313831, 0.14324768905658636, 0.17699241045484537, 0.14858255457088365, 0.06561226470406034, 0.14261689290906265, 0.16087306061226514, 0.14533494580654605, 0.16338852586705854, 0.10605201310507617, 0.10841052820606056, 0.1353879083222035, 0.16619155338921077, 0.1263147398833262, 0.13713809938355137, 0.13432717380453818, 0.13948616621254872, 0.15213493835115588, 0.1200695619343689, 0.9859628423767254, 0.9771724030897488, 0.9790777977180285, 0.9722321172913488, 0.980227479273507, 0.9855537089527114, 0.9816050301396516, 0.9842866943511625, 0.9772165091635696, 0.6035374819356868, 0.6034652866576571, 0.5924617844531641, 0.5936744314686937, 0.5977415413458933, 0.5905168270437555, 0.5560622936261657, 0.08815385716133717, 0.5998821830083311, 0.702771399734195, 0.8037810649208329, 0.7228967683112411, 0.8349654397821475, 0.6976275838430163, 0.27542213191672504, 0.6864621188793496, 0.7497101170774645, 0.8533871428723367, 0.12298054234121958, 0.22305744705277952, 0.21627755639662039, 0.23550598325192396, 0.12296715275187742, 0.1326886697659615, 0.23547457678829764, 0.22470188677901226, 0.22644817447774734, 0.15469089674610625, 0.1315511721195055, 0.2357924738659477, 0.26465259293112087, 0.1328668148169323, 0.23926102439172459, 0.25191950987062006, 0.22399920081410163, 0.39225419571630904, 0.044268884531516006, 0.0457155862684151, 0.035478887882005594, 9.999999999998899e-05, 0.027100576359495032, 0.0024054159064483827, 0.04559548849137096, 0.028171665721311023, 0.05135904795466539, 0.13635343119469312, 0.13405236131352627, 0.13028353310636376, 0.13790525755399052, 0.113199074838082, 0.13189615075585337, 0.11105586370224751, 0.1427069513702407, 0.12082377215318629, 0.05498921489975839, 0.03333934832523178, 0.11408235434538871, 0.07448755766029957, 0.07448962219214006, 0.09047043264581445, 0.13243480033061372, 0.11420401483878817, 0.15096906047024472, 0.15762620484690082, 0.18298032412229015, 0.17985115912116634, 0.15441180821938727, 0.2648694747486082, 0.20126638387091556, 0.08238124099589317, 0.16645980457752485, 0.06153671184405085, 0.5905209544724479, 0.5466083330521323, 0.5670290588824718, 0.6017477691590354, 0.5659175649885885, 0.5557624708122941, 0.5854110313220062, 0.5831193640793368, 0.5753497546654374, 0.07508326827577672, 0.114907797349453, 0.12878206963048155, 0.12020727431089506, 0.11416607319968075, 0.11798668018544578, 0.1504112811214673, 0.1453219191356555, 0.11726004938831269, 0.2674440747339849, 0.29062316196251947, 0.1975350242866185, 0.15009310320724434, 0.16047071487639275, 0.22179267594660845, 0.19228176530306784, 0.16600169248325258, 0.2891511643577891, 0.37158157700012473, 0.4759015412996165, 0.4008269676624676, 0.3811731072898681, 0.3947528914945475, 0.4603446800033839, 0.4382925930934972, 0.4543270743627653, 0.5957077463791793, 0.23703986311500025, 0.22055692300163365, 0.30514861703438, 0.22475849369508671, 0.29415036971809194, 0.30774522725074616, 0.24866116142753136, 0.3553047279532874, 0.2732438368714889, 0.18180329916721139, 0.22977608334943567, 0.2306129429193321, 0.2068342669861597, 0.20901824709363415, 0.2235930689055412, 0.18617013263124793, 0.20049598431705196, 0.21518941251061885, 0.21900974748176072, 0.20700462093529703, 0.47228698247894585, 0.18886585596604577, 0.22375325437877425, 0.20698058175745104, 0.2066492050924562, 0.21834908806682463, 0.21722463370832634, 0.13892521163515825, 0.9012781282778882, 0.1860044794399871, 0.14768355466499183, 0.8630892992666115, 0.850052789282491, 0.12290067555828466, 0.17868683434514765, 0.8754642945886674, 0.412459671333528, 0.16838643451683888, 0.21221826784819076, 0.20641362388168705, 0.1691279958945604, 0.1685258923754145, 0.20086094683581734, 0.7978757836443757, 0.15516075427398557, 0.17351636407808468, 0.20650298067079131, 0.18408379431899802, 0.18365124451717085, 0.1821107763390849, 0.19770123865746314, 0.19279772028173747, 0.181551498833336, 0.17863684615649966, 0.1136061451356194, 0.08877475272455071, 0.09758062684317959, 0.07689091921513824, 0.09573132955795716, 0.08442923412060077, 0.12505924669287383, 0.10520076993099536, 0.09463878764090272]}, "mutation_prompt": null}
{"id": "488a6919-1aad-4a98-993b-fae605bb5549", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.9  # Adaptively adjusted\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        # Adaptive inertia weight\n        self.inertia_weight = 0.4 + 0.5 * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.6 * (b - c)\n        \n        # Multi-point mutation\n        additional_mutation = np.random.choice([a, b, c], size=self.dim)\n        mutant = 0.5 * (mutant + additional_mutation)\n        \n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  # Adjusted probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight and multi-point mutation to improve exploration and convergence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {}, "mutation_prompt": null}
{"id": "d8e92a0b-2a6d-4852-812c-33e565ebd93a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)  # Dynamically adjust mutation probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved exploration by adjusting the mutation probability dynamically based on the current evaluation ratio.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {"aucs": [0.8386806500719317, 0.8658928128651482, 0.8476316404603792, 0.8688241989304849, 0.8643162627796306, 0.8562490761539097, 0.8507738697298557, 0.866210978290186, 0.8583437161911046, 0.6809064072559248, 0.6138426093622579, 0.6949239854760586, 0.6766978681471112, 0.6967471169082622, 0.684248345654435, 0.6854469873329156, 0.6767256195098372, 0.7112958317313831, 0.14324768905658636, 0.17699241045484537, 0.14858255457088365, 0.06561226470406034, 0.14261689290906265, 0.16087306061226514, 0.14533494580654605, 0.16338852586705854, 0.10605201310507617, 0.10841052820606056, 0.1353879083222035, 0.16619155338921077, 0.1263147398833262, 0.13713809938355137, 0.13432717380453818, 0.13948616621254872, 0.15213493835115588, 0.1200695619343689, 0.9859628423767254, 0.9771724030897488, 0.9790777977180285, 0.9722321172913488, 0.980227479273507, 0.9855537089527114, 0.9816050301396516, 0.9842866943511625, 0.9772165091635696, 0.6035374819356868, 0.6034652866576571, 0.5924617844531641, 0.5936744314686937, 0.5977415413458933, 0.5905168270437555, 0.5560622936261657, 0.08815385716133717, 0.5998821830083311, 0.702771399734195, 0.8037810649208329, 0.7228967683112411, 0.8349654397821475, 0.6976275838430163, 0.27542213191672504, 0.6864621188793496, 0.7497101170774645, 0.8533871428723367, 0.12298054234121958, 0.22305744705277952, 0.21627755639662039, 0.23550598325192396, 0.12296715275187742, 0.1326886697659615, 0.23547457678829764, 0.22470188677901226, 0.22644817447774734, 0.15469089674610625, 0.1315511721195055, 0.2357924738659477, 0.26465259293112087, 0.1328668148169323, 0.23926102439172459, 0.25191950987062006, 0.22399920081410163, 0.39225419571630904, 0.044268884531516006, 0.0457155862684151, 0.035478887882005594, 9.999999999998899e-05, 0.027100576359495032, 0.0024054159064483827, 0.04559548849137096, 0.028171665721311023, 0.05135904795466539, 0.13635343119469312, 0.13405236131352627, 0.13028353310636376, 0.13790525755399052, 0.113199074838082, 0.13189615075585337, 0.11105586370224751, 0.1427069513702407, 0.12082377215318629, 0.05498921489975839, 0.03333934832523178, 0.11408235434538871, 0.07448755766029957, 0.07448962219214006, 0.09047043264581445, 0.13243480033061372, 0.11420401483878817, 0.15096906047024472, 0.15762620484690082, 0.18298032412229015, 0.17985115912116634, 0.15441180821938727, 0.2648694747486082, 0.20126638387091556, 0.08238124099589317, 0.16645980457752485, 0.06153671184405085, 0.5905209544724479, 0.5466083330521323, 0.5670290588824718, 0.6017477691590354, 0.5659175649885885, 0.5557624708122941, 0.5854110313220062, 0.5831193640793368, 0.5753497546654374, 0.07508326827577672, 0.114907797349453, 0.12878206963048155, 0.12020727431089506, 0.11416607319968075, 0.11798668018544578, 0.1504112811214673, 0.1453219191356555, 0.11726004938831269, 0.2674440747339849, 0.29062316196251947, 0.1975350242866185, 0.15009310320724434, 0.16047071487639275, 0.22179267594660845, 0.19228176530306784, 0.16600169248325258, 0.2891511643577891, 0.37158157700012473, 0.4759015412996165, 0.4008269676624676, 0.3811731072898681, 0.3947528914945475, 0.4603446800033839, 0.4382925930934972, 0.4543270743627653, 0.5957077463791793, 0.23703986311500025, 0.22055692300163365, 0.30514861703438, 0.22475849369508671, 0.29415036971809194, 0.30774522725074616, 0.24866116142753136, 0.3553047279532874, 0.2732438368714889, 0.18180329916721139, 0.22977608334943567, 0.2306129429193321, 0.2068342669861597, 0.20901824709363415, 0.2235930689055412, 0.18617013263124793, 0.20049598431705196, 0.21518941251061885, 0.21900974748176072, 0.20700462093529703, 0.47228698247894585, 0.18886585596604577, 0.22375325437877425, 0.20698058175745104, 0.2066492050924562, 0.21834908806682463, 0.21722463370832634, 0.13892521163515825, 0.9012781282778882, 0.1860044794399871, 0.14768355466499183, 0.8630892992666115, 0.850052789282491, 0.12290067555828466, 0.17868683434514765, 0.8754642945886674, 0.412459671333528, 0.16838643451683888, 0.21221826784819076, 0.20641362388168705, 0.1691279958945604, 0.1685258923754145, 0.20086094683581734, 0.7978757836443757, 0.15516075427398557, 0.17351636407808468, 0.20650298067079131, 0.18408379431899802, 0.18365124451717085, 0.1821107763390849, 0.19770123865746314, 0.19279772028173747, 0.181551498833336, 0.17863684615649966, 0.1136061451356194, 0.08877475272455071, 0.09758062684317959, 0.07689091921513824, 0.09573132955795716, 0.08442923412060077, 0.12505924669287383, 0.10520076993099536, 0.09463878764090272]}, "mutation_prompt": null}
{"id": "83fdde4d-4794-4ab8-8523-3baa1f5db2f3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_max = 0.9  # Adjusted for adaptive inertia\n        self.inertia_weight_min = 0.4  # Adjusted for adaptive inertia\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (self.current_evaluations / self.budget)  # Adaptive inertia weight\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def local_search(self, position, func):\n        # Simple local search to improve convergence\n        neighbors = np.random.uniform(-0.1, 0.1, size=position.shape) + position\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        best_neighbor = position\n        best_fitness = func(position)\n        for neighbor in neighbors:\n            fitness = func(neighbor)\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_neighbor = neighbor\n        return best_neighbor\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n                positions[i] = self.local_search(positions[i], func)  # Apply local search\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced convergence by incorporating local search and adaptive inertia weight.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1. Sphere (iid=1 dim=5)>, -0.9141282360591335').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1. Sphere (iid=1 dim=5)>, -0.9141282360591335')", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {}, "mutation_prompt": null}
{"id": "6ebff165-a129-4496-94bc-f92c50cb8cf0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)  # Dynamically adjust mutation probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index] + 0.01 * np.random.randn(self.dim)  # Add perturbation\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhancing global exploration by adding a small random perturbation to the global best position.", "configspace": "", "generation": 33, "fitness": 0.2872260715115065, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {"aucs": [0.599772666453144, 0.6373567079401112, 0.6423172440041074, 0.609155683886129, 0.6235089970244283, 0.626365183971489, 0.6236857376091598, 0.6355512792868808, 0.6532384372719597, 0.18529774340204652, 0.22700619684854473, 0.21883369152279997, 0.23718928445001164, 0.2274010588129768, 0.23925360204235735, 0.18888437185567963, 0.05283186111851412, 0.19495583065741717, 0.1132795092302098, 0.20354552982876006, 0.1455810323253114, 0.13495511644859293, 0.12707002687006297, 0.13378324270231712, 0.13907907826181676, 0.1251903530687687, 0.15948651434329475, 0.11765116658779262, 0.12700430973514865, 0.10134272294450475, 0.14219925178093784, 0.13690298774519927, 0.11964226079498474, 0.1466613276000882, 0.11117569457920273, 0.10833104639457924, 0.9849820652664445, 0.9623096859034953, 0.9721470974529155, 0.9772138952005195, 0.9775011761215222, 0.9876088833329632, 0.9882199200946762, 0.986815928068602, 0.9774038150696504, 0.40023885335065124, 0.4204041687116584, 0.37667059166520744, 0.4013273372537596, 0.42969349593027273, 0.4254064125463014, 0.41391255846510244, 0.3738745790689071, 0.417803072636301, 0.7272996644029603, 0.5765757951425028, 0.792329032959935, 0.8436517369792911, 0.16117838840281296, 0.27503116689814233, 0.26728947220897015, 0.7375797240585839, 0.7522823128477965, 0.11784934241998812, 0.2397247049631973, 0.12493726133582628, 0.21119120186108808, 0.2209258563042158, 0.20514096983972352, 0.21924743603868124, 0.27687742095132584, 0.22395311030965737, 0.11567990892899294, 0.2294764776337065, 0.23720656430005815, 0.21852945919478883, 0.2170919206593832, 0.2647669811670448, 0.24824435204596507, 0.12919113930718396, 0.21008168558161622, 0.06329548308834398, 0.058025346938574196, 0.05691668516794013, 9.999999999998899e-05, 0.010745616300902427, 0.015451028980388415, 0.010626077651582855, 0.0030665757475762945, 0.06133559639878372, 0.1293844777608698, 0.14083596710661628, 0.14178604007401885, 0.10290328756089384, 0.14467411490838256, 0.11757965886823474, 0.13047795389824735, 0.15251182914278838, 0.12212991836181641, 0.027256117898805665, 0.07380749304224121, 0.02894846143494123, 0.05691854323600254, 0.06520938306086554, 0.07810376581630352, 0.07109429295283787, 0.07096356043419672, 0.10523348858029824, 0.18808747937174042, 0.17934472637402576, 0.15675520801780363, 0.18505986913019679, 0.1782004127095148, 0.1865326254375682, 0.12867212713103326, 0.20114873667743427, 0.061943798461114974, 0.5019326389855898, 0.5275663770987846, 0.5102868206061021, 0.5099974604009696, 0.5260013001748445, 0.5334903589832569, 0.515663754954524, 0.5077320835485297, 0.5204080851155777, 0.07524634306248934, 0.12494998408932156, 0.1375989192312561, 0.12875802597428987, 0.09776253395551049, 0.12763576210640726, 0.11986375614546363, 0.14117677581980392, 0.09240958814737044, 0.2672018980243194, 0.1977692958605105, 0.3047750118241729, 0.24480977076495725, 0.30030141298559554, 0.2973374334011788, 0.21728540242259686, 0.2606702386422962, 0.24028040606225354, 0.29258829841341727, 0.3641806286036271, 0.36433257704945987, 0.37182815556534543, 0.36886519922443495, 0.2740209355987919, 0.33940960024079203, 0.37699055306685947, 0.3575151972221988, 0.2877994512331188, 0.2883700349051418, 0.26950442179647227, 0.29560969091630473, 0.18437145086966633, 0.2811691538599851, 0.2721651109910863, 0.2555892276104428, 0.20514729821245847, 0.2105902321448705, 0.2071846264310756, 0.19024578563744576, 0.22935485071659845, 0.23067161755361698, 0.21172302791332476, 0.19344138363495966, 0.22220763808077593, 0.20844870115194325, 0.2121021136252762, 0.20458751481014914, 0.24021222644296136, 0.20398283248235594, 0.23997129601790068, 0.19270557063525717, 0.21803185970637207, 0.3670892212444651, 0.20678693583298768, 0.18899799251548088, 0.8835080180896993, 0.1588503109667304, 0.1654577086642165, 0.8982675701088312, 0.7166288028258996, 0.14595026059394678, 0.17884292943944968, 0.8430199823470695, 0.1278979446650399, 0.16830799401964613, 0.21146844241327467, 0.7401458561989753, 0.1691948401423189, 0.16901417154888965, 0.745883434646262, 0.7368096139296414, 0.1559984373556379, 0.18711939310784442, 0.19327801718875948, 0.20960985980421598, 0.17266142591263756, 0.1867830701943669, 0.1889820664019356, 0.1852319736132133, 0.19024234250814487, 0.19266489312890211, 0.08841862917186005, 0.08016301749928256, 0.0982538724832126, 0.07842099274389058, 0.09390997545144708, 0.08904201093269126, 0.10637481196655085, 0.09665153440054308, 0.09359427167037226]}, "mutation_prompt": null}
{"id": "2a8f1cdb-7811-49cc-92a8-4df61f6e5075", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7  # Changed back to 0.7 for more adaptive exploration\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 5, replace=False)  # Increased from 3 to 5 for greater diversity\n        a, b, c, d, e = best_positions[indices]\n        mutant = a + 0.5 * (b - c) + 0.5 * (d - e)  # Modified to utilize more diverse vectors\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)  # Dynamically adjust mutation probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration using adaptive inertia weight and more diverse mutation strategy for better convergence.", "configspace": "", "generation": 34, "fitness": 0.27220510292354577, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {"aucs": [0.6751497153092246, 0.7083638269555083, 0.7160851819454214, 0.7013958241912375, 0.7574173206540649, 0.7194511193994868, 0.6930141571816124, 0.7281636468716871, 0.7487251397606052, 0.32564687879027043, 0.45221330480581867, 0.42568878836715285, 0.3506406485895269, 0.4129249875017329, 0.4314255208316975, 0.050804927773660524, 0.430921538937337, 0.42314953852295123, 0.10683333602682721, 0.11731305148817428, 0.16412068476734898, 0.09367058050287236, 0.12785716917216283, 0.12114001393287022, 0.11070027856346709, 0.13448673827236213, 0.11679060164398869, 0.09786201374262837, 0.1237396345654268, 0.10987574567793912, 0.11004365641831737, 0.10091257336043058, 0.10205553428315339, 0.107265697332108, 0.11264513737438542, 0.11588744764460612, 0.9851151260986528, 0.9771660737843465, 0.9854161004472789, 0.9688292493587355, 0.9845969939789222, 0.9857282335796274, 0.9863729505978319, 0.9903245546080166, 0.98157212931091, 0.33425336435874975, 0.3657791705967134, 0.2858766090039069, 0.3335984489031155, 0.14514600726293014, 0.26403304654319915, 0.34029830682808193, 0.08800205717811749, 0.3363428176162876, 0.5883383678334556, 0.5834851041115059, 0.6004406715624109, 0.7088210125006494, 0.4117107616496971, 0.41868747998747824, 0.4026381177966144, 0.6710217193804147, 0.577576136051982, 0.14418785555460767, 0.16795778105715287, 0.1733054813419438, 0.16338775456626065, 0.16890748415487833, 0.12144608159052495, 0.1631320718345034, 0.1525530976458609, 0.17923039073130387, 0.05120961342577812, 0.1854361235425549, 0.1418646207114782, 0.1575070126367747, 0.19484005076544142, 0.16470239369690753, 0.2032576484374926, 0.18172240015153052, 0.18797394040748572, 0.016507292328188483, 0.00999894345170993, 0.002166355737588277, 9.999999999998899e-05, 0.035542533068784854, 0.02140496413959969, 0.01916953634088736, 0.017116079098862258, 0.01180876500590644, 0.04571885656989083, 0.12488449149586234, 0.09518385299292931, 0.10234275177660579, 0.1305228772604491, 0.12533689259494962, 0.1147065097059854, 0.0860617594836025, 0.10148764510139607, 0.025444923022773902, 0.06597597790019205, 0.037548042231085654, 0.055807268345072436, 0.05858220396223601, 0.07076868119745128, 0.05035667929609444, 0.008577783405322448, 0.0710915369665106, 0.11464192539080809, 0.13807877229244714, 0.10530768035988736, 0.14971822454247652, 0.20358240922960213, 0.12862690140290955, 0.07617000159670773, 0.15721082815111953, 0.06574968105899659, 0.4883881001674537, 0.47153315444105204, 0.4854371544108417, 0.48869555318326563, 0.5141164212776128, 0.5168956084200982, 0.4824637025043049, 0.4908638220560628, 0.49734510870987514, 0.07718235241126747, 0.12554264037478968, 0.121788995998248, 0.07822762312344855, 0.09188739710498961, 0.11164272298406908, 0.10003404273144256, 0.09547070914028788, 0.12108468978579257, 0.1778837196341505, 0.23316432728436343, 0.2538203916122055, 0.2538408387220463, 0.18764934680319367, 0.25186679062357764, 0.17835125013166775, 0.22363539035451752, 0.14177312658655283, 0.32373842045468737, 0.3246491338883817, 0.2710330835305106, 0.34281781886982077, 0.36384456843983026, 0.28645161232632, 0.3722470534966168, 0.3726572665291179, 0.389208516328607, 0.2446127827282255, 0.208362142259658, 0.2199194117579294, 0.2267558774834013, 0.1891925792719812, 0.1861930835209039, 0.2559041733354058, 0.24412568993459183, 0.2776602440727256, 0.22152068224198007, 0.20246598215165157, 0.19791803517414053, 0.1899697912585233, 0.1814693485403982, 0.23081039151164084, 0.18392922451667315, 0.18628114095018566, 0.22003088020579709, 0.19433150527094867, 0.18538798942956314, 0.2026882466402895, 0.2540435266557435, 0.2009577900469227, 0.3235246105825771, 0.215916768370518, 0.20168370174584205, 0.20244104731235235, 0.16372962543349023, 0.7764267418064966, 0.16815327662053192, 0.19642702400534484, 0.7234529844656761, 0.1637318371419364, 0.18021799030597596, 0.6974136698730478, 0.6105299642660333, 0.12472080665317775, 0.16790205352970478, 0.20583843381990496, 0.42229581464673693, 0.1684188961479105, 0.49661607443372535, 0.3918513867420572, 0.6314848661060035, 0.20078836351926688, 0.17616549918940183, 0.1868282409282338, 0.18614062506217866, 0.18849987102966093, 0.18820740323381757, 0.18553840087347573, 0.19008537702078976, 0.1798562220032811, 0.1868817329012521, 0.08950807850609255, 0.09934020476409311, 0.08773594227608661, 0.09189099585806382, 0.07943808544058106, 0.08474080756218716, 0.11530294071522496, 0.08238943182818026, 0.08094946051956142]}, "mutation_prompt": null}
{"id": "00b7ea4f-b90a-4ade-9267-4d3a22d66187", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (self.current_evaluations / self.budget)\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        velocities = inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, neighborhood_positions):\n        indices = np.random.choice(len(neighborhood_positions), 3, replace=False)\n        a, b, c = neighborhood_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    neighborhood_indices = np.random.choice(self.population_size, 5, replace=False)\n                    neighborhood_positions = personal_best_positions[neighborhood_indices]\n                    positions[i] = self.mutation_strategy(positions[i], neighborhood_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance convergence by incorporating adaptive inertia weight and neighborhood-based mutation selection.", "configspace": "", "generation": 35, "fitness": 0.2478573311047356, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {"aucs": [0.5962239546764788, 0.621929352518396, 0.6236949516550403, 0.6323276264003328, 0.6436961369808858, 0.6447313548988776, 0.6032707157392425, 0.6328672383400415, 0.6373982958084348, 0.39662218261392845, 0.3784238986284013, 0.3622174074819534, 0.3623463029944711, 0.4024910934074213, 0.3869307785044874, 0.03890778441118581, 0.39505796969183193, 0.02688941023420377, 0.11518752742013638, 0.12004969895239759, 0.1143618239587122, 0.14722836473417278, 0.10226776872792576, 0.11933706370271757, 0.09181984131492105, 0.10739642605869681, 0.11959288369608434, 0.1097039147556167, 0.1032927540645493, 0.10007192776528695, 0.11729355058335045, 0.09795608592381833, 0.12969437059422506, 0.0906301704180893, 0.11727781231056889, 0.10869410161506443, 0.981471287303817, 0.981777781626199, 0.9855212422652814, 0.9851018761329781, 0.9819229236170077, 0.9862226344459993, 0.9861544799024456, 0.9903269669645198, 0.9818856293914139, 0.3418869954501089, 0.3599623755816499, 0.3050887080773492, 0.34041885223426627, 0.3399862941115721, 0.3287896989293311, 0.33620640751477116, 0.08830024313433482, 0.319137388787884, 0.47109200953109054, 0.41172685654933494, 0.4339101338778657, 0.5141948166072694, 0.41398446407295664, 0.2608386450930107, 0.19133979890564634, 0.2923570968538979, 0.2740840673342566, 0.08739648050198079, 0.13491307831882182, 0.16729707322482867, 0.14659146751277807, 0.14695492421432754, 0.15573275804279563, 0.15367081833588125, 0.1568356638520001, 0.15476866600029027, 0.02203202291597628, 0.1331865760512293, 0.15346837431176386, 0.13040287263848882, 0.12372941873096477, 0.11182483410092336, 0.1722978554126976, 0.14324284664310105, 0.16706874804410832, 0.014481689386543484, 0.02740221867937742, 0.01953639709085131, 0.018505461868978057, 0.001405180325817157, 0.004226953955956958, 0.0015620578472247404, 0.0016488142381780868, 0.026087400665113947, 0.11280837438554425, 0.12760023766958384, 0.11193704520222181, 0.06527601053315812, 0.10585366907497318, 0.08637233672110556, 0.13747088677390873, 0.09158999092077191, 0.13202743329606603, 0.021365071289026316, 0.02019070404093415, 0.029491001351808377, 0.042445078399642955, 0.04397326345105268, 0.037624949988394496, 0.030609081519474057, 0.06978547941120761, 0.035926427229368896, 0.07771179737676925, 0.12616443734348026, 0.11474739051641314, 0.11365803067725833, 0.10362612631080192, 0.19141758935497755, 0.0710982785215909, 0.13241534680705247, 0.043468876132572776, 0.44087906382867836, 0.4339340384928093, 0.4264629697324003, 0.43535415185553417, 0.47115688348973284, 0.45232466395399407, 0.4232346990229382, 0.43673021986163285, 0.4364156641849579, 0.0865791498285946, 0.10452960181188431, 0.0995632607818292, 0.08156362951927842, 0.08551923612302093, 0.10470119867861072, 0.09929676607194082, 0.09713719294532419, 0.08385004732966461, 0.21340133287108043, 0.17307235555411693, 0.17257516312279053, 0.18325587208021454, 0.15453236279954796, 0.1950706660048397, 0.1410252653747308, 0.13731637920981543, 0.19823590558117754, 0.3112862114274746, 0.3506666591327242, 0.34307122558502656, 0.2593032207811746, 0.2854409521236968, 0.3089263064558976, 0.375255374752792, 0.3006783427789488, 0.3842945015410776, 0.1899599453490285, 0.2426755343356518, 0.2082174252595581, 0.22883186343241524, 0.24667234096807733, 0.22137036117151465, 0.24944451557441438, 0.22348991731178025, 0.24801435454300036, 0.20889715354173855, 0.1966671469146456, 0.19403570263956849, 0.19680873153541356, 0.2035432991481495, 0.18348208262380516, 0.1832233858027078, 0.1820863529508826, 0.18608097761936782, 0.2874185509566425, 0.2005378462816526, 0.19701265294154302, 0.3500888301043398, 0.18799355672608276, 0.21463440397365108, 0.19903016925100514, 0.1954902979146963, 0.1945524488720093, 0.1699353804160626, 0.7085589592377717, 0.17082254326328927, 0.1832064890451528, 0.6540371867930947, 0.17061134049377813, 0.5427052701214463, 0.17423990406114065, 0.5937918556650852, 0.17850978382277194, 0.16710740304004845, 0.20227888990818754, 0.39385004712454585, 0.16643508223442582, 0.4193053158860476, 0.19912012370590093, 0.580241859147476, 0.20247420854424203, 0.17695353506158862, 0.19196794791850746, 0.1876917911932352, 0.20723217606913535, 0.18220363844096588, 0.19124418353854267, 0.18770868609548375, 0.19317774627184314, 0.17469492191250013, 0.07510530086974887, 0.09772217245752712, 0.07854933953722032, 0.0669474353619478, 0.07727038187310609, 0.080659819467228, 0.09995990655060227, 0.07491410742535243, 0.07455062054622663]}, "mutation_prompt": null}
{"id": "108cf338-3b60-40b5-9b54-e3ca9e6a139f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5  # Modified from 0.7 to 0.5 for better convergence\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()  # Dynamic social coefficient\n        self.current_evaluations = 0\n        \n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        self.inertia_weight = 0.5 * (1 - self.current_evaluations / self.budget)  # Adaptive inertia weight reduction\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        # Initialize population\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        # Main optimization loop\n        while self.current_evaluations < self.budget:\n            # Update velocities and positions\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Apply mutation strategy\n            mutation_probability = 0.2 * (1 - self.current_evaluations / self.budget)  # Dynamically adjust mutation probability\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            # Evaluate new positions\n            fitness = self.evaluate_population(positions, func)\n            \n            # Update personal and global bests\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration by incorporating adaptive inertia weight reduction based on evaluation progress.", "configspace": "", "generation": 36, "fitness": 0.3396014517813769, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "a28b0d9c-bbf5-43d6-bdc1-dbbea3ab4f0a", "metadata": {"aucs": [0.8675495763635646, 0.879979146963344, 0.8662879744773708, 0.8832940096988983, 0.8835619344389435, 0.8774016079764223, 0.8742404097959774, 0.8786843184425861, 0.8782137302627895, 0.7429556642048709, 0.7437136729237395, 0.7275140401206797, 0.7361502652578147, 0.7221431024338922, 0.7470398823575761, 0.7415005236272919, 0.7462925894664356, 0.7496138790500892, 0.1450657437170938, 0.1646961529146096, 0.13112191496238212, 0.07157586591540677, 0.1552425092111569, 0.11050817544828462, 0.0567751234756273, 0.15843490284253126, 0.14599346188505746, 0.14396702706067188, 0.13224462267770198, 0.16335067673994963, 0.15982503599779085, 0.12430037735180155, 0.09284959020554051, 0.14054498217083422, 0.15607630181721965, 0.13832144324222861, 0.9853777348362396, 0.9771707067190929, 0.9790217696521696, 0.9722311705463317, 0.9802158874238668, 0.9855415056860728, 0.9815906366305082, 0.9858799738906784, 0.9771981767672103, 0.6706694956080613, 0.7053597160615471, 0.7071245017242405, 0.6041976291225017, 0.6741570633626277, 0.6382862483752636, 0.6609961675702543, 0.08801722806448509, 0.6768739146681652, 0.8187395285987519, 0.7466027761607353, 0.3129828271350019, 0.8775364275108245, 0.2632033499846438, 0.21263098422430116, 0.3720658680092236, 0.7780885017245717, 0.7860756310690749, 0.18552223521301736, 0.24439882463165674, 0.23909393353903186, 0.22322968893356387, 0.12829494394438656, 0.2572786781819505, 0.2621864464724242, 0.22821376539481508, 0.26149183204493254, 0.13156193952603568, 0.19139360815812623, 0.246037342813346, 0.3360970744457592, 0.15260300881609234, 0.26523582238751586, 0.2377178501696039, 0.27857393028395694, 0.297739395854807, 0.0649999065049719, 0.03687600703906069, 0.04297789104020522, 0.0043958231054204155, 0.012290551601877087, 0.03858718537094852, 0.038714276958577654, 0.009700143746959267, 0.06192097098467242, 0.14390433952542447, 0.1773538260610389, 0.13316172515241265, 0.11519527568665922, 0.10509093462010555, 0.15806214403169727, 0.15125767447120653, 0.13973572347536678, 0.18095758039551135, 0.039718644470042475, 0.03358792165343949, 0.10188837753805113, 0.07931144823713676, 0.07612147651235868, 0.0908289968307443, 0.2355067819013299, 0.13569117403215025, 0.16243849175390168, 0.13933559732404388, 0.14622682143316612, 0.12975463378272267, 0.16796085130790994, 0.1706457300475206, 0.16375646211041583, 0.08338885642006566, 0.24929695724695533, 0.05578577819178843, 0.5704100819779211, 0.6062225309603022, 0.5852492373324572, 0.6159647503581784, 0.6008039926084503, 0.6605270688245998, 0.5733785473008173, 0.5977798712281266, 0.6184781520167435, 0.07455014047443642, 0.503636984459152, 0.10034394967493643, 0.10970928355766973, 0.11969784805711059, 0.11278508188927716, 0.139813266178196, 0.1437288801661023, 0.13389971278184098, 0.27214021256462406, 0.1650362905690148, 0.33582549203846834, 0.20259959435324204, 0.23560986421672314, 0.4519041458519676, 0.27917697657908325, 0.3101089648131756, 0.21438251625758453, 0.49530240068856446, 0.3323058720798613, 0.39775115441721987, 0.43106239496780574, 0.21269291541771962, 0.34352797760262743, 0.33505924273641363, 0.4189201976455186, 0.5070346348814898, 0.20013625945432445, 0.28155406565158914, 0.2950359653914292, 0.31484311208868143, 0.3422662787226509, 0.3262472670313351, 0.13814223418979343, 0.22152417076460373, 0.26675087875588543, 0.23718610480906155, 0.24335799551517667, 0.20860056395767912, 0.21080411360779538, 0.21969226632785743, 0.20380184580771787, 0.2142503300748746, 0.23517306550317785, 0.2159787903650655, 0.24092917701093952, 0.22212603200971814, 0.1828877290694515, 0.20459374089568438, 0.20895574734437816, 0.2015606243302155, 0.24703428551153828, 0.21364500631906091, 0.2406017424138588, 0.1653152532438722, 0.882846578346219, 0.18610165522221922, 0.14741665751997202, 0.9037797542141093, 0.8579635123787024, 0.8007085280128674, 0.17914839440118835, 0.8681049796527114, 0.12787381702765455, 0.16841309468920684, 0.21269752422407695, 0.20639247791742832, 0.16913446335575277, 0.16857460990002804, 0.19649312003249775, 0.7575733514862366, 0.15532623717040062, 0.17986038823242323, 0.2038709263829256, 0.18488394838443356, 0.1997215453230664, 0.2174586215797003, 0.19466726203813367, 0.18712864800871687, 0.20038435327029136, 0.18973494534215307, 0.08432507992340255, 0.08959830585721196, 0.08275896898856139, 0.1289682410353018, 0.09975305687481728, 0.09155813756588016, 0.12927491119633483, 0.09606059666506261, 0.09697906086139607]}, "mutation_prompt": null}
{"id": "a373231b-0024-4230-8e53-b32a3ee607d9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation and combined heuristic adaptation based on diversity and evaluations.", "configspace": "", "generation": 37, "fitness": 0.3435800521731464, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "108cf338-3b60-40b5-9b54-e3ca9e6a139f", "metadata": {"aucs": [0.8402659200829536, 0.8542795591227172, 0.8490346137048239, 0.84688908329695, 0.8577979798711433, 0.8663705040207466, 0.8393178609746315, 0.8564291825584341, 0.8436906174083869, 0.7159805467642322, 0.07478654088529824, 0.746101259901579, 0.72368687026045, 0.7270959746922427, 0.6904520113161131, 0.7127031684152803, 0.7420713872253077, 0.7329825742654092, 0.6324143151424152, 0.1341403528786146, 0.14632620123606888, 0.16718085494550483, 0.17463625947434525, 0.13765551728811898, 0.11143349154996451, 0.12322588772326348, 0.16523064963401835, 0.15295864543842508, 0.12469827625901875, 0.10824188584170313, 0.094072931357985, 0.1317109740619029, 0.1135261867111127, 0.13806322396252801, 0.1219598050739471, 0.1108153121281501, 0.9827559832568926, 0.9760826746662686, 0.9791340605288648, 0.9767380746783154, 0.9814857583979004, 0.9859784857615842, 0.9856493788865591, 0.9892658562808224, 0.9728603567341167, 0.6359573941619698, 0.6639238764965125, 0.5899994548199956, 0.5640195358147515, 0.6147132789999509, 0.528276229778941, 0.6078389987262418, 0.6180543559557957, 0.5382516707383171, 0.7251056620069477, 0.78760764173807, 0.6755967351566512, 0.7282440284702615, 0.7612768240848138, 0.7209425521115609, 0.7181605463959928, 0.7535521414031203, 0.74490402813735, 0.23828392365007778, 0.314751985828871, 0.2170278858876945, 0.13058256675117041, 0.1274656464823516, 0.1330052550606441, 0.2942937238356901, 0.15522377058093606, 0.21662410528550047, 0.11804873200983856, 0.21667560627846394, 0.22842740960156904, 0.2634991344903609, 0.26563720989000505, 0.17076734350339573, 0.12830733055886123, 0.19618150392499378, 0.28767586432629977, 0.035471047497068864, 0.05024369943191409, 0.05192431744080095, 0.010002167494150171, 0.003726366531007441, 0.03908358973445425, 0.0059523331852333605, 0.037209221030514716, 0.03119253114135989, 0.17294894767300717, 0.14219258361382292, 0.14374055761517435, 0.1470269473607514, 0.15567332038929127, 0.13796934209699319, 0.1603080789414476, 0.16411636276120112, 0.16780743687265243, 0.036578752821407434, 0.047346627371117056, 0.03308381563544405, 0.07306190998108775, 0.07281618663957357, 0.08943965529493758, 0.25625065081386456, 0.17413824888402873, 0.06829414829496383, 0.2532296955384554, 0.3100556106713256, 0.200003738512731, 0.14357408778342218, 0.2623549540829331, 0.23207819399574503, 0.19285789190913738, 0.09930451855767608, 0.05537985752022201, 0.6017797756355214, 0.5928713709976566, 0.5643046334031196, 0.5750593756497482, 0.5950994560274585, 0.5752829531959605, 0.5762856775955787, 0.5623542244932536, 0.5779806369387409, 0.08594210313250039, 0.12824917806551672, 0.11267265167256624, 0.10687252977328354, 0.13149348728845545, 0.09034141032958232, 0.11101629794977375, 0.1150737630527352, 0.10967283811279871, 0.14616802200890722, 0.2340630375175743, 0.16625091972175465, 0.1656223045860412, 0.18931409909723262, 0.2867013569496667, 0.4448754785651119, 0.3378942551062283, 0.20906272238044954, 0.3636916841580252, 0.27876884059137474, 0.4056112309806108, 0.4088763232166672, 0.38500106937562173, 0.25345889897518326, 0.3559192780899091, 0.4673070176357792, 0.3997198706042855, 0.21261450186146025, 0.2742802982301834, 0.28023835647629936, 0.2044160847594373, 0.26343348903297725, 0.18424600498155252, 0.28693899097221753, 0.3468826590209064, 0.42609073576360723, 0.20442579910757153, 0.21088405778144415, 0.2055974668508198, 0.22077023265641182, 0.2334191735192085, 0.23102192885079154, 0.18634722171602924, 0.2359295419095051, 0.2324976825999654, 0.2100363998614736, 0.1880859200197924, 0.6820854963524976, 0.23035982610722872, 0.23605912306964694, 0.24167673354871988, 0.5740286504507345, 0.19206904623595966, 0.203169050639617, 0.2062627407077654, 0.8799565223601403, 0.1856626036874589, 0.19622004833794604, 0.8936179462979599, 0.8234096918185803, 0.12199612322476405, 0.7787438962537526, 0.16712272809677875, 0.18980902061990745, 0.21170875982365533, 0.1691957616498363, 0.6924436498187465, 0.16761229380361709, 0.16772743456953032, 0.20691583249060108, 0.7601366054568006, 0.7375783638074178, 0.2074570100446279, 0.1873303336484442, 0.1835614915368874, 0.19085107697163695, 0.20922459320967768, 0.1935601695032717, 0.2054082486005182, 0.19041854373831502, 0.194772529539597, 0.08519976103552729, 0.08636228943868396, 0.10086397605719066, 0.07573309871837208, 0.09777921017541502, 0.0900933814403434, 0.08237207556936732, 0.09294839153492718, 0.10145341783282835]}, "mutation_prompt": null}
{"id": "d5690505-eb26-47dd-8852-1982e2ca3ea6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation and combined heuristic adaptation based on diversity and evaluations.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8402659200829536, 0.8542795591227172, 0.8490346137048239, 0.84688908329695, 0.8577979798711433, 0.8663705040207466, 0.8393178609746315, 0.8564291825584341, 0.8436906174083869, 0.7159805467642322, 0.07478654088529824, 0.746101259901579, 0.72368687026045, 0.7270959746922427, 0.6904520113161131, 0.7127031684152803, 0.7420713872253077, 0.7329825742654092, 0.6324143151424152, 0.1341403528786146, 0.14632620123606888, 0.16718085494550483, 0.17463625947434525, 0.13765551728811898, 0.11143349154996451, 0.12322588772326348, 0.16523064963401835, 0.15295864543842508, 0.12469827625901875, 0.10824188584170313, 0.094072931357985, 0.1317109740619029, 0.1135261867111127, 0.13806322396252801, 0.1219598050739471, 0.1108153121281501, 0.9827559832568926, 0.9760826746662686, 0.9791340605288648, 0.9767380746783154, 0.9814857583979004, 0.9859784857615842, 0.9856493788865591, 0.9892658562808224, 0.9728603567341167, 0.6359573941619698, 0.6639238764965125, 0.5899994548199956, 0.5640195358147515, 0.6147132789999509, 0.528276229778941, 0.6078389987262418, 0.6180543559557957, 0.5382516707383171, 0.7251056620069477, 0.78760764173807, 0.6755967351566512, 0.7282440284702615, 0.7612768240848138, 0.7209425521115609, 0.7181605463959928, 0.7535521414031203, 0.74490402813735, 0.23828392365007778, 0.314751985828871, 0.2170278858876945, 0.13058256675117041, 0.1274656464823516, 0.1330052550606441, 0.2942937238356901, 0.15522377058093606, 0.21662410528550047, 0.11804873200983856, 0.21667560627846394, 0.22842740960156904, 0.2634991344903609, 0.26563720989000505, 0.17076734350339573, 0.12830733055886123, 0.19618150392499378, 0.28767586432629977, 0.035471047497068864, 0.05024369943191409, 0.05192431744080095, 0.010002167494150171, 0.003726366531007441, 0.03908358973445425, 0.0059523331852333605, 0.037209221030514716, 0.03119253114135989, 0.17294894767300717, 0.14219258361382292, 0.14374055761517435, 0.1470269473607514, 0.15567332038929127, 0.13796934209699319, 0.1603080789414476, 0.16411636276120112, 0.16780743687265243, 0.036578752821407434, 0.047346627371117056, 0.03308381563544405, 0.07306190998108775, 0.07281618663957357, 0.08943965529493758, 0.25625065081386456, 0.17413824888402873, 0.06829414829496383, 0.2532296955384554, 0.3100556106713256, 0.200003738512731, 0.14357408778342218, 0.2623549540829331, 0.23207819399574503, 0.19285789190913738, 0.09930451855767608, 0.05537985752022201, 0.6017797756355214, 0.5928713709976566, 0.5643046334031196, 0.5750593756497482, 0.5950994560274585, 0.5752829531959605, 0.5762856775955787, 0.5623542244932536, 0.5779806369387409, 0.08594210313250039, 0.12824917806551672, 0.11267265167256624, 0.10687252977328354, 0.13149348728845545, 0.09034141032958232, 0.11101629794977375, 0.1150737630527352, 0.10967283811279871, 0.14616802200890722, 0.2340630375175743, 0.16625091972175465, 0.1656223045860412, 0.18931409909723262, 0.2867013569496667, 0.4448754785651119, 0.3378942551062283, 0.20906272238044954, 0.3636916841580252, 0.27876884059137474, 0.4056112309806108, 0.4088763232166672, 0.38500106937562173, 0.25345889897518326, 0.3559192780899091, 0.4673070176357792, 0.3997198706042855, 0.21261450186146025, 0.2742802982301834, 0.28023835647629936, 0.2044160847594373, 0.26343348903297725, 0.18424600498155252, 0.28693899097221753, 0.3468826590209064, 0.42609073576360723, 0.20442579910757153, 0.21088405778144415, 0.2055974668508198, 0.22077023265641182, 0.2334191735192085, 0.23102192885079154, 0.18634722171602924, 0.2359295419095051, 0.2324976825999654, 0.2100363998614736, 0.1880859200197924, 0.6820854963524976, 0.23035982610722872, 0.23605912306964694, 0.24167673354871988, 0.5740286504507345, 0.19206904623595966, 0.203169050639617, 0.2062627407077654, 0.8799565223601403, 0.1856626036874589, 0.19622004833794604, 0.8936179462979599, 0.8234096918185803, 0.12199612322476405, 0.7787438962537526, 0.16712272809677875, 0.18980902061990745, 0.21170875982365533, 0.1691957616498363, 0.6924436498187465, 0.16761229380361709, 0.16772743456953032, 0.20691583249060108, 0.7601366054568006, 0.7375783638074178, 0.2074570100446279, 0.1873303336484442, 0.1835614915368874, 0.19085107697163695, 0.20922459320967768, 0.1935601695032717, 0.2054082486005182, 0.19041854373831502, 0.194772529539597, 0.08519976103552729, 0.08636228943868396, 0.10086397605719066, 0.07573309871837208, 0.09777921017541502, 0.0900933814403434, 0.08237207556936732, 0.09294839153492718, 0.10145341783282835]}, "mutation_prompt": null}
{"id": "181bad20-fa9e-4f71-847c-5bf9602d0ca9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation and combined heuristic adaptation based on diversity and evaluations.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8402659200829536, 0.8542795591227172, 0.8490346137048239, 0.84688908329695, 0.8577979798711433, 0.8663705040207466, 0.8393178609746315, 0.8564291825584341, 0.8436906174083869, 0.7159805467642322, 0.07478654088529824, 0.746101259901579, 0.72368687026045, 0.7270959746922427, 0.6904520113161131, 0.7127031684152803, 0.7420713872253077, 0.7329825742654092, 0.6324143151424152, 0.1341403528786146, 0.14632620123606888, 0.16718085494550483, 0.17463625947434525, 0.13765551728811898, 0.11143349154996451, 0.12322588772326348, 0.16523064963401835, 0.15295864543842508, 0.12469827625901875, 0.10824188584170313, 0.094072931357985, 0.1317109740619029, 0.1135261867111127, 0.13806322396252801, 0.1219598050739471, 0.1108153121281501, 0.9827559832568926, 0.9760826746662686, 0.9791340605288648, 0.9767380746783154, 0.9814857583979004, 0.9859784857615842, 0.9856493788865591, 0.9892658562808224, 0.9728603567341167, 0.6359573941619698, 0.6639238764965125, 0.5899994548199956, 0.5640195358147515, 0.6147132789999509, 0.528276229778941, 0.6078389987262418, 0.6180543559557957, 0.5382516707383171, 0.7251056620069477, 0.78760764173807, 0.6755967351566512, 0.7282440284702615, 0.7612768240848138, 0.7209425521115609, 0.7181605463959928, 0.7535521414031203, 0.74490402813735, 0.23828392365007778, 0.314751985828871, 0.2170278858876945, 0.13058256675117041, 0.1274656464823516, 0.1330052550606441, 0.2942937238356901, 0.15522377058093606, 0.21662410528550047, 0.11804873200983856, 0.21667560627846394, 0.22842740960156904, 0.2634991344903609, 0.26563720989000505, 0.17076734350339573, 0.12830733055886123, 0.19618150392499378, 0.28767586432629977, 0.035471047497068864, 0.05024369943191409, 0.05192431744080095, 0.010002167494150171, 0.003726366531007441, 0.03908358973445425, 0.0059523331852333605, 0.037209221030514716, 0.03119253114135989, 0.17294894767300717, 0.14219258361382292, 0.14374055761517435, 0.1470269473607514, 0.15567332038929127, 0.13796934209699319, 0.1603080789414476, 0.16411636276120112, 0.16780743687265243, 0.036578752821407434, 0.047346627371117056, 0.03308381563544405, 0.07306190998108775, 0.07281618663957357, 0.08943965529493758, 0.25625065081386456, 0.17413824888402873, 0.06829414829496383, 0.2532296955384554, 0.3100556106713256, 0.200003738512731, 0.14357408778342218, 0.2623549540829331, 0.23207819399574503, 0.19285789190913738, 0.09930451855767608, 0.05537985752022201, 0.6017797756355214, 0.5928713709976566, 0.5643046334031196, 0.5750593756497482, 0.5950994560274585, 0.5752829531959605, 0.5762856775955787, 0.5623542244932536, 0.5779806369387409, 0.08594210313250039, 0.12824917806551672, 0.11267265167256624, 0.10687252977328354, 0.13149348728845545, 0.09034141032958232, 0.11101629794977375, 0.1150737630527352, 0.10967283811279871, 0.14616802200890722, 0.2340630375175743, 0.16625091972175465, 0.1656223045860412, 0.18931409909723262, 0.2867013569496667, 0.4448754785651119, 0.3378942551062283, 0.20906272238044954, 0.3636916841580252, 0.27876884059137474, 0.4056112309806108, 0.4088763232166672, 0.38500106937562173, 0.25345889897518326, 0.3559192780899091, 0.4673070176357792, 0.3997198706042855, 0.21261450186146025, 0.2742802982301834, 0.28023835647629936, 0.2044160847594373, 0.26343348903297725, 0.18424600498155252, 0.28693899097221753, 0.3468826590209064, 0.42609073576360723, 0.20442579910757153, 0.21088405778144415, 0.2055974668508198, 0.22077023265641182, 0.2334191735192085, 0.23102192885079154, 0.18634722171602924, 0.2359295419095051, 0.2324976825999654, 0.2100363998614736, 0.1880859200197924, 0.6820854963524976, 0.23035982610722872, 0.23605912306964694, 0.24167673354871988, 0.5740286504507345, 0.19206904623595966, 0.203169050639617, 0.2062627407077654, 0.8799565223601403, 0.1856626036874589, 0.19622004833794604, 0.8936179462979599, 0.8234096918185803, 0.12199612322476405, 0.7787438962537526, 0.16712272809677875, 0.18980902061990745, 0.21170875982365533, 0.1691957616498363, 0.6924436498187465, 0.16761229380361709, 0.16772743456953032, 0.20691583249060108, 0.7601366054568006, 0.7375783638074178, 0.2074570100446279, 0.1873303336484442, 0.1835614915368874, 0.19085107697163695, 0.20922459320967768, 0.1935601695032717, 0.2054082486005182, 0.19041854373831502, 0.194772529539597, 0.08519976103552729, 0.08636228943868396, 0.10086397605719066, 0.07573309871837208, 0.09777921017541502, 0.0900933814403434, 0.08237207556936732, 0.09294839153492718, 0.10145341783282835]}, "mutation_prompt": null}
{"id": "f1565033-690c-4a22-ae5e-23992b0e336c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation and combined heuristic adaptation based on diversity and evaluations.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8402659200829536, 0.8542795591227172, 0.8490346137048239, 0.84688908329695, 0.8577979798711433, 0.8663705040207466, 0.8393178609746315, 0.8564291825584341, 0.8436906174083869, 0.7159805467642322, 0.07478654088529824, 0.746101259901579, 0.72368687026045, 0.7270959746922427, 0.6904520113161131, 0.7127031684152803, 0.7420713872253077, 0.7329825742654092, 0.6324143151424152, 0.1341403528786146, 0.14632620123606888, 0.16718085494550483, 0.17463625947434525, 0.13765551728811898, 0.11143349154996451, 0.12322588772326348, 0.16523064963401835, 0.15295864543842508, 0.12469827625901875, 0.10824188584170313, 0.094072931357985, 0.1317109740619029, 0.1135261867111127, 0.13806322396252801, 0.1219598050739471, 0.1108153121281501, 0.9827559832568926, 0.9760826746662686, 0.9791340605288648, 0.9767380746783154, 0.9814857583979004, 0.9859784857615842, 0.9856493788865591, 0.9892658562808224, 0.9728603567341167, 0.6359573941619698, 0.6639238764965125, 0.5899994548199956, 0.5640195358147515, 0.6147132789999509, 0.528276229778941, 0.6078389987262418, 0.6180543559557957, 0.5382516707383171, 0.7251056620069477, 0.78760764173807, 0.6755967351566512, 0.7282440284702615, 0.7612768240848138, 0.7209425521115609, 0.7181605463959928, 0.7535521414031203, 0.74490402813735, 0.23828392365007778, 0.314751985828871, 0.2170278858876945, 0.13058256675117041, 0.1274656464823516, 0.1330052550606441, 0.2942937238356901, 0.15522377058093606, 0.21662410528550047, 0.11804873200983856, 0.21667560627846394, 0.22842740960156904, 0.2634991344903609, 0.26563720989000505, 0.17076734350339573, 0.12830733055886123, 0.19618150392499378, 0.28767586432629977, 0.035471047497068864, 0.05024369943191409, 0.05192431744080095, 0.010002167494150171, 0.003726366531007441, 0.03908358973445425, 0.0059523331852333605, 0.037209221030514716, 0.03119253114135989, 0.17294894767300717, 0.14219258361382292, 0.14374055761517435, 0.1470269473607514, 0.15567332038929127, 0.13796934209699319, 0.1603080789414476, 0.16411636276120112, 0.16780743687265243, 0.036578752821407434, 0.047346627371117056, 0.03308381563544405, 0.07306190998108775, 0.07281618663957357, 0.08943965529493758, 0.25625065081386456, 0.17413824888402873, 0.06829414829496383, 0.2532296955384554, 0.3100556106713256, 0.200003738512731, 0.14357408778342218, 0.2623549540829331, 0.23207819399574503, 0.19285789190913738, 0.09930451855767608, 0.05537985752022201, 0.6017797756355214, 0.5928713709976566, 0.5643046334031196, 0.5750593756497482, 0.5950994560274585, 0.5752829531959605, 0.5762856775955787, 0.5623542244932536, 0.5779806369387409, 0.08594210313250039, 0.12824917806551672, 0.11267265167256624, 0.10687252977328354, 0.13149348728845545, 0.09034141032958232, 0.11101629794977375, 0.1150737630527352, 0.10967283811279871, 0.14616802200890722, 0.2340630375175743, 0.16625091972175465, 0.1656223045860412, 0.18931409909723262, 0.2867013569496667, 0.4448754785651119, 0.3378942551062283, 0.20906272238044954, 0.3636916841580252, 0.27876884059137474, 0.4056112309806108, 0.4088763232166672, 0.38500106937562173, 0.25345889897518326, 0.3559192780899091, 0.4673070176357792, 0.3997198706042855, 0.21261450186146025, 0.2742802982301834, 0.28023835647629936, 0.2044160847594373, 0.26343348903297725, 0.18424600498155252, 0.28693899097221753, 0.3468826590209064, 0.42609073576360723, 0.20442579910757153, 0.21088405778144415, 0.2055974668508198, 0.22077023265641182, 0.2334191735192085, 0.23102192885079154, 0.18634722171602924, 0.2359295419095051, 0.2324976825999654, 0.2100363998614736, 0.1880859200197924, 0.6820854963524976, 0.23035982610722872, 0.23605912306964694, 0.24167673354871988, 0.5740286504507345, 0.19206904623595966, 0.203169050639617, 0.2062627407077654, 0.8799565223601403, 0.1856626036874589, 0.19622004833794604, 0.8936179462979599, 0.8234096918185803, 0.12199612322476405, 0.7787438962537526, 0.16712272809677875, 0.18980902061990745, 0.21170875982365533, 0.1691957616498363, 0.6924436498187465, 0.16761229380361709, 0.16772743456953032, 0.20691583249060108, 0.7601366054568006, 0.7375783638074178, 0.2074570100446279, 0.1873303336484442, 0.1835614915368874, 0.19085107697163695, 0.20922459320967768, 0.1935601695032717, 0.2054082486005182, 0.19041854373831502, 0.194772529539597, 0.08519976103552729, 0.08636228943868396, 0.10086397605719066, 0.07573309871837208, 0.09777921017541502, 0.0900933814403434, 0.08237207556936732, 0.09294839153492718, 0.10145341783282835]}, "mutation_prompt": null}
{"id": "0ddb1720-51b7-45f3-a806-91d15569d8b3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.1 + 0.9 * np.random.rand()  # Changed line\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.95 - 0.45 * (self.current_evaluations / self.budget)  # Changed line\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation with dynamic social influence and improved perturbation scaling.", "configspace": "", "generation": 41, "fitness": 0.3271541510442058, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8298205018638011, 0.8525022681277583, 0.8386229396050807, 0.8206476429596167, 0.8393401855202082, 0.8548362330978629, 0.8314693835565363, 0.8416794071335572, 0.8533382058505546, 0.07487649158852361, 0.7329160552918554, 0.06875239730172367, 0.7116091321596685, 0.7343987519238884, 0.7166694002922165, 0.7287651001648557, 0.7407264711734787, 0.01825671731440548, 0.13571886754671725, 0.3997081111702233, 0.14087821740583206, 0.1344250701094587, 0.1494240125182612, 0.14230058409821156, 0.16270574084042655, 0.12761558149996455, 0.15663580655979803, 0.12363884664883629, 0.13331587023542035, 0.1301445186905743, 0.14816110412073558, 0.14468361648088934, 0.1284927265503324, 0.1441635889101084, 0.1387959548269717, 0.10309629804833109, 0.9828052082029802, 0.9761063118510295, 0.9793268500914432, 0.9757614149670112, 0.9814614626661868, 0.9859927381216688, 0.985718976675971, 0.9892785658995407, 0.9729014499810709, 0.6258900638670992, 0.6403268181079969, 0.6392294308228081, 0.5711826744083788, 0.5581235113227478, 0.604408610259783, 0.603423962028494, 0.6195360083848788, 0.6028965997795894, 0.7345780510295752, 0.7549458450214239, 0.7604783578087762, 0.784107375378836, 0.6872658678206842, 0.21585390149799555, 0.7233379351407377, 0.6977811828594052, 0.7343600340128311, 0.17575504586254354, 0.2345619753110374, 0.2148872172173828, 0.13056516044769506, 0.2438372644039798, 0.2254117656160357, 0.1895082370629857, 0.14220802884739148, 0.22624218499192816, 0.2048144389310954, 0.21292838756609678, 0.23978653080118117, 0.1300993065978806, 0.3149856205410563, 0.23077725913181635, 0.12668883574736844, 0.12893772343368493, 0.2741695007664833, 0.044614609828077856, 0.05394469205910102, 0.03787557343757075, 0.01721214564588769, 0.026270679415951737, 0.03983883664193488, 0.0053939512319665095, 0.04265487707709237, 0.037760128593967046, 0.12281236118281447, 0.13069966179125492, 0.16779383925107783, 0.13031961013471394, 0.10817722517695838, 0.11025517554553821, 0.16361346140969568, 0.11453899243577526, 0.15386334045033034, 9.999999999998899e-05, 0.047184946983602094, 0.2953057670056817, 0.07164498547026377, 0.07099703282907777, 0.08861469825286117, 0.29044174908641696, 0.10445943035513061, 0.06603961087706411, 0.20588617142876176, 0.20017235546947543, 0.11654491195107619, 0.09865799651606866, 0.20721795423265188, 0.2742499473595923, 0.2391231018624036, 0.08221802526960909, 0.055426625196243196, 0.5415419803859759, 0.6282599182380386, 0.5564502170732608, 0.6095794066818246, 0.5773410347650749, 0.6062269950441721, 0.6012920680324965, 0.5960538888022411, 0.5681804465086477, 0.08430468149815074, 0.14011332576552926, 0.11798943757236247, 0.15151410130100007, 0.11776990076044536, 0.12864041152645622, 0.10435240935427714, 0.10173059860763856, 0.12633760634981006, 0.1818045143001007, 0.1686126891282269, 0.16669741650907632, 0.1511042912706032, 0.14856288130988815, 0.20759304782438193, 0.19157939177031003, 0.1587197007238037, 0.2398671271573487, 0.4018088682083625, 0.36560469535105644, 0.30272520586288787, 0.4096882214646367, 0.4118826707647012, 0.35002650461622054, 0.4851874996314576, 0.46681096427370994, 0.4849214932721194, 0.23654554171727937, 0.23102780830728198, 0.3001939138658537, 0.309941370066831, 0.25690524717022756, 0.27126785309382107, 0.23977747848791287, 0.2490492618961062, 0.2928325276418424, 0.21971683811643072, 0.19726007528987344, 0.20883753234064328, 0.20989824407272895, 0.23676532610895518, 0.20914921751490367, 0.21148784082182714, 0.21696020513735548, 0.22359525169744388, 0.19420942059136892, 0.19601545986456714, 0.6743013898980497, 0.2121206950250748, 0.2074901332462571, 0.23456169046625464, 0.6386268636744412, 0.21383139062773504, 0.20017976805193638, 0.18489722115502538, 0.8702765985875779, 0.18637061601241134, 0.1639013570812926, 0.1984246718313344, 0.8467588037774846, 0.12276027247916221, 0.17796538240996873, 0.16827325712969943, 0.16051489033055755, 0.20952412914559604, 0.16850902797113598, 0.6698865109606167, 0.638727676183289, 0.6737732441300145, 0.20412285826466336, 0.2099788239444279, 0.5707126407621174, 0.1872785763659639, 0.21978034891858933, 0.17921295036461016, 0.1976796280541181, 0.17644944494232517, 0.22904241734577535, 0.18323105488235136, 0.18249593119107044, 0.20157284164421607, 0.07594912625067396, 0.11932246778042932, 0.08962101810591705, 0.08033679456039078, 0.10231509313218634, 0.08071481873261688, 0.12209013607543762, 0.08948985523603004, 0.0916122193811203]}, "mutation_prompt": null}
{"id": "9fc29ed7-0771-460f-abc4-d991f8c74ac7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation and combined heuristic adaptation based on diversity and evaluations.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8402659200829536, 0.8542795591227172, 0.8490346137048239, 0.84688908329695, 0.8577979798711433, 0.8663705040207466, 0.8393178609746315, 0.8564291825584341, 0.8436906174083869, 0.7159805467642322, 0.07478654088529824, 0.746101259901579, 0.72368687026045, 0.7270959746922427, 0.6904520113161131, 0.7127031684152803, 0.7420713872253077, 0.7329825742654092, 0.6324143151424152, 0.1341403528786146, 0.14632620123606888, 0.16718085494550483, 0.17463625947434525, 0.13765551728811898, 0.11143349154996451, 0.12322588772326348, 0.16523064963401835, 0.15295864543842508, 0.12469827625901875, 0.10824188584170313, 0.094072931357985, 0.1317109740619029, 0.1135261867111127, 0.13806322396252801, 0.1219598050739471, 0.1108153121281501, 0.9827559832568926, 0.9760826746662686, 0.9791340605288648, 0.9767380746783154, 0.9814857583979004, 0.9859784857615842, 0.9856493788865591, 0.9892658562808224, 0.9728603567341167, 0.6359573941619698, 0.6639238764965125, 0.5899994548199956, 0.5640195358147515, 0.6147132789999509, 0.528276229778941, 0.6078389987262418, 0.6180543559557957, 0.5382516707383171, 0.7251056620069477, 0.78760764173807, 0.6755967351566512, 0.7282440284702615, 0.7612768240848138, 0.7209425521115609, 0.7181605463959928, 0.7535521414031203, 0.74490402813735, 0.23828392365007778, 0.314751985828871, 0.2170278858876945, 0.13058256675117041, 0.1274656464823516, 0.1330052550606441, 0.2942937238356901, 0.15522377058093606, 0.21662410528550047, 0.11804873200983856, 0.21667560627846394, 0.22842740960156904, 0.2634991344903609, 0.26563720989000505, 0.17076734350339573, 0.12830733055886123, 0.19618150392499378, 0.28767586432629977, 0.035471047497068864, 0.05024369943191409, 0.05192431744080095, 0.010002167494150171, 0.003726366531007441, 0.03908358973445425, 0.0059523331852333605, 0.037209221030514716, 0.03119253114135989, 0.17294894767300717, 0.14219258361382292, 0.14374055761517435, 0.1470269473607514, 0.15567332038929127, 0.13796934209699319, 0.1603080789414476, 0.16411636276120112, 0.16780743687265243, 0.036578752821407434, 0.047346627371117056, 0.03308381563544405, 0.07306190998108775, 0.07281618663957357, 0.08943965529493758, 0.25625065081386456, 0.17413824888402873, 0.06829414829496383, 0.2532296955384554, 0.3100556106713256, 0.200003738512731, 0.14357408778342218, 0.2623549540829331, 0.23207819399574503, 0.19285789190913738, 0.09930451855767608, 0.05537985752022201, 0.6017797756355214, 0.5928713709976566, 0.5643046334031196, 0.5750593756497482, 0.5950994560274585, 0.5752829531959605, 0.5762856775955787, 0.5623542244932536, 0.5779806369387409, 0.08594210313250039, 0.12824917806551672, 0.11267265167256624, 0.10687252977328354, 0.13149348728845545, 0.09034141032958232, 0.11101629794977375, 0.1150737630527352, 0.10967283811279871, 0.14616802200890722, 0.2340630375175743, 0.16625091972175465, 0.1656223045860412, 0.18931409909723262, 0.2867013569496667, 0.4448754785651119, 0.3378942551062283, 0.20906272238044954, 0.3636916841580252, 0.27876884059137474, 0.4056112309806108, 0.4088763232166672, 0.38500106937562173, 0.25345889897518326, 0.3559192780899091, 0.4673070176357792, 0.3997198706042855, 0.21261450186146025, 0.2742802982301834, 0.28023835647629936, 0.2044160847594373, 0.26343348903297725, 0.18424600498155252, 0.28693899097221753, 0.3468826590209064, 0.42609073576360723, 0.20442579910757153, 0.21088405778144415, 0.2055974668508198, 0.22077023265641182, 0.2334191735192085, 0.23102192885079154, 0.18634722171602924, 0.2359295419095051, 0.2324976825999654, 0.2100363998614736, 0.1880859200197924, 0.6820854963524976, 0.23035982610722872, 0.23605912306964694, 0.24167673354871988, 0.5740286504507345, 0.19206904623595966, 0.203169050639617, 0.2062627407077654, 0.8799565223601403, 0.1856626036874589, 0.19622004833794604, 0.8936179462979599, 0.8234096918185803, 0.12199612322476405, 0.7787438962537526, 0.16712272809677875, 0.18980902061990745, 0.21170875982365533, 0.1691957616498363, 0.6924436498187465, 0.16761229380361709, 0.16772743456953032, 0.20691583249060108, 0.7601366054568006, 0.7375783638074178, 0.2074570100446279, 0.1873303336484442, 0.1835614915368874, 0.19085107697163695, 0.20922459320967768, 0.1935601695032717, 0.2054082486005182, 0.19041854373831502, 0.194772529539597, 0.08519976103552729, 0.08636228943868396, 0.10086397605719066, 0.07573309871837208, 0.09777921017541502, 0.0900933814403434, 0.08237207556936732, 0.09294839153492718, 0.10145341783282835]}, "mutation_prompt": null}
{"id": "bc19c720-a9cd-48e8-ab61-3bc81c07b8c6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        dynamic_bound = self.upper_bound - 0.05 * (self.current_evaluations / self.budget)  # Change\n        return np.clip(mutant, self.lower_bound, dynamic_bound)  # Change\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced diversity and convergence through adaptive boundary adjustments and dynamic perturbation in HybridPSO_DE.", "configspace": "", "generation": 43, "fitness": 0.33987993343820294, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8381412121896998, 0.8528801316859119, 0.8502519855741268, 0.8429586561849166, 0.8584162457493862, 0.8679781836438356, 0.8393679254825941, 0.857348342976407, 0.843786276116845, 0.7238129483613592, 0.6229412962704666, 0.7391658698893449, 0.7199811285270981, 0.7337835965699081, 0.6841757026979385, 0.7193520813045436, 0.7390246283624344, 0.7331299318699953, 0.6262554973729197, 0.13945906194945523, 0.11955231514006992, 0.14628247466749567, 0.1450964863747407, 0.13514787300892572, 0.13119214542605118, 0.145854861905373, 0.14635002203180647, 0.13952200806624426, 0.13459011572911328, 0.1345894155853049, 0.125294975755315, 0.1397791906282182, 0.09272423610686364, 0.11015460140284516, 0.14225179672405353, 0.144293132497481, 0.982755983408233, 0.976082735066019, 0.9791340605742098, 0.9767380521327671, 0.981485758637856, 0.9859784857502137, 0.9856493355343232, 0.9892658562796349, 0.9728603143224163, 0.5966917887451537, 0.6068687772680692, 0.5694990588638915, 0.5845028365891783, 0.6142881460641663, 0.5554671706831606, 0.6052420895544735, 0.5195885519172028, 0.6075421652669888, 0.7614846639089587, 0.7620437249136293, 0.21821241885234655, 0.7289442837332116, 0.728157381864895, 0.2168720260792778, 0.7128816669576303, 0.8012632567300616, 0.7608481198719202, 0.23680587296408262, 0.3373129890137754, 0.2107132421650184, 0.13059399120002857, 0.12745957126497798, 0.13299014892453054, 0.286290787184711, 0.19521156743234191, 0.2401812083654603, 0.12056621470895246, 0.21383374400941046, 0.22834314539190137, 0.2610973161079785, 0.2767350812266103, 0.17488572512221257, 0.2807599254101889, 0.20532633319626126, 0.2869910385536898, 0.0587056074889053, 0.08766823260538259, 0.05006137784624021, 0.017103473222220278, 0.0009106279832569175, 0.03717640828004787, 0.011577877212020526, 0.023648077827806646, 0.06843507204818433, 0.1596094750028224, 0.17596049320831864, 0.1326773229807915, 0.13861476931429317, 0.1336335765071781, 0.14019485218072003, 0.14837137738287398, 0.1159213494357707, 0.16522316177510588, 0.036152645087279, 0.047344694413042454, 0.03294009442396639, 0.07293266310733781, 0.07281203693222871, 0.08847183611012899, 0.25428017110644663, 0.16853795541532213, 0.06818920506713788, 0.2204977496725462, 0.3069112858946118, 0.20611926756765975, 0.2116649925229207, 0.2882960255614242, 0.22610747378827722, 0.19297893748475448, 0.10065476921897165, 0.08123861087940643, 0.5880773417379284, 0.5481999980092276, 0.5641844275818295, 0.605374062486594, 0.6122133574115602, 0.5967942843313133, 0.5951139444530363, 0.5752130588079003, 0.5766856044731095, 0.08780421373157166, 0.1116337318236772, 0.1126124552586365, 0.11284446627591205, 0.1312536207881494, 0.0978147549941949, 0.14748155739371616, 0.16159704729176083, 0.1096683478623558, 0.17648330593637818, 0.20401198534947773, 0.20506022059395324, 0.1704688124439765, 0.21185729326100933, 0.2548267933868338, 0.2888885897677749, 0.30816857850199997, 0.1635865713461251, 0.24439378253987942, 0.27782501308647745, 0.43395073787767535, 0.44995746183024965, 0.36094187038393577, 0.25333825466372584, 0.45617101977345853, 0.5340982046030408, 0.44565133787527933, 0.27576190529438027, 0.29698292591171616, 0.24214217233737567, 0.2459955534035161, 0.24218995164011892, 0.1832634250417966, 0.2615890167918071, 0.23648375264628985, 0.3632173389862575, 0.20289150117270172, 0.2405255545862779, 0.21870558963445086, 0.21352576997780492, 0.2500044066172896, 0.20802797671108175, 0.20120056831040534, 0.20458239056182248, 0.19688306487869034, 0.21003419103895593, 0.18808637862122846, 0.24122028395131878, 0.2303625750162669, 0.2360614140250652, 0.24167670921652162, 0.574018463843062, 0.192067730002913, 0.2032076106488454, 0.20626272485263197, 0.8894246025583833, 0.1856618588055733, 0.19622062767177773, 0.8935725311482712, 0.8234942158507659, 0.12199505930287413, 0.7774362324617258, 0.16712500187521107, 0.1263651161160234, 0.21170931997155007, 0.16919578548991554, 0.7023207901883333, 0.1676122173795087, 0.1677279747608318, 0.20691746866162408, 0.7678557806295662, 0.7345260962172833, 0.1801807396430799, 0.17760142373017984, 0.1854648831316139, 0.1827498163628266, 0.18968067820970302, 0.203080600772365, 0.19852651467359617, 0.17804726815523686, 0.18563531981706793, 0.0926499343881525, 0.0979365276702916, 0.08458523450914612, 0.07993715849132788, 0.08444374157283674, 0.08257918876869608, 0.08670906366753517, 0.09295788424171092, 0.1079653999064194]}, "mutation_prompt": null}
{"id": "4b69b4be-f92a-415b-ab59-290f50798ccd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.9 - 0.4 * (self.current_evaluations / self.budget)\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            mutation_probability = 0.3 * (1 - self.current_evaluations / self.budget)  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration and convergence through adaptive mutation and combined heuristic adaptation based on diversity and evaluations.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8402659200829536, 0.8542795591227172, 0.8490346137048239, 0.84688908329695, 0.8577979798711433, 0.8663705040207466, 0.8393178609746315, 0.8564291825584341, 0.8436906174083869, 0.7159805467642322, 0.07478654088529824, 0.746101259901579, 0.72368687026045, 0.7270959746922427, 0.6904520113161131, 0.7127031684152803, 0.7420713872253077, 0.7329825742654092, 0.6324143151424152, 0.1341403528786146, 0.14632620123606888, 0.16718085494550483, 0.17463625947434525, 0.13765551728811898, 0.11143349154996451, 0.12322588772326348, 0.16523064963401835, 0.15295864543842508, 0.12469827625901875, 0.10824188584170313, 0.094072931357985, 0.1317109740619029, 0.1135261867111127, 0.13806322396252801, 0.1219598050739471, 0.1108153121281501, 0.9827559832568926, 0.9760826746662686, 0.9791340605288648, 0.9767380746783154, 0.9814857583979004, 0.9859784857615842, 0.9856493788865591, 0.9892658562808224, 0.9728603567341167, 0.6359573941619698, 0.6639238764965125, 0.5899994548199956, 0.5640195358147515, 0.6147132789999509, 0.528276229778941, 0.6078389987262418, 0.6180543559557957, 0.5382516707383171, 0.7251056620069477, 0.78760764173807, 0.6755967351566512, 0.7282440284702615, 0.7612768240848138, 0.7209425521115609, 0.7181605463959928, 0.7535521414031203, 0.74490402813735, 0.23828392365007778, 0.314751985828871, 0.2170278858876945, 0.13058256675117041, 0.1274656464823516, 0.1330052550606441, 0.2942937238356901, 0.15522377058093606, 0.21662410528550047, 0.11804873200983856, 0.21667560627846394, 0.22842740960156904, 0.2634991344903609, 0.26563720989000505, 0.17076734350339573, 0.12830733055886123, 0.19618150392499378, 0.28767586432629977, 0.035471047497068864, 0.05024369943191409, 0.05192431744080095, 0.010002167494150171, 0.003726366531007441, 0.03908358973445425, 0.0059523331852333605, 0.037209221030514716, 0.03119253114135989, 0.17294894767300717, 0.14219258361382292, 0.14374055761517435, 0.1470269473607514, 0.15567332038929127, 0.13796934209699319, 0.1603080789414476, 0.16411636276120112, 0.16780743687265243, 0.036578752821407434, 0.047346627371117056, 0.03308381563544405, 0.07306190998108775, 0.07281618663957357, 0.08943965529493758, 0.25625065081386456, 0.17413824888402873, 0.06829414829496383, 0.2532296955384554, 0.3100556106713256, 0.200003738512731, 0.14357408778342218, 0.2623549540829331, 0.23207819399574503, 0.19285789190913738, 0.09930451855767608, 0.05537985752022201, 0.6017797756355214, 0.5928713709976566, 0.5643046334031196, 0.5750593756497482, 0.5950994560274585, 0.5752829531959605, 0.5762856775955787, 0.5623542244932536, 0.5779806369387409, 0.08594210313250039, 0.12824917806551672, 0.11267265167256624, 0.10687252977328354, 0.13149348728845545, 0.09034141032958232, 0.11101629794977375, 0.1150737630527352, 0.10967283811279871, 0.14616802200890722, 0.2340630375175743, 0.16625091972175465, 0.1656223045860412, 0.18931409909723262, 0.2867013569496667, 0.4448754785651119, 0.3378942551062283, 0.20906272238044954, 0.3636916841580252, 0.27876884059137474, 0.4056112309806108, 0.4088763232166672, 0.38500106937562173, 0.25345889897518326, 0.3559192780899091, 0.4673070176357792, 0.3997198706042855, 0.21261450186146025, 0.2742802982301834, 0.28023835647629936, 0.2044160847594373, 0.26343348903297725, 0.18424600498155252, 0.28693899097221753, 0.3468826590209064, 0.42609073576360723, 0.20442579910757153, 0.21088405778144415, 0.2055974668508198, 0.22077023265641182, 0.2334191735192085, 0.23102192885079154, 0.18634722171602924, 0.2359295419095051, 0.2324976825999654, 0.2100363998614736, 0.1880859200197924, 0.6820854963524976, 0.23035982610722872, 0.23605912306964694, 0.24167673354871988, 0.5740286504507345, 0.19206904623595966, 0.203169050639617, 0.2062627407077654, 0.8799565223601403, 0.1856626036874589, 0.19622004833794604, 0.8936179462979599, 0.8234096918185803, 0.12199612322476405, 0.7787438962537526, 0.16712272809677875, 0.18980902061990745, 0.21170875982365533, 0.1691957616498363, 0.6924436498187465, 0.16761229380361709, 0.16772743456953032, 0.20691583249060108, 0.7601366054568006, 0.7375783638074178, 0.2074570100446279, 0.1873303336484442, 0.1835614915368874, 0.19085107697163695, 0.20922459320967768, 0.1935601695032717, 0.2054082486005182, 0.19041854373831502, 0.194772529539597, 0.08519976103552729, 0.08636228943868396, 0.10086397605719066, 0.07573309871837208, 0.09777921017541502, 0.0900933814403434, 0.08237207556936732, 0.09294839153492718, 0.10145341783282835]}, "mutation_prompt": null}
{"id": "d783e1ff-73e9-4d60-a5e6-6926033cfc4a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved diversity and convergence through adaptive crossover probability and enhanced mutation differentiated by population fitness variance.", "configspace": "", "generation": 45, "fitness": 0.3627561503344011, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "a373231b-0024-4230-8e53-b32a3ee607d9", "metadata": {"aucs": [0.8546589403467146, 0.8679329453349809, 0.8618358013886926, 0.862269518488183, 0.8691837058669727, 0.8587336357556576, 0.8550653546956135, 0.8660670040956696, 0.8669365797004809, 0.04106906312312675, 0.7316816514459341, 0.041166797909379604, 0.751327680191604, 0.758042345494937, 0.7484149323210378, 0.7443622923584452, 0.7473666787400663, 0.7432504870263825, 0.1366168343952331, 0.14014433335517495, 0.17906035311118207, 0.1557125562134919, 0.173684805272727, 0.13319096549533405, 0.13493424581593372, 0.16039310942061802, 0.1550235451861698, 0.12216030103785014, 0.11306968519520055, 0.11428645661923198, 0.14366908013070423, 0.14261805166503705, 0.13748492965414993, 0.13334515330506924, 0.1459462113161809, 0.12797860510327042, 0.9830225777444215, 0.9730672048958733, 0.9779500285741046, 0.9770431387245002, 0.9814781732006749, 0.9848041444649848, 0.9860564519045828, 0.9860501388149303, 0.9725537620642052, 0.6333945663351872, 0.6217980601710192, 0.6332081800004151, 0.6623642925353236, 0.6455428120490146, 0.6582217333028615, 0.6388499137679605, 0.6475571967233611, 0.6284118730180275, 0.7348946449782245, 0.7795664559101925, 0.7708390092362247, 0.8463333381471371, 0.816116075454195, 0.7536327965078623, 0.7974887484794179, 0.7633137718058816, 0.7861128257426336, 0.385630480152079, 0.3194700145939534, 0.3350517027350385, 0.31029159556846586, 0.29894382547075005, 0.4015196968022343, 0.30713677116529736, 0.3312835176492711, 0.27307899039971184, 0.053382689043414366, 0.24256289139617526, 0.31010823370626783, 0.3427013244816207, 0.33384763199498846, 0.36011531745961267, 0.3104065967481524, 0.3601502596522671, 0.46694887825289466, 0.11308232056529055, 0.1293355643994808, 0.12533907458204685, 0.12197989202704262, 0.10426427954378326, 0.13562501632876978, 0.11675169589084722, 0.1262673047108519, 0.15337646289850526, 0.2641518746463598, 0.27828493839419066, 0.23659904739091686, 0.21990140686539794, 0.26947224966397443, 0.26752905324607723, 0.2627387976252734, 0.24422574617349246, 0.2785168193601105, 0.034221000288536585, 0.04752946564954075, 0.2736620909747315, 0.08010095195143274, 0.12248606769825587, 0.08982259947532822, 0.2751119724876503, 0.06924333188984022, 0.06630063478335035, 0.18709589260725157, 0.22579795409418368, 0.19922670441338464, 0.2701563606533367, 0.2560790174497257, 0.2675222625575464, 0.20235190560242267, 0.23377991458928526, 0.05749232322275022, 0.6236662115447968, 0.6046360738766831, 0.6025548873327015, 0.6125281568809569, 0.6054784729540619, 0.6175371947517123, 0.5714822023954886, 0.6013090855540053, 0.6131272753937871, 0.10669611226253206, 0.09473423225814348, 0.08336921779300033, 0.12926307026161354, 0.10814387566906558, 0.12663517326344464, 0.13794905727485296, 0.10506710268692188, 0.12401069606879478, 0.1451543714901441, 0.26130074237521517, 0.4731416489858503, 0.17502281068817793, 0.1484442887838432, 0.22277308863559575, 0.16681865466496126, 0.16322502948063788, 0.2150935783932879, 0.3799913901671701, 0.35411486273961923, 0.5059961286601236, 0.4789952241714873, 0.3002675427667594, 0.4158212960803641, 0.32218068574171255, 0.5807114906285813, 0.49430379005286085, 0.19355950555264345, 0.30419931288473323, 0.2747964756278114, 0.26022555067899145, 0.32685457004695595, 0.3449004690213724, 0.32219270428344604, 0.23575232178231953, 0.36603734182278536, 0.23760349818550286, 0.19122585486348032, 0.206882367501799, 0.21271026426261053, 0.2329217705079083, 0.19049085022773204, 0.218660777962572, 0.2277296472146585, 0.21488744546783467, 0.21244534262929138, 0.1948786774614213, 0.5028317280171597, 0.224505412107595, 0.21130881055835116, 0.5876939782078494, 0.21662747622512313, 0.2366619463520343, 0.23632492126956106, 0.18467783842227004, 0.8852692150020264, 0.16752779710322807, 0.19711683540380398, 0.8815397802496688, 0.6532096537206853, 0.19972566860239294, 0.8471516936921973, 0.16894084488752792, 0.12752062181484403, 0.16836974389385673, 0.21129502989983318, 0.7118449976055727, 0.16773946756909486, 0.16804263598291436, 0.20382463898228242, 0.8029888529468197, 0.20931222502033697, 0.18513938761771775, 0.18668587453885732, 0.1830166325357161, 0.20581201792080894, 0.1729955658777491, 0.1985490489737346, 0.18915920881417336, 0.19775853018953127, 0.19324273370031197, 0.11004716661858605, 0.08038338850717086, 0.08156068874129885, 0.08626777594512536, 0.07814238855606925, 0.08653812011367246, 0.10860384377259213, 0.09707908497563422, 0.09538676747723707]}, "mutation_prompt": null}
{"id": "f8a02f0a-99d0-4651-84fb-352737476ac9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)  # Change 1\n        self.social_coefficient = 1.0 + 0.5 * (1 - self.current_evaluations / self.budget)  # Change 2\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced convergence by adjusting cognitive and social coefficients dynamically based on current evaluations.", "configspace": "", "generation": 46, "fitness": 0.3614550212814745, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "d783e1ff-73e9-4d60-a5e6-6926033cfc4a", "metadata": {"aucs": [0.849831405457254, 0.8547440317021028, 0.8671776948136629, 0.8647254263260364, 0.8602902122107643, 0.8633931393940131, 0.854168243797389, 0.860653045799007, 0.8621968751082827, 0.7509410698442956, 0.7493141216627268, 0.7407345590296603, 0.7407447593263699, 0.7549448503906018, 0.04690742589690311, 0.7537294817712469, 0.7295197512065514, 0.7501754494263783, 0.13210355807777818, 0.28378931538531826, 0.1313937751871166, 0.16658691726316643, 0.12903919377112583, 0.13504924475694824, 0.5586845325327707, 0.12353255392134199, 0.11176177461563219, 0.16631255608424467, 0.09676250403215547, 0.10337386620599687, 0.11934845301215014, 0.11742182738635742, 0.11981190571735822, 0.10229814929407699, 0.10124500814455017, 0.1636959060371097, 0.9829460895267563, 0.9732857308487565, 0.9779497616792828, 0.9770091689423563, 0.9814800066781283, 0.9848157582306127, 0.9860482911757302, 0.9878034122143234, 0.9725451402850176, 0.6326226629081455, 0.6419824184263481, 0.6226663983239549, 0.6420084408343657, 0.636696021671243, 0.6041665174726834, 0.6507594651669979, 0.5967132552818594, 0.6288938650250784, 0.7987890614616815, 0.7872179458522044, 0.7144006157783709, 0.8447924679688124, 0.7181899413782888, 0.7241057665615189, 0.44469872194421745, 0.7985773150717284, 0.88320052865686, 0.34425606072858683, 0.36668706084934144, 0.3504966634368143, 0.2878643122454836, 0.3073837600467908, 0.2597907279379986, 0.3740379320390189, 0.3192976708653611, 0.5467465873931421, 0.1388097562139594, 0.30740422784914967, 0.34196435009001125, 0.31202173870183736, 0.310521156154135, 0.5258812776062785, 0.30164944001664906, 0.2942385528334206, 0.12989790433910398, 0.11200438150046887, 0.1437957030698983, 0.1471523624947535, 0.11863624552711372, 0.14339866347748464, 0.14293950428308422, 0.1496409807990704, 0.10682313437610647, 0.1511192996826225, 0.23786868440003628, 0.25589873326586, 0.2602426611813051, 0.23635604781647768, 0.2381060925080103, 0.2538366820109347, 0.2862566439162719, 0.20202429133582622, 0.2688580651086606, 0.006815377731098082, 0.04825727121520651, 0.11856077808915233, 0.1813562021289128, 0.07014193855632855, 0.08847999841644871, 0.10668951769581636, 0.18384764398928644, 0.13728598396076208, 0.2018729110531281, 0.2708279565507947, 0.20091297138743625, 0.2593102304181274, 0.22961085056959796, 0.23724746052373324, 0.22008303513418093, 0.21954927055352014, 0.057196231013570076, 0.5559081365435417, 0.6196406943514774, 0.589077593755662, 0.5869766830930152, 0.5953339119458504, 0.6340726166383193, 0.5833155854898342, 0.5843701962452241, 0.5786404386285984, 0.08024404039909883, 0.15095515372837376, 0.14700319682940577, 0.14039760351310038, 0.12823919313167953, 0.1409804396688119, 0.1408908326562689, 0.15648424585859955, 0.11808994911577175, 0.16997114756579268, 0.20203105831646473, 0.3146752602067342, 0.22841970742357187, 0.2174406135468474, 0.21134365647925413, 0.14163797327526395, 0.20482464463602912, 0.17186414549168172, 0.4716735471557847, 0.5415552464215416, 0.4442915550895057, 0.45503043460817194, 0.43829275475668883, 0.44104034482229326, 0.5262675345884459, 0.4414685073382898, 0.528221690589417, 0.21453156015733, 0.35129216822593157, 0.27076741883567357, 0.3470678863818778, 0.3140444787832912, 0.28020502194472097, 0.3960355030058538, 0.1920429377388576, 0.3264612464873292, 0.2221651941520868, 0.20946854608864585, 0.20777518759072933, 0.19740789530421, 0.22003874789510847, 0.18289669608807113, 0.20639128853734723, 0.21316514164688227, 0.2125310897218925, 0.20800490655787152, 0.2310485764674346, 0.19433416702661244, 0.19150976351557214, 0.21897905047499866, 0.21976991982833816, 0.22047968784142136, 0.21148293124319473, 0.2230396208668417, 0.1849526320172895, 0.8831280701513066, 0.16661169625837247, 0.1467904313358307, 0.8957878707163859, 0.18040945267715358, 0.1898165921390188, 0.8432031152600812, 0.16899330604262652, 0.12769305642500695, 0.1678817645585179, 0.21152670605711354, 0.7105823581310747, 0.1674104734883194, 0.16827816945642704, 0.20398213820337419, 0.812091521642015, 0.29344285780618584, 0.19446965196404575, 0.18617960781963216, 0.18153820203446436, 0.17830301858234265, 0.18407213581042603, 0.1978006855495238, 0.17938492957314045, 0.19359262327397686, 0.19049021454753845, 0.09399848054770954, 0.07842696202664634, 0.07812932378516912, 0.08747843257169319, 0.09019181784645769, 0.0885773797579299, 0.09480387629944431, 0.08908903087677611, 0.07884870621101292]}, "mutation_prompt": null}
{"id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Added adaptive learning rates for cognitive and social coefficients to balance exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.37058087888206614, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "d783e1ff-73e9-4d60-a5e6-6926033cfc4a", "metadata": {"aucs": [0.8569020670639276, 0.8645957681440297, 0.8625242095769396, 0.8640778292690237, 0.8788784825055189, 0.8592813256861845, 0.8658281901713579, 0.8635396827888892, 0.8592388152991143, 0.7477664227406347, 0.7014379145875475, 0.7324804322666889, 0.7242269924823046, 0.7567164656763522, 0.7294015829593599, 0.7413142198454739, 0.7472305624374592, 0.7546735471051077, 0.1321558869847509, 0.13145200765942244, 0.133474927179298, 0.16283585919528154, 0.4034925002714187, 0.14272489451131154, 0.12584905616169784, 0.1277268194458826, 0.1410187080673333, 0.1321142813096443, 0.13157723983321556, 0.13732909234891688, 0.13221828259941026, 0.12889897059156752, 0.14724220219630546, 0.11531363402809314, 0.1258373574845999, 0.10849380397109887, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374697288, 0.665313669877003, 0.6294656180035442, 0.6338373432376565, 0.6267329827246306, 0.6180590371221248, 0.6464334065260293, 0.6067029002197676, 0.6225377211093723, 0.6379151758866657, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.2950940056638326, 0.32950188188318896, 0.32640855110853373, 0.29762889247356183, 0.3844332592120455, 0.40631237790606256, 0.3053997005388551, 0.3035696240032554, 0.45262513144806094, 0.15838790334394293, 0.28354715225280236, 0.29197894097875776, 0.3560266440172911, 0.3716488632432885, 0.2636563141709036, 0.28818666477994304, 0.27097742082365284, 0.1708939949468513, 0.08461441561428162, 0.13352231901162537, 0.13771182537900006, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705342396, 0.12030783009505253, 0.1422531351262829, 0.2668758367488726, 0.2988203225811702, 0.2755825923743791, 0.23542115632095595, 0.21501838526060768, 0.2321943091228339, 0.2538700662374419, 0.21976208281829968, 0.25648669887288633, 0.03482214683410856, 0.04707343284627785, 0.0592732932465333, 0.09614223924821452, 0.0753261361018378, 0.132287515897885, 0.13266723443913253, 0.08538186730010566, 0.0805197053934873, 0.19018297610776047, 0.21489139550621383, 0.23037727099769956, 0.18832358024241158, 0.20861459246331282, 0.23939280461842327, 0.17591205123257636, 0.1867465396203879, 0.04854781884135029, 0.5866409469959487, 0.5956197746137197, 0.5919221546653817, 0.6186794359767602, 0.5840138904057572, 0.6197203668869604, 0.6085898570205136, 0.6338752071498687, 0.580769311307668, 0.09012026015657215, 0.11634923916030604, 0.10838430396844856, 0.13290674847784434, 0.10467247413665626, 0.09664933957756605, 0.1360313561448676, 0.12395919790557286, 0.10334360424709155, 0.17749790903971174, 0.20166980065715412, 0.31731419813311446, 0.17856763066764758, 0.3805601980779507, 0.18342873221551537, 0.34807483466476763, 0.21354735008968828, 0.3177728835988506, 0.4496050037959529, 0.47935949055264104, 0.4396932490898211, 0.458984032093129, 0.4733200783917759, 0.5092076619129268, 0.48860445179143674, 0.5425682259612649, 0.5067152895649834, 0.2592285200952654, 0.24855915333580836, 0.33232564283452126, 0.3015277092921027, 0.24493515494449214, 0.3118221977793182, 0.28271342443218195, 0.2277328221671684, 0.28608218427998133, 0.21247351352587174, 0.21260431037749639, 0.1960077059571972, 0.23368376947030534, 0.20442852219163954, 0.19307096511717958, 0.2023472152193967, 0.20069542559415832, 0.2142958665261856, 0.23394626426350995, 0.20546162474554408, 0.24023722915156276, 0.21592344376808092, 0.6321623866440926, 0.20053808599871292, 0.21157873781303405, 0.21146477283916942, 0.5491768581097044, 0.18340734916139068, 0.885542380729564, 0.1848706754302657, 0.14754255467342337, 0.8164302896176949, 0.7862831410690807, 0.7896693195716351, 0.7932421058575989, 0.1690530041066315, 0.12725236992507238, 0.21029445479003894, 0.21096933958626496, 0.7646300460993856, 0.16762708051695696, 0.16853053840479082, 0.09358005515017032, 0.7838730535519425, 0.20040494884371274, 0.18228921240815987, 0.1892840408501687, 0.20013031783574953, 0.19186918659312047, 0.1840035878338202, 0.19209696619427008, 0.17615469206980383, 0.2088237833611002, 0.193922338772599, 0.07895736149871613, 0.08717086343814484, 0.09054525420665427, 0.10352103694913928, 0.08821645148346546, 0.08464520405927867, 0.09862826738193164, 0.07832612044915588, 0.08367535624046063]}, "mutation_prompt": null}
{"id": "692f368e-1d5b-4fac-90ab-60c96bbfd418", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.6 + 0.2 * (diversity / (np.max(diversity) + 1e-5))  # Modified line\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced the inertia weight adaptation to improve balance between exploration and exploitation phases. ", "configspace": "", "generation": 48, "fitness": 0.3228119925597274, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.7483872091857136, 0.752299022106877, 0.7617489867363176, 0.7898915938542885, 0.7954624634848195, 0.7796099563616654, 0.7559215516437384, 0.7795142190094285, 0.7704514248683845, 0.6528040915585791, 0.644191778387478, 0.6370159873794621, 0.6556235752716788, 0.632003387472589, 0.6331657387026866, 0.6428341841092651, 0.6287941974899653, 0.632973206486847, 0.11156059010915198, 0.30328629636834703, 0.14494912051040754, 0.15482643951990993, 0.10426430206502535, 0.1009876017735234, 0.13416754019550425, 0.13456421025265242, 0.1413750798110638, 0.11775695483700599, 0.10798004227182978, 0.10316712647385029, 0.10597861529725183, 0.10933149823231014, 0.11936045273279228, 0.11889827448241974, 0.10952136925272038, 0.11413164081129457, 0.9840456432367862, 0.9774047425376162, 0.9851366895465438, 0.9770655629075159, 0.9814725045545291, 0.9861310993677525, 0.9863042029787366, 0.9879269444573178, 0.9750299577187888, 0.544513501784525, 0.5100545175257873, 0.477662456831614, 0.5182287506938265, 0.4742095683073665, 0.2626627232877521, 0.5070996832388346, 0.4817369057861469, 0.5107849138198413, 0.6924966582046663, 0.6466374070765648, 0.6745083018705218, 0.7316858560631583, 0.6973318893380309, 0.20740360640353273, 0.6830412988773142, 0.6433639713712251, 0.6997636436489357, 0.18420933120171312, 0.1987388945333297, 0.2713364767458394, 0.25867828949274696, 0.12310422416835731, 0.21674584964349997, 0.25085061383869844, 0.2202737455887528, 0.20552796427779885, 0.1442546185680168, 0.24449755634690096, 0.10721390683908871, 0.2843762899149117, 0.25202220915185236, 0.2072592631357767, 0.23601196340412633, 0.11768724791702101, 0.2583139386151635, 0.11829507567649167, 0.12135513035303958, 0.1023257796049043, 0.10044860990343274, 0.09855091123446291, 0.11202982012224871, 0.10946216933107822, 0.08950286953877307, 0.1090264491247197, 0.21950298475502183, 0.23355869908677296, 0.26462657129960776, 0.24226839116389276, 0.21653920316210318, 0.26455320841101304, 0.237628677125022, 0.23247501330438491, 0.25850326974929805, 0.030173681242598782, 0.041405291006959666, 0.02515732764667611, 0.06100993072672667, 0.08124002010428633, 0.06778473948733066, 0.05294553790650425, 0.03929076417636845, 0.08345303127649806, 0.17040450151276787, 0.16968042849307263, 0.1892818113701007, 0.19083555958964726, 0.16915441377774165, 0.178820619360328, 0.17823529109214287, 0.15650402116046847, 0.14895987441085345, 0.5309957739197053, 0.5422288045643872, 0.5312407353560835, 0.5333267702389424, 0.5237265036722727, 0.5805469598451, 0.5408324762194326, 0.5397423112731183, 0.5475277172486386, 0.09317748286203953, 0.10947277337424544, 0.10955039237156905, 0.1165670499001239, 0.12539629677204323, 0.1082036045044179, 0.1083551813705943, 0.09608273889163743, 0.10080920678554106, 0.1693463434375051, 0.16651079646979217, 0.2694864725033098, 0.15357546634768227, 0.26409396121887385, 0.15402723694121723, 0.13440656997935563, 0.15892819383502088, 0.15201202108387002, 0.36453089625346047, 0.3668656035101806, 0.43088534160482783, 0.3884488722335705, 0.4311686327233134, 0.3798724308373381, 0.4248479600036573, 0.42862311913456264, 0.39114736922223714, 0.29181595803442484, 0.285837674146716, 0.2584126168514512, 0.24832022151175537, 0.2618446534688341, 0.3021707945601685, 0.32578567498626143, 0.30245948923592236, 0.367748650132823, 0.18054704170949976, 0.22303198110531575, 0.18639770439639003, 0.20026827625027133, 0.20806155750016497, 0.21470359391870864, 0.18750179062808625, 0.1948824156519735, 0.20304045045215513, 0.19790188184334034, 0.2677108214742987, 0.21806088336524632, 0.25589632144101193, 0.19190221074064728, 0.19154652968472574, 0.45346176122391946, 0.1912792854258143, 0.4023572860616439, 0.16395854778042052, 0.8305584188946862, 0.16882657384754207, 0.18875155790796339, 0.7871070146510043, 0.7041921247959748, 0.7349727215837939, 0.7494977067383224, 0.17998935552345852, 0.6084509654770925, 0.20741890301100796, 0.20635518551018572, 0.19857303865762144, 0.16723857219270233, 0.1665105114897666, 0.20605236856827802, 0.20669266062683522, 0.2096045004518743, 0.18660496554396944, 0.17672819311674104, 0.20795731695448416, 0.1741598214395006, 0.17915334234997227, 0.18197299740601924, 0.18536260003556715, 0.19085633129389123, 0.17939030395290667, 0.07807703456500659, 0.07521086781330921, 0.08060307868027017, 0.07684829982814367, 0.07897528771379225, 0.07600430736160446, 0.09502285394211685, 0.0849627389325811, 0.07664694073848333]}, "mutation_prompt": null}
{"id": "c963d59d-11aa-4213-aceb-c8d6d722f127", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        elite_positions = np.copy(positions)  # Line 1 changed\n        elite_fitness = np.copy(fitness)      # Line 2 changed\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n\n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced an elite selection mechanism that preserves top-performing solutions to enhance convergence stability.", "configspace": "", "generation": 49, "fitness": 0.37058087888206614, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8569020670639276, 0.8645957681440297, 0.8625242095769396, 0.8640778292690237, 0.8788784825055189, 0.8592813256861845, 0.8658281901713579, 0.8635396827888892, 0.8592388152991143, 0.7477664227406347, 0.7014379145875475, 0.7324804322666889, 0.7242269924823046, 0.7567164656763522, 0.7294015829593599, 0.7413142198454739, 0.7472305624374592, 0.7546735471051077, 0.1321558869847509, 0.13145200765942244, 0.133474927179298, 0.16283585919528154, 0.4034925002714187, 0.14272489451131154, 0.12584905616169784, 0.1277268194458826, 0.1410187080673333, 0.1321142813096443, 0.13157723983321556, 0.13732909234891688, 0.13221828259941026, 0.12889897059156752, 0.14724220219630546, 0.11531363402809314, 0.1258373574845999, 0.10849380397109887, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374697288, 0.665313669877003, 0.6294656180035442, 0.6338373432376565, 0.6267329827246306, 0.6180590371221248, 0.6464334065260293, 0.6067029002197676, 0.6225377211093723, 0.6379151758866657, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.2950940056638326, 0.32950188188318896, 0.32640855110853373, 0.29762889247356183, 0.3844332592120455, 0.40631237790606256, 0.3053997005388551, 0.3035696240032554, 0.45262513144806094, 0.15838790334394293, 0.28354715225280236, 0.29197894097875776, 0.3560266440172911, 0.3716488632432885, 0.2636563141709036, 0.28818666477994304, 0.27097742082365284, 0.1708939949468513, 0.08461441561428162, 0.13352231901162537, 0.13771182537900006, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705342396, 0.12030783009505253, 0.1422531351262829, 0.2668758367488726, 0.2988203225811702, 0.2755825923743791, 0.23542115632095595, 0.21501838526060768, 0.2321943091228339, 0.2538700662374419, 0.21976208281829968, 0.25648669887288633, 0.03482214683410856, 0.04707343284627785, 0.0592732932465333, 0.09614223924821452, 0.0753261361018378, 0.132287515897885, 0.13266723443913253, 0.08538186730010566, 0.0805197053934873, 0.19018297610776047, 0.21489139550621383, 0.23037727099769956, 0.18832358024241158, 0.20861459246331282, 0.23939280461842327, 0.17591205123257636, 0.1867465396203879, 0.04854781884135029, 0.5866409469959487, 0.5956197746137197, 0.5919221546653817, 0.6186794359767602, 0.5840138904057572, 0.6197203668869604, 0.6085898570205136, 0.6338752071498687, 0.580769311307668, 0.09012026015657215, 0.11634923916030604, 0.10838430396844856, 0.13290674847784434, 0.10467247413665626, 0.09664933957756605, 0.1360313561448676, 0.12395919790557286, 0.10334360424709155, 0.17749790903971174, 0.20166980065715412, 0.31731419813311446, 0.17856763066764758, 0.3805601980779507, 0.18342873221551537, 0.34807483466476763, 0.21354735008968828, 0.3177728835988506, 0.4496050037959529, 0.47935949055264104, 0.4396932490898211, 0.458984032093129, 0.4733200783917759, 0.5092076619129268, 0.48860445179143674, 0.5425682259612649, 0.5067152895649834, 0.2592285200952654, 0.24855915333580836, 0.33232564283452126, 0.3015277092921027, 0.24493515494449214, 0.3118221977793182, 0.28271342443218195, 0.2277328221671684, 0.28608218427998133, 0.21247351352587174, 0.21260431037749639, 0.1960077059571972, 0.23368376947030534, 0.20442852219163954, 0.19307096511717958, 0.2023472152193967, 0.20069542559415832, 0.2142958665261856, 0.23394626426350995, 0.20546162474554408, 0.24023722915156276, 0.21592344376808092, 0.6321623866440926, 0.20053808599871292, 0.21157873781303405, 0.21146477283916942, 0.5491768581097044, 0.18340734916139068, 0.885542380729564, 0.1848706754302657, 0.14754255467342337, 0.8164302896176949, 0.7862831410690807, 0.7896693195716351, 0.7932421058575989, 0.1690530041066315, 0.12725236992507238, 0.21029445479003894, 0.21096933958626496, 0.7646300460993856, 0.16762708051695696, 0.16853053840479082, 0.09358005515017032, 0.7838730535519425, 0.20040494884371274, 0.18228921240815987, 0.1892840408501687, 0.20013031783574953, 0.19186918659312047, 0.1840035878338202, 0.19209696619427008, 0.17615469206980383, 0.2088237833611002, 0.193922338772599, 0.07895736149871613, 0.08717086343814484, 0.09054525420665427, 0.10352103694913928, 0.08821645148346546, 0.08464520405927867, 0.09862826738193164, 0.07832612044915588, 0.08367535624046063]}, "mutation_prompt": null}
{"id": "88e706a7-ef2a-4420-9e68-5bd5de379b87", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        improvement_rate = np.mean(best_positions) / (np.mean(fitness_variance) + 1e-5)\n        perturbation_scale = 0.6 + 0.3 * improvement_rate\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced mutation strategy with dynamic scale based on fitness improvement rate.", "configspace": "", "generation": 50, "fitness": 0.3587776760163362, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8115606191905689, 0.8459807313183851, 0.8098904539684425, 0.844948949581136, 0.8182334675513384, 0.7994203489101308, 0.8027303296312197, 0.8242515105946147, 0.826145567330022, 0.6955159486372339, 0.6381808314727274, 0.6815047771335213, 0.699250106859816, 0.7093267349496974, 0.6938072343699185, 0.7318426391700774, 0.7386917749860922, 0.7422559533324995, 0.13054409627193075, 0.42106145705561226, 0.124985727384331, 0.1423030772767686, 0.1397411445940907, 0.14273058796504534, 0.13812417582929315, 0.13853444237987622, 0.13341347441689122, 0.13167408005980374, 0.13169105726351193, 0.1372655713069244, 0.1322185238564545, 0.12888969332589584, 0.12914073856311115, 0.137247288834089, 0.1258381200455737, 0.10849449382623222, 0.981690748838069, 0.9731831752497775, 0.9849688709731959, 0.9769610836762702, 0.9814541807202466, 0.9848196726929105, 0.9859922707527295, 0.9878213497636832, 0.9725411293978505, 0.6130681842385878, 0.6065001789112732, 0.5957209619071847, 0.6083031040539669, 0.636073854789523, 0.6421183201078144, 0.5953027495195478, 0.5970890302220522, 0.6081570197169597, 0.7769283076810047, 0.7735006514527568, 0.7321733104956036, 0.7918546943127752, 0.7860310099226784, 0.7203942184027541, 0.7726011368408954, 0.6234083843956444, 0.7643032607185694, 0.2916691193102878, 0.2862840189710435, 0.2986770743922662, 0.3074047134445901, 0.36322365619029706, 0.39083893105125245, 0.2940945724989895, 0.25219614385513656, 0.45375606674546765, 0.1583878238654456, 0.29518612374469244, 0.31156541827989226, 0.3467153136371016, 0.37694397690290493, 0.2712068227080867, 0.37179613281205093, 0.2795937161404961, 0.18030012676727747, 0.08461441480938592, 0.13352231898259392, 0.13771182568203133, 0.1315864915127951, 0.12088101926940631, 0.12250082595045719, 0.12083345358087483, 0.12030783004764112, 0.1422531330920297, 0.2668758407421328, 0.29882035570901966, 0.2755825578405584, 0.23542115673727582, 0.21501838352886593, 0.23219430133964858, 0.253870017368633, 0.21976208061187463, 0.2564866989230271, 0.03482213816984936, 0.047073459097282444, 0.05927329325285302, 0.09614225721787462, 0.07548685390693133, 0.13226495173567832, 0.1326672336209047, 0.08538126102114951, 0.08030084135941995, 0.19137658051825523, 0.212401782101571, 0.22787744694009326, 0.18441359477635477, 0.2108855116275975, 0.22219571028525031, 0.15064847448419372, 0.19142621574551266, 0.05049560703737166, 0.5758333010311345, 0.5792592474400591, 0.5627142033551773, 0.5450195155322801, 0.5565751663078387, 0.5403768417104926, 0.6113545502617412, 0.5807610285475964, 0.602901486006583, 0.09924401246448944, 0.1300936528816775, 0.11380923114203723, 0.13266587021185894, 0.12851074741016655, 0.09725347503324244, 0.11279530201508847, 0.08295108385259498, 0.12686049493077278, 0.13138635727847126, 0.21220196468664576, 0.32109026418492626, 0.27093249457738033, 0.18641365270820032, 0.17312321147251164, 0.36617312097088894, 0.19987703525298417, 0.1951146286553842, 0.3455385028429506, 0.34160494072363246, 0.3735281840420652, 0.36738709316696194, 0.36159319513108457, 0.3731556871422971, 0.42179896089785385, 0.4196045188709563, 0.4201638554718409, 0.2648038219184742, 0.2645655110003562, 0.30819332066737803, 0.31346558460156926, 0.24532869350740738, 0.3230550030455597, 0.2635082380089979, 0.2889663850566525, 0.2873065440636936, 0.21685112770180193, 0.21615575530884945, 0.21129410419770633, 0.22559848306977692, 0.20015248617857218, 0.21240001362511052, 0.21258950156146306, 0.2132260520336936, 0.21593302504017298, 0.2339461810917517, 0.20545604166545173, 0.2402373720648603, 0.2159240721161606, 0.6047702124070196, 0.2005384538410654, 0.21157806056931872, 0.2114719418614054, 0.5182557807057304, 0.18364587934614218, 0.8807604077579688, 0.1846180754443988, 0.147551301626217, 0.8157830820512388, 0.7784030984091197, 0.7871708126976202, 0.7893444137419795, 0.16905285144442972, 0.1272096753872929, 0.21029699668850255, 0.21096996531332834, 0.7530726741069084, 0.16762506633321406, 0.16853373972039465, 0.09358065276954075, 0.7767466740776043, 0.2080538005995276, 0.17691489580197572, 0.18145509895442857, 0.20579825192415546, 0.18215887070132142, 0.19433649141397635, 0.2174030509955942, 0.19655543827132282, 0.18884550847649817, 0.18331878234438803, 0.07889577567378969, 0.08188864588742795, 0.07804594033520662, 0.09796142387901241, 0.08425577415576513, 0.08580341920525392, 0.10423341808110331, 0.08845166581664232, 0.08838549603259072]}, "mutation_prompt": null}
{"id": "ac96af09-8672-4990-9d25-9469839d9e82", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Added adaptive learning rates for cognitive and social coefficients to balance exploration and exploitation.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8569020670639276, 0.8645957681440297, 0.8625242095769396, 0.8640778292690237, 0.8788784825055189, 0.8592813256861845, 0.8658281901713579, 0.8635396827888892, 0.8592388152991143, 0.7477664227406347, 0.7014379145875475, 0.7324804322666889, 0.7242269924823046, 0.7567164656763522, 0.7294015829593599, 0.7413142198454739, 0.7472305624374592, 0.7546735471051077, 0.1321558869847509, 0.13145200765942244, 0.133474927179298, 0.16283585919528154, 0.4034925002714187, 0.14272489451131154, 0.12584905616169784, 0.1277268194458826, 0.1410187080673333, 0.1321142813096443, 0.13157723983321556, 0.13732909234891688, 0.13221828259941026, 0.12889897059156752, 0.14724220219630546, 0.11531363402809314, 0.1258373574845999, 0.10849380397109887, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374697288, 0.665313669877003, 0.6294656180035442, 0.6338373432376565, 0.6267329827246306, 0.6180590371221248, 0.6464334065260293, 0.6067029002197676, 0.6225377211093723, 0.6379151758866657, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.2950940056638326, 0.32950188188318896, 0.32640855110853373, 0.29762889247356183, 0.3844332592120455, 0.40631237790606256, 0.3053997005388551, 0.3035696240032554, 0.45262513144806094, 0.15838790334394293, 0.28354715225280236, 0.29197894097875776, 0.3560266440172911, 0.3716488632432885, 0.2636563141709036, 0.28818666477994304, 0.27097742082365284, 0.1708939949468513, 0.08461441561428162, 0.13352231901162537, 0.13771182537900006, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705342396, 0.12030783009505253, 0.1422531351262829, 0.2668758367488726, 0.2988203225811702, 0.2755825923743791, 0.23542115632095595, 0.21501838526060768, 0.2321943091228339, 0.2538700662374419, 0.21976208281829968, 0.25648669887288633, 0.03482214683410856, 0.04707343284627785, 0.0592732932465333, 0.09614223924821452, 0.0753261361018378, 0.132287515897885, 0.13266723443913253, 0.08538186730010566, 0.0805197053934873, 0.19018297610776047, 0.21489139550621383, 0.23037727099769956, 0.18832358024241158, 0.20861459246331282, 0.23939280461842327, 0.17591205123257636, 0.1867465396203879, 0.04854781884135029, 0.5866409469959487, 0.5956197746137197, 0.5919221546653817, 0.6186794359767602, 0.5840138904057572, 0.6197203668869604, 0.6085898570205136, 0.6338752071498687, 0.580769311307668, 0.09012026015657215, 0.11634923916030604, 0.10838430396844856, 0.13290674847784434, 0.10467247413665626, 0.09664933957756605, 0.1360313561448676, 0.12395919790557286, 0.10334360424709155, 0.17749790903971174, 0.20166980065715412, 0.31731419813311446, 0.17856763066764758, 0.3805601980779507, 0.18342873221551537, 0.34807483466476763, 0.21354735008968828, 0.3177728835988506, 0.4496050037959529, 0.47935949055264104, 0.4396932490898211, 0.458984032093129, 0.4733200783917759, 0.5092076619129268, 0.48860445179143674, 0.5425682259612649, 0.5067152895649834, 0.2592285200952654, 0.24855915333580836, 0.33232564283452126, 0.3015277092921027, 0.24493515494449214, 0.3118221977793182, 0.28271342443218195, 0.2277328221671684, 0.28608218427998133, 0.21247351352587174, 0.21260431037749639, 0.1960077059571972, 0.23368376947030534, 0.20442852219163954, 0.19307096511717958, 0.2023472152193967, 0.20069542559415832, 0.2142958665261856, 0.23394626426350995, 0.20546162474554408, 0.24023722915156276, 0.21592344376808092, 0.6321623866440926, 0.20053808599871292, 0.21157873781303405, 0.21146477283916942, 0.5491768581097044, 0.18340734916139068, 0.885542380729564, 0.1848706754302657, 0.14754255467342337, 0.8164302896176949, 0.7862831410690807, 0.7896693195716351, 0.7932421058575989, 0.1690530041066315, 0.12725236992507238, 0.21029445479003894, 0.21096933958626496, 0.7646300460993856, 0.16762708051695696, 0.16853053840479082, 0.09358005515017032, 0.7838730535519425, 0.20040494884371274, 0.18228921240815987, 0.1892840408501687, 0.20013031783574953, 0.19186918659312047, 0.1840035878338202, 0.19209696619427008, 0.17615469206980383, 0.2088237833611002, 0.193922338772599, 0.07895736149871613, 0.08717086343814484, 0.09054525420665427, 0.10352103694913928, 0.08821645148346546, 0.08464520405927867, 0.09862826738193164, 0.07832612044915588, 0.08367535624046063]}, "mutation_prompt": null}
{"id": "f0b820be-9fc7-4827-8f6f-4bb15a409535", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Added adaptive learning rates for cognitive and social coefficients to balance exploration and exploitation.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8569020670639276, 0.8645957681440297, 0.8625242095769396, 0.8640778292690237, 0.8788784825055189, 0.8592813256861845, 0.8658281901713579, 0.8635396827888892, 0.8592388152991143, 0.7477664227406347, 0.7014379145875475, 0.7324804322666889, 0.7242269924823046, 0.7567164656763522, 0.7294015829593599, 0.7413142198454739, 0.7472305624374592, 0.7546735471051077, 0.1321558869847509, 0.13145200765942244, 0.133474927179298, 0.16283585919528154, 0.4034925002714187, 0.14272489451131154, 0.12584905616169784, 0.1277268194458826, 0.1410187080673333, 0.1321142813096443, 0.13157723983321556, 0.13732909234891688, 0.13221828259941026, 0.12889897059156752, 0.14724220219630546, 0.11531363402809314, 0.1258373574845999, 0.10849380397109887, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374697288, 0.665313669877003, 0.6294656180035442, 0.6338373432376565, 0.6267329827246306, 0.6180590371221248, 0.6464334065260293, 0.6067029002197676, 0.6225377211093723, 0.6379151758866657, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.2950940056638326, 0.32950188188318896, 0.32640855110853373, 0.29762889247356183, 0.3844332592120455, 0.40631237790606256, 0.3053997005388551, 0.3035696240032554, 0.45262513144806094, 0.15838790334394293, 0.28354715225280236, 0.29197894097875776, 0.3560266440172911, 0.3716488632432885, 0.2636563141709036, 0.28818666477994304, 0.27097742082365284, 0.1708939949468513, 0.08461441561428162, 0.13352231901162537, 0.13771182537900006, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705342396, 0.12030783009505253, 0.1422531351262829, 0.2668758367488726, 0.2988203225811702, 0.2755825923743791, 0.23542115632095595, 0.21501838526060768, 0.2321943091228339, 0.2538700662374419, 0.21976208281829968, 0.25648669887288633, 0.03482214683410856, 0.04707343284627785, 0.0592732932465333, 0.09614223924821452, 0.0753261361018378, 0.132287515897885, 0.13266723443913253, 0.08538186730010566, 0.0805197053934873, 0.19018297610776047, 0.21489139550621383, 0.23037727099769956, 0.18832358024241158, 0.20861459246331282, 0.23939280461842327, 0.17591205123257636, 0.1867465396203879, 0.04854781884135029, 0.5866409469959487, 0.5956197746137197, 0.5919221546653817, 0.6186794359767602, 0.5840138904057572, 0.6197203668869604, 0.6085898570205136, 0.6338752071498687, 0.580769311307668, 0.09012026015657215, 0.11634923916030604, 0.10838430396844856, 0.13290674847784434, 0.10467247413665626, 0.09664933957756605, 0.1360313561448676, 0.12395919790557286, 0.10334360424709155, 0.17749790903971174, 0.20166980065715412, 0.31731419813311446, 0.17856763066764758, 0.3805601980779507, 0.18342873221551537, 0.34807483466476763, 0.21354735008968828, 0.3177728835988506, 0.4496050037959529, 0.47935949055264104, 0.4396932490898211, 0.458984032093129, 0.4733200783917759, 0.5092076619129268, 0.48860445179143674, 0.5425682259612649, 0.5067152895649834, 0.2592285200952654, 0.24855915333580836, 0.33232564283452126, 0.3015277092921027, 0.24493515494449214, 0.3118221977793182, 0.28271342443218195, 0.2277328221671684, 0.28608218427998133, 0.21247351352587174, 0.21260431037749639, 0.1960077059571972, 0.23368376947030534, 0.20442852219163954, 0.19307096511717958, 0.2023472152193967, 0.20069542559415832, 0.2142958665261856, 0.23394626426350995, 0.20546162474554408, 0.24023722915156276, 0.21592344376808092, 0.6321623866440926, 0.20053808599871292, 0.21157873781303405, 0.21146477283916942, 0.5491768581097044, 0.18340734916139068, 0.885542380729564, 0.1848706754302657, 0.14754255467342337, 0.8164302896176949, 0.7862831410690807, 0.7896693195716351, 0.7932421058575989, 0.1690530041066315, 0.12725236992507238, 0.21029445479003894, 0.21096933958626496, 0.7646300460993856, 0.16762708051695696, 0.16853053840479082, 0.09358005515017032, 0.7838730535519425, 0.20040494884371274, 0.18228921240815987, 0.1892840408501687, 0.20013031783574953, 0.19186918659312047, 0.1840035878338202, 0.19209696619427008, 0.17615469206980383, 0.2088237833611002, 0.193922338772599, 0.07895736149871613, 0.08717086343814484, 0.09054525420665427, 0.10352103694913928, 0.08821645148346546, 0.08464520405927867, 0.09862826738193164, 0.07832612044915588, 0.08367535624046063]}, "mutation_prompt": null}
{"id": "7f1e0326-b2f8-4640-bbd2-1c2324f16a12", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.7 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = personal_best_positions[global_best_index]  # Updated line\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance global best update and mutation step to improve convergence.", "configspace": "", "generation": 53, "fitness": 0.352304820439196, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8497649004288339, 0.8531577390706356, 0.8669688239737688, 0.8575357697082698, 0.8536147799858239, 0.8486793548415652, 0.8592851262544259, 0.8476008700923148, 0.85563163403344, 0.7213430430912628, 0.7093831340155714, 0.7214453802664647, 0.7423942123027032, 0.7266746796305578, 0.7106536974162894, 0.7275074837447304, 0.7343687988681286, 0.7158604095738634, 0.12524231130118302, 0.13441673607958893, 0.13917742914433806, 0.2921351090956599, 0.1398961220032252, 0.14705865967134035, 0.1597303062435309, 0.12443742947261893, 0.1278821171957505, 0.10261430102166746, 0.11409875065604824, 0.13406083374255773, 0.13627215143158378, 0.10855452550555544, 0.14043970740293665, 0.12302804650475663, 0.1507469764670768, 0.11466644176345131, 0.981648934623892, 0.976079967739704, 0.984969690444354, 0.9768685947353258, 0.9814553715433976, 0.9848195573200065, 0.9859965210951855, 0.9878215338937962, 0.9725920346590329, 0.6296733663986427, 0.6280005984476722, 0.5518019392518481, 0.615768679055941, 0.4951585376349399, 0.14980293020708302, 0.6212892861072388, 0.5836381833788873, 0.6164258128413831, 0.7870522360721126, 0.7362595629305179, 0.7436407111352457, 0.7344115632195223, 0.782223358030817, 0.19404714635547005, 0.7788737850703366, 0.7305360155312255, 0.7642768749177807, 0.12975278119211875, 0.3360747164948973, 0.4111178038241772, 0.12977867171564195, 0.26915717895899416, 0.27154250245600875, 0.3813997879893336, 0.12817764985563174, 0.5642577675678401, 0.19960030434366893, 0.2597643629891043, 0.31184534116196905, 0.30023864152268254, 0.37895141290852286, 0.3668016617330524, 0.273169318307086, 0.23930410510361955, 0.32066587262565505, 0.10732902895526153, 0.0597442545592336, 0.07685456587483241, 0.08495482762127415, 0.07179999884250898, 0.11268535666100776, 0.07104315442649256, 0.10833959771235313, 0.10487415358542418, 0.21204939838763082, 0.21798422932705241, 0.21155975200382504, 0.20911629396574816, 0.1893878376920155, 0.22677338355582843, 0.24354303411792466, 0.2019114102597671, 0.23756584974198036, 0.0338278768887641, 0.05533443510527758, 0.0815290041733584, 0.07169726784869634, 0.07471464057804256, 0.08587136272037621, 0.09706450126744526, 0.08929488885458814, 0.06874292600246212, 0.20423127321743006, 0.18440044960769464, 0.18846681061609383, 0.22114790381708282, 0.20780597306636606, 0.25644397511926353, 0.1303646391521721, 0.17518331424588873, 0.05563642698898552, 0.5935911566199258, 0.5910073320684981, 0.5664308799290452, 0.5921163397979661, 0.5684546992902682, 0.5905120040128916, 0.5812087351408846, 0.6080987925448142, 0.5753939849012542, 0.13296709486028813, 0.14229281815939232, 0.14880672473772283, 0.12996932648228976, 0.11430220376514044, 0.1457986398883735, 0.13313217808304367, 0.131095019168872, 0.11877786965738435, 0.22585647568665457, 0.13739228681414484, 0.3361471990969017, 0.1693384723428646, 0.24565471516461623, 0.24263101031612355, 0.2625226125923007, 0.209819911878371, 0.13744653455545286, 0.4411551878011827, 0.3301401249168635, 0.43293187892257035, 0.5090025857782374, 0.44812280454519315, 0.4609971476527833, 0.4988069009443229, 0.458461447579638, 0.5454664139253742, 0.3311824609634445, 0.2763046496400897, 0.34212528520258256, 0.30195201051543263, 0.23558900014410578, 0.2381526121073384, 0.3237900984186629, 0.30526355870181854, 0.35693281847288094, 0.20503663186055532, 0.2187205545651385, 0.21562602133474051, 0.20894939532903778, 0.1908698812640217, 0.18679468576380787, 0.20943132175748325, 0.21158115506573416, 0.22472611519077623, 0.21792735350974302, 0.23638228800489047, 0.20670250612730645, 0.23146210515989696, 0.410085337480817, 0.23517270588508132, 0.6268659356520397, 0.21960976289127676, 0.24670225452341088, 0.6525933180232071, 0.8972074087676878, 0.1698661842543865, 0.16430143497513527, 0.8359954133337426, 0.18054439036014813, 0.7334017153204158, 0.17756416083875015, 0.1942458004310469, 0.12759557980973713, 0.20930231704401858, 0.16748030570458872, 0.7637635159960682, 0.1670193211175256, 0.16823796463995078, 0.20703915528034245, 0.8092707559434279, 0.1996960307146156, 0.20035263224817323, 0.1880629661403056, 0.20504197426769344, 0.19030797323945192, 0.17918218122515406, 0.1912745733693748, 0.18150102567359605, 0.18253286069750196, 0.18826154738677803, 0.08189621196462471, 0.08737252961979391, 0.07715851075592106, 0.0958553996944107, 0.08644576477501598, 0.08120151376411033, 0.12548379207635574, 0.0765936206200244, 0.0920690876864666]}, "mutation_prompt": null}
{"id": "e8517bed-9497-43ad-983a-56c0844dc76a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            # Updated mutation probability\n            fitness_variance = np.var(fitness)\n            mutation_probability = 0.1 + 0.2 * (self.current_evaluations / self.budget)\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced a dynamic mutation rate that increases as evaluations progress, enhancing exploration in later stages.", "configspace": "", "generation": 54, "fitness": 0.3539738448792975, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8877354985754562, 0.8973919585173774, 0.8994012106915362, 0.8970995869598628, 0.7504993720158628, 0.9060368982831407, 0.8926839201376596, 0.9031492963909119, 0.9005586031719723, 0.8009093762037361, 0.786894575409574, 0.7865606316871372, 0.7624637805865988, 0.7957533473036482, 0.7919566577121386, 0.8011897806950012, 0.7513973724637539, 0.7766903062692417, 0.08923229824086243, 0.1532036985984625, 0.15655988795147424, 0.07344050244243971, 0.15019276060920383, 0.16271640818499344, 0.13739212488926278, 0.13244683485717945, 0.5808221257989467, 0.12858215998910105, 0.13134806549932143, 0.1356019161956976, 0.11388616278410624, 0.11585568220214937, 0.17465949819898596, 0.1410639488742238, 0.10291919912788416, 0.13061832933996043, 0.9864497902241101, 0.9468039065940334, 0.9775350350525365, 0.9640302807620398, 0.9889550583149979, 0.9859939894110002, 0.9859467641009035, 0.9863388054857648, 0.9811358669898462, 0.705508430108775, 0.7271974874413878, 0.7068395889775769, 0.6913789642945034, 0.6748535420415755, 0.6777071723149461, 0.7096579993554912, 0.6774998324506345, 0.6738384691049399, 0.7938360379164309, 0.8014657904630335, 0.24195775756291327, 0.9516477780904595, 0.1612991710386963, 0.2087973909741745, 0.8188657280030582, 0.8328397812070832, 0.7449832934079761, 0.1253396574033262, 0.2750206119513926, 0.1326207126232508, 0.31052030279939946, 0.29380887170184233, 0.30394973546159976, 0.2553607506352712, 0.569582807931995, 0.1347778739895008, 0.0540158723505918, 0.3737794709208422, 0.28694951543796654, 0.15421442424107734, 0.13540809977570112, 0.13324538215751114, 0.3517288306633676, 0.2718811847454753, 0.2451098652384831, 0.06437601585885788, 0.07132247006041803, 0.04056329333329545, 0.14477867350271867, 0.13430650999372706, 0.008682717817017349, 0.05426553222802899, 0.12981065048369433, 0.22357293645132603, 0.20261864592787804, 0.20722079746377997, 0.1931464209296263, 0.14186879229088278, 0.12637731410705288, 0.1343344061538584, 0.14641142912536176, 0.16554577956393368, 0.26364311509733895, 9.999999999998899e-05, 0.0511700885419053, 0.10295439725163669, 0.07705183916580705, 0.07977774280571537, 0.10407475689112522, 0.14676524815848846, 0.09900793168962607, 0.15942069504211975, 0.06503087560466358, 0.17392592198790935, 0.04347437082445049, 0.15907048129201962, 0.1565139707034332, 0.23863417028237166, 0.08329264091786714, 0.12514616084870667, 0.05189057717723933, 0.6362395816818907, 0.6625905105899781, 0.5823663627916609, 0.5974381285548245, 0.618691309713975, 0.6303384384791406, 0.6266120526316721, 0.6616651065496488, 0.6440801740345294, 0.12826306735726212, 0.11751551928154691, 0.08505212774614324, 0.12642200938903536, 0.14246606201823941, 0.1426084397557955, 0.10992004823454005, 0.16086234897901908, 0.15856748532354636, 0.28125745031981064, 0.49443317116319063, 0.2041669876626483, 0.34289283193885045, 0.22239457513733873, 0.15742189432410958, 0.1949224100680217, 0.34921289565653113, 0.1957004987800064, 0.25309733915024113, 0.34006329360101173, 0.32185736110468566, 0.3013078958202138, 0.3818952557446741, 0.503606149815486, 0.35675659353120404, 0.2649574667641833, 0.31580417853805287, 0.17330526502444976, 0.23163100288402105, 0.22859752394641397, 0.2921011573478247, 0.3445384947166764, 0.3500750701456704, 0.1383512424346618, 0.2619328158128831, 0.30707080171210666, 0.23778444926960918, 0.22337661458824165, 0.19453712820681623, 0.2152039783205686, 0.21546949494335488, 0.22001447397232654, 0.20734284837581418, 0.22033391826807247, 0.20762073325909192, 0.7150287411180949, 0.1770205823440929, 0.22523541860343999, 0.19746990743013426, 0.2255789739397882, 0.22308987583087148, 0.22485475732864535, 0.22560334400778315, 0.7149808898606519, 0.1804543725301444, 0.9226778720393444, 0.15866332094758906, 0.14822060526596492, 0.9359379446953573, 0.17844118366154782, 0.12279200116290645, 0.17787925733352494, 0.9068882545575611, 0.1281290949557211, 0.21069038188392875, 0.21161116074967135, 0.762618883768812, 0.1692572377034619, 0.16911418358382102, 0.7846800469953261, 0.8725091677025711, 0.10493857428047382, 0.20965234047938397, 0.1873173849832407, 0.18791681601390797, 0.18996657826606078, 0.2015463086686924, 0.20353524557395708, 0.1741115988877816, 0.17978541350604682, 0.17867760006615296, 0.10745322453219064, 0.16924362080557187, 0.08988130348054113, 0.08538880150079897, 0.09468329621719118, 0.08544500484127437, 0.10246101388295847, 0.08702273812226191, 0.08742330620748329]}, "mutation_prompt": null}
{"id": "e9f0485b-941b-4b54-aec3-8fbef496d05e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Added adaptive learning rates for cognitive and social coefficients to balance exploration and exploitation.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8569020670639276, 0.8645957681440297, 0.8625242095769396, 0.8640778292690237, 0.8788784825055189, 0.8592813256861845, 0.8658281901713579, 0.8635396827888892, 0.8592388152991143, 0.7477664227406347, 0.7014379145875475, 0.7324804322666889, 0.7242269924823046, 0.7567164656763522, 0.7294015829593599, 0.7413142198454739, 0.7472305624374592, 0.7546735471051077, 0.1321558869847509, 0.13145200765942244, 0.133474927179298, 0.16283585919528154, 0.4034925002714187, 0.14272489451131154, 0.12584905616169784, 0.1277268194458826, 0.1410187080673333, 0.1321142813096443, 0.13157723983321556, 0.13732909234891688, 0.13221828259941026, 0.12889897059156752, 0.14724220219630546, 0.11531363402809314, 0.1258373574845999, 0.10849380397109887, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374697288, 0.665313669877003, 0.6294656180035442, 0.6338373432376565, 0.6267329827246306, 0.6180590371221248, 0.6464334065260293, 0.6067029002197676, 0.6225377211093723, 0.6379151758866657, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.2950940056638326, 0.32950188188318896, 0.32640855110853373, 0.29762889247356183, 0.3844332592120455, 0.40631237790606256, 0.3053997005388551, 0.3035696240032554, 0.45262513144806094, 0.15838790334394293, 0.28354715225280236, 0.29197894097875776, 0.3560266440172911, 0.3716488632432885, 0.2636563141709036, 0.28818666477994304, 0.27097742082365284, 0.1708939949468513, 0.08461441561428162, 0.13352231901162537, 0.13771182537900006, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705342396, 0.12030783009505253, 0.1422531351262829, 0.2668758367488726, 0.2988203225811702, 0.2755825923743791, 0.23542115632095595, 0.21501838526060768, 0.2321943091228339, 0.2538700662374419, 0.21976208281829968, 0.25648669887288633, 0.03482214683410856, 0.04707343284627785, 0.0592732932465333, 0.09614223924821452, 0.0753261361018378, 0.132287515897885, 0.13266723443913253, 0.08538186730010566, 0.0805197053934873, 0.19018297610776047, 0.21489139550621383, 0.23037727099769956, 0.18832358024241158, 0.20861459246331282, 0.23939280461842327, 0.17591205123257636, 0.1867465396203879, 0.04854781884135029, 0.5866409469959487, 0.5956197746137197, 0.5919221546653817, 0.6186794359767602, 0.5840138904057572, 0.6197203668869604, 0.6085898570205136, 0.6338752071498687, 0.580769311307668, 0.09012026015657215, 0.11634923916030604, 0.10838430396844856, 0.13290674847784434, 0.10467247413665626, 0.09664933957756605, 0.1360313561448676, 0.12395919790557286, 0.10334360424709155, 0.17749790903971174, 0.20166980065715412, 0.31731419813311446, 0.17856763066764758, 0.3805601980779507, 0.18342873221551537, 0.34807483466476763, 0.21354735008968828, 0.3177728835988506, 0.4496050037959529, 0.47935949055264104, 0.4396932490898211, 0.458984032093129, 0.4733200783917759, 0.5092076619129268, 0.48860445179143674, 0.5425682259612649, 0.5067152895649834, 0.2592285200952654, 0.24855915333580836, 0.33232564283452126, 0.3015277092921027, 0.24493515494449214, 0.3118221977793182, 0.28271342443218195, 0.2277328221671684, 0.28608218427998133, 0.21247351352587174, 0.21260431037749639, 0.1960077059571972, 0.23368376947030534, 0.20442852219163954, 0.19307096511717958, 0.2023472152193967, 0.20069542559415832, 0.2142958665261856, 0.23394626426350995, 0.20546162474554408, 0.24023722915156276, 0.21592344376808092, 0.6321623866440926, 0.20053808599871292, 0.21157873781303405, 0.21146477283916942, 0.5491768581097044, 0.18340734916139068, 0.885542380729564, 0.1848706754302657, 0.14754255467342337, 0.8164302896176949, 0.7862831410690807, 0.7896693195716351, 0.7932421058575989, 0.1690530041066315, 0.12725236992507238, 0.21029445479003894, 0.21096933958626496, 0.7646300460993856, 0.16762708051695696, 0.16853053840479082, 0.09358005515017032, 0.7838730535519425, 0.20040494884371274, 0.18228921240815987, 0.1892840408501687, 0.20013031783574953, 0.19186918659312047, 0.1840035878338202, 0.19209696619427008, 0.17615469206980383, 0.2088237833611002, 0.193922338772599, 0.07895736149871613, 0.08717086343814484, 0.09054525420665427, 0.10352103694913928, 0.08821645148346546, 0.08464520405927867, 0.09862826738193164, 0.07832612044915588, 0.08367535624046063]}, "mutation_prompt": null}
{"id": "00761cad-ed03-4805-bc37-c16176f14434", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.var(best_positions) + 1e-5))  # Changed line\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced adaptive scaling for the mutation strategy to enhance exploration capabilities.", "configspace": "", "generation": 56, "fitness": 0.20102381584486262, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.42099257043538596, 0.4656513744159203, 0.41652779396990913, 0.6060426885235398, 0.5537489963366234, 0.5789480812821939, 0.5049745086338013, 0.4833969184808712, 0.4922972791905622, 0.013462065577842464, 0.048654050740814636, 9.999999999998899e-05, 9.999999999998899e-05, 0.0694765569185467, 0.013967151303904024, 9.999999999998899e-05, 0.001327764449495561, 0.0046911766489625695, 0.14612601929833147, 0.11383553690403059, 0.11192298343977092, 0.09641508168472268, 0.08139798878069593, 0.10615673026702566, 0.09081480943648035, 0.12934005109751834, 0.09833340591869622, 0.08452195085153269, 0.09771569912585487, 0.10334922529813395, 0.09832468335819033, 0.08815238731457897, 0.07547637640645988, 0.0867312172373984, 0.12116647863566099, 0.09337641466947266, 0.9920307723957901, 0.9812394479255155, 0.9892004502335372, 0.9886092468066148, 0.9940920104430236, 0.99212774409728, 0.9859868495083408, 0.9894074709950265, 0.981781162849218, 0.22841259080633547, 0.27250140550735746, 0.12968709035150827, 0.226814560563109, 0.15904872844225026, 0.14420530652762842, 0.21198184735200032, 0.23035201322930565, 0.23347421633419252, 0.2596087056675508, 0.49330581093439607, 0.3012920870935699, 0.252698753087503, 0.18036482562692524, 0.2014396475217356, 0.32386448014462643, 0.215950301993433, 0.21994978004819843, 0.09495913749992047, 0.13391621050066882, 0.12068370159120045, 0.1150734423331583, 0.11773799511133443, 0.12239150891820771, 0.14898383284488792, 0.10533782455745078, 0.1548854462529844, 0.05526851624346396, 0.11520226252446542, 0.1251716990816163, 0.13531916891038087, 0.11850090259541068, 0.14482164846295598, 0.13864473582223358, 0.11942145561900397, 0.15889200465460274, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017363948721427214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0360311005267977, 0.06419812012356374, 0.0502200438614433, 0.012048593455439405, 0.021321499093076124, 0.06528877876226724, 0.03897246135416044, 0.012122540804922366, 0.07095637294992774, 0.008404672339986763, 0.021325805693845012, 0.020004123309948718, 0.010607464463268323, 0.004206997604808915, 0.005895725044915756, 0.0008453341147429683, 0.031356246670106724, 0.026148661178434618, 0.12270160379463291, 0.10677096967192756, 0.06862644658086026, 9.999999999998899e-05, 0.062493955670050894, 0.12891898038850647, 0.06900306148370838, 0.0883878798158737, 0.08659262216820263, 0.40861901237302367, 0.38338380592406907, 0.37586291663782756, 0.43613820037387463, 0.39611456334094564, 0.39056982837866694, 0.4071151564831794, 0.45481907300878366, 0.36032374562280334, 0.08195099943197381, 0.1023746307191683, 0.06422753147545557, 0.09371660811357774, 0.07513010097017636, 0.12091836236112574, 0.08930148566879548, 0.09144851207160132, 0.07247304760890727, 0.1683306965499991, 0.148814878444116, 0.1472636868337297, 0.17066253277578147, 0.18749053785620717, 0.15477110570307107, 0.1425815488238994, 0.16208413176744818, 0.1899936558587768, 0.23406250345837354, 0.2671733464366347, 0.24445476500696595, 0.2670917984245993, 0.20923064696517202, 0.23302424106042796, 0.28638474937019975, 0.3297862235147536, 0.395546424816423, 0.1703628160242211, 0.2183381226659714, 0.2563046633042946, 0.14787820264798412, 0.21784419496816487, 0.17776859844282067, 0.17111765242212273, 0.19490234820703223, 0.22589093624325796, 0.1857451076462303, 0.18729510783471204, 0.18862192498202957, 0.1961497544012829, 0.18282165943024797, 0.17963513172978163, 0.17815705292054318, 0.17496752396812376, 0.16849781422160526, 0.19904857158682365, 0.1931074506042837, 0.19735690285695595, 0.19600043405611167, 0.17526480145026546, 0.23308317698666636, 0.21130441112282206, 0.17813442016277237, 0.17637338682833548, 0.11311441480888518, 0.6917031912526665, 0.1612076151803773, 0.17242450997965775, 0.5699104953286325, 0.1658442059799521, 0.15746620846500103, 0.17408651675115472, 0.1841005515050942, 0.12419083409563736, 0.20363658993840694, 0.16656610418440232, 0.211565332995852, 0.27301494459284914, 0.15393303695881877, 0.20530812293561362, 0.4073917157168203, 0.20735734622371604, 0.18457305465761054, 0.20347875434471396, 0.1939704616660165, 0.1871485566525951, 0.2034390080066314, 0.19899596916749174, 0.18026022249689866, 0.18154597817426055, 0.1996075936292384, 0.06556963404381899, 0.07123368639900707, 0.07143518131109994, 0.09340217317814825, 0.06950944546025073, 0.07282658631391892, 0.08699872672789422, 0.07521513418393333, 0.07712658018178498]}, "mutation_prompt": null}
{"id": "f993e67c-062f-4353-a554-f4d0f2e3a5ef", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance, global_best_fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - global_best_fitness_variance / (np.max(global_best_fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            global_best_fitness_variance = np.var(personal_best_fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance, global_best_fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced a dynamic perturbation scale in DE mutation strategy based on global best fitness variance to enhance convergence speed.", "configspace": "", "generation": 57, "fitness": 0.3694699690801535, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8566612429747803, 0.8580019711549841, 0.8613437954241896, 0.8599512321103899, 0.877233218245077, 0.8578241849529911, 0.8605868311342187, 0.8570485960867891, 0.855865584035347, 0.7488189432547038, 0.7028803290270891, 0.7330688446777589, 0.7255494649918628, 0.7523654062461581, 0.7276973473987902, 0.7428675647358259, 0.7525003075700394, 0.7560088642999588, 0.13215591523502457, 0.13145200370238652, 0.1334749240868327, 0.16283636093090603, 0.4012707921152986, 0.14272488074521839, 0.12584906948978825, 0.1277268196632082, 0.14101870958450202, 0.13211427627092076, 0.13157723949761424, 0.13732908861600934, 0.1322182860904504, 0.1288989696045152, 0.14724220287340795, 0.11531363520973614, 0.12583735803064466, 0.10849380344495552, 0.9816906977222939, 0.97318325853868, 0.9849688712085147, 0.9769609201292604, 0.9814541810080584, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374766722, 0.6380651126197381, 0.6315685000423898, 0.6225037654606878, 0.6026539384602484, 0.6218499966954624, 0.6171751959236877, 0.6053107507319935, 0.5949645259768879, 0.6119418687205203, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.756482993040467, 0.28638938036759887, 0.3307029442990629, 0.30883931547514765, 0.29377302943896766, 0.3753029587802049, 0.37882652825960594, 0.2843542562529494, 0.30214777965605066, 0.4526710353775908, 0.15821840121657404, 0.2766903838208621, 0.2830653040292229, 0.33980122421126924, 0.3463063851776619, 0.2560157947478865, 0.3227095245105931, 0.28850209577392827, 0.17044191076482262, 0.08461515775261486, 0.13352222519210322, 0.13770977040408527, 0.1315864643970277, 0.12088094225308377, 0.12250096999571469, 0.12083282335862955, 0.12030806665798321, 0.14225937319638737, 0.2653203671531953, 0.29725786583223346, 0.2777023449593018, 0.23534115416521095, 0.2140052355046841, 0.23239079661619677, 0.23404193637914017, 0.22272845766475025, 0.2567363887710581, 0.03482214673898976, 0.04707343182510848, 0.05927329527301972, 0.09614248926526847, 0.07559051450596321, 0.1326086117240266, 0.13266680508751216, 0.08538113395798241, 0.08054136886819685, 0.19003359555071053, 0.21530536105319487, 0.2305782994521084, 0.1958738561514376, 0.20956222065770602, 0.23595413660510334, 0.17787983005240948, 0.18669043173705135, 0.048547818814271504, 0.5631548462047391, 0.5963153889189513, 0.5834056204733706, 0.5826780192854792, 0.5620500649911695, 0.5818190831202497, 0.5805149810233241, 0.587434962244364, 0.5946035848792586, 0.09012029132592814, 0.11634923708611167, 0.10838430404651866, 0.13290671926044084, 0.10467248256042583, 0.09664940455050286, 0.13603135642963593, 0.12395920726228848, 0.10334367258320676, 0.1774912316447289, 0.20175982157790617, 0.3177573124336931, 0.178565297579944, 0.3931691717291599, 0.18342635906788507, 0.3536047254016055, 0.21357204399903207, 0.32506398168866824, 0.4650159525317469, 0.47717602000235737, 0.44214585726104483, 0.6127858648717215, 0.5000435208709586, 0.4843406735691589, 0.46135826792612955, 0.5553010203801683, 0.5054935255424846, 0.2565107604029505, 0.24914336349943778, 0.33594996049918335, 0.333567058965087, 0.2565028597221699, 0.3289969371270206, 0.2927553502895026, 0.22755621495975642, 0.28629010095148555, 0.2272883375816136, 0.20851381121861268, 0.1960889777678516, 0.23368651216378844, 0.2045311395208106, 0.19857492547867894, 0.20114369353812267, 0.19673262877023445, 0.21863099055239754, 0.2339452668848776, 0.20546160905325517, 0.2402372575528141, 0.2159234396619174, 0.6284802375928307, 0.20054009159529385, 0.21157887882312532, 0.21146650663424416, 0.5478968368183088, 0.18340728360402003, 0.8869308785484376, 0.18487069097717979, 0.1475425597624459, 0.8161666466126515, 0.7866588974595738, 0.7902977501317597, 0.7921903956664264, 0.16905300425068526, 0.12725235895173193, 0.21029444030509625, 0.21096931589133028, 0.7660614761691055, 0.1676270310046566, 0.1685304986748395, 0.09358005192162855, 0.7803465436996659, 0.20040492745480099, 0.16944536728910975, 0.1892327866928959, 0.2001067414124601, 0.19188378378396054, 0.18404911648222322, 0.19209693557256946, 0.1742805654239037, 0.20884050050643665, 0.19393799704869708, 0.0789573214088054, 0.08717085369319699, 0.09054520416226675, 0.10352106653088522, 0.08821652164075189, 0.08464524154517816, 0.09862803485008464, 0.07832613159193047, 0.08367539339747232]}, "mutation_prompt": null}
{"id": "5b034b2e-6332-46a1-b178-3c261fb22bc1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n        previous_best_fitness = np.inf\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n                    \n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Reset velocities if no improvement\n            if np.min(personal_best_fitness) >= previous_best_fitness:\n                velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            previous_best_fitness = np.min(personal_best_fitness)\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced velocity reset when fitness stagnation occurs to enhance convergence speed.", "configspace": "", "generation": 58, "fitness": 0.28118091553400965, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.5627673047960491, 0.5432691101890853, 0.5528066997822138, 0.5465549305382728, 0.5522455352940365, 0.5122519133487189, 0.5533562798106542, 0.5418298141583873, 0.5313797868654613, 0.16266396766848157, 0.18312723712222745, 0.22619578059843404, 0.1492093147304242, 0.16325465131535732, 0.17047897396908684, 0.1757345415404281, 0.15935809188591288, 0.19452237384118598, 0.11421934106842202, 0.11069362537556682, 0.12223122317888868, 0.13651130801087097, 0.11661366205907975, 0.1103072977032673, 0.10651221840977798, 0.11688024816974407, 0.10800291529170047, 0.10703117698941589, 0.10035019194738015, 0.09763891041763872, 0.11168084016522739, 0.08840078648393024, 0.10286860702216405, 0.10523729901937806, 0.09975027562424643, 0.10079794736111158, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9747021804760596, 0.3145745946887035, 0.34349117516981675, 0.30630614304377735, 0.3322174990467155, 0.29639686724418424, 0.3270195759167861, 0.33055966897080946, 0.3081427448996461, 0.3372997731978158, 0.6439659692485182, 0.5693756306958586, 0.529948308470019, 0.5975948360520578, 0.4592501165712194, 0.5821879717865038, 0.5235930776483029, 0.6238611926524, 0.6271109222969014, 0.1731736841173257, 0.20246240740870536, 0.1547051473363179, 0.19494891073064669, 0.1933035977632117, 0.19921081749694824, 0.21707189505864322, 0.21515105159339243, 0.19574027369480318, 0.12796131475295092, 0.17180477588134313, 0.19227784843122897, 0.20227229693589688, 0.2040339287936076, 0.24711262367700493, 0.2118942089495811, 0.2623774195822848, 0.18488465156627087, 0.126736927419689, 0.11983497309663094, 0.10138394450999022, 0.12970968163386842, 0.14259766548576758, 0.08222334133078346, 0.11572048841396076, 0.14395579024413796, 0.13003491229223707, 0.21881999200988744, 0.3003254857403552, 0.29552411697546654, 0.24401904771519556, 0.23005420245449804, 0.22506237370561222, 0.25774090324621124, 0.2741732486590388, 0.310415065192543, 0.026345347850695755, 0.035494443937281406, 0.056907973636110554, 0.0350407907690089, 0.06461651235463506, 0.059452632119916915, 0.07494800735491003, 0.043648592231797734, 0.03543267228347158, 0.15205384237500275, 0.15307206761078873, 0.15576033087003038, 0.16744497735682873, 0.172868165028214, 0.1791706294468759, 0.15942023492349033, 0.16900439798758726, 0.11823325967176856, 0.49822287048562597, 0.5033466575278226, 0.5013289794844354, 0.48601202809758104, 0.4879383344211228, 0.48821156719202397, 0.4610348144351065, 0.4699362867915171, 0.4779303125456821, 0.10097985386695163, 0.10724996338575588, 0.09630309442538765, 0.10612686458909282, 0.1159031944510156, 0.11883957075800577, 0.09006111671222683, 0.12852515840960588, 0.10658367893524279, 0.14729941436969762, 0.21293065684429113, 0.2589569764076448, 0.24326696893524458, 0.30067139933817844, 0.27727153702158824, 0.3215244912624988, 0.23705806712085342, 0.20641697403468606, 0.2942040723643169, 0.30510322082965025, 0.2993462745909946, 0.3058666791009741, 0.2895256919151341, 0.3035167499486998, 0.34441912598219526, 0.3141617966816097, 0.32608825309258727, 0.19375155037027492, 0.25664374770301923, 0.2611205401379775, 0.20496417011108592, 0.268096753121815, 0.25744054205552, 0.24926711507394506, 0.2462481403266895, 0.2627585883025043, 0.19815389410091055, 0.21541081377303906, 0.20139973989390692, 0.2708937544478114, 0.18722359448612902, 0.19946441399994197, 0.20696057664638845, 0.2152858943800191, 0.210584822010894, 0.22629220734291167, 0.20543131828348637, 0.22156993632629152, 0.2456176983722288, 0.20843257358960798, 0.30602038733190995, 0.22688159336950264, 0.20031662220649382, 0.1998720089352194, 0.18484151795106896, 0.7968173748803506, 0.1702699843122748, 0.16646673418984015, 0.7957231624735368, 0.17083957253104531, 0.7928201145858994, 0.17851008499358012, 0.16891484676079527, 0.6140676909088045, 0.21000896349200437, 0.21005563310855668, 0.6977618485711419, 0.16865267311589816, 0.580386134649812, 0.6914100124051721, 0.6890282462437438, 0.20966002342715329, 0.20186693799752942, 0.18263575603615456, 0.18006069101635425, 0.18699896115852066, 0.19272051226408937, 0.19678391076656454, 0.18632039596929195, 0.20487707434926183, 0.21025606840062805, 0.08831248288461269, 0.08150354132339122, 0.0887516196795397, 0.10322255533949687, 0.0910132920131127, 0.09622295196261843, 0.12196466962666186, 0.09005267572660691, 0.07815580333865746]}, "mutation_prompt": null}
{"id": "7f38dd7c-d7a5-49e2-b1cc-e5828ec06b91", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Added adaptive learning rates for cognitive and social coefficients to balance exploration and exploitation.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.8569020670639276, 0.8645957681440297, 0.8625242095769396, 0.8640778292690237, 0.8788784825055189, 0.8592813256861845, 0.8658281901713579, 0.8635396827888892, 0.8592388152991143, 0.7477664227406347, 0.7014379145875475, 0.7324804322666889, 0.7242269924823046, 0.7567164656763522, 0.7294015829593599, 0.7413142198454739, 0.7472305624374592, 0.7546735471051077, 0.1321558869847509, 0.13145200765942244, 0.133474927179298, 0.16283585919528154, 0.4034925002714187, 0.14272489451131154, 0.12584905616169784, 0.1277268194458826, 0.1410187080673333, 0.1321142813096443, 0.13157723983321556, 0.13732909234891688, 0.13221828259941026, 0.12889897059156752, 0.14724220219630546, 0.11531363402809314, 0.1258373574845999, 0.10849380397109887, 0.9816906977219764, 0.9731832585146122, 0.984968871208515, 0.9769609201297447, 0.9814541810080569, 0.9848196726138249, 0.9859922713312481, 0.987821349776989, 0.9725414374697288, 0.665313669877003, 0.6294656180035442, 0.6338373432376565, 0.6267329827246306, 0.6180590371221248, 0.6464334065260293, 0.6067029002197676, 0.6225377211093723, 0.6379151758866657, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.2950940056638326, 0.32950188188318896, 0.32640855110853373, 0.29762889247356183, 0.3844332592120455, 0.40631237790606256, 0.3053997005388551, 0.3035696240032554, 0.45262513144806094, 0.15838790334394293, 0.28354715225280236, 0.29197894097875776, 0.3560266440172911, 0.3716488632432885, 0.2636563141709036, 0.28818666477994304, 0.27097742082365284, 0.1708939949468513, 0.08461441561428162, 0.13352231901162537, 0.13771182537900006, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705342396, 0.12030783009505253, 0.1422531351262829, 0.2668758367488726, 0.2988203225811702, 0.2755825923743791, 0.23542115632095595, 0.21501838526060768, 0.2321943091228339, 0.2538700662374419, 0.21976208281829968, 0.25648669887288633, 0.03482214683410856, 0.04707343284627785, 0.0592732932465333, 0.09614223924821452, 0.0753261361018378, 0.132287515897885, 0.13266723443913253, 0.08538186730010566, 0.0805197053934873, 0.19018297610776047, 0.21489139550621383, 0.23037727099769956, 0.18832358024241158, 0.20861459246331282, 0.23939280461842327, 0.17591205123257636, 0.1867465396203879, 0.04854781884135029, 0.5866409469959487, 0.5956197746137197, 0.5919221546653817, 0.6186794359767602, 0.5840138904057572, 0.6197203668869604, 0.6085898570205136, 0.6338752071498687, 0.580769311307668, 0.09012026015657215, 0.11634923916030604, 0.10838430396844856, 0.13290674847784434, 0.10467247413665626, 0.09664933957756605, 0.1360313561448676, 0.12395919790557286, 0.10334360424709155, 0.17749790903971174, 0.20166980065715412, 0.31731419813311446, 0.17856763066764758, 0.3805601980779507, 0.18342873221551537, 0.34807483466476763, 0.21354735008968828, 0.3177728835988506, 0.4496050037959529, 0.47935949055264104, 0.4396932490898211, 0.458984032093129, 0.4733200783917759, 0.5092076619129268, 0.48860445179143674, 0.5425682259612649, 0.5067152895649834, 0.2592285200952654, 0.24855915333580836, 0.33232564283452126, 0.3015277092921027, 0.24493515494449214, 0.3118221977793182, 0.28271342443218195, 0.2277328221671684, 0.28608218427998133, 0.21247351352587174, 0.21260431037749639, 0.1960077059571972, 0.23368376947030534, 0.20442852219163954, 0.19307096511717958, 0.2023472152193967, 0.20069542559415832, 0.2142958665261856, 0.23394626426350995, 0.20546162474554408, 0.24023722915156276, 0.21592344376808092, 0.6321623866440926, 0.20053808599871292, 0.21157873781303405, 0.21146477283916942, 0.5491768581097044, 0.18340734916139068, 0.885542380729564, 0.1848706754302657, 0.14754255467342337, 0.8164302896176949, 0.7862831410690807, 0.7896693195716351, 0.7932421058575989, 0.1690530041066315, 0.12725236992507238, 0.21029445479003894, 0.21096933958626496, 0.7646300460993856, 0.16762708051695696, 0.16853053840479082, 0.09358005515017032, 0.7838730535519425, 0.20040494884371274, 0.18228921240815987, 0.1892840408501687, 0.20013031783574953, 0.19186918659312047, 0.1840035878338202, 0.19209696619427008, 0.17615469206980383, 0.2088237833611002, 0.193922338772599, 0.07895736149871613, 0.08717086343814484, 0.09054525420665427, 0.10352103694913928, 0.08821645148346546, 0.08464520405927867, 0.09862826738193164, 0.07832612044915588, 0.08367535624046063]}, "mutation_prompt": null}
{"id": "09a33c52-e51f-47d6-a64e-15967db1c376", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            # Change: Adjusted mutation probability based on diversity\n            mutation_probability = 0.1 + 0.2 * (np.mean(diversity) / (np.max(diversity) + 1e-5))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced adaptive mutation probability based on diversity to enhance exploration during stagnation.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'diversity' is not defined\").", "error": "NameError(\"name 'diversity' is not defined\")", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {}, "mutation_prompt": null}
{"id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved the mutation strategy by enhancing the diversity factor scaling for more robust exploration.", "configspace": "", "generation": 61, "fitness": 0.37100721915051194, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "21bb723a-3f92-4aed-9adc-a492fb93d0ac", "metadata": {"aucs": [0.855254594285909, 0.8648239776269577, 0.8625802381627854, 0.8647120064635749, 0.8765487962240156, 0.8611141660386882, 0.8619567329690346, 0.860691336899759, 0.8622054780258547, 0.7495821662339555, 0.7010567978062674, 0.733639663345403, 0.7239419287151415, 0.7538119503620407, 0.7304220081476829, 0.7425476322123244, 0.7524348503320609, 0.7570462526724202, 0.13215591538596094, 0.13145200816977742, 0.13347492700922137, 0.162835861500377, 0.4011734750573892, 0.1427248939007153, 0.12584906978214383, 0.12772681916151685, 0.1410187080978894, 0.13211428097715183, 0.13157723965725876, 0.13732909147781158, 0.13221828262555246, 0.12889897048036947, 0.14724220263595522, 0.11531363419270235, 0.1258373574186984, 0.10849380354787386, 0.9816906977195767, 0.973183258523721, 0.9849688712085233, 0.9769609201287355, 0.9814541810080797, 0.9848196726138216, 0.9859922713312944, 0.9878213497769915, 0.9725414374720274, 0.6584325969709665, 0.6342727453693368, 0.6371722871587782, 0.6246743599453408, 0.6203806630495637, 0.6459995460876253, 0.6111030031744118, 0.625745631446754, 0.6320376174303131, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.30511675127710747, 0.33044249246924096, 0.32660898811979155, 0.29763322179914453, 0.3886652501002824, 0.4205218025738955, 0.30585741049789195, 0.3056437709993842, 0.45179534429856094, 0.15838790333720987, 0.28360196879434163, 0.29195145716058346, 0.3502349856458852, 0.3720980977960159, 0.26362427781578657, 0.2906379533429285, 0.2709270209935125, 0.1708945936652695, 0.08461441561439442, 0.13352231901162537, 0.13771182537900006, 0.131586491509187, 0.12088101927947248, 0.1225008260217113, 0.12083345705352, 0.12030783009504953, 0.1422531351261621, 0.2668758367488645, 0.2988203225809577, 0.27558259237415084, 0.23542115632111416, 0.2150183852606664, 0.23219430912277828, 0.2538700662370793, 0.21976208281830345, 0.256486698872884, 0.03482214698978514, 0.04707343299177558, 0.0592732932465333, 0.0961422392485316, 0.07538963237059304, 0.13228751589271814, 0.13266723443924278, 0.08538186730195862, 0.0805197057610969, 0.1901827653427457, 0.21489131360927727, 0.23037720124694205, 0.18832361813164966, 0.20861447704044278, 0.23938227312035487, 0.1759120976612505, 0.18674654071266006, 0.04854781884386716, 0.5984682753406079, 0.6075846430285852, 0.591707742539928, 0.6317935449551627, 0.5752437221454221, 0.6272392452868069, 0.6210630112071853, 0.6035581242180268, 0.5824863628187765, 0.0901202628976231, 0.11634923871902536, 0.10838430347410744, 0.13290674019686288, 0.10467247569521476, 0.09664934498544986, 0.13603135555247625, 0.12395919341190043, 0.10334362629189875, 0.17749563503989452, 0.20166733558513938, 0.31736553812974655, 0.17856758007717888, 0.3824628945777162, 0.18342863968203071, 0.34419878152615113, 0.21354862098495775, 0.33480429831451797, 0.41598989842980505, 0.4329423077542953, 0.4425708670668581, 0.47096291108510535, 0.4936725214197242, 0.510618975037489, 0.5292144640295439, 0.556679180696422, 0.5235840835806813, 0.25851692042679086, 0.24822206380022516, 0.3346939706455051, 0.30167416702491934, 0.2449288455603038, 0.3120015220868362, 0.28342099781289654, 0.22781329071488798, 0.2861475137175512, 0.2124725010240326, 0.21260780503703214, 0.1960096231885553, 0.23368420425689473, 0.20443517858667815, 0.19307020616786796, 0.20234417334455856, 0.19675158206224852, 0.2142958524816302, 0.2339462552618513, 0.20546162356105535, 0.24023723952795395, 0.21592344337197977, 0.6311929296903769, 0.20053808631084147, 0.21157873767824553, 0.21146476619070187, 0.5470207419724256, 0.18340734627925792, 0.8855755525560333, 0.18487067314261496, 0.1475425600875384, 0.8164194869376754, 0.7864065962981006, 0.7896547113419774, 0.7934007003503036, 0.1690530115238824, 0.12725238501159997, 0.2102944460780526, 0.21096933876640345, 0.7655329456345945, 0.16762707664349397, 0.16853053944716245, 0.09358005607374198, 0.7835646608993977, 0.20040494736104786, 0.18228780035365433, 0.18928382906183328, 0.20013051240981417, 0.19186955786549964, 0.18400383909385998, 0.19209696684761346, 0.17615619686961925, 0.2088251199912632, 0.19392130255101747, 0.07895735886052246, 0.08717086037800303, 0.09054522334748816, 0.10352103683893188, 0.08821646432279573, 0.08464519915456181, 0.09862824707386886, 0.07832612292527175, 0.0836753626029102]}, "mutation_prompt": null}
{"id": "38b734f1-f64b-458c-8daa-919fa2b10be0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved the mutation strategy by enhancing the diversity factor scaling for more robust exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.855254594285909, 0.8648239776269577, 0.8625802381627854, 0.8647120064635749, 0.8765487962240156, 0.8611141660386882, 0.8619567329690346, 0.860691336899759, 0.8622054780258547, 0.7495821662339555, 0.7010567978062674, 0.733639663345403, 0.7239419287151415, 0.7538119503620407, 0.7304220081476829, 0.7425476322123244, 0.7524348503320609, 0.7570462526724202, 0.13215591538596094, 0.13145200816977742, 0.13347492700922137, 0.162835861500377, 0.4011734750573892, 0.1427248939007153, 0.12584906978214383, 0.12772681916151685, 0.1410187080978894, 0.13211428097715183, 0.13157723965725876, 0.13732909147781158, 0.13221828262555246, 0.12889897048036947, 0.14724220263595522, 0.11531363419270235, 0.1258373574186984, 0.10849380354787386, 0.9816906977195767, 0.973183258523721, 0.9849688712085233, 0.9769609201287355, 0.9814541810080797, 0.9848196726138216, 0.9859922713312944, 0.9878213497769915, 0.9725414374720274, 0.6584325969709665, 0.6342727453693368, 0.6371722871587782, 0.6246743599453408, 0.6203806630495637, 0.6459995460876253, 0.6111030031744118, 0.625745631446754, 0.6320376174303131, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.30511675127710747, 0.33044249246924096, 0.32660898811979155, 0.29763322179914453, 0.3886652501002824, 0.4205218025738955, 0.30585741049789195, 0.3056437709993842, 0.45179534429856094, 0.15838790333720987, 0.28360196879434163, 0.29195145716058346, 0.3502349856458852, 0.3720980977960159, 0.26362427781578657, 0.2906379533429285, 0.2709270209935125, 0.1708945936652695, 0.08461441561439442, 0.13352231901162537, 0.13771182537900006, 0.131586491509187, 0.12088101927947248, 0.1225008260217113, 0.12083345705352, 0.12030783009504953, 0.1422531351261621, 0.2668758367488645, 0.2988203225809577, 0.27558259237415084, 0.23542115632111416, 0.2150183852606664, 0.23219430912277828, 0.2538700662370793, 0.21976208281830345, 0.256486698872884, 0.03482214698978514, 0.04707343299177558, 0.0592732932465333, 0.0961422392485316, 0.07538963237059304, 0.13228751589271814, 0.13266723443924278, 0.08538186730195862, 0.0805197057610969, 0.1901827653427457, 0.21489131360927727, 0.23037720124694205, 0.18832361813164966, 0.20861447704044278, 0.23938227312035487, 0.1759120976612505, 0.18674654071266006, 0.04854781884386716, 0.5984682753406079, 0.6075846430285852, 0.591707742539928, 0.6317935449551627, 0.5752437221454221, 0.6272392452868069, 0.6210630112071853, 0.6035581242180268, 0.5824863628187765, 0.0901202628976231, 0.11634923871902536, 0.10838430347410744, 0.13290674019686288, 0.10467247569521476, 0.09664934498544986, 0.13603135555247625, 0.12395919341190043, 0.10334362629189875, 0.17749563503989452, 0.20166733558513938, 0.31736553812974655, 0.17856758007717888, 0.3824628945777162, 0.18342863968203071, 0.34419878152615113, 0.21354862098495775, 0.33480429831451797, 0.41598989842980505, 0.4329423077542953, 0.4425708670668581, 0.47096291108510535, 0.4936725214197242, 0.510618975037489, 0.5292144640295439, 0.556679180696422, 0.5235840835806813, 0.25851692042679086, 0.24822206380022516, 0.3346939706455051, 0.30167416702491934, 0.2449288455603038, 0.3120015220868362, 0.28342099781289654, 0.22781329071488798, 0.2861475137175512, 0.2124725010240326, 0.21260780503703214, 0.1960096231885553, 0.23368420425689473, 0.20443517858667815, 0.19307020616786796, 0.20234417334455856, 0.19675158206224852, 0.2142958524816302, 0.2339462552618513, 0.20546162356105535, 0.24023723952795395, 0.21592344337197977, 0.6311929296903769, 0.20053808631084147, 0.21157873767824553, 0.21146476619070187, 0.5470207419724256, 0.18340734627925792, 0.8855755525560333, 0.18487067314261496, 0.1475425600875384, 0.8164194869376754, 0.7864065962981006, 0.7896547113419774, 0.7934007003503036, 0.1690530115238824, 0.12725238501159997, 0.2102944460780526, 0.21096933876640345, 0.7655329456345945, 0.16762707664349397, 0.16853053944716245, 0.09358005607374198, 0.7835646608993977, 0.20040494736104786, 0.18228780035365433, 0.18928382906183328, 0.20013051240981417, 0.19186955786549964, 0.18400383909385998, 0.19209696684761346, 0.17615619686961925, 0.2088251199912632, 0.19392130255101747, 0.07895735886052246, 0.08717086037800303, 0.09054522334748816, 0.10352103683893188, 0.08821646432279573, 0.08464519915456181, 0.09862824707386886, 0.07832612292527175, 0.0836753626029102]}, "mutation_prompt": null}
{"id": "56c02ef9-47e0-4dd4-a7f4-90a9182d9987", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.7 + 0.1 * (diversity / (np.max(diversity) + 1e-5))  # Adjusted\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Fine-tuned the adaptive inertia weight to decrease linearly with more iterations for stable convergence.", "configspace": "", "generation": 63, "fitness": 0.31086819101984803, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.744127194858319, 0.7372516984205253, 0.7424178714702396, 0.7750126811330744, 0.7711591166954924, 0.7667628788145514, 0.7492374453391579, 0.7771656772076247, 0.768906363136206, 0.6105219439140677, 0.5964425464370706, 0.6231404073758847, 0.6163125492798692, 0.5941303696284177, 0.6115765626146533, 0.6052334008171503, 0.5902508606831454, 0.5942921973200486, 0.14801662914905223, 0.13064795545294927, 0.12375006256028487, 0.10426040660310187, 0.09681636228252866, 0.12946476089267667, 0.13894327738336454, 0.13321359890925288, 0.15935063618410183, 0.12403607985525977, 0.12171532978353938, 0.11000903928186345, 0.09983274587682622, 0.11710203208105507, 0.11479747054555534, 0.1122514276066282, 0.10346377505333659, 0.11489625328064335, 0.9840961968133173, 0.9774076434508729, 0.9851360478879289, 0.9770577705461425, 0.9814833933382168, 0.9862459280509522, 0.9863423804245233, 0.9879962293200459, 0.975031263864385, 0.4836250992462129, 0.4644812703553125, 0.4549682420223067, 0.49283865793622117, 0.45573330170458437, 0.4827654924781182, 0.49816014368710115, 0.4658561615008405, 0.4584056174544682, 0.6241138637559994, 0.627391771179771, 0.5981506906525937, 0.6441700444656664, 0.6443619091968784, 0.6305292780963211, 0.6861279280557305, 0.6766942636177696, 0.654221363894616, 0.11162819252994383, 0.25543832845474645, 0.1953402768339061, 0.23008749537670847, 0.22363869830747396, 0.2450790143181344, 0.20883612580223976, 0.2003360470983252, 0.2332062350571099, 0.12661077705844492, 0.22657797928053947, 0.10321306689443832, 0.23943391858619445, 0.19411942860459475, 0.247292507919888, 0.26980097195912345, 0.2665153318023029, 0.24626023782247375, 0.12127356029533554, 0.10703196387857172, 0.12903963445958744, 0.08762652849062191, 0.09202531896454202, 0.10129676058582515, 0.13519925738022465, 0.1176382408727108, 0.10741466202806027, 0.24204051451735986, 0.2315299729936564, 0.2475466894409567, 0.2208512294931968, 0.18920389665928228, 0.23023339134581167, 0.24959132885544255, 0.2198830399989038, 0.23645336280735674, 0.03302842115309035, 0.06409725157993762, 0.04844672563375374, 0.06064595716710719, 0.05937096696267541, 0.036804864436001505, 0.04203313419915489, 0.058066817688459005, 0.04800022187281916, 0.19372494137326757, 0.1733395556614451, 0.2044353614798492, 0.17479391312656922, 0.17201982405574834, 0.1630131164170081, 0.16700893512771453, 0.14953969627539376, 0.04633436072254993, 0.5385552287803068, 0.5103856417355861, 0.5373787151219811, 0.5306201579814882, 0.5318341327425433, 0.5360125848347419, 0.5415830021657924, 0.5467003984687617, 0.5162664891132762, 0.08962766259109922, 0.09776565945330895, 0.11028773083275278, 0.11012982428285634, 0.10983160486532229, 0.12716137004592964, 0.10999705621535327, 0.10855953863084866, 0.12159091058274207, 0.14124675435344636, 0.1555988222636051, 0.20374745514229697, 0.15827228787311287, 0.31446804470803724, 0.23307109343507026, 0.28364132183619806, 0.1565446293015581, 0.14806800185351643, 0.3823543359620021, 0.388161054439645, 0.42188220154930567, 0.3977263653759654, 0.358617345388766, 0.4508170763695374, 0.4509747419618292, 0.41259533692899775, 0.4110616382404476, 0.2687623556730939, 0.27526048617520615, 0.2099056721629493, 0.29808175886968424, 0.2517001356868165, 0.27883194391955435, 0.3900513772671872, 0.3114257455675724, 0.2565438302211497, 0.18279686240397475, 0.20397659178488015, 0.1927600802983448, 0.1985671106326128, 0.19606022303387827, 0.19258958143614735, 0.18034322567303718, 0.2009991164815197, 0.20009295106966607, 0.21297647921556917, 0.1986441407551398, 0.2079355289539342, 0.206242324799646, 0.19203291080404838, 0.19677771938254907, 0.2037431731328645, 0.1806884834744078, 0.19563334363930518, 0.16497316766579007, 0.8150481904860918, 0.16974914858447687, 0.16172624209883502, 0.7467068883390202, 0.5757294882687167, 0.12215878370265598, 0.17504051746702098, 0.1804107408886061, 0.6159355445978414, 0.20556928808328634, 0.20589719696543085, 0.2008371685059125, 0.16757791353523566, 0.16645718321373537, 0.2006182534944717, 0.20436939641690743, 0.20048674061744176, 0.18651357987263661, 0.18276099504664967, 0.18096344167965306, 0.1850634667338643, 0.1819368992121515, 0.1885513940294209, 0.1853036784372316, 0.18753789077872818, 0.20955100769533486, 0.08688806198698673, 0.07877243270171619, 0.07761190238837878, 0.07609367730360717, 0.08000644790515232, 0.07486166019367502, 0.09438740813600033, 0.08992721865750464, 0.07104726402324069]}, "mutation_prompt": null}
{"id": "d6ddf615-695c-4de6-a580-1d7650ccc507", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved the mutation strategy by enhancing the diversity factor scaling for more robust exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.855254594285909, 0.8648239776269577, 0.8625802381627854, 0.8647120064635749, 0.8765487962240156, 0.8611141660386882, 0.8619567329690346, 0.860691336899759, 0.8622054780258547, 0.7495821662339555, 0.7010567978062674, 0.733639663345403, 0.7239419287151415, 0.7538119503620407, 0.7304220081476829, 0.7425476322123244, 0.7524348503320609, 0.7570462526724202, 0.13215591538596094, 0.13145200816977742, 0.13347492700922137, 0.162835861500377, 0.4011734750573892, 0.1427248939007153, 0.12584906978214383, 0.12772681916151685, 0.1410187080978894, 0.13211428097715183, 0.13157723965725876, 0.13732909147781158, 0.13221828262555246, 0.12889897048036947, 0.14724220263595522, 0.11531363419270235, 0.1258373574186984, 0.10849380354787386, 0.9816906977195767, 0.973183258523721, 0.9849688712085233, 0.9769609201287355, 0.9814541810080797, 0.9848196726138216, 0.9859922713312944, 0.9878213497769915, 0.9725414374720274, 0.6584325969709665, 0.6342727453693368, 0.6371722871587782, 0.6246743599453408, 0.6203806630495637, 0.6459995460876253, 0.6111030031744118, 0.625745631446754, 0.6320376174303131, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.30511675127710747, 0.33044249246924096, 0.32660898811979155, 0.29763322179914453, 0.3886652501002824, 0.4205218025738955, 0.30585741049789195, 0.3056437709993842, 0.45179534429856094, 0.15838790333720987, 0.28360196879434163, 0.29195145716058346, 0.3502349856458852, 0.3720980977960159, 0.26362427781578657, 0.2906379533429285, 0.2709270209935125, 0.1708945936652695, 0.08461441561439442, 0.13352231901162537, 0.13771182537900006, 0.131586491509187, 0.12088101927947248, 0.1225008260217113, 0.12083345705352, 0.12030783009504953, 0.1422531351261621, 0.2668758367488645, 0.2988203225809577, 0.27558259237415084, 0.23542115632111416, 0.2150183852606664, 0.23219430912277828, 0.2538700662370793, 0.21976208281830345, 0.256486698872884, 0.03482214698978514, 0.04707343299177558, 0.0592732932465333, 0.0961422392485316, 0.07538963237059304, 0.13228751589271814, 0.13266723443924278, 0.08538186730195862, 0.0805197057610969, 0.1901827653427457, 0.21489131360927727, 0.23037720124694205, 0.18832361813164966, 0.20861447704044278, 0.23938227312035487, 0.1759120976612505, 0.18674654071266006, 0.04854781884386716, 0.5984682753406079, 0.6075846430285852, 0.591707742539928, 0.6317935449551627, 0.5752437221454221, 0.6272392452868069, 0.6210630112071853, 0.6035581242180268, 0.5824863628187765, 0.0901202628976231, 0.11634923871902536, 0.10838430347410744, 0.13290674019686288, 0.10467247569521476, 0.09664934498544986, 0.13603135555247625, 0.12395919341190043, 0.10334362629189875, 0.17749563503989452, 0.20166733558513938, 0.31736553812974655, 0.17856758007717888, 0.3824628945777162, 0.18342863968203071, 0.34419878152615113, 0.21354862098495775, 0.33480429831451797, 0.41598989842980505, 0.4329423077542953, 0.4425708670668581, 0.47096291108510535, 0.4936725214197242, 0.510618975037489, 0.5292144640295439, 0.556679180696422, 0.5235840835806813, 0.25851692042679086, 0.24822206380022516, 0.3346939706455051, 0.30167416702491934, 0.2449288455603038, 0.3120015220868362, 0.28342099781289654, 0.22781329071488798, 0.2861475137175512, 0.2124725010240326, 0.21260780503703214, 0.1960096231885553, 0.23368420425689473, 0.20443517858667815, 0.19307020616786796, 0.20234417334455856, 0.19675158206224852, 0.2142958524816302, 0.2339462552618513, 0.20546162356105535, 0.24023723952795395, 0.21592344337197977, 0.6311929296903769, 0.20053808631084147, 0.21157873767824553, 0.21146476619070187, 0.5470207419724256, 0.18340734627925792, 0.8855755525560333, 0.18487067314261496, 0.1475425600875384, 0.8164194869376754, 0.7864065962981006, 0.7896547113419774, 0.7934007003503036, 0.1690530115238824, 0.12725238501159997, 0.2102944460780526, 0.21096933876640345, 0.7655329456345945, 0.16762707664349397, 0.16853053944716245, 0.09358005607374198, 0.7835646608993977, 0.20040494736104786, 0.18228780035365433, 0.18928382906183328, 0.20013051240981417, 0.19186955786549964, 0.18400383909385998, 0.19209696684761346, 0.17615619686961925, 0.2088251199912632, 0.19392130255101747, 0.07895735886052246, 0.08717086037800303, 0.09054522334748816, 0.10352103683893188, 0.08821646432279573, 0.08464519915456181, 0.09862824707386886, 0.07832612292527175, 0.0836753626029102]}, "mutation_prompt": null}
{"id": "62549084-278b-4399-bd1d-9002f88d6c36", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.7 + 0.5 * (self.current_evaluations / self.budget)  # Adjusted line\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced cognitive and social coefficients adaption to better balance exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.34572233089041765, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.8401708300602686, 0.8527298082686048, 0.852534480002829, 0.850534186001727, 0.8628594509113264, 0.8521201957290007, 0.8579822462117909, 0.856761590866175, 0.8456785278671116, 0.7429477692373114, 0.7259708289073439, 0.7245242642237033, 0.7372835153504465, 0.734861361562489, 0.7148172224521192, 0.7412355230147543, 0.7198464388744499, 0.7310828112835297, 0.21116116483564584, 0.1760232077151238, 0.1483131815366322, 0.1638384879002064, 0.14519501213109087, 0.12592403923025886, 0.14151962268020746, 0.13670925273285173, 0.11675038447624408, 0.13667512605435894, 0.11661362091727989, 0.1301881375715902, 0.11721516898406337, 0.14550730736148765, 0.11990964698330842, 0.11349935390825483, 0.11232810418048667, 0.1435553985947452, 0.9816968017886256, 0.9761825619453933, 0.9849755475405525, 0.9769893442257679, 0.9816047305665406, 0.9848196726138216, 0.985991865137913, 0.9878213497769915, 0.9726858367507735, 0.620429284147223, 0.5845970294836496, 0.5656158306500857, 0.6063012989315721, 0.15074932982699607, 0.5562713213695574, 0.5665143345988346, 0.5713880577249054, 0.5825900444412937, 0.7374185753361165, 0.7424043910151785, 0.6997358795904258, 0.21282442032771764, 0.211408831855879, 0.19376152138343972, 0.8076373120549964, 0.793191132325115, 0.6799269780753197, 0.35188784360509406, 0.2686448090534883, 0.44642170511151547, 0.22211649610729545, 0.32984994651414246, 0.3071788012102141, 0.30898894687241707, 0.2623698804375887, 0.29864113238988854, 0.05129777403462776, 0.32263292011307676, 0.2802441158516197, 0.32134091246595764, 0.2901727556019431, 0.1305114847379325, 0.28684167970119534, 0.18081416624715774, 0.2886210834808258, 0.08058089062448359, 0.14367245617684143, 0.13131698082607257, 0.11097164338516963, 0.09574761146953881, 0.12884832207717245, 0.11525663570539013, 0.08927988631032568, 0.13603198159079488, 0.25332720918030505, 0.28393643174991223, 0.2472387357588901, 0.21706217751492363, 0.21194601252021328, 0.26119199364738366, 0.2706536277394048, 0.20656218713214247, 0.2514143462688069, 0.03348119010886241, 0.07977366056134505, 0.13532898455261744, 0.0888141024979896, 0.07097078912913435, 0.08322955750843952, 0.1411981194903379, 0.07149112470981456, 0.06634532148169892, 0.18340929942445094, 0.23478229255956884, 0.19046040525744112, 0.21137420944472818, 0.1847644135330222, 0.22302388011644236, 0.20893855783492266, 0.19921515387711342, 0.056823132698608836, 0.5658145640219039, 0.5608033826146772, 0.6009552183084668, 0.5861871867766992, 0.574818805497652, 0.629382536577861, 0.5929006566594055, 0.5807925645198428, 0.5750579253446262, 0.09176204133729648, 0.32143019127846706, 0.1170781192880791, 0.10870083421503585, 0.11481865918890288, 0.1337350471985963, 0.13444206112519663, 0.12755362076932142, 0.13363957908271618, 0.16397447410563404, 0.1526829939794856, 0.1901240142806161, 0.1493788787933703, 0.18432573157626497, 0.19120952663991886, 0.1855896347490259, 0.17990072681151015, 0.1570940120475247, 0.44857170755804243, 0.44506616570554747, 0.43491979528017777, 0.4272937576355412, 0.3782354530146208, 0.49003695847246875, 0.46966684662297364, 0.5132858986649124, 0.4215601737867326, 0.23541684984596944, 0.2883459442757408, 0.30090803189242366, 0.3237410640468832, 0.25775505865183823, 0.24971920576445772, 0.26071475865937876, 0.3142261319962124, 0.2947596553745937, 0.20526863106023685, 0.19126663762861762, 0.21269804845513274, 0.20072617663132408, 0.20300113321533308, 0.1915176256474166, 0.19159970540276172, 0.2192278273843753, 0.20943192400235888, 0.2041247247271587, 0.22093009897477467, 0.2364225808926962, 0.21540721331810586, 0.23266475746410087, 0.22408914057064822, 0.22870433531619516, 0.2172521906018141, 0.20150976092790907, 0.18291086205921014, 0.8746065237489051, 0.18262422959899172, 0.14733103262577918, 0.8695557713574573, 0.7131406421121462, 0.13314704414727097, 0.772583467850645, 0.7571031231743439, 0.5034654550258388, 0.21023077535584078, 0.2092596696612814, 0.7391487165206165, 0.16794452233698542, 0.1679262919791641, 0.20463620646934433, 0.20647978749779194, 0.617864411584486, 0.19104209365975544, 0.18404424072402947, 0.18731155215993645, 0.18481763810416707, 0.17277790262266157, 0.20084481099123364, 0.18791476326181322, 0.1907603874126722, 0.2007572875505783, 0.0828930605853202, 0.07862220174813705, 0.0769090459349876, 0.07708442882025501, 0.08951985486791159, 0.07879691800849165, 0.10273003850217954, 0.08213595987342015, 0.07544346803520807]}, "mutation_prompt": null}
{"id": "ab8595d0-fa77-4583-a1b7-175b0c72afc7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget + 0.05)  # Changed line\n\n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.55 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Changed line\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced learning factors for dynamic adaptation by modifying inertia and mutation scaling based on evaluation progress.", "configspace": "", "generation": 66, "fitness": 0.36422004638951355, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.8499254339953625, 0.8601039339471758, 0.8578483211894614, 0.8609617006868725, 0.8558562134121654, 0.856953805566189, 0.8380026520807405, 0.8477525772027377, 0.8586516364267129, 0.6988000098119017, 0.7303922230945123, 0.7272223297263356, 0.7310785353637225, 0.7383268496946771, 0.7338786618320123, 0.7221282720781992, 0.7448201852471346, 0.7114491919195793, 0.56504297386112, 0.13119673990340341, 0.11673666708084207, 0.14179504955432642, 0.5877242338897699, 0.13636099443619298, 0.12973721773482827, 0.10857497930720961, 0.4813298454623186, 0.15110487255110205, 0.14250118163759184, 0.12007620009029452, 0.11950597393928675, 0.11352469540992682, 0.13005190536088962, 0.1230911689934463, 0.13166789166621018, 0.13013551802879575, 0.9831348015908921, 0.976106326476435, 0.9849750619795249, 0.9769715198655594, 0.9814410412042663, 0.9848259384146957, 0.9860055288595616, 0.987828287830639, 0.9717119023990886, 0.6401765135724544, 0.6471317193077093, 0.566761006615309, 0.6463799178100094, 0.5754171684509353, 0.6192841427234165, 0.6133227343025576, 0.5792774232161753, 0.598307503340497, 0.7865508294326227, 0.7171177928622665, 0.7477572089637994, 0.7159587138469279, 0.21519990827174906, 0.7687738867990764, 0.8248588138762352, 0.767083473453755, 0.7594302438786961, 0.26031297296206846, 0.35748274337686436, 0.4345718408423933, 0.29911432817914374, 0.2695260916396395, 0.4321188701095997, 0.3131894203672714, 0.3034299705822071, 0.4580340298737722, 0.14690845715597645, 0.24671878169878814, 0.31495499074002464, 0.3344523325977612, 0.31073715603570695, 0.2868848647810124, 0.3596577923906882, 0.27148685984776966, 0.30321499195781676, 0.1375359887387867, 0.10361674793365006, 0.12148778177158526, 0.15903804650489728, 0.1161252717642276, 0.14009141186917062, 0.11546238820672039, 0.12442036595640316, 0.14002250585549103, 0.2502857379289587, 0.26026167036686054, 0.258713531961979, 0.23473027766138255, 0.23637635857876005, 0.2493574150841713, 0.25545215123926723, 0.232940195047023, 0.2563930981242071, 9.999999999998899e-05, 0.05639680085323562, 0.11187246763359149, 0.08743028638407291, 0.07226203530692188, 0.11847187454576324, 0.17590096438517178, 0.09982604561750452, 0.08225269529996238, 0.1864006748090976, 0.21965422740115437, 0.226776162643873, 0.22521494338416148, 0.21050723331316834, 0.24488863028840802, 0.21459815444402097, 0.1840028835698675, 0.0556798215833062, 0.5716972922328353, 0.5744098631451328, 0.5994303703180206, 0.5895016098004019, 0.5705845175448505, 0.5905532784998011, 0.6049168782823575, 0.5799496697869725, 0.5826550902674308, 0.07661969135576785, 0.13317405520390457, 0.14665252101569604, 0.10602840245584755, 0.1507293033176449, 0.13855477237901592, 0.13145949356076803, 0.15594536953833538, 0.08956235620441655, 0.23952911230161555, 0.14236725647478765, 0.3271176609275487, 0.22749060876343408, 0.14369999731008576, 0.21032454739942896, 0.3724052795321864, 0.23533975115287487, 0.14728358596090096, 0.4416001504877598, 0.4584131046654104, 0.43978699848006375, 0.449872876941975, 0.34957429494552383, 0.5146148793223442, 0.4228049629130255, 0.5185071114354771, 0.5202803604651578, 0.2753008027548385, 0.2933756702743858, 0.2858022375750702, 0.30998308581588085, 0.26007367270062953, 0.3261108206725417, 0.312834560875882, 0.36497165523758746, 0.27241250493323743, 0.19404065002453985, 0.205321367631213, 0.20991526779748026, 0.2135101730942739, 0.21121435877458594, 0.1960013954837827, 0.19142430635393148, 0.18663665639357374, 0.22208979285287278, 0.2187837205087486, 0.21695059703238329, 0.2020512385148181, 0.22763787689796533, 0.6368740682901481, 0.2138045359273909, 0.6348832538111508, 0.1972213468438967, 0.19270134275430884, 0.16549982378041805, 0.8922667696236913, 0.1700178981393461, 0.16608007145067638, 0.8685404337756455, 0.15287853803352702, 0.19253482287093115, 0.7295384754088856, 0.16824326628806707, 0.12756596946400678, 0.2100904380197789, 0.21064023164121137, 0.20954514133041968, 0.1671014566251633, 0.6352007089614342, 0.2058633279582105, 0.7905130742946743, 0.20892124764504727, 0.1960291988723759, 0.18212952020855344, 0.18032496724943592, 0.1881871706587751, 0.17983704050540805, 0.18263077440140463, 0.19882917612761852, 0.20026139085418548, 0.19359400298023166, 0.07996665266302061, 0.0872228176096792, 0.08963435346202697, 0.100829192673352, 0.08970056735704002, 0.08331646252201663, 0.09803864881410007, 0.08215290052856439, 0.08899606039684893]}, "mutation_prompt": null}
{"id": "4537ef28-000c-4827-8b57-93cf88a3ef83", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.5 + 0.2 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.7 + 0.3 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Refined the adaptive inertia weight and perturbation scale to improve convergence stability and exploration balance.", "configspace": "", "generation": 67, "fitness": 0.3264510708059177, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.7657926480858486, 0.8068041949474207, 0.7890620721998295, 0.809590182360069, 0.8015769730324974, 0.7954294133738852, 0.7884397217642196, 0.7886549941418088, 0.7989001456032281, 0.6774547724871807, 0.5737078000496724, 0.6613471190566536, 0.5478753425791404, 0.669595914659227, 0.6446875798651062, 0.6801938517665619, 0.6402326596144943, 0.6743132367448288, 0.1319192113668185, 0.15978703147198525, 0.13541831658392878, 0.13364078163932258, 0.15910600706269928, 0.20524187821718587, 0.14111771246031624, 0.12359069319404625, 0.11982519345086495, 0.1440689779842682, 0.14742177751828078, 0.09892553496548029, 0.11649539985557822, 0.11446073212274332, 0.12870802709683282, 0.12504338890469902, 0.11008711767057155, 0.11597866987173933, 0.9839466606260837, 0.976630166322155, 0.9850391620271199, 0.9769594742388948, 0.9814332196226316, 0.9860428310829565, 0.9856613503572574, 0.9892962191625401, 0.9769720551095594, 0.5212849323874906, 0.5248228112087654, 0.48451551070513366, 0.528424796405067, 0.5026298378615892, 0.5214984221325123, 0.49163808317239965, 0.49285789845222694, 0.5030594538082194, 0.6543663462694722, 0.6794785976513305, 0.6166565683256332, 0.7497114028961749, 0.7226628968276897, 0.2644713816980906, 0.7530957677049332, 0.7291113273496483, 0.643440075783116, 0.2762356335479558, 0.27237254661789345, 0.2573843422385941, 0.2628887444461536, 0.12653705765056422, 0.27936154529372903, 0.2744362304025183, 0.2541001721914675, 0.2694736335024823, 0.24501720024420348, 0.17916527800134296, 0.23729344797876584, 0.24343780667624237, 0.2582891589734342, 0.12392912174265025, 0.27566632559327875, 0.26303938109348923, 0.2532019770414501, 0.06057564432504481, 0.09300041447796703, 0.083659111767304, 0.04697103374998457, 0.08392449099591504, 0.05409927219203414, 0.07387390774481628, 0.05591934613951621, 0.09987245995070548, 0.2303444979842999, 0.21039277860517924, 0.2151506000118466, 0.1842023014548103, 0.1884156759024841, 0.192971263585771, 0.19526607562852172, 0.21836777771238447, 0.20813609382825748, 0.028315638219948647, 0.026508468060457924, 0.05139338620602518, 0.06506328238547099, 0.09722954964518271, 0.1063415819091662, 0.0416522313472667, 0.07254441246075571, 0.06846984530150235, 0.1813734999231228, 0.1799757416810993, 0.15750086429976817, 0.15216780037268562, 0.1917738717606038, 0.1734307283234655, 0.17388192649250267, 0.20254259481272252, 0.1597490771274348, 0.52842205725832, 0.5278786850375838, 0.5493452417654978, 0.5448060748679802, 0.548643706326326, 0.5464664460565086, 0.5607908015932919, 0.5523504549019806, 0.5650174194571406, 0.08082181059483651, 0.1042859260701704, 0.11757998243470169, 0.12444224334849774, 0.11480544176910412, 0.11041527807736784, 0.11500190866132876, 0.0914925092124449, 0.11227913859995065, 0.20189549746275248, 0.1587771227753827, 0.3015818491169897, 0.16744266070888958, 0.16823723453379713, 0.25844882676616543, 0.1722888158156919, 0.1659949617010139, 0.1850561801000591, 0.4110288348764525, 0.4052494356720162, 0.4621284815321979, 0.35117847620570597, 0.2445674438673765, 0.32491526859726594, 0.42583731845021056, 0.27810022770337706, 0.4806327674870742, 0.2658184713990891, 0.32912538869781993, 0.22921258385441368, 0.2782351766254225, 0.18208528195330953, 0.2930228103889181, 0.3314589409725578, 0.3368471398461179, 0.3678881518698719, 0.19363521215410406, 0.2131991796216074, 0.1949031476944385, 0.23092976138990318, 0.18112458864989756, 0.18951473885556047, 0.1871744198473685, 0.20168718934921037, 0.19520778119039273, 0.21816301611585698, 0.3863636965467083, 0.22186184120734442, 0.21260931005401384, 0.20074084332107356, 0.4269113827887352, 0.39259779371622094, 0.21162075389916135, 0.2174170383827574, 0.2035630243425881, 0.8360652657036091, 0.17101046099995443, 0.701402738358859, 0.7611729842001458, 0.18726331459392032, 0.7142973848099081, 0.17728186056338724, 0.16831729505366433, 0.12625185915231918, 0.20947895495702318, 0.20606596104756214, 0.7339160595689957, 0.16691112105886674, 0.16777798505882346, 0.2043529196456595, 0.7037971877810106, 0.15470901773921464, 0.19047955008886386, 0.18235483940842756, 0.1809659701718428, 0.173503769080249, 0.18157552815869604, 0.19129912480020206, 0.19554991325223414, 0.19154772940625375, 0.17716245221369065, 0.0800644685320131, 0.08625388682438495, 0.08054981244014214, 0.08211969537181685, 0.08724622556871797, 0.08457582191471558, 0.11861774064302377, 0.08093106800191285, 0.08034696118822993]}, "mutation_prompt": null}
{"id": "bc76c9da-2901-4c0f-a44b-a660b4372745", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved the mutation strategy by enhancing the diversity factor scaling for more robust exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.855254594285909, 0.8648239776269577, 0.8625802381627854, 0.8647120064635749, 0.8765487962240156, 0.8611141660386882, 0.8619567329690346, 0.860691336899759, 0.8622054780258547, 0.7495821662339555, 0.7010567978062674, 0.733639663345403, 0.7239419287151415, 0.7538119503620407, 0.7304220081476829, 0.7425476322123244, 0.7524348503320609, 0.7570462526724202, 0.13215591538596094, 0.13145200816977742, 0.13347492700922137, 0.162835861500377, 0.4011734750573892, 0.1427248939007153, 0.12584906978214383, 0.12772681916151685, 0.1410187080978894, 0.13211428097715183, 0.13157723965725876, 0.13732909147781158, 0.13221828262555246, 0.12889897048036947, 0.14724220263595522, 0.11531363419270235, 0.1258373574186984, 0.10849380354787386, 0.9816906977195767, 0.973183258523721, 0.9849688712085233, 0.9769609201287355, 0.9814541810080797, 0.9848196726138216, 0.9859922713312944, 0.9878213497769915, 0.9725414374720274, 0.6584325969709665, 0.6342727453693368, 0.6371722871587782, 0.6246743599453408, 0.6203806630495637, 0.6459995460876253, 0.6111030031744118, 0.625745631446754, 0.6320376174303131, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.30511675127710747, 0.33044249246924096, 0.32660898811979155, 0.29763322179914453, 0.3886652501002824, 0.4205218025738955, 0.30585741049789195, 0.3056437709993842, 0.45179534429856094, 0.15838790333720987, 0.28360196879434163, 0.29195145716058346, 0.3502349856458852, 0.3720980977960159, 0.26362427781578657, 0.2906379533429285, 0.2709270209935125, 0.1708945936652695, 0.08461441561439442, 0.13352231901162537, 0.13771182537900006, 0.131586491509187, 0.12088101927947248, 0.1225008260217113, 0.12083345705352, 0.12030783009504953, 0.1422531351261621, 0.2668758367488645, 0.2988203225809577, 0.27558259237415084, 0.23542115632111416, 0.2150183852606664, 0.23219430912277828, 0.2538700662370793, 0.21976208281830345, 0.256486698872884, 0.03482214698978514, 0.04707343299177558, 0.0592732932465333, 0.0961422392485316, 0.07538963237059304, 0.13228751589271814, 0.13266723443924278, 0.08538186730195862, 0.0805197057610969, 0.1901827653427457, 0.21489131360927727, 0.23037720124694205, 0.18832361813164966, 0.20861447704044278, 0.23938227312035487, 0.1759120976612505, 0.18674654071266006, 0.04854781884386716, 0.5984682753406079, 0.6075846430285852, 0.591707742539928, 0.6317935449551627, 0.5752437221454221, 0.6272392452868069, 0.6210630112071853, 0.6035581242180268, 0.5824863628187765, 0.0901202628976231, 0.11634923871902536, 0.10838430347410744, 0.13290674019686288, 0.10467247569521476, 0.09664934498544986, 0.13603135555247625, 0.12395919341190043, 0.10334362629189875, 0.17749563503989452, 0.20166733558513938, 0.31736553812974655, 0.17856758007717888, 0.3824628945777162, 0.18342863968203071, 0.34419878152615113, 0.21354862098495775, 0.33480429831451797, 0.41598989842980505, 0.4329423077542953, 0.4425708670668581, 0.47096291108510535, 0.4936725214197242, 0.510618975037489, 0.5292144640295439, 0.556679180696422, 0.5235840835806813, 0.25851692042679086, 0.24822206380022516, 0.3346939706455051, 0.30167416702491934, 0.2449288455603038, 0.3120015220868362, 0.28342099781289654, 0.22781329071488798, 0.2861475137175512, 0.2124725010240326, 0.21260780503703214, 0.1960096231885553, 0.23368420425689473, 0.20443517858667815, 0.19307020616786796, 0.20234417334455856, 0.19675158206224852, 0.2142958524816302, 0.2339462552618513, 0.20546162356105535, 0.24023723952795395, 0.21592344337197977, 0.6311929296903769, 0.20053808631084147, 0.21157873767824553, 0.21146476619070187, 0.5470207419724256, 0.18340734627925792, 0.8855755525560333, 0.18487067314261496, 0.1475425600875384, 0.8164194869376754, 0.7864065962981006, 0.7896547113419774, 0.7934007003503036, 0.1690530115238824, 0.12725238501159997, 0.2102944460780526, 0.21096933876640345, 0.7655329456345945, 0.16762707664349397, 0.16853053944716245, 0.09358005607374198, 0.7835646608993977, 0.20040494736104786, 0.18228780035365433, 0.18928382906183328, 0.20013051240981417, 0.19186955786549964, 0.18400383909385998, 0.19209696684761346, 0.17615619686961925, 0.2088251199912632, 0.19392130255101747, 0.07895735886052246, 0.08717086037800303, 0.09054522334748816, 0.10352103683893188, 0.08821646432279573, 0.08464519915456181, 0.09862824707386886, 0.07832612292527175, 0.0836753626029102]}, "mutation_prompt": null}
{"id": "7506b078-0da5-4dfe-8149-9cf6eadcdc13", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.7 * (self.current_evaluations / self.budget)  # Changed from 0.5 to 0.7\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced the cognitive coefficient adjustment for better individual exploration during early iterations.", "configspace": "", "generation": 69, "fitness": 0.3663189866761319, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.8571484051517279, 0.8556783028588606, 0.8626520454201579, 0.8700950779726684, 0.8606842434725639, 0.8547664300862079, 0.8655008107128516, 0.8608944202307186, 0.8673508178538599, 0.7562446841689997, 0.6855967985290841, 0.7300467101605861, 0.706256556528756, 0.7472930313246504, 0.7180742433206142, 0.7372111883729405, 0.7522739849209377, 0.7505934211479388, 0.11967106516895076, 0.14075769626976087, 0.4529274573505978, 0.1291258793260457, 0.15175136824365654, 0.13770270181152866, 0.13151683801985203, 0.11675887031695187, 0.14677533138826615, 0.13071972998127146, 0.12711190327230837, 0.1323827534885026, 0.14512625987709848, 0.12885513931484982, 0.14081036153955884, 0.11057884437106602, 0.11575750103686755, 0.14574491078905993, 0.981690762130498, 0.973201146545645, 0.9849689325803705, 0.9769611358590718, 0.9814557743114626, 0.9848196726138216, 0.9859922672060321, 0.9878213497769915, 0.9725439460363899, 0.6186971726149427, 0.6450039261220945, 0.6214826195228771, 0.6406119467926037, 0.5601266957295663, 0.6044972756054036, 0.5919677635659575, 0.6229452220659542, 0.5948590100975244, 0.6512926119138379, 0.7482651390172526, 0.7983646675874702, 0.6948972342932955, 0.8362449137550165, 0.2120207215044524, 0.7914247989054985, 0.8015829119747924, 0.8076374390176232, 0.270644208246408, 0.30430002719093485, 0.3392057580808894, 0.1295627592778792, 0.40192953615566407, 0.39115211020872587, 0.28461085617143433, 0.30290196519208656, 0.49278449531623914, 0.1548727897063723, 0.26654612179056225, 0.2891890781338149, 0.3202625616374909, 0.338216139452317, 0.1317091720813327, 0.312091369993986, 0.12881238487032298, 0.1809744282561947, 0.08978376757602524, 0.12866385377423517, 0.12345943155119388, 0.1380293265823631, 0.13052612898470672, 0.14501629228617408, 0.1158755614411362, 0.15536626100510165, 0.11588108405514286, 0.253203711167, 0.25664363637652876, 0.28750727873726023, 0.1935899906637013, 0.24896950576529875, 0.2524404111405646, 0.257646150679821, 0.2312326314796499, 0.24845372327201043, 0.03450538721083851, 0.0472805991237043, 0.09373703597021432, 0.13648605218190968, 0.07369760810457537, 0.13135740818010233, 0.13260133954861142, 0.08523538268724518, 0.0795208341289062, 0.2129094861172186, 0.2315562889945355, 0.20612284439563722, 0.23818536412364333, 0.24983979153585678, 0.17558165547093685, 0.2085590989254329, 0.19106682573493194, 0.04854649708251091, 0.5805332601901871, 0.6264412711438495, 0.5792904753735137, 0.5925134282980722, 0.5990448652461873, 0.584937965837806, 0.6434870301825267, 0.574517562749415, 0.5989535231007594, 0.07706685598064411, 0.1227007764569138, 0.13160641440686394, 0.1288429733050127, 0.1371864118127083, 0.13528915391569862, 0.12062759121649302, 0.10841056523128756, 0.10154781072855745, 0.13157186620545258, 0.14399271962276394, 0.3361625939937817, 0.15631417802010306, 0.19501674953265224, 0.1706606984051814, 0.3842762120227853, 0.21031160915025005, 0.16867034526627012, 0.42719559496532133, 0.4663825646167078, 0.4422315043497236, 0.5626601024879465, 0.4195962856685602, 0.5525057958101579, 0.47290903026888953, 0.5003713039600878, 0.5129771350550276, 0.3206944851953921, 0.3892297573905579, 0.36909437277631063, 0.3113295231711227, 0.367530230519166, 0.30857352350782197, 0.2457751127302502, 0.3188232179566569, 0.27405132618397554, 0.20210769804520956, 0.20816272989012174, 0.19841886236072936, 0.2217443007559119, 0.1912309457797391, 0.18944479047592433, 0.2014385274842425, 0.21658726902236747, 0.21079152864705752, 0.20443613934239602, 0.20673886037541833, 0.20615272758332548, 0.2016008235146206, 0.5934412384529704, 0.5100167015809816, 0.20522591971331727, 0.21428029635227552, 0.22113166867525003, 0.18354457479410335, 0.8954387408959604, 0.18455824352463857, 0.16467886606914361, 0.8460899378923816, 0.784765250998601, 0.7719915953395854, 0.7910183685367483, 0.16906113282326984, 0.4993894497856042, 0.21028273890796345, 0.2108177753256666, 0.7532911332943866, 0.16763556178449857, 0.16780988106921302, 0.09350904945544147, 0.8108418495667687, 0.20854899042639408, 0.18275039583775754, 0.18316090741905244, 0.17611731455992363, 0.18186399070689285, 0.20524102603257777, 0.19642459390171008, 0.17797286304701665, 0.1971735694701363, 0.2039398710921453, 0.08354941913673897, 0.08773547629256429, 0.09171846037726372, 0.09233382451849759, 0.08169014617275372, 0.07990881454653664, 0.10605653878970733, 0.08935340337659958, 0.08712371545083275]}, "mutation_prompt": null}
{"id": "d8bfff94-8b5a-40b1-9fa0-936ae686310c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.5 + 0.2 * (diversity / (np.max(diversity) + 1e-5))  # Adjusted\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Refined the inertia weight adaptation to improve exploration and convergence balance.", "configspace": "", "generation": 70, "fitness": 0.34258987257503537, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.7837497325220327, 0.7998874395671963, 0.7703222996130143, 0.810555479030836, 0.8239229008522537, 0.7987209736587363, 0.8074068810764812, 0.816167897224029, 0.8247002303521616, 0.6886508689307533, 0.6651799292098247, 0.6957585872068162, 0.6997704132164673, 0.6887973961306153, 0.6973259266685583, 0.6767635414811148, 0.6834548906497864, 0.6882021424820877, 0.12851517755872044, 0.1546168222299824, 0.15340024391563145, 0.12786645960208642, 0.14022357752868087, 0.14098275721893716, 0.2255661001994128, 0.1340494318081139, 0.13043805896755545, 0.10664430652305801, 0.13402823448434664, 0.11448046391700739, 0.11618417586788476, 0.10994232609103693, 0.14766127920235483, 0.1198709375742073, 0.10605687471260994, 0.12178147826820551, 0.9839708678492111, 0.9766364912789798, 0.9850759019619462, 0.9769981677467829, 0.9814298158359309, 0.9860429534805032, 0.9856573827646046, 0.9878825531473175, 0.9769361248636435, 0.5501983958356486, 0.548182772491544, 0.5149418864353525, 0.5349806529043888, 0.1854454059552011, 0.5333972955141779, 0.5617954140356202, 0.5570929802328757, 0.5252090524597787, 0.6968542134402118, 0.7023851034774786, 0.7120943392860881, 0.7917734109203121, 0.7800254516544127, 0.2016735928857294, 0.7256309786194018, 0.6763917005581994, 0.7041258670486139, 0.2664374468607724, 0.2682362657792432, 0.2777685164415389, 0.12509038755240176, 0.2848281920513641, 0.2646675155181367, 0.3047384316187649, 0.221590556243644, 0.3002346802878968, 0.16623677081408428, 0.29226942913955023, 0.23165917049261797, 0.2723683572855059, 0.25941851895178414, 0.2931885226980414, 0.310135272933615, 0.22881208120783547, 0.28267238329870337, 0.06696737078380066, 0.14495418490151823, 0.09765272015027149, 0.0944385760409232, 0.10991972811956674, 0.10205405481610264, 0.1248652238389486, 0.106334717706971, 0.1023974617937905, 0.24170665821771598, 0.28275742805871795, 0.2481008458992241, 0.21119301453007955, 0.22672050686536027, 0.2169723171021115, 0.24055599641136127, 0.2657256276924892, 0.25391039495870704, 0.049618678088641954, 0.12638090796139845, 0.02895444406073533, 0.06599204370947775, 0.0693953613824968, 0.11776655262300706, 0.05966296718575215, 0.054628099107486894, 0.05438405877832431, 0.23927715681736794, 0.18882374648153277, 0.21599996313507708, 0.20487984108484225, 0.2123776382972703, 0.19383432299124914, 0.19349851496601533, 0.2128523234549642, 0.16302318275211602, 0.5587433761035085, 0.5715977035382553, 0.5621164143115628, 0.5748809770071657, 0.5671685870629651, 0.5566437686066903, 0.5354965220056263, 0.5674482484996538, 0.5306714997214692, 0.07408824718596496, 0.1062059778954959, 0.08853477189596903, 0.12609140957377263, 0.11025208311820878, 0.14505915437799555, 0.10823761938502918, 0.11706390233371455, 0.10155796745261325, 0.16690157887846913, 0.20555074423770225, 0.2077021470116136, 0.16041706367693465, 0.17088284884027294, 0.2968780201941419, 0.15843883299892836, 0.1515781137405, 0.17313310102098856, 0.3832421771979736, 0.4284525969397578, 0.46525795785956015, 0.44721175722060125, 0.4101755701051706, 0.4474968895121285, 0.48335252867571676, 0.47228418382277093, 0.3850497457483899, 0.3172511256489772, 0.2759514359569445, 0.22815194912275405, 0.27663444591723807, 0.2956697252763313, 0.28963003257673026, 0.1323886957885898, 0.3330055910787937, 0.40658124790645356, 0.2068880233327196, 0.22691780512213466, 0.20630130556851844, 0.1901285840910566, 0.20660926618926512, 0.1887261986949209, 0.1882436302206547, 0.22656684551277695, 0.17967884575795956, 0.4556084285033074, 0.2173458201007351, 0.20892650649620026, 0.37239792912718916, 0.21633715859108238, 0.654431662523986, 0.19620401885128835, 0.2232703336855616, 0.20008664369670526, 0.2040810103447812, 0.8459812021790669, 0.17076395123701726, 0.1639917764370623, 0.8325417432858915, 0.7370511200078698, 0.6604831430698057, 0.7685924107881799, 0.1789041594993772, 0.20551090110423564, 0.20941739819247973, 0.2087849831014047, 0.7283087988260746, 0.16668172648811175, 0.16780959716023192, 0.194591450913285, 0.7417518140933217, 0.2070554026451925, 0.17881561249024414, 0.18024253910787758, 0.18320679522183114, 0.1760842741626829, 0.19759904756560231, 0.18471104590940857, 0.21318707063733044, 0.19134933627452777, 0.18056521108299017, 0.085706031135523, 0.09058103310165533, 0.07857824301779148, 0.0880415132945791, 0.08281878710980439, 0.08409812566800023, 0.10335329604367072, 0.08051651451894382, 0.07845392922816208]}, "mutation_prompt": null}
{"id": "65810232-5d69-4757-9d8d-d604dd58c919", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.5 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced convergence by adapting the perturbation scale and maintaining diversity via modified mutation strategy.", "configspace": "", "generation": 71, "fitness": 0.36983530586951197, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.8612857293569857, 0.8779244830724875, 0.8678097842259233, 0.8681776090250943, 0.8694229174275032, 0.8543682784022628, 0.8607981440909266, 0.8595186673683073, 0.8684466982945186, 0.7632253156706985, 0.7728820757600472, 0.7612546295866358, 0.7628297330363383, 0.7750783540169387, 0.7674209824227838, 0.7275884161801403, 0.7675097628369937, 0.746363541121839, 0.1395768502333633, 0.14221247102173207, 0.14568377640394992, 0.1654767678049891, 0.12913271627744416, 0.15372959491500227, 0.16870688022737923, 0.1181092402605538, 0.1537287664303818, 0.12822805797832892, 0.12353431477893861, 0.10933558676031496, 0.12876923381536776, 0.1391545936039913, 0.11061558774272073, 0.12764335089355283, 0.13546573224602543, 0.1612922097800249, 0.9839412744581268, 0.9763565461226599, 0.9849707117401033, 0.9772571000573529, 0.9814467538426783, 0.9848197907794841, 0.9859866990675451, 0.9878211748222963, 0.9725052409802567, 0.6647804696677515, 0.6534626334892761, 0.6606031990798835, 0.6354372066820999, 0.6049419561776945, 0.6863534436169708, 0.688414666232904, 0.6132067213310763, 0.6553541410733205, 0.8220918764520377, 0.22408439927874502, 0.819340509253397, 0.8365977671731306, 0.2123922379751384, 0.2076028691487588, 0.23898864974109124, 0.7759209578627487, 0.7768170080386132, 0.332061144433633, 0.2920534172347059, 0.33888534396231584, 0.2781581361337695, 0.13060328373569718, 0.38017251593831747, 0.3212277711545296, 0.3633759579695198, 0.37144501636700356, 0.3729609364417955, 0.2827066990639645, 0.30474186446703455, 0.3154734428293252, 0.3287016954424661, 0.47790459046069267, 0.3963918359282341, 0.129329252699117, 0.1272088102971537, 0.08243023827744766, 0.17178352440248223, 0.17278466148703897, 0.15534526084819322, 0.18379767434486338, 0.1704499165902118, 0.14626284817647062, 0.14693097036626912, 0.15949083174577539, 0.2557755520091807, 0.3100124495570802, 0.2736463831287891, 0.2862067855552456, 0.32519412968790107, 0.29271755964466406, 0.2777183816099653, 0.2898627381171671, 0.3194792720291424, 0.03467799380071157, 0.1265973072586286, 0.17178688011398113, 0.07531758042206749, 0.07546755521983473, 0.2896951526352468, 0.16432064871705498, 0.2656874276374078, 0.07876650424301757, 0.13579322319042164, 0.2585847927364082, 0.19055759151447194, 0.27024086457766994, 0.2481499609921779, 0.26889208253757146, 0.2406791574640328, 0.1941814080586517, 0.057579229593194614, 0.6143177608116676, 0.6035515115812076, 0.6353382746853279, 0.6345142380594788, 0.6235062431063747, 0.6101006164126404, 0.6058261052673284, 0.5863739488032358, 0.6054170931232612, 0.10351734233541177, 0.14485246714963484, 0.09377059451979508, 0.1302823137615291, 0.09248067121653325, 0.14531873913578297, 0.12754280619242364, 0.12724165935034615, 0.11400675555337514, 0.1548140766201952, 0.31258915507189877, 0.18295660733798447, 0.5508666191433327, 0.27570953377000673, 0.2643540700525663, 0.5163044986029097, 0.16100621146343108, 0.18485433180070532, 0.4792378245905947, 0.4722227077785379, 0.5495935528452778, 0.4180041309786028, 0.3205175773831904, 0.6118290965300086, 0.5250872315464912, 0.5217847499059491, 0.5404942318652203, 0.31689633940812045, 0.34241338177949965, 0.3073331206834995, 0.2710351168582681, 0.3917727281168941, 0.36573363231883504, 0.35507287762384043, 0.2139867771107854, 0.3240015592150972, 0.22146740492734585, 0.21089469312761477, 0.2302828959094314, 0.21542609695425385, 0.19462995436783825, 0.18851504805581243, 0.2216164413221452, 0.20014347513978725, 0.22044980835736738, 0.21883001070398522, 0.2224457402981348, 0.20196848128725275, 0.2169785325287531, 0.2026446108249127, 0.7523920100345135, 0.23987947458707182, 0.24205623800214093, 0.21749998225762046, 0.18320292981875153, 0.8921745518331616, 0.18386295547846243, 0.1473130719478064, 0.8503589868686473, 0.16827843033383683, 0.8012069045721731, 0.1775372180971888, 0.16930158178476362, 0.6017798858714563, 0.2106774413516881, 0.2118315444070601, 0.20411543291758594, 0.1682159682014659, 0.7461926170902662, 0.19622789152563413, 0.8325727443718253, 0.20957242327771342, 0.18310586386479022, 0.18381193005494478, 0.18713666276960272, 0.20970177981621418, 0.18410374094725857, 0.1967454445470963, 0.19508647201018614, 0.18758117309771194, 0.19633086788535647, 0.09707487777433377, 0.0886188403355731, 0.08422278673529326, 0.10931566784318514, 0.0898590775782745, 0.08034364747376732, 0.10674682127399626, 0.08203029030953168, 0.08757265352957189]}, "mutation_prompt": null}
{"id": "170b7129-fab6-4387-b0f8-e054ef12cf18", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance, global_best_fitness, previous_global_best_fitness):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        improvement_rate = abs(global_best_fitness - previous_global_best_fitness) / (abs(previous_global_best_fitness) + 1e-5)\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5)) + 0.1 * improvement_rate  # Modified\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n        previous_global_best_fitness = float('inf')\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            global_best_fitness = personal_best_fitness[global_best_index]\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance, global_best_fitness, previous_global_best_fitness)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n            previous_global_best_fitness = global_best_fitness\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Introduced dynamic adjustment to perturbation scale based on global best fitness improvement rate for enhanced exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.05713121131606214, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.10781999363118644, 0.12790968231572675, 0.09547764779247647, 0.13212017385271702, 0.14631269873614872, 0.08494426072760142, 0.14817227221969276, 0.1350118946783988, 0.15145361539935642, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.022897066439769853, 0.008277222361807945, 0.02541144698320008, 0.01998745651664502, 0.03791549332628985, 0.02099093945046937, 0.010028573852585376, 0.022131880887015898, 0.0016584225767563021, 0.01734542163760977, 0.013773504024906291, 0.004664893584889751, 0.015706409261361687, 0.016346866135518168, 0.0193044555246783, 0.0020563355067588773, 0.00957243131083274, 0.006045431169561577, 0.06767401226853487, 0.05597380471645752, 0.04546316300776765, 0.06280674147689902, 0.0866020033800935, 0.06360556874541268, 0.07268801400695268, 0.09382906292843274, 0.05031024792742589, 0.05166643168344798, 0.05396341328274734, 0.0, 0.04930062243802058, 0.0, 0.03486138894915125, 0.08836242671326489, 0.012859408868982625, 0.0, 0.060689249054935335, 0.07621837065547021, 0.07232957697738274, 0.1138288972591237, 0.1002292776810878, 0.0941937287680168, 0.18137711016828062, 0.10616286620017457, 0.08155379169657262, 0.0, 0.012385719152941066, 0.0, 0.0, 0.0, 0.0012553434962548904, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05615849532211492, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004039979143947714, 0.0, 0.16454032703751142, 0.1917221331650516, 0.16683370440115963, 0.17135411602834028, 0.12787837536985025, 0.15776284486469372, 0.14468934694344626, 0.14304141902790923, 0.16165358534656804, 0.028793891225019963, 0.03863194035966955, 0.016799314335703253, 0.03753365941412745, 0.023914001245004868, 0.03513649057114565, 0.027377016825085754, 0.026409586185090705, 0.018027233658395203, 0.05861880328973146, 0.07548335978895615, 0.08712666362674504, 0.10021761648367278, 0.06556361650568865, 0.08443735564153942, 0.08386299093082383, 0.08742898540667488, 0.08913653230045127, 0.1219410654990456, 0.14806885018922944, 0.1305017392871739, 0.14453588780539506, 0.1296506287214615, 0.14470383539517384, 0.13175882059598387, 0.1225142249638429, 0.1427337657869775, 0.07424172320746525, 0.08584046078228291, 0.0597764701007214, 0.07102561649993933, 0.09348640861487534, 0.07810438403505193, 0.0659836523805497, 0.05987003587904527, 0.09338455816685531, 0.14204344921060308, 0.10566977205512051, 0.1422087448008077, 0.14831796656974094, 0.12737524260886113, 0.12167266817472921, 0.14092791587343056, 0.10758538179716326, 0.16639795756662812, 0.1418467352974072, 0.1296478249367259, 0.028911720619573367, 0.0, 0.0, 0.0447950334112287, 0.0, 0.0, 0.0, 0.06871551780207996, 0.12337292094997887, 0.10264564734441373, 0.07707095850411227, 0.11194201588756658, 0.05397823945462954, 0.10593508164468934, 0.12549862532649625, 0.08752656896690336, 0.09795218363370184, 0.06788996370445366, 0.09352692514847527, 0.06358712438419423, 0.09069482146146401, 0.10097799209397817, 0.0579648092394589, 0.10338938669769648, 0.05527884121622084, 0.1325391010660114, 0.15701593260295865, 0.14609343643544903, 0.15638337545919145, 0.14136855986135488, 0.19126911675410396, 0.13241552954909308, 0.1426539503397265, 0.13560190345098688, 0.025762324643796464, 0.02806850175068243, 0.02983181321907702, 0.03403573784673519, 0.0287917547183415, 0.02739285224728305, 0.057209478075131326, 0.04187114602426156, 0.030866850079722452]}, "mutation_prompt": null}
{"id": "942f6ee2-e5e4-44e5-9f69-07343657e01d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        # Changed line for social coefficient\n        self.social_coefficient = 1.5 - 0.3 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Modified social coefficient dynamically for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.3702882310685055, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.8563235127857605, 0.8628744873330225, 0.8603796328078901, 0.8602941228283022, 0.8643137262570753, 0.8578604987377532, 0.865374523976107, 0.8584933088249506, 0.8577177252407742, 0.7347353111497665, 0.7418698754794144, 0.7304467835255746, 0.7307736037527126, 0.7402434912575233, 0.731452459801083, 0.7506429688104301, 0.7383593785335967, 0.7459671431997421, 0.12406970895790947, 0.12327211084024581, 0.1578883939841773, 0.46598219925602224, 0.1754172648740414, 0.512132386022901, 0.1234097576404165, 0.11443880778422932, 0.13826208442752796, 0.13885674064362907, 0.14167755191511366, 0.13311322622737876, 0.13297124613169375, 0.11597872731518932, 0.134215613094521, 0.12223405815708466, 0.13493863857585242, 0.14109311926590284, 0.9817081099374463, 0.9731943371994703, 0.9849692523023432, 0.9769625105251903, 0.9814541814485176, 0.9848200847354217, 0.9859938024661795, 0.9878217566651432, 0.9725409540805187, 0.6538966213919135, 0.6521980418478724, 0.6002465544858695, 0.6624762307423127, 0.6233688850258527, 0.6190223327194864, 0.5888626507015281, 0.6076444617796888, 0.5973486046660615, 0.7875602058865319, 0.784085009070774, 0.7801173202496199, 0.7338845154906865, 0.7910845844970936, 0.33369906760716905, 0.7971392145905192, 0.7535658160217188, 0.7626258728770183, 0.44469217069551903, 0.3618862872393652, 0.35693450925525516, 0.2731372715924213, 0.39423723531050436, 0.38891236201531987, 0.30921749579175095, 0.26999415299578655, 0.38725895955326384, 0.14317190793362045, 0.2720612149129311, 0.3020414901583828, 0.3664287716095006, 0.32608342494817166, 0.2786475669324494, 0.3027738255950295, 0.20910366306663553, 0.2236051604039011, 0.06697202489023235, 0.10944740776505912, 0.1335987615330012, 0.11560810153731838, 0.13395399464393065, 0.11005356446260717, 0.13983507968123854, 0.08987566831096849, 0.14846458802070361, 0.2579683995460532, 0.25570606809178964, 0.25753247945881896, 0.24684376030849575, 0.26949782169517444, 0.26612904747461097, 0.27619274868450994, 0.20414939347126482, 0.261160426544773, 0.034001165849693815, 0.05249991546081312, 0.19648051015021895, 0.08814425790432434, 0.07419050326317178, 0.19125824672175618, 0.10657548732237132, 0.07918232804065228, 0.08526524758230969, 0.20462640597727355, 0.24334485103335723, 0.23782886881478338, 0.25769406385454663, 0.2100129035036007, 0.166075011724937, 0.20746870129921668, 0.18937555190249866, 0.05600216581540585, 0.599074157163562, 0.6280171518481173, 0.6028046458230445, 0.6048140340511647, 0.5928937882814089, 0.6353357054787555, 0.5932395763128955, 0.5759386905764923, 0.6155194232878722, 0.08194411263666335, 0.1261901239985076, 0.09697653859212985, 0.14271893306712968, 0.09932728738073748, 0.14289412533095525, 0.13120476917549928, 0.11915067098846599, 0.14383374290472806, 0.17740582025484508, 0.21815220924076573, 0.32357615268216167, 0.1682487103306941, 0.18782010243338199, 0.3523514738301413, 0.26787980728293104, 0.215489533882535, 0.17691831231743493, 0.44059541457847795, 0.4533628601664066, 0.35569304801595936, 0.38655394490717043, 0.3854824295476921, 0.46620512066693975, 0.4380358808784064, 0.5157018061078602, 0.5535713464602441, 0.27570611096519826, 0.2773450898963813, 0.30794271862841216, 0.28825355879593084, 0.24924981614377006, 0.30606461422768283, 0.33892851394080004, 0.2475447756451976, 0.37951166551125926, 0.21855216781245068, 0.2225647249886532, 0.19718904890641342, 0.21729450457951838, 0.20007026274685868, 0.2150332476460345, 0.20073482081745897, 0.21390795763607862, 0.21795781360883415, 0.211607682767034, 0.21337923628882638, 0.20981804754753108, 0.19983606622045968, 0.21813346211017892, 0.5691729527100808, 0.23557366244549016, 0.21934917012650934, 0.22129849229535636, 0.18328654353490614, 0.882598106258828, 0.1849956399356092, 0.14756551363439763, 0.8095157836565159, 0.7980238648410503, 0.8092572079802558, 0.7913769425647104, 0.16904504507338247, 0.6115291073745486, 0.2102091347503522, 0.21082904822219606, 0.7279944663126728, 0.16762097826231093, 0.1678066294140914, 0.09349667545856521, 0.7719532701693322, 0.1995033780058204, 0.17968236816301597, 0.1958918669507791, 0.18616540464131015, 0.18519640467583065, 0.1764565732241301, 0.1947518357629836, 0.17670070998273735, 0.18143673779779534, 0.1806037641513938, 0.087886995126364, 0.08601441905761498, 0.07707219173629509, 0.09249091052408154, 0.08695507037461625, 0.07769406046889649, 0.10758290918853453, 0.0900845301516714, 0.0864740271004717]}, "mutation_prompt": null}
{"id": "c9e6f70d-6dd9-4c22-ba5c-49df5dd9e67d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        global_best_improvement = np.min(personal_best_positions, axis=0) - global_best_position\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5)) * (1 + np.mean(global_best_improvement))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced the adaptive inertia calculation by including a modulation factor based on the global best improvement.", "configspace": "", "generation": 74, "fitness": 0.3693817521112549, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.8732767467776775, 0.8688341338409686, 0.8791581109128492, 0.8803055709870279, 0.8785553375723576, 0.8823662781606403, 0.8763128497766346, 0.8689546444687674, 0.8748545784542144, 0.7540654901723973, 0.7458365361223213, 0.7443747776769789, 0.7621723722568324, 0.7580007873614092, 0.7662238176467022, 0.7581766196862015, 0.7852430501651269, 0.7423959722328836, 0.11609709338149699, 0.17378446797641678, 0.15280920333479264, 0.1400017578404651, 0.1553492790463069, 0.12174549362636566, 0.5510642364086555, 0.11062735672599355, 0.1382606672087633, 0.13363292225275325, 0.15153506587780907, 0.1232194769060867, 0.08888427294586787, 0.15006123990465747, 0.11155673867539806, 0.1376201153958838, 0.11534184924688584, 0.08981846591434861, 0.9669251508387702, 0.9681653229308218, 0.9675621136773666, 0.9711041565224311, 0.9815355809067097, 0.9827421572269194, 0.9800514768552367, 0.9860990611026338, 0.971614957278384, 0.6729396123582932, 0.6611953629407754, 0.658756697165847, 0.6817179344225558, 0.6430642764738634, 0.6809564479800444, 0.7014027895796024, 0.6465519129971745, 0.6415044579011036, 0.7181458390994686, 0.804749222085827, 0.7784524283237768, 0.7372033626839525, 0.8247411075849882, 0.47803405224951634, 0.9087198164204265, 0.8085740283363941, 0.7568017465100991, 0.123041213696223, 0.3193277048698292, 0.26476801831121066, 0.33073589938764625, 0.3251681759874917, 0.3371493136678523, 0.3292435329468182, 0.3976108557322856, 0.5428165328202559, 0.1481898215420857, 0.28956246617895254, 0.30049650942480677, 0.33343275678547646, 0.6048715518569361, 0.13506514342529774, 0.41279067468949815, 0.34603111022275446, 0.35990723830207283, 0.10858193729437082, 0.15965794599450944, 0.12649303086211694, 0.15097714618429414, 0.12567968596387058, 0.14981868935309905, 0.16860670800068023, 0.19802423776048594, 0.14726506297602515, 0.24430677224875996, 0.25479046388633597, 0.26344640535469444, 0.24798221454275104, 0.2750487172886761, 0.31467180485404833, 0.2804436777609868, 0.2712698842289326, 0.2527661013429683, 0.041335762051570746, 0.0490405765886095, 0.13547721870276075, 0.07636545649660298, 0.23414434958637698, 0.16768474011954781, 0.17270751231848847, 0.1926362438881899, 0.07114603447710177, 0.17762157499835907, 0.291392522451724, 0.1966808807923187, 0.23658854250818673, 0.21901729000791836, 0.2721383747488585, 0.08368194509811333, 0.2459761344655622, 0.04895137371361491, 0.6137816462932703, 0.6004128006342846, 0.6109305272854009, 0.6132862242726739, 0.6210861183677638, 0.6039366270621249, 0.6183324829998447, 0.5992094276810569, 0.6043967365403451, 0.6573503602281447, 0.0931329382941698, 0.14029096510687977, 0.14595720234439158, 0.14500399197967295, 0.14267382274220364, 0.14019112906791464, 0.10269465309840109, 0.12334263791436606, 0.4433791005931095, 0.21680809122803646, 0.21016441725421287, 0.2459527166901353, 0.20920978419006753, 0.16608176736028712, 0.20761870871736532, 0.217098283746595, 0.2598147648372904, 0.26275030813498856, 0.45033825476599876, 0.48666904775280795, 0.45675194110550843, 0.4822469279236561, 0.3426329659517158, 0.38177957362616266, 0.5262440889946313, 0.48555632632305, 0.2280222982613187, 0.2551000148506837, 0.38273034061964994, 0.35883952789976126, 0.2725188522549319, 0.33176683833874254, 0.23438048718827287, 0.15702407210835723, 0.33811143632420904, 0.1732484529087418, 0.22353813409612489, 0.20781693094670728, 0.20080060528141985, 0.2056234067759678, 0.19808714758602797, 0.21012731054856504, 0.20495054752888997, 0.1999643857494401, 0.19791642866923875, 0.19181566442068543, 0.4909578295194903, 0.24945345332495206, 0.20711348942114527, 0.2203083354442289, 0.2158460337006154, 0.2085622771606308, 0.2230879606829833, 0.17633648710371397, 0.900982608284106, 0.15892667258268978, 0.19739214510253933, 0.9062242400707683, 0.15577092219466848, 0.13633358747473245, 0.1779234007432613, 0.17567553567956096, 0.6737290572737213, 0.2115927233490178, 0.21233638447314007, 0.2077373918188712, 0.16950373563046983, 0.16899363106822507, 0.1671210005661654, 0.8333857668257383, 0.2113199723742456, 0.18179888552339984, 0.21173001282060744, 0.18252838586688258, 0.1898114021184386, 0.1848431500745501, 0.1990871281378872, 0.1801457711375679, 0.17671083983643565, 0.19195350367094477, 0.08392901940355912, 0.09784915224310331, 0.09384212890090093, 0.1124205456978894, 0.08392152133742425, 0.08469823620295269, 0.09855150706363691, 0.0938982317731597, 0.09018016073283086]}, "mutation_prompt": null}
{"id": "40f53412-9edc-4455-8e77-9e9dc150099d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improved the mutation strategy by enhancing the diversity factor scaling for more robust exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.855254594285909, 0.8648239776269577, 0.8625802381627854, 0.8647120064635749, 0.8765487962240156, 0.8611141660386882, 0.8619567329690346, 0.860691336899759, 0.8622054780258547, 0.7495821662339555, 0.7010567978062674, 0.733639663345403, 0.7239419287151415, 0.7538119503620407, 0.7304220081476829, 0.7425476322123244, 0.7524348503320609, 0.7570462526724202, 0.13215591538596094, 0.13145200816977742, 0.13347492700922137, 0.162835861500377, 0.4011734750573892, 0.1427248939007153, 0.12584906978214383, 0.12772681916151685, 0.1410187080978894, 0.13211428097715183, 0.13157723965725876, 0.13732909147781158, 0.13221828262555246, 0.12889897048036947, 0.14724220263595522, 0.11531363419270235, 0.1258373574186984, 0.10849380354787386, 0.9816906977195767, 0.973183258523721, 0.9849688712085233, 0.9769609201287355, 0.9814541810080797, 0.9848196726138216, 0.9859922713312944, 0.9878213497769915, 0.9725414374720274, 0.6584325969709665, 0.6342727453693368, 0.6371722871587782, 0.6246743599453408, 0.6203806630495637, 0.6459995460876253, 0.6111030031744118, 0.625745631446754, 0.6320376174303131, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.30511675127710747, 0.33044249246924096, 0.32660898811979155, 0.29763322179914453, 0.3886652501002824, 0.4205218025738955, 0.30585741049789195, 0.3056437709993842, 0.45179534429856094, 0.15838790333720987, 0.28360196879434163, 0.29195145716058346, 0.3502349856458852, 0.3720980977960159, 0.26362427781578657, 0.2906379533429285, 0.2709270209935125, 0.1708945936652695, 0.08461441561439442, 0.13352231901162537, 0.13771182537900006, 0.131586491509187, 0.12088101927947248, 0.1225008260217113, 0.12083345705352, 0.12030783009504953, 0.1422531351261621, 0.2668758367488645, 0.2988203225809577, 0.27558259237415084, 0.23542115632111416, 0.2150183852606664, 0.23219430912277828, 0.2538700662370793, 0.21976208281830345, 0.256486698872884, 0.03482214698978514, 0.04707343299177558, 0.0592732932465333, 0.0961422392485316, 0.07538963237059304, 0.13228751589271814, 0.13266723443924278, 0.08538186730195862, 0.0805197057610969, 0.1901827653427457, 0.21489131360927727, 0.23037720124694205, 0.18832361813164966, 0.20861447704044278, 0.23938227312035487, 0.1759120976612505, 0.18674654071266006, 0.04854781884386716, 0.5984682753406079, 0.6075846430285852, 0.591707742539928, 0.6317935449551627, 0.5752437221454221, 0.6272392452868069, 0.6210630112071853, 0.6035581242180268, 0.5824863628187765, 0.0901202628976231, 0.11634923871902536, 0.10838430347410744, 0.13290674019686288, 0.10467247569521476, 0.09664934498544986, 0.13603135555247625, 0.12395919341190043, 0.10334362629189875, 0.17749563503989452, 0.20166733558513938, 0.31736553812974655, 0.17856758007717888, 0.3824628945777162, 0.18342863968203071, 0.34419878152615113, 0.21354862098495775, 0.33480429831451797, 0.41598989842980505, 0.4329423077542953, 0.4425708670668581, 0.47096291108510535, 0.4936725214197242, 0.510618975037489, 0.5292144640295439, 0.556679180696422, 0.5235840835806813, 0.25851692042679086, 0.24822206380022516, 0.3346939706455051, 0.30167416702491934, 0.2449288455603038, 0.3120015220868362, 0.28342099781289654, 0.22781329071488798, 0.2861475137175512, 0.2124725010240326, 0.21260780503703214, 0.1960096231885553, 0.23368420425689473, 0.20443517858667815, 0.19307020616786796, 0.20234417334455856, 0.19675158206224852, 0.2142958524816302, 0.2339462552618513, 0.20546162356105535, 0.24023723952795395, 0.21592344337197977, 0.6311929296903769, 0.20053808631084147, 0.21157873767824553, 0.21146476619070187, 0.5470207419724256, 0.18340734627925792, 0.8855755525560333, 0.18487067314261496, 0.1475425600875384, 0.8164194869376754, 0.7864065962981006, 0.7896547113419774, 0.7934007003503036, 0.1690530115238824, 0.12725238501159997, 0.2102944460780526, 0.21096933876640345, 0.7655329456345945, 0.16762707664349397, 0.16853053944716245, 0.09358005607374198, 0.7835646608993977, 0.20040494736104786, 0.18228780035365433, 0.18928382906183328, 0.20013051240981417, 0.19186955786549964, 0.18400383909385998, 0.19209696684761346, 0.17615619686961925, 0.2088251199912632, 0.19392130255101747, 0.07895735886052246, 0.08717086037800303, 0.09054522334748816, 0.10352103683893188, 0.08821646432279573, 0.08464519915456181, 0.09862824707386886, 0.07832612292527175, 0.0836753626029102]}, "mutation_prompt": null}
{"id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Tweaked the perturbation scale calculation to enhance diversity and convergence by using a more dynamic range.", "configspace": "", "generation": 76, "fitness": 0.37532669197271956, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "60c419a2-407a-4aa0-ae4c-5ac6e7b206af", "metadata": {"aucs": [0.871921993173987, 0.8782282028506291, 0.8698344217995295, 0.8797336504937215, 0.8761733668405137, 0.8612472056957419, 0.8714755002003318, 0.8774894945260258, 0.8827847863606155, 0.7863485830746758, 0.7598519810367959, 0.7698388850736579, 0.7843468416988014, 0.7650337243496097, 0.7579809101233825, 0.7790414473535452, 0.766966823457661, 0.7594594186748596, 0.13512032031115428, 0.5170768607315166, 0.13380246091054415, 0.16101682667555228, 0.14086957232221653, 0.15222854530452823, 0.14639617316491782, 0.16316465501438948, 0.4880608757805426, 0.10854345293819279, 0.15448144584028722, 0.10570732983769415, 0.1325920844621271, 0.12651706263137186, 0.13439455685546942, 0.1423110513257808, 0.12526899349989218, 0.13976134640619042, 0.9839025538705095, 0.9808215668911742, 0.9849803038093187, 0.9780771713200218, 0.9821398312338037, 0.9848199114606122, 0.9859834679818151, 0.9878212565883995, 0.9724863516306077, 0.6871940392994478, 0.6986242997622413, 0.6336285374643442, 0.7049696258607963, 0.6560384614628398, 0.7204439516004304, 0.6944986615670409, 0.6542259817379361, 0.6729142395320022, 0.7252611346262698, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8475523047481994, 0.8286301692591358, 0.829951705930096, 0.26678839179025426, 0.32424726351394906, 0.2537978028771434, 0.13149601646272835, 0.22536787299782435, 0.2628245740221258, 0.33471851339258096, 0.2433485333836206, 0.2534700098151743, 0.02169042947353572, 0.13136672925246007, 0.26557922073607454, 0.2829289027759324, 0.28626118468598805, 0.45550340650461607, 0.37838243526571036, 0.2889207119583336, 0.2538710632436407, 0.07928726721927015, 0.035753579418468906, 0.25022702658437834, 0.035649604800292445, 0.18432525454920123, 0.05874800886308762, 0.23489265676384807, 0.186126546983847, 0.27095237616022194, 0.07414530442726741, 0.40016082308055045, 0.28561622447810064, 0.33461884760331206, 0.3520922552405411, 0.2639776384913416, 0.19986946631924274, 0.33551080193934457, 0.3519321520789004, 0.03373558844394031, 0.04877357093150081, 0.13837456854815477, 0.07985965938083772, 0.07588570625461433, 0.11736554947669087, 0.19409293153697327, 0.09323455814866666, 0.07117182685672196, 0.13945694915917084, 0.20133443116466465, 0.29848849186139703, 0.15028735735047938, 0.23396523101832412, 0.21721092116048346, 0.2529705364801803, 0.19772175091775857, 0.1876897442183525, 0.6107190748513467, 0.6311084022538662, 0.5973431901084374, 0.6087178635721759, 0.6523850901436778, 0.6446790785947979, 0.6185551640543747, 0.6207805766292431, 0.6109958818410433, 0.09919067911764945, 0.13453245111515766, 0.12038993449794966, 0.11964422476030545, 0.12240815832894836, 0.11234995272048831, 0.11383046437737598, 0.1472502974258605, 0.11495843313312926, 0.2243983371691759, 0.4254500031328454, 0.28054154600908043, 0.5352808734910477, 0.2067979560638471, 0.21700294101252582, 0.1590234268776085, 0.22970223105230525, 0.15290994866161056, 0.4451512125557757, 0.5333722126003411, 0.5027295816995334, 0.5075728604405902, 0.47291537822143537, 0.3737525877322224, 0.287256696692453, 0.56278407340753, 0.4484072787938982, 0.31782827510754386, 0.28110648103230185, 0.2908309525192203, 0.377289022210177, 0.2933457393282042, 0.30721966095738085, 0.3010200373469377, 0.2548715406879244, 0.3492416066980132, 0.22689806567835147, 0.20898532730523034, 0.19272649533452046, 0.21079773169746985, 0.2580780334056413, 0.19655193285580075, 0.2170841857043564, 0.2215818130364361, 0.20839531229533337, 0.23753824127530465, 0.24300557218151542, 0.24203961529028806, 0.2427842605537489, 0.20064283930149718, 0.7517142776625745, 0.21861810491477862, 0.2363099930024377, 0.686942286342564, 0.16512010137146682, 0.898701838725241, 0.1584749470582305, 0.1977618368932733, 0.9100386254507166, 0.16452130600275627, 0.7907837349956057, 0.17827019267818467, 0.16905908069942577, 0.12805579885486817, 0.21014847397040337, 0.21066556969205008, 0.7867665940607314, 0.16853230707406097, 0.16798050168251588, 0.8167532716354597, 0.8276966770051536, 0.10488562835586002, 0.1908436676592703, 0.19386241302601537, 0.19118462589340202, 0.1774668843157291, 0.1909566401072209, 0.19153029810398736, 0.17646936809130298, 0.1945875577249203, 0.19773870410202887, 0.11608896839695193, 0.08777185233801987, 0.10590933276213743, 0.08290802970622757, 0.08484319986135269, 0.09174990001267158, 0.11774668572489932, 0.0844561911274122, 0.08953357320555821]}, "mutation_prompt": null}
{"id": "1f3f3155-2534-46b0-a6e6-bd6eb0b7c9b0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Tweaked the perturbation scale calculation to enhance diversity and convergence by using a more dynamic range.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.871921993173987, 0.8782282028506291, 0.8698344217995295, 0.8797336504937215, 0.8761733668405137, 0.8612472056957419, 0.8714755002003318, 0.8774894945260258, 0.8827847863606155, 0.7863485830746758, 0.7598519810367959, 0.7698388850736579, 0.7843468416988014, 0.7650337243496097, 0.7579809101233825, 0.7790414473535452, 0.766966823457661, 0.7594594186748596, 0.13512032031115428, 0.5170768607315166, 0.13380246091054415, 0.16101682667555228, 0.14086957232221653, 0.15222854530452823, 0.14639617316491782, 0.16316465501438948, 0.4880608757805426, 0.10854345293819279, 0.15448144584028722, 0.10570732983769415, 0.1325920844621271, 0.12651706263137186, 0.13439455685546942, 0.1423110513257808, 0.12526899349989218, 0.13976134640619042, 0.9839025538705095, 0.9808215668911742, 0.9849803038093187, 0.9780771713200218, 0.9821398312338037, 0.9848199114606122, 0.9859834679818151, 0.9878212565883995, 0.9724863516306077, 0.6871940392994478, 0.6986242997622413, 0.6336285374643442, 0.7049696258607963, 0.6560384614628398, 0.7204439516004304, 0.6944986615670409, 0.6542259817379361, 0.6729142395320022, 0.7252611346262698, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8475523047481994, 0.8286301692591358, 0.829951705930096, 0.26678839179025426, 0.32424726351394906, 0.2537978028771434, 0.13149601646272835, 0.22536787299782435, 0.2628245740221258, 0.33471851339258096, 0.2433485333836206, 0.2534700098151743, 0.02169042947353572, 0.13136672925246007, 0.26557922073607454, 0.2829289027759324, 0.28626118468598805, 0.45550340650461607, 0.37838243526571036, 0.2889207119583336, 0.2538710632436407, 0.07928726721927015, 0.035753579418468906, 0.25022702658437834, 0.035649604800292445, 0.18432525454920123, 0.05874800886308762, 0.23489265676384807, 0.186126546983847, 0.27095237616022194, 0.07414530442726741, 0.40016082308055045, 0.28561622447810064, 0.33461884760331206, 0.3520922552405411, 0.2639776384913416, 0.19986946631924274, 0.33551080193934457, 0.3519321520789004, 0.03373558844394031, 0.04877357093150081, 0.13837456854815477, 0.07985965938083772, 0.07588570625461433, 0.11736554947669087, 0.19409293153697327, 0.09323455814866666, 0.07117182685672196, 0.13945694915917084, 0.20133443116466465, 0.29848849186139703, 0.15028735735047938, 0.23396523101832412, 0.21721092116048346, 0.2529705364801803, 0.19772175091775857, 0.1876897442183525, 0.6107190748513467, 0.6311084022538662, 0.5973431901084374, 0.6087178635721759, 0.6523850901436778, 0.6446790785947979, 0.6185551640543747, 0.6207805766292431, 0.6109958818410433, 0.09919067911764945, 0.13453245111515766, 0.12038993449794966, 0.11964422476030545, 0.12240815832894836, 0.11234995272048831, 0.11383046437737598, 0.1472502974258605, 0.11495843313312926, 0.2243983371691759, 0.4254500031328454, 0.28054154600908043, 0.5352808734910477, 0.2067979560638471, 0.21700294101252582, 0.1590234268776085, 0.22970223105230525, 0.15290994866161056, 0.4451512125557757, 0.5333722126003411, 0.5027295816995334, 0.5075728604405902, 0.47291537822143537, 0.3737525877322224, 0.287256696692453, 0.56278407340753, 0.4484072787938982, 0.31782827510754386, 0.28110648103230185, 0.2908309525192203, 0.377289022210177, 0.2933457393282042, 0.30721966095738085, 0.3010200373469377, 0.2548715406879244, 0.3492416066980132, 0.22689806567835147, 0.20898532730523034, 0.19272649533452046, 0.21079773169746985, 0.2580780334056413, 0.19655193285580075, 0.2170841857043564, 0.2215818130364361, 0.20839531229533337, 0.23753824127530465, 0.24300557218151542, 0.24203961529028806, 0.2427842605537489, 0.20064283930149718, 0.7517142776625745, 0.21861810491477862, 0.2363099930024377, 0.686942286342564, 0.16512010137146682, 0.898701838725241, 0.1584749470582305, 0.1977618368932733, 0.9100386254507166, 0.16452130600275627, 0.7907837349956057, 0.17827019267818467, 0.16905908069942577, 0.12805579885486817, 0.21014847397040337, 0.21066556969205008, 0.7867665940607314, 0.16853230707406097, 0.16798050168251588, 0.8167532716354597, 0.8276966770051536, 0.10488562835586002, 0.1908436676592703, 0.19386241302601537, 0.19118462589340202, 0.1774668843157291, 0.1909566401072209, 0.19153029810398736, 0.17646936809130298, 0.1945875577249203, 0.19773870410202887, 0.11608896839695193, 0.08777185233801987, 0.10590933276213743, 0.08290802970622757, 0.08484319986135269, 0.09174990001267158, 0.11774668572489932, 0.0844561911274122, 0.08953357320555821]}, "mutation_prompt": null}
{"id": "9ee77e65-cb62-4eec-b7db-c2da47f32d63", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        # Adjusted perturbation scale to better exploit high variance situations\n        perturbation_scale = 0.5 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced mutation strategy to better exploit the search space by increasing perturbation scale for high variance.", "configspace": "", "generation": 78, "fitness": 0.3705618365402813, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.859282728484859, 0.8769490437095998, 0.8676459665689533, 0.8707365980212276, 0.8731576133245804, 0.8553388690882917, 0.8632347878341795, 0.8583137024124377, 0.8687223600934344, 0.7596631748100099, 0.7723504197885835, 0.760757901878337, 0.7642956890116047, 0.7713916509951535, 0.7703908060704465, 0.7311358271714432, 0.7707380596430953, 0.7457102421125226, 0.13957684917195856, 0.1422124719122334, 0.14568377746454864, 0.16547676785466825, 0.1291327169306311, 0.1537295954309137, 0.16870688200127437, 0.11810924032975767, 0.1537287668452858, 0.12822805804970083, 0.12353431477518484, 0.10933558684553535, 0.12876923482853964, 0.13915459365309757, 0.11061558778661074, 0.12764335080463896, 0.1354657321017243, 0.16129219884538493, 0.9839412744576336, 0.9763565461227204, 0.9849707117401992, 0.9772571000572909, 0.9814467538423878, 0.9848197907794858, 0.9859866990674983, 0.9878211748222947, 0.972505240979932, 0.668906635312005, 0.6533208552658064, 0.6606826214017898, 0.6543320100324346, 0.606871243242049, 0.6867568550430874, 0.6860606049533831, 0.622654413536342, 0.6489005527292233, 0.8220918764520377, 0.22408439927874502, 0.819340509253397, 0.8365977671731306, 0.2123922379751384, 0.2076028691487588, 0.23898864974109124, 0.7759209578627487, 0.7768170080386132, 0.32896473496925105, 0.2781758435164877, 0.3388792913401054, 0.24865957847868025, 0.1306033625381331, 0.3782996078105463, 0.32126025326697205, 0.3639674034723952, 0.36272404780326883, 0.37040076412040945, 0.2831889575508003, 0.3047574172935228, 0.31550051212868546, 0.3286499093661981, 0.48066112843878117, 0.3949292789846438, 0.12938297682752886, 0.1272088095550069, 0.08243023827745677, 0.17178352440263134, 0.1727846614870857, 0.15534526084805456, 0.1837976743444223, 0.17044991659018072, 0.14626284817633073, 0.14693097036621583, 0.1594908317457766, 0.2557755520098637, 0.31001244955378493, 0.2736463831264312, 0.2862067855553547, 0.3251941297091756, 0.2927175596451076, 0.277718381609696, 0.2898627381195731, 0.31947927202986315, 0.034670915439208194, 0.12659730725837048, 0.17178688011336163, 0.07531758042967485, 0.07546216830885566, 0.28969515234776133, 0.16432064871816543, 0.26568742758182073, 0.07878015909779901, 0.13579292738854676, 0.25858498331098567, 0.190557830925423, 0.2702483665977661, 0.24815054081397425, 0.2688903389388628, 0.24067909776194807, 0.19418181445231342, 0.05757924330310693, 0.5982492364167591, 0.5920885062275492, 0.6084478071806798, 0.622801222281873, 0.6206393945580821, 0.6319972474277662, 0.6030958695596544, 0.6038512684224266, 0.5826963520752535, 0.10351734165045667, 0.14485243992033592, 0.09377059477732164, 0.13028231369102816, 0.09248067128379756, 0.14531874029925873, 0.12754280814527352, 0.127241657703829, 0.11400675105119007, 0.15481399491830383, 0.32707885296289685, 0.1829564783093811, 0.5246827120655957, 0.2755175808504171, 0.26426603581326136, 0.5692684311357592, 0.16100622439430357, 0.184854328587015, 0.4741555286068774, 0.5567803013622734, 0.47395586023671243, 0.5040625833793726, 0.3209232045506383, 0.5358063965860714, 0.6827479516783059, 0.5564747109093644, 0.5235300237514753, 0.33116834620436486, 0.34315479943722693, 0.3063856810567659, 0.27104912978835793, 0.3725771575395541, 0.3664884817372961, 0.35735500497463357, 0.21394797983479896, 0.3254986278276034, 0.22146686094614476, 0.21089534857197145, 0.23028653432409507, 0.21542636696678663, 0.19463034065691365, 0.18851495287826625, 0.22161700840822807, 0.2001409428370141, 0.22044905074394705, 0.21883001815912195, 0.2224457144580454, 0.20196850155513513, 0.21697853078627616, 0.20264461002214051, 0.7543857284824156, 0.23987947458689696, 0.24205624281567584, 0.21749998206008636, 0.18320294354480915, 0.8940903261692383, 0.18386293158180456, 0.14731307195272692, 0.8503589749862404, 0.16827842957816608, 0.8012168901470365, 0.177537248623167, 0.16930166234351984, 0.6017799202446181, 0.2106774615025705, 0.21183154339821264, 0.20411543379595398, 0.1682159255431528, 0.747616915917479, 0.196227891818475, 0.8325399231207332, 0.20957242499063888, 0.18310543419016967, 0.1838117583695862, 0.1871357961497312, 0.20970142802517544, 0.18410386557698988, 0.19674819549820266, 0.19508546129375437, 0.18758128751355396, 0.19633109684548378, 0.09707487162720996, 0.08861884308044443, 0.08422278194544197, 0.1093156568910768, 0.08985908432172962, 0.08034365001433486, 0.10674682510127909, 0.08203029408976181, 0.08757263967192208]}, "mutation_prompt": null}
{"id": "20242704-8aa3-4bc1-a3c5-41f36feac695", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.3 + 0.7 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced mutation strategy to better exploit fitness variance for improved convergence.", "configspace": "", "generation": 79, "fitness": 0.355481373445383, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.8736557537795465, 0.8839111889769062, 0.8876117112432975, 0.8732017165972745, 0.8815068599700215, 0.8759077337451482, 0.8788748590091119, 0.8804814060619397, 0.8841656753033488, 0.7886741913032831, 0.7617936592420259, 0.7699017711771647, 0.7841857331492479, 0.6422941229623081, 0.7738384880478415, 0.7191874167393137, 0.7619974140141264, 0.7659173123290851, 0.4347870973631017, 0.14635667531037688, 0.1720648145159661, 0.16026218401665682, 0.1694497918578769, 0.1387815725708319, 0.1473976700079711, 0.14371994151423673, 0.11289281878563129, 0.12736939622466403, 0.1368170056006497, 0.11248039944018329, 0.15055634478939606, 0.12839718436384318, 0.12565852020084567, 0.1111565265877893, 0.11915769969712364, 0.12585942693475993, 0.9838841769789655, 0.9808193665636029, 0.9850116565920816, 0.9793319477634509, 0.9821382532995006, 0.9861385829790693, 0.9859834503146324, 0.9878215590701516, 0.9724740632007998, 0.7196173537298187, 0.6850675489139534, 0.5828073834744054, 0.7306335655424878, 0.6927148858313343, 0.7205529602959448, 0.7096997214197638, 0.712340491837686, 0.6673159787091748, 0.8405134310145286, 0.7669473657163528, 0.8256954983077953, 0.27850842465894377, 0.8519196690147574, 0.19297142427730885, 0.722684264332909, 0.22173480925237687, 0.8406398046621357, 0.13105170877810146, 0.22783386154784768, 0.5827080798636977, 0.19824912717375864, 0.4871298210243219, 0.23487681072771793, 0.3083652781236331, 0.18626839041774212, 0.22193345958683008, 0.11984011516861626, 0.1295766234911192, 0.19353909509727896, 0.28885851927362693, 0.2654985661942685, 0.33428929167062515, 0.24743659066471402, 0.2572376554764223, 0.25198270957505897, 0.06837557228018287, 0.03640476037688245, 0.08268519927945162, 0.05430948707069749, 0.014989602702576876, 0.27630225739333136, 0.00015857361345661403, 0.039110599239845945, 0.14381981303088764, 0.10823748487377194, 0.21048165073647385, 0.28870429328838965, 0.09370382249937725, 0.21339711966912367, 0.31161120866867864, 0.13477330158723766, 0.16732873478398036, 0.16635276920328124, 0.037394142861219226, 0.1180546785892782, 0.26096731080529767, 0.07600280701060402, 0.0831913368442998, 0.09384267892664233, 0.24415242076473453, 0.10076187735558173, 0.0733640492485319, 0.08661617238236508, 0.18077121208350233, 0.10678319626043886, 0.18642299854697064, 0.28974715039790233, 0.10602641164962112, 0.1243453717209444, 0.15585085704312174, 0.059122307114876094, 0.6052648265432454, 0.6237149482028628, 0.5813828720253159, 0.6004849481536438, 0.6072136207187211, 0.6355499794513668, 0.6249284269069073, 0.6364309383348203, 0.6133217619595215, 0.08324485447226593, 0.1246814726089599, 0.10347195700442624, 0.1451086268802334, 0.1153916180668142, 0.12600291560068422, 0.1221277562787152, 0.12571311748889824, 0.12538086758721878, 0.39751306803033826, 0.16031247822955774, 0.2466149564025243, 0.3186697791592784, 0.21246851447842963, 0.3199958778102605, 0.4022763549393761, 0.2420818559444018, 0.2616471874194032, 0.48795397508811766, 0.36315461415721506, 0.3312797374167614, 0.5074092287110629, 0.2465049849761971, 0.3073178057340834, 0.470352378213163, 0.2864567947660377, 0.47878249220379854, 0.19999535070542906, 0.40584300634659354, 0.28603961616294715, 0.38125155251836196, 0.20143730440557361, 0.34223253215672167, 0.1371483505683747, 0.21974425630427297, 0.3590833231232463, 0.19968522819144663, 0.2200383765188756, 0.2142263320058163, 0.20991411265077042, 0.20239159825498032, 0.20264044200236164, 0.3222995260480238, 0.20743874748139146, 0.21707169239144963, 0.24121891504099724, 0.22406054131372066, 0.20575578055853438, 0.21622614688650232, 0.18922049631405058, 0.2153981475961092, 0.21552114317444937, 0.20200879650112824, 0.1935674870731694, 0.16516999184928227, 0.9026926808743205, 0.16394701612274531, 0.1479826508165274, 0.9113365876394417, 0.16752705067851426, 0.8396761205900682, 0.17854823713269286, 0.8452885574458397, 0.12804076561012212, 0.1689640864979285, 0.20973059055759202, 0.761238707965773, 0.6260933383017682, 0.1685923352268306, 0.2081824517572306, 0.8333221895568999, 0.20981523236648514, 0.1988790381796829, 0.18403888952698944, 0.1872207774854645, 0.18142553928202498, 0.1798673998027983, 0.20112112651674374, 0.18912574338752242, 0.18526592458586355, 0.18817501521241442, 0.08292758120771138, 0.09327665419498588, 0.11121134477543615, 0.10429419626711534, 0.08906956145541534, 0.09293136717825512, 0.12225358391495389, 0.07857777866239635, 0.08942150237119384]}, "mutation_prompt": null}
{"id": "3cf01170-b636-4cfb-ba20-2f7bf5a23a78", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.7 - 0.7 * (self.current_evaluations / self.budget)  # Changed from 1.5 to 1.7\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.3 + 0.7 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Changed from 0.4 to 0.3\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced social influence and mutation strategy to improve convergence and diversity balance.", "configspace": "", "generation": 80, "fitness": 0.3582957811296944, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.854384235730997, 0.8646548808777228, 0.8723130821764099, 0.8737782470469189, 0.864976266394021, 0.8705036075617443, 0.8640203477840803, 0.8697393658429099, 0.8777680000989363, 0.7591069802789586, 0.7406631631848128, 0.7718003673895169, 0.777445649251848, 0.7481394092835512, 9.999999999998899e-05, 0.7738270995240841, 0.7691215507699645, 0.7689741312790003, 0.1338558884925376, 0.5232693516342584, 0.17246705188110334, 0.13260389513438875, 0.14164988375608667, 0.13932215145092197, 0.14524697800988307, 0.1615253055061423, 0.13400155203198394, 0.10955341821316633, 0.14198787139923785, 0.09179438756198177, 0.14097891409056607, 0.14329206910011583, 0.11207814435527874, 0.11034380882318695, 0.11015394959989677, 0.13591531534849566, 0.9841394221271721, 0.9818048909753154, 0.985191649944889, 0.9813542563296567, 0.9821222362008526, 0.9870116132386137, 0.9861739272779558, 0.9880545283535018, 0.9724285633852379, 0.6860870813664866, 0.6999267008887183, 0.6579165677804095, 0.7074455157749316, 0.66519326555995, 0.6843634628197084, 0.6792603388339221, 0.6867403035878752, 0.6463752958611703, 0.8604447432510337, 0.22360925291081923, 0.8610809756907338, 0.8987984346046545, 0.8161283517492984, 0.2125585259568895, 0.8299083624506562, 0.2296611742249809, 0.3927328666653117, 0.1957691290897623, 0.3181384175906161, 0.22083370337404884, 0.18778927255260425, 0.13384761710810522, 0.1318601981622458, 0.25021651847861415, 0.24744030542133133, 0.25413784498291725, 0.12366743814916159, 0.242834893211767, 0.114047246795842, 0.2589482826765226, 0.25813037363240066, 0.28426517519741124, 0.2624322709960263, 0.2555601170459979, 0.26296854117437796, 0.07423726779754236, 0.07264992018192828, 0.16522641748027567, 0.008916668622474977, 0.011710517187100589, 0.07791426714279204, 0.005127958514869579, 0.01569962538323122, 0.14695952392215117, 0.14149497254915988, 0.3953165967743111, 0.4617199521560508, 0.2836037925029956, 0.14592743902210148, 0.09142576193418339, 0.27704663326857204, 0.20743925958757936, 0.1899568933242568, 0.03432526830295679, 0.06017158536839162, 0.11940449701787181, 0.07488622943512457, 0.07450975102189494, 0.09169667678255278, 0.06823212896865005, 0.09529310636844457, 0.07093924268424001, 0.04433173462509532, 0.19975134188377908, 0.054134334750648105, 0.04312831958685315, 0.3342788718249914, 0.14701671850643128, 0.18829789338464786, 0.23085691668715513, 0.05615753513164201, 0.6381887170199192, 0.6272382969310863, 0.5870706288760348, 0.6532333403257844, 0.6071441135926465, 0.635882243637188, 0.6236737644251985, 0.598400776390958, 0.6220997866588976, 0.09277538730503143, 0.12265937349443068, 0.10990637607471831, 0.17325287830998082, 0.10828279366513738, 0.13972901080877143, 0.10673396288933179, 0.6413506639920058, 0.12493717092747281, 0.28955535811022814, 0.21313945119461664, 0.27605688095072034, 0.1841565433426542, 0.223264811092315, 0.29968801850024174, 0.2265218623579912, 0.20826419924145867, 0.2344887427910357, 0.4465839545010246, 0.5089345403063226, 0.5027246258008817, 0.5393899048428399, 0.21106534773586882, 0.5317987015247776, 0.4388673876516128, 0.4724599481514016, 0.2983864245033955, 0.19322932929812853, 0.26228782896259295, 0.26804472871811014, 0.30418705607139407, 0.3975143671092094, 0.3769297910034656, 0.22808683495380433, 0.4888197048025038, 0.3227338671803657, 0.2275287572265785, 0.243529923262767, 0.22337721347397377, 0.21819629377912053, 0.21553080101980626, 0.21613403541990595, 0.2286335260047877, 0.17574762383531506, 0.20150154997202674, 0.21725743412000742, 0.20732306017676072, 0.21787957307241546, 0.2121599822588921, 0.18826211006637705, 0.7052881163947267, 0.21370045280706607, 0.2123016818692368, 0.5933337846771964, 0.2006271295710087, 0.9108993512903638, 0.820366611068896, 0.19056135475863567, 0.89480442444385, 0.8464021854315651, 0.12246308766216407, 0.1776541228133105, 0.8441389535531518, 0.1273419943355386, 0.16841692608563585, 0.20969680552483327, 0.7178326335910052, 0.1692142298947671, 0.1677222119539007, 0.6531310421938821, 0.8496674916194306, 0.10401276427757189, 0.18779921198329885, 0.178722192962682, 0.17524602284174817, 0.20179148738609887, 0.1894226571449953, 0.1914113851272471, 0.1897390894890938, 0.18385398858185964, 0.18748203541804764, 0.10358351308284641, 0.08366547713235539, 0.0889457899953543, 0.1466152357539119, 0.09431719664356819, 0.08533106652564615, 0.11207524929444512, 0.09827681160237278, 0.09068998352024282]}, "mutation_prompt": null}
{"id": "7c5e5040-9afa-4e4b-8d77-3736cb956bcf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.6 + 0.4 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced balance between exploration and exploitation by dynamically tuning perturbation and update strategies.", "configspace": "", "generation": 81, "fitness": 0.37092947906897045, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.8559563819969241, 0.8605099811344881, 0.8614830316151113, 0.8640771709555561, 0.8759129051587805, 0.8606005505425313, 0.8646465432495538, 0.8585430117933656, 0.8602974042654522, 0.7484569895561515, 0.7009692175565954, 0.7321891033874202, 0.7261831534743151, 0.7581118846873328, 0.7287940148983808, 0.7421385051994743, 0.7513640477630955, 0.7544217090909333, 0.13215587076260304, 0.13145200790941658, 0.13347492711013742, 0.16283586034785824, 0.40394566186249936, 0.14272489413471978, 0.1258490559838259, 0.12772681930247087, 0.14101870804038863, 0.13211428085947174, 0.1315772397342655, 0.1373290922823429, 0.13221828256199553, 0.1288989704749427, 0.14724220502534902, 0.11531363436512931, 0.12583735739711266, 0.1084938039336123, 0.9816906977207766, 0.9731832585191666, 0.9849688712085192, 0.9769609201292401, 0.9814541810080682, 0.9848196726138233, 0.9859922713312712, 0.9878213497769903, 0.9725414374708778, 0.6592898293250898, 0.622177568896035, 0.6327133882159348, 0.6261333808490414, 0.6119199649169647, 0.6474870151425862, 0.6110664100614367, 0.6252244259797565, 0.6360875458032649, 0.7568386194604887, 0.7550568864261996, 0.7852848118642284, 0.7988000019704664, 0.8125927038523127, 0.7712820344631932, 0.7877487287049953, 0.7029262877792166, 0.7784117776376345, 0.302015590233886, 0.32993123564289584, 0.3264356545006081, 0.2976310649697216, 0.38593286854158415, 0.416375023964601, 0.3058464825491042, 0.30356452691770675, 0.45364320173316086, 0.15838790334060815, 0.2835749493207096, 0.2919652064022953, 0.3581087998732795, 0.3721312347503968, 0.26363895447925223, 0.28990868114197954, 0.27095253135595254, 0.17089431099823882, 0.08461441561439442, 0.13352231901162537, 0.13771182537896365, 0.13158649150918678, 0.12088101927946338, 0.1225008260217113, 0.12083345705345105, 0.12030783009505253, 0.14225313512620108, 0.2668758367488885, 0.2988203225806324, 0.2755825923741523, 0.23542115632097516, 0.2150183852606249, 0.2321943091228248, 0.25387006623733765, 0.21976208281835607, 0.25648669887275577, 0.034822146990443836, 0.047073433011444066, 0.0592732932465333, 0.09614223924843313, 0.07542502247140781, 0.13228751589528254, 0.13266723443927697, 0.08538186730113029, 0.0805197055773137, 0.19018287072417217, 0.21489135455967312, 0.23037723612375627, 0.18832359935344634, 0.20861453482910608, 0.23938754202514778, 0.17591207444839296, 0.18674654017069636, 0.04854781884315962, 0.5800683920242747, 0.5881311800450513, 0.5976576684632013, 0.6486735665857386, 0.5983328485347581, 0.5993228765770235, 0.5815173479255358, 0.6490075370717662, 0.6052766353873991, 0.09012026151688368, 0.1163492388966153, 0.10838430370880792, 0.13290674354094356, 0.10467247491593279, 0.09664934228152311, 0.13603135562634183, 0.12395919713350922, 0.10334362332739311, 0.17749229456514604, 0.2016697887266582, 0.3172281939217775, 0.17856760565333485, 0.39799525139230396, 0.18342868730658957, 0.3447939039411003, 0.2135322264426751, 0.3248485438584089, 0.48337776882664263, 0.4297967309228238, 0.4419526497257038, 0.4414172242697776, 0.5253237789713299, 0.5020540523198811, 0.48363987361312266, 0.5616428505360662, 0.50450993430913, 0.25860110441608253, 0.24822287588868908, 0.33171850609209663, 0.3016965257686145, 0.24493201561217992, 0.31218547680865727, 0.28306249736134803, 0.22779173839065125, 0.28622860064639066, 0.212473007528162, 0.21260605811315847, 0.1960086646188075, 0.23368398690728165, 0.2044318505120868, 0.19307058561505486, 0.20234569492798538, 0.20069692641764436, 0.21429585961082498, 0.23394625552632564, 0.2054616243643772, 0.2402372304077025, 0.21592344366843774, 0.6314013615177207, 0.2005380903109113, 0.21157873747745448, 0.2114647724555352, 0.5455430165565356, 0.1834073488441088, 0.8856327766034638, 0.18487067169549853, 0.1475425555551867, 0.8164302998228076, 0.7864070308853517, 0.7896693014438488, 0.7932297938843154, 0.16905300629694697, 0.1272523691843287, 0.21029444703732902, 0.21096933722497702, 0.7648320647829563, 0.16762707829707035, 0.16853054017364189, 0.09358005501848987, 0.7838560493359836, 0.20040494858929436, 0.18228847532153336, 0.18928402074514317, 0.20012999776623097, 0.1918692957240371, 0.1840036231784834, 0.19209696649981867, 0.17615550354400478, 0.20882444634632746, 0.19392178016197237, 0.07895736017961918, 0.08717086190834344, 0.09054523877711307, 0.10352103689404835, 0.0882164579030803, 0.08464520160684919, 0.09862825722789781, 0.07832612168734576, 0.08367535942171145]}, "mutation_prompt": null}
{"id": "b2fb92d6-75d1-46e7-9e9e-45f45c61f9dd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            mutation_probability = 0.1 + 0.2 * ((fitness_variance / (np.max(fitness_variance) + 1e-5)) *\n                                                (1 - self.current_evaluations / self.budget))  # Adjusted\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploration by adjusting the probability of mutation dynamically based on both fitness variance and current evaluations.", "configspace": "", "generation": 82, "fitness": 0.3632836954777237, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.8661411518522356, 0.8828581881250845, 0.8797825828594341, 0.8730641168852835, 0.8734867736643686, 0.8770282847604465, 0.8781024002633808, 0.8730703005983794, 0.8769580843361788, 0.7852216397952505, 0.7857936437573596, 0.7312920206596861, 0.7775670023058643, 0.7442976467112379, 0.7594192171588587, 0.7684346403622717, 0.7701625205449013, 0.7731941333859642, 0.14845522927379373, 0.14774672816730183, 0.13906023245590726, 0.15136400207182055, 0.15792448849827156, 0.13251965015083256, 0.6824927764747832, 0.18540864257441148, 0.47530493541323915, 0.14576631336883272, 0.15190686933280706, 0.10730660029796457, 0.14607379100568563, 0.11273602451900389, 0.13634640024400946, 0.11854655346995135, 0.14805190815422697, 0.13856463699154176, 0.9839025538705095, 0.9808215668911742, 0.9808854855173117, 0.9780771713200218, 0.9821398312338037, 0.9859941924097059, 0.9859834679818151, 0.9878212565883995, 0.9627387989987672, 0.7234325666695962, 0.6978558541843187, 0.6413451731335597, 0.6949606017108076, 0.3005492187121156, 0.5917289567913797, 0.6732090017857884, 0.6926113167609622, 0.6699263913172107, 0.21685737986653442, 0.784713469971431, 0.8556172069559935, 0.8808100814595665, 0.7822439199724032, 0.21293974922048287, 0.8165324928249633, 0.7534512261232074, 0.8315113516664261, 0.1753560881423919, 0.3625837457479104, 0.21728666934771113, 0.1269040738977366, 0.24806528672054207, 0.1337263306833092, 0.3331272862192747, 0.22678366298684416, 0.12621015416535775, 0.11676156795213155, 0.26390237465862754, 0.2632394177526295, 0.3880474511590759, 0.2982667814843617, 0.2730916452641854, 0.12946437601891225, 0.2781739012553377, 0.28614828719643814, 0.056931852974330455, 0.04697055658530569, 0.08907662640867586, 0.13958656630496658, 0.07995834292931447, 0.09732892071414301, 0.1485174805488625, 0.15824640438669335, 0.19767157676605962, 0.07209310945421699, 0.3001892142553082, 0.2939307006005728, 0.2856589283243437, 0.21672792390957674, 0.3131484068885757, 0.17398926605228937, 0.2527539724924789, 0.3051275138293321, 0.03488090704569802, 0.05399051510085062, 0.19042618132256817, 0.0768778329511931, 0.07628490332053772, 0.09379193769893213, 0.14843422795042738, 0.17636915691160482, 0.07563816166899195, 0.13825581218351257, 0.19128537948326452, 0.11372729089898881, 0.25344113720500216, 0.1953317031754893, 0.17829544348089943, 0.14207531120314254, 0.21886778033689813, 0.057385599680481736, 0.6019490851261793, 0.570514455792927, 0.5974827873353323, 0.6374744285275292, 0.6079628521552998, 0.6197661331939217, 0.5997260925186054, 0.6233192756161445, 0.6232427724886296, 0.07844308186969351, 0.13513669330484368, 0.10671877563927978, 0.1673052291701912, 0.10235573998281855, 0.12046183251716991, 0.12539750382811454, 0.14953004668650394, 0.11009914293332623, 0.25048222675913656, 0.19140556565608502, 0.2655548432180209, 0.2698058708137592, 0.18029248946058507, 0.3094944976393086, 0.16645997851794836, 0.24512721340195276, 0.18059582383045203, 0.37762191774686193, 0.4060351734277404, 0.27113031128312537, 0.49785731259038624, 0.3323458733626684, 0.5092496613511046, 0.5460430483675978, 0.4811798218339681, 0.5394106797863885, 0.26274943678585283, 0.29554136141989285, 0.290804166464784, 0.21205315646998857, 0.21493807036859547, 0.39085441262821596, 0.2739324920969932, 0.3636701934462776, 0.27343733888709587, 0.21842444289388563, 0.19138519902224893, 0.2061026894149952, 0.20143388195778622, 0.20271496966265623, 0.19128622392770633, 0.1925413317711535, 0.20900899588019906, 0.22132368529212776, 0.2399243149118886, 0.31046682231918243, 0.22571957823318411, 0.7245239019120813, 0.18962525214820758, 0.24497594444905113, 0.20500857159440777, 0.2182388689065401, 0.20705654759183167, 0.7933583926994656, 0.888014139529764, 0.15794858541346335, 0.19811291833751288, 0.9008360230635545, 0.20577959211032126, 0.7451513371553753, 0.17834518831955193, 0.1691040390787979, 0.581569862170142, 0.210546220028774, 0.21054698442438036, 0.8225900624974913, 0.16854128093357812, 0.16810724974498992, 0.76166073984109, 0.2086470632822397, 0.21020732068734882, 0.18906817947797294, 0.18658910605156231, 0.18527684727269966, 0.18788771983727381, 0.18302127840227833, 0.19128027851883622, 0.18415779961131917, 0.21265178143483665, 0.18402661771877793, 0.11209013442114579, 0.09367881063645378, 0.08987056598567922, 0.1193315712698364, 0.09233241257832414, 0.08887347375435928, 0.0985743960307216, 0.08908936868417572, 0.08717463386866697]}, "mutation_prompt": null}
{"id": "6d4851e4-b3b1-4ac8-a3e9-67b08fdee0c2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Tweaked the perturbation scale calculation to enhance diversity and convergence by using a more dynamic range.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.871921993173987, 0.8782282028506291, 0.8698344217995295, 0.8797336504937215, 0.8761733668405137, 0.8612472056957419, 0.8714755002003318, 0.8774894945260258, 0.8827847863606155, 0.7863485830746758, 0.7598519810367959, 0.7698388850736579, 0.7843468416988014, 0.7650337243496097, 0.7579809101233825, 0.7790414473535452, 0.766966823457661, 0.7594594186748596, 0.13512032031115428, 0.5170768607315166, 0.13380246091054415, 0.16101682667555228, 0.14086957232221653, 0.15222854530452823, 0.14639617316491782, 0.16316465501438948, 0.4880608757805426, 0.10854345293819279, 0.15448144584028722, 0.10570732983769415, 0.1325920844621271, 0.12651706263137186, 0.13439455685546942, 0.1423110513257808, 0.12526899349989218, 0.13976134640619042, 0.9839025538705095, 0.9808215668911742, 0.9849803038093187, 0.9780771713200218, 0.9821398312338037, 0.9848199114606122, 0.9859834679818151, 0.9878212565883995, 0.9724863516306077, 0.6871940392994478, 0.6986242997622413, 0.6336285374643442, 0.7049696258607963, 0.6560384614628398, 0.7204439516004304, 0.6944986615670409, 0.6542259817379361, 0.6729142395320022, 0.7252611346262698, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8475523047481994, 0.8286301692591358, 0.829951705930096, 0.26678839179025426, 0.32424726351394906, 0.2537978028771434, 0.13149601646272835, 0.22536787299782435, 0.2628245740221258, 0.33471851339258096, 0.2433485333836206, 0.2534700098151743, 0.02169042947353572, 0.13136672925246007, 0.26557922073607454, 0.2829289027759324, 0.28626118468598805, 0.45550340650461607, 0.37838243526571036, 0.2889207119583336, 0.2538710632436407, 0.07928726721927015, 0.035753579418468906, 0.25022702658437834, 0.035649604800292445, 0.18432525454920123, 0.05874800886308762, 0.23489265676384807, 0.186126546983847, 0.27095237616022194, 0.07414530442726741, 0.40016082308055045, 0.28561622447810064, 0.33461884760331206, 0.3520922552405411, 0.2639776384913416, 0.19986946631924274, 0.33551080193934457, 0.3519321520789004, 0.03373558844394031, 0.04877357093150081, 0.13837456854815477, 0.07985965938083772, 0.07588570625461433, 0.11736554947669087, 0.19409293153697327, 0.09323455814866666, 0.07117182685672196, 0.13945694915917084, 0.20133443116466465, 0.29848849186139703, 0.15028735735047938, 0.23396523101832412, 0.21721092116048346, 0.2529705364801803, 0.19772175091775857, 0.1876897442183525, 0.6107190748513467, 0.6311084022538662, 0.5973431901084374, 0.6087178635721759, 0.6523850901436778, 0.6446790785947979, 0.6185551640543747, 0.6207805766292431, 0.6109958818410433, 0.09919067911764945, 0.13453245111515766, 0.12038993449794966, 0.11964422476030545, 0.12240815832894836, 0.11234995272048831, 0.11383046437737598, 0.1472502974258605, 0.11495843313312926, 0.2243983371691759, 0.4254500031328454, 0.28054154600908043, 0.5352808734910477, 0.2067979560638471, 0.21700294101252582, 0.1590234268776085, 0.22970223105230525, 0.15290994866161056, 0.4451512125557757, 0.5333722126003411, 0.5027295816995334, 0.5075728604405902, 0.47291537822143537, 0.3737525877322224, 0.287256696692453, 0.56278407340753, 0.4484072787938982, 0.31782827510754386, 0.28110648103230185, 0.2908309525192203, 0.377289022210177, 0.2933457393282042, 0.30721966095738085, 0.3010200373469377, 0.2548715406879244, 0.3492416066980132, 0.22689806567835147, 0.20898532730523034, 0.19272649533452046, 0.21079773169746985, 0.2580780334056413, 0.19655193285580075, 0.2170841857043564, 0.2215818130364361, 0.20839531229533337, 0.23753824127530465, 0.24300557218151542, 0.24203961529028806, 0.2427842605537489, 0.20064283930149718, 0.7517142776625745, 0.21861810491477862, 0.2363099930024377, 0.686942286342564, 0.16512010137146682, 0.898701838725241, 0.1584749470582305, 0.1977618368932733, 0.9100386254507166, 0.16452130600275627, 0.7907837349956057, 0.17827019267818467, 0.16905908069942577, 0.12805579885486817, 0.21014847397040337, 0.21066556969205008, 0.7867665940607314, 0.16853230707406097, 0.16798050168251588, 0.8167532716354597, 0.8276966770051536, 0.10488562835586002, 0.1908436676592703, 0.19386241302601537, 0.19118462589340202, 0.1774668843157291, 0.1909566401072209, 0.19153029810398736, 0.17646936809130298, 0.1945875577249203, 0.19773870410202887, 0.11608896839695193, 0.08777185233801987, 0.10590933276213743, 0.08290802970622757, 0.08484319986135269, 0.09174990001267158, 0.11774668572489932, 0.0844561911274122, 0.08953357320555821]}, "mutation_prompt": null}
{"id": "c88be986-d98a-4bb8-86a3-9136045b0931", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        # Adjusted perturbation scale to balance exploration and exploitation\n        perturbation_scale = 0.4 + 0.5 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced exploitation by adjusting the mutation strategy perturbation to balance exploration and convergence.", "configspace": "", "generation": 84, "fitness": 0.37520814547621484, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.8679963003539674, 0.8764158677318731, 0.8700884049607435, 0.877658214583138, 0.875680445224795, 0.8717020546576952, 0.8749052168928854, 0.8778821253182482, 0.8857305999452647, 0.7861445857002655, 0.7571977090879297, 0.7698595568134744, 0.7811091043717105, 0.7647304301817935, 0.7583500729028154, 0.7812546619727351, 0.7634553239861164, 0.7548859139382131, 0.13512031955918558, 0.5176213365285097, 0.13380246135764573, 0.16101682670345074, 0.1408695739040402, 0.15222855188243445, 0.1463961730567691, 0.16316465645427758, 0.49031775254234766, 0.10854345287374834, 0.15448144595999058, 0.1057073298364607, 0.13259208402534517, 0.12651706637311322, 0.13439455687044355, 0.14231104029533603, 0.12526899342515774, 0.13976134627461545, 0.9839025538701857, 0.9808215668912207, 0.984980303809546, 0.9780771713205663, 0.9821398312337927, 0.9848199114606139, 0.9859834679818141, 0.9878212565884013, 0.9724863516303297, 0.6808675207827806, 0.6933751262866636, 0.6290056510857196, 0.7029717138973812, 0.6467832497415438, 0.7207647000493801, 0.691843132518698, 0.662126036781866, 0.687100617183515, 0.7252611346262698, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8475523047481994, 0.8286301692591358, 0.829951705930096, 0.26599807105879314, 0.3277845502307909, 0.25014033780045775, 0.1314959626122203, 0.2091395289006095, 0.2626699129259087, 0.3343011497691063, 0.2440712817384072, 0.2502235639244089, 0.021690429474186534, 0.1313759109045083, 0.2678411319755827, 0.2845422490730867, 0.2842010429091054, 0.4752387856016953, 0.374660391961986, 0.280886791192584, 0.25232778906635456, 0.07928726721924417, 0.03575357941840007, 0.25022702657905627, 0.035649604800292445, 0.18432525454891768, 0.05874800886308762, 0.23489265678838045, 0.18612654698394682, 0.2709523761392201, 0.07414530442723577, 0.40016082309577083, 0.2856162244854621, 0.3346188476671792, 0.35209225521487586, 0.263977638490806, 0.19986946631926872, 0.3355108019286126, 0.35193215183805693, 0.033738413538251244, 0.04877357092356582, 0.13837456854354002, 0.07985965933717998, 0.07588561064074506, 0.11736554947456479, 0.19409293153732798, 0.09323455814735115, 0.07117182696527724, 0.13945692362029494, 0.20133351902708874, 0.29848492299746954, 0.1502873240588638, 0.23396509043969038, 0.21721093111009482, 0.25297044343833675, 0.19772180177859622, 0.1876896997009363, 0.6216778787696828, 0.6199013878961928, 0.619337268526013, 0.6078970199493877, 0.6352335840920598, 0.6250655130390628, 0.627887698278634, 0.628447576139061, 0.6040771768595665, 0.09919067914357405, 0.13453245550977355, 0.12038993481107396, 0.11964422476739178, 0.12240815830707275, 0.11234995059774688, 0.11383046467948721, 0.1472503078874583, 0.1149584330039195, 0.22440732401898067, 0.43612815371488, 0.2789888855297318, 0.5714410542610231, 0.206797987897681, 0.21700494131635384, 0.15902342135298642, 0.22970052274297859, 0.1529099930841934, 0.43502444003032037, 0.5227416750228435, 0.5025262030081201, 0.5430370462323759, 0.42728083247125814, 0.4231910707982274, 0.28718778545400026, 0.5056196647973692, 0.4527348160756517, 0.3188621017991595, 0.2808091157691771, 0.29111540618118525, 0.381609727686665, 0.29366315914250585, 0.3056942887134122, 0.3008830426453516, 0.25485807607814026, 0.34456027495394836, 0.2268973764659742, 0.20898549005179812, 0.192727948238532, 0.21079830098925223, 0.2580745326018108, 0.1965534190404734, 0.21708372262030373, 0.22158191830572982, 0.20839486725620537, 0.23753824098697274, 0.24300557209756946, 0.2420396159474093, 0.2427842611120189, 0.20064283728562338, 0.7468930069908257, 0.21861810242489732, 0.23630999299331856, 0.6821646930100953, 0.16512043619973338, 0.8988624766487379, 0.15847494660996597, 0.19776184089852555, 0.910037569059331, 0.16449193663192963, 0.7907838635654423, 0.17827009238103397, 0.16905908043672313, 0.1280557978856095, 0.21014847067368014, 0.2106655729672915, 0.7867439367444439, 0.16853230720635404, 0.16798050179736224, 0.8166611148841098, 0.8270215742409006, 0.1048856356856821, 0.1908441480404668, 0.19386300041436666, 0.19118548557425652, 0.17746707413300522, 0.1909553564719969, 0.1915302990559169, 0.17646982622840734, 0.1945858623198109, 0.19773876373380028, 0.11608896821003167, 0.08777185557974587, 0.1059093383592703, 0.08290802711978285, 0.08484320310328752, 0.0917498971770907, 0.11774670788483199, 0.0844561899080083, 0.08953357576415177]}, "mutation_prompt": null}
{"id": "e2c6c730-4733-4aa7-b035-354971a140ac", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Tweaked the perturbation scale calculation to enhance diversity and convergence by using a more dynamic range.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.871921993173987, 0.8782282028506291, 0.8698344217995295, 0.8797336504937215, 0.8761733668405137, 0.8612472056957419, 0.8714755002003318, 0.8774894945260258, 0.8827847863606155, 0.7863485830746758, 0.7598519810367959, 0.7698388850736579, 0.7843468416988014, 0.7650337243496097, 0.7579809101233825, 0.7790414473535452, 0.766966823457661, 0.7594594186748596, 0.13512032031115428, 0.5170768607315166, 0.13380246091054415, 0.16101682667555228, 0.14086957232221653, 0.15222854530452823, 0.14639617316491782, 0.16316465501438948, 0.4880608757805426, 0.10854345293819279, 0.15448144584028722, 0.10570732983769415, 0.1325920844621271, 0.12651706263137186, 0.13439455685546942, 0.1423110513257808, 0.12526899349989218, 0.13976134640619042, 0.9839025538705095, 0.9808215668911742, 0.9849803038093187, 0.9780771713200218, 0.9821398312338037, 0.9848199114606122, 0.9859834679818151, 0.9878212565883995, 0.9724863516306077, 0.6871940392994478, 0.6986242997622413, 0.6336285374643442, 0.7049696258607963, 0.6560384614628398, 0.7204439516004304, 0.6944986615670409, 0.6542259817379361, 0.6729142395320022, 0.7252611346262698, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8475523047481994, 0.8286301692591358, 0.829951705930096, 0.26678839179025426, 0.32424726351394906, 0.2537978028771434, 0.13149601646272835, 0.22536787299782435, 0.2628245740221258, 0.33471851339258096, 0.2433485333836206, 0.2534700098151743, 0.02169042947353572, 0.13136672925246007, 0.26557922073607454, 0.2829289027759324, 0.28626118468598805, 0.45550340650461607, 0.37838243526571036, 0.2889207119583336, 0.2538710632436407, 0.07928726721927015, 0.035753579418468906, 0.25022702658437834, 0.035649604800292445, 0.18432525454920123, 0.05874800886308762, 0.23489265676384807, 0.186126546983847, 0.27095237616022194, 0.07414530442726741, 0.40016082308055045, 0.28561622447810064, 0.33461884760331206, 0.3520922552405411, 0.2639776384913416, 0.19986946631924274, 0.33551080193934457, 0.3519321520789004, 0.03373558844394031, 0.04877357093150081, 0.13837456854815477, 0.07985965938083772, 0.07588570625461433, 0.11736554947669087, 0.19409293153697327, 0.09323455814866666, 0.07117182685672196, 0.13945694915917084, 0.20133443116466465, 0.29848849186139703, 0.15028735735047938, 0.23396523101832412, 0.21721092116048346, 0.2529705364801803, 0.19772175091775857, 0.1876897442183525, 0.6107190748513467, 0.6311084022538662, 0.5973431901084374, 0.6087178635721759, 0.6523850901436778, 0.6446790785947979, 0.6185551640543747, 0.6207805766292431, 0.6109958818410433, 0.09919067911764945, 0.13453245111515766, 0.12038993449794966, 0.11964422476030545, 0.12240815832894836, 0.11234995272048831, 0.11383046437737598, 0.1472502974258605, 0.11495843313312926, 0.2243983371691759, 0.4254500031328454, 0.28054154600908043, 0.5352808734910477, 0.2067979560638471, 0.21700294101252582, 0.1590234268776085, 0.22970223105230525, 0.15290994866161056, 0.4451512125557757, 0.5333722126003411, 0.5027295816995334, 0.5075728604405902, 0.47291537822143537, 0.3737525877322224, 0.287256696692453, 0.56278407340753, 0.4484072787938982, 0.31782827510754386, 0.28110648103230185, 0.2908309525192203, 0.377289022210177, 0.2933457393282042, 0.30721966095738085, 0.3010200373469377, 0.2548715406879244, 0.3492416066980132, 0.22689806567835147, 0.20898532730523034, 0.19272649533452046, 0.21079773169746985, 0.2580780334056413, 0.19655193285580075, 0.2170841857043564, 0.2215818130364361, 0.20839531229533337, 0.23753824127530465, 0.24300557218151542, 0.24203961529028806, 0.2427842605537489, 0.20064283930149718, 0.7517142776625745, 0.21861810491477862, 0.2363099930024377, 0.686942286342564, 0.16512010137146682, 0.898701838725241, 0.1584749470582305, 0.1977618368932733, 0.9100386254507166, 0.16452130600275627, 0.7907837349956057, 0.17827019267818467, 0.16905908069942577, 0.12805579885486817, 0.21014847397040337, 0.21066556969205008, 0.7867665940607314, 0.16853230707406097, 0.16798050168251588, 0.8167532716354597, 0.8276966770051536, 0.10488562835586002, 0.1908436676592703, 0.19386241302601537, 0.19118462589340202, 0.1774668843157291, 0.1909566401072209, 0.19153029810398736, 0.17646936809130298, 0.1945875577249203, 0.19773870410202887, 0.11608896839695193, 0.08777185233801987, 0.10590933276213743, 0.08290802970622757, 0.08484319986135269, 0.09174990001267158, 0.11774668572489932, 0.0844561911274122, 0.08953357320555821]}, "mutation_prompt": null}
{"id": "96246f51-b0df-440a-90b0-530347e47eec", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.2 * (diversity / (np.max(diversity) + 1e-5))  # Adjusted\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced adaptive inertia weight calculation to better balance exploration and exploitation.", "configspace": "", "generation": 86, "fitness": 0.3726773649354043, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.8515847488033128, 0.8528248946453134, 0.8527053483789321, 0.8424932504508638, 0.8607100096706712, 0.8550911838970061, 0.8609447090579172, 0.8572379847464555, 0.8656368283259777, 0.7743187136381467, 0.7604862354332464, 0.7361910220035226, 0.7656755194546601, 0.7417508719563033, 0.7299300773106729, 0.7001793197805171, 0.7643744188676176, 0.7477590428428009, 0.4059147663895467, 0.186576692233967, 0.15257916525812798, 0.1123228764530999, 0.15054138260444305, 0.5025299552130151, 0.13392739385756136, 0.14761777956385413, 0.15294372153534863, 0.10749730109128663, 0.1356830371633132, 0.10766216563636521, 0.14030372391122037, 0.12522130569636336, 0.1014595429997347, 0.12722891036695816, 0.11374146383971306, 0.12162408306945582, 0.9839221638028812, 0.9771666191881354, 0.9850490456396424, 0.9809791202705409, 0.9821338889400509, 0.9848829495660248, 0.9860166272281856, 0.9878445351648715, 0.9706632915030093, 0.6851140438761092, 0.6654618001273298, 0.5873739582309849, 0.6394240328417741, 0.6542666950625213, 0.6597355805556735, 0.7032413398227575, 0.6630977212467668, 0.6429919181078885, 0.8055586109610091, 0.7467682348127851, 0.8063349413719262, 0.8429472991402643, 0.7205944150896093, 0.8252259358471414, 0.8301695483090988, 0.7937951169900366, 0.8355135138785075, 0.3041388785503435, 0.2541464948951675, 0.12244914458385825, 0.22495524739501238, 0.28584282017039575, 0.2846728755851887, 0.3137681996331052, 0.18972509941587468, 0.24980070914367303, 0.11798754120024046, 0.2763038579860323, 0.25969768367473667, 0.3015767913166063, 0.3101380227093362, 0.5635958917868461, 0.3304923516501055, 0.24996044205079437, 0.24671529795541758, 0.07191550137841218, 0.21372330778877635, 0.23664778317338797, 0.03470301538233156, 0.03719047340448001, 0.20215069109129435, 0.2225308458019135, 0.02397412500722207, 0.24677140927678032, 0.1797890899161484, 0.334160070125608, 0.32162480480084465, 0.32719370324126384, 0.3177064616937456, 0.3966504594930198, 0.16166460107718716, 0.3600138196535061, 0.4146556661554086, 0.03333980313090801, 0.047964667912276826, 0.09320135950047259, 0.0737637245956344, 0.0761668997018875, 0.16849933502514647, 0.1328854489870046, 0.09441735365376602, 0.17693581322517693, 0.1818633574265105, 0.24837096912889378, 0.3108181047259624, 0.23503244270228862, 0.2365762687284363, 0.1545955432943409, 0.26476838660311974, 0.2695491988302705, 0.06488564932696483, 0.6082863861028192, 0.6063718294595871, 0.6059726506074999, 0.61866429329732, 0.6190968891939884, 0.6066688417782541, 0.6064305403544141, 0.6230464452767257, 0.6031273310436074, 0.0836432331782958, 0.16489781276715276, 0.1234252359995629, 0.1624148775796468, 0.1236577475599, 0.11522005931290447, 0.14078299408627937, 0.14820801351947122, 0.12503443947530946, 0.3658521915395401, 0.2928289707866035, 0.19153496412654936, 0.14837124505247612, 0.15750960275836245, 0.19244655261425636, 0.18029255506903208, 0.20731440611146623, 0.16909361617548035, 0.45285137068431147, 0.5133855607473158, 0.49912895908862653, 0.5564337746777689, 0.43184424921432274, 0.4214761290277482, 0.5441397699061653, 0.4906894098389507, 0.5411863048952228, 0.2837535256507442, 0.288933192812037, 0.2898652384910654, 0.23175603873463912, 0.28624044177787966, 0.26958408350374796, 0.43257282761012794, 0.39465521757348054, 0.3538584193432627, 0.21340130502670596, 0.19644738684456242, 0.207000332285729, 0.1929993292635358, 0.19681475077223864, 0.19953619913503484, 0.1981125442212468, 0.2160469949184608, 0.2324907937173758, 0.6602437659291283, 0.19173747306267963, 0.5988115916610146, 0.21300134173792928, 0.21590665920253616, 0.5428335299093988, 0.23640371888626233, 0.21709108661643173, 0.19438842062307193, 0.16201959943765742, 0.8830814552535603, 0.17074734348451037, 0.8459112146335366, 0.880468339406654, 0.1623381219918969, 0.15167858762566355, 0.17716355972997244, 0.1689297946017012, 0.20156022215797376, 0.20950739880120073, 0.20986226977804878, 0.20627747215627157, 0.16839060185246357, 0.16831359190369677, 0.1950758023831557, 0.7862277235805843, 0.20829568523108366, 0.19413750850894806, 0.17724949962838998, 0.189964384425928, 0.19018378690061344, 0.18380174768357738, 0.1807730069208524, 0.19126174510611937, 0.17820193243454063, 0.20164884001879269, 0.08837439353608134, 0.08277404847533687, 0.08815842123682138, 0.09706103931832555, 0.08995821314351438, 0.0952688202171239, 0.09931894536104502, 0.09782280664569842, 0.07647754187276401]}, "mutation_prompt": null}
{"id": "be811fb4-877c-4a89-b6fd-8f2ab833d888", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        # Modified inertia weight calculation\n        self.inertia_weight = adaptive_inertia * (0.8 - 0.5 * (self.current_evaluations / self.budget))\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        perturbation_scale = 0.4 + 0.6 * (1 - fitness_variance / (np.max(fitness_variance) + 1e-5))  # Adjusted\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Refined inertia weight adaptation to dynamically adjust based on both diversity and generation progression.", "configspace": "", "generation": 87, "fitness": 0.35540047697734856, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.87090155474837, 0.8968953595267848, 0.8912544864036528, 0.8956975122551093, 0.8967533129555953, 0.885882253294634, 0.8955297375546397, 0.8940225664522177, 0.8920576537873197, 0.7718355179095766, 0.7347255755534361, 0.7957783240750645, 0.7793368219129877, 0.7935325036885372, 0.6759415502215189, 0.7814785436401741, 0.779552476917944, 0.7786469663388337, 0.14405971337583146, 0.12942132760372438, 0.17687798110784947, 0.1443488380467688, 0.13744195043109253, 0.14685359103186857, 0.13985641418598338, 0.18440652004927216, 0.16635687383780318, 0.13680937294373596, 0.11421333176202064, 0.12764958203162546, 0.11158984819863216, 0.13739694583792117, 0.10757369629681857, 0.10766013574478617, 0.11397714383510571, 0.1662257256006251, 0.981305311622807, 0.9765367374225455, 0.9792399528709337, 0.9774574519863991, 0.9820653897911458, 0.9848007523796664, 0.9819596897190938, 0.9862161683102881, 0.971498186572327, 0.7231558350481688, 0.6982523333987642, 0.6914654463860905, 0.7114547246687162, 0.5519569253441677, 0.25209332597420064, 0.7177715740274381, 0.6809994212656896, 0.6950660531777809, 0.8234299649777367, 0.7839906116522716, 0.7755028091524644, 0.920916263660133, 0.8752626877858792, 0.19421997259199042, 0.23756913691335768, 0.33443155428668714, 0.23756245926979336, 0.11494055704169381, 0.35192382170141123, 0.13036209818698352, 0.24817937172080484, 0.27083886124552614, 0.31006712587992546, 0.29005601070435616, 0.45653255615184873, 0.2857558590334186, 0.12703706558696282, 0.2617458134791041, 0.2399438258099218, 0.27522430676088405, 0.2671996793843028, 0.3059780735027111, 0.26943455356507395, 0.2744287452632437, 0.30638234965128963, 0.0602630558439643, 0.043790081455241325, 0.12474712827886847, 0.053950736482621164, 0.04140754881491393, 0.04912618249938483, 0.09873400797150078, 0.0480639557098117, 0.23321325184138664, 0.19678871484688776, 0.32887800374103193, 0.33566230214662685, 0.3671998071475838, 0.3068271143762392, 0.23542074749865682, 0.3995512569083176, 0.3568177388798276, 0.39750423371762056, 0.03546777037751381, 0.11165303064457988, 0.0896874248341053, 0.07897558651043057, 0.07717995394504285, 0.09659850955249072, 0.12583410622347524, 0.10448208076238008, 0.0809740718098999, 0.12224116799335971, 0.32942145797443134, 0.13424360164719218, 0.2983217893910388, 0.30082758095715856, 0.1575222887925516, 0.2395404863823637, 0.14273884424691985, 0.05736411236726968, 0.6282892784714573, 0.6259192300102379, 0.6073590301763481, 0.6271288536489947, 0.6483993085760094, 0.643258430071439, 0.6333640585477384, 0.6128520802124724, 0.6404538135860112, 0.09233027619295464, 0.1257313470176854, 0.10824912330979952, 0.17128848045771883, 0.09548943082916261, 0.14403372039707696, 0.10498670173991353, 0.14781481805804564, 0.09965664595083545, 0.2404100145399528, 0.17447307505023146, 0.25301283723632984, 0.44980214168431265, 0.3039319031134702, 0.1676487799836015, 0.21353988336344998, 0.2175957037497671, 0.17679014515094948, 0.2333652667640127, 0.40152943925242934, 0.46919334386197853, 0.4011304815573469, 0.5186522529499895, 0.2825618886705673, 0.4972499072680825, 0.257848153224428, 0.5983762981729561, 0.21216099301827152, 0.2439736295542838, 0.2838992686588956, 0.346690051930186, 0.4023392819535868, 0.25498393355690263, 0.28479321621840714, 0.1889869455581944, 0.3116948529650282, 0.1999647161915823, 0.22320169724619, 0.21055744545460797, 0.2372448780384585, 0.2051868946900578, 0.21578892783716297, 0.1992578396834087, 0.2083820953577542, 0.21042800878711732, 0.22431558645869576, 0.2075568254286988, 0.24825203407805907, 0.24797401098226513, 0.19437254675298132, 0.25234740310357406, 0.19371452462587557, 0.24347036214636675, 0.22626308406452622, 0.2015939701578905, 0.910485348474281, 0.15824320240378087, 0.1956420232204169, 0.9221602933874199, 0.1293640037079936, 0.20021405193829556, 0.17817870970512228, 0.1691226852637019, 0.6075664375017389, 0.20878202279200841, 0.21180505352678203, 0.8085374395062992, 0.1686243644281198, 0.16794158855090247, 0.7111923617880944, 0.8178614593887964, 0.1049771134277998, 0.20699636193008641, 0.1829070584179049, 0.19898049852160404, 0.18844139224935386, 0.19998112217609731, 0.19188574154238425, 0.19356274381205985, 0.19703769120441006, 0.17890104149989272, 0.129055988283306, 0.09347501977429351, 0.08893411149732833, 0.08795753187884092, 0.08965292383722112, 0.09685381131219617, 0.12769961055450696, 0.08795045745212571, 0.08664773814879867]}, "mutation_prompt": null}
{"id": "7e20f5d2-a80e-4830-8725-847cbc67273f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        fitness_diversity = np.std(best_positions, axis=0).mean()\n        perturbation_scale = 0.4 + 0.6 * (1 - (fitness_diversity / (np.max(fitness_diversity) + 1e-5)))  # Enhanced\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1 + 0.2 * (fitness_variance / (np.max(fitness_variance) + 1e-5)):\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variance)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhanced mutation strength adaptation by incorporating fitness diversity to balance exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.3759767551721576, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "7fe41c72-6f33-47d0-87c6-b1fbaece2c8d", "metadata": {"aucs": [0.8706594785992896, 0.8781851256657506, 0.8698852307189615, 0.8824437822174346, 0.8766150240059147, 0.8687110189848768, 0.8776772264956784, 0.8795004088017264, 0.886468260388583, 0.7889949146384612, 0.7602197750602824, 0.7665501723993242, 0.7808163006559288, 0.7559996102417554, 0.7600767856196454, 0.7783552787567141, 0.7705245935426275, 0.7594001773856554, 0.13511949941219825, 0.5151945505534445, 0.13380232964623917, 0.1610569457153881, 0.14086942127327184, 0.15222423323477274, 0.15779479462404722, 0.1844718686745207, 0.48756791218176243, 0.10857891654926521, 0.15448083650084865, 0.10570717972635213, 0.13242245459638524, 0.1242025645190552, 0.134394618355551, 0.14229425670579, 0.1252790065154713, 0.13976214839931023, 0.983902554545551, 0.9808215668168474, 0.984980303362041, 0.9780771700638751, 0.9821398312533616, 0.9848199114579642, 0.9859834679843642, 0.9878212565839475, 0.972486352048688, 0.6842282590607758, 0.6930962652977328, 0.6134617276130667, 0.7077275647500508, 0.6586690820862501, 0.7134414390375039, 0.6922740795677249, 0.651096915725327, 0.6815352847362015, 0.7949364734693845, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8475523047481994, 0.8286088558595615, 0.829951705930096, 0.26326017149669223, 0.29894033024998756, 0.2694420338944491, 0.1315121602051187, 0.30110011252209457, 0.1843494446113414, 0.3611857560868762, 0.2903289073230315, 0.25665882136178475, 0.021690432545540705, 0.13138824600832244, 0.2748827791194116, 0.2679551179294435, 0.3077607460986812, 0.4031810339510945, 0.32589172343127837, 0.2769081857608694, 0.2757613849231646, 0.07571855629575364, 0.035688289772080495, 0.21460314650869472, 0.04344868065040752, 0.16608681501772204, 0.06099226090270404, 0.24044731754809334, 0.14963153412124597, 0.26868159888296517, 0.061963900862490484, 0.39575460968698395, 0.32142479915553734, 0.3326986490312087, 0.3316184956263547, 0.28502644397619836, 0.20457846190023443, 0.3259459665797386, 0.34171925549721205, 0.033709712177007134, 0.048776229904150536, 0.13505255177866549, 0.07875924905341858, 0.07587740872232263, 0.11333038144558683, 0.19198215961086407, 0.10422267168064459, 0.0711634605650795, 0.12207974431499546, 0.19930977382721127, 0.28793058583797526, 0.1638148470452916, 0.2205821329788149, 0.27834965174729487, 0.23559470517906722, 0.20542054639530893, 0.19614958562701468, 0.5672969800131152, 0.6004721643737547, 0.638269958420461, 0.5602459599254714, 0.6853708330294077, 0.6625553766655699, 0.6229904755938422, 0.6288183740375073, 0.6582440516020563, 0.09918999902186898, 0.1345248125721772, 0.12038978388610777, 0.11791989505159184, 0.12240850665773162, 0.11234868793683073, 0.11383010886776723, 0.14725074512367098, 0.11495826828207012, 0.24702988254711122, 0.40845512194468225, 0.28122944924717386, 0.34897317066927247, 0.2075737897454646, 0.21659205979636365, 0.15498927372568938, 0.23015033215034053, 0.16448733927709003, 0.44884064040144067, 0.5194202758867448, 0.4773388922923333, 0.5360608477893543, 0.42314420063513314, 0.412839931520246, 0.2872036855586071, 0.5974106558688843, 0.43402930142694696, 0.3865966543989665, 0.28037926999399665, 0.289335342831334, 0.37473954704261636, 0.28631818464908565, 0.31579864552433345, 0.35555516964143086, 0.3847444546961233, 0.398014497785222, 0.20351029214381056, 0.2389377895245891, 0.2127406032133402, 0.2147141336434949, 0.20363369033456402, 0.17762886374264086, 0.21192630650043398, 0.22514582195668964, 0.2023232850633564, 0.2375388037353332, 0.2430054963363717, 0.2413517929164043, 0.2431026484614307, 0.20064254509326007, 0.7538431890188995, 0.21861836666267753, 0.23630980578442706, 0.6841657594052697, 0.16512155778174742, 0.8986809523971604, 0.15847494684894214, 0.19776181524341785, 0.9099898182977562, 0.16449194213478913, 0.7906815030507544, 0.1782699948446529, 0.1690590738060378, 0.1280557999464732, 0.21014850485420788, 0.21066558828256188, 0.7867364304993937, 0.16853229913577183, 0.1679804861632339, 0.8152971929632884, 0.8288712958732531, 0.10488563493286107, 0.1905588779462103, 0.17755998882463986, 0.19110838924922324, 0.1862918742852102, 0.18696105968747534, 0.1915300711436556, 0.17887522898410713, 0.1947708672144064, 0.19772065794244187, 0.11609070604028093, 0.08726533899180666, 0.13369208669495325, 0.08291357828345258, 0.08455317977319521, 0.09175435176877522, 0.1176458400455449, 0.0844591077220046, 0.08953667072025895]}, "mutation_prompt": null}
{"id": "093d1d01-fdc5-4cc2-a038-6fe83bc5a392", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        fitness_diversity = np.std(best_positions, axis=0).mean()\n        perturbation_scale = 0.4 + 0.6 * (1 - (fitness_diversity / (np.max(fitness_diversity) + 1e-5)))  # Enhanced\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.2 * (fitness_variation / (np.max(fitness_variation) + 1e-5))  # Line Changed\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:  # Line Changed\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improve exploration by dynamically adjusting mutation probability based on fitness improvement rate.", "configspace": "", "generation": 89, "fitness": 0.37893389382071835, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "7e20f5d2-a80e-4830-8725-847cbc67273f", "metadata": {"aucs": [0.8691713406102533, 0.8729495108605491, 0.8666295683548755, 0.8749110645959208, 0.8735907311527373, 0.8680784788011842, 0.8711448035291955, 0.8739360878573901, 0.8813597385237045, 0.7826367508552442, 0.7549112911302529, 0.758882059822149, 0.7798945645336618, 0.7464942276797031, 0.7536007931610162, 0.7781640336753396, 0.7650675390919447, 0.7567945548178248, 0.1351194404939441, 0.5134141486163615, 0.1338022610651658, 0.1610569325932485, 0.1408694230147597, 0.1522242591120998, 0.15779479410566277, 0.18447196628033902, 0.48551909462355236, 0.10857891657321284, 0.15448083630551046, 0.105707166843093, 0.13242169648015767, 0.12420256447865463, 0.1343946184631144, 0.14229424386891187, 0.12527900640296752, 0.13976214707543955, 0.983902554545551, 0.9808215668168474, 0.984980303362041, 0.9780771700638751, 0.9821398312533616, 0.9848199114579642, 0.9859834679843642, 0.9878212565839475, 0.972486352048688, 0.6829911017108838, 0.6947335563911918, 0.6165008507969605, 0.7047944375416804, 0.6750183042020786, 0.7184724919001217, 0.6893845815541462, 0.6611481452612622, 0.681282622341933, 0.7949364734693845, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8485910366501705, 0.8286088558595615, 0.829951705930096, 0.26317454535858353, 0.29697528470901857, 0.2690256761165213, 0.13151194404114142, 0.30130742537127475, 0.18463846064509037, 0.368291728955365, 0.2903289073230315, 0.25483801388165606, 0.021690432538660542, 0.1313874718470992, 0.2748827791194116, 0.26797295408995325, 0.3057265846883327, 0.42023893944158086, 0.3289114212731261, 0.27689938697905514, 0.27374253168046037, 0.07571855629575364, 0.035688289772080495, 0.21460314650869472, 0.04344868065040752, 0.16608681501772204, 0.06099226090270404, 0.24044731754809334, 0.14963153412124597, 0.26868159888296517, 0.061963900862490484, 0.39575460968698395, 0.32142479915553734, 0.3326986490312087, 0.3316184956263547, 0.28502644397619836, 0.20457846190023443, 0.3259459665797386, 0.34171925549721205, 0.03372898146177028, 0.04877622934508308, 0.13505255177866549, 0.07875924905341858, 0.07589728560479958, 0.11333038144558683, 0.19198215961086407, 0.10422267168064459, 0.07116342797683306, 0.12207974431499546, 0.19937022510676838, 0.28793058583797526, 0.1638148470452916, 0.2205821329788149, 0.27834965174729487, 0.23559470517906722, 0.20542054639530893, 0.19614958562701468, 0.553386240714846, 0.6146066597074316, 0.675903379060616, 0.7016645504341201, 0.7129443581306562, 0.7093357880694877, 0.7336388781221375, 0.7052932679432052, 0.7054539483857163, 0.09918999616309598, 0.13452480584980075, 0.12038977817032082, 0.11791989505159184, 0.12240850712060547, 0.11234868793683073, 0.11383011075939609, 0.14725077400153064, 0.11495826805846843, 0.24735378415016795, 0.4654437315979597, 0.2810247946837333, 0.3493440646034659, 0.2075737897454646, 0.21659361244218667, 0.15498927372568938, 0.23015184648330578, 0.16448733927709003, 0.5105001923065378, 0.49236156750389837, 0.5506782149521368, 0.44691932321617034, 0.44269542321514177, 0.40765528021175623, 0.2874213332684493, 0.6430699343273719, 0.4303529727351435, 0.38117923180165103, 0.28041086159600537, 0.2871449542964801, 0.38368783818026897, 0.28641496208472705, 0.31527836937846876, 0.3610908295217118, 0.40836974431688733, 0.4344409152602362, 0.20351029214381056, 0.2389377895245891, 0.2127406032133402, 0.2147141336434949, 0.20363369033456402, 0.17762886374264086, 0.21192630650043398, 0.22514582195668964, 0.2023232850633564, 0.23753880324846155, 0.24300548876346006, 0.24135194262293047, 0.24310264949951732, 0.20064251935731314, 0.7484726018567261, 0.2186183974065944, 0.2363097996793243, 0.6794197015821946, 0.16510299107681603, 0.9001625927522217, 0.1584749522621065, 0.19776179109505476, 0.909979506795342, 0.16453167428130344, 0.7906827672841316, 0.178270306333698, 0.16905908968870276, 0.12805578772435366, 0.21014849073738173, 0.21066547191918994, 0.7867152976592473, 0.1685323207872611, 0.16798049394192127, 0.8136493766917823, 0.8279734617662282, 0.1048856106371453, 0.1905588779462103, 0.17755998882463986, 0.19110838924922324, 0.1862918742852102, 0.18696105968747534, 0.1915300711436556, 0.17887522898410713, 0.1947708672144064, 0.19772065794244187, 0.11609070604028093, 0.08726533899180666, 0.13369208669495325, 0.08291357828345258, 0.08455317977319521, 0.09175435176877522, 0.1176458400455449, 0.0844591077220046, 0.08953667072025895]}, "mutation_prompt": null}
{"id": "37afe391-cb35-4ce6-b0c0-db2e531c4f74", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (0.7 - 0.3 * (self.current_evaluations / self.budget)) # Line Changed\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        fitness_diversity = np.std(best_positions, axis=0).mean()\n        perturbation_scale = 0.4 + 0.6 * (1 - (fitness_diversity / (np.max(fitness_diversity) + 1e-5)))  # Enhanced\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.2 * (fitness_variation / (np.max(fitness_variation) + 1e-5))\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improve exploitation by refining inertia weight strategy to prioritize convergence as evaluations increase.", "configspace": "", "generation": 90, "fitness": 0.3505053476997092, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "093d1d01-fdc5-4cc2-a038-6fe83bc5a392", "metadata": {"aucs": [0.890054679552091, 0.9001718255242268, 0.8943024472250249, 0.8914758012668887, 0.9029754920867208, 0.8973408137854489, 0.8932558762276495, 0.8947304219657451, 0.8977428112345475, 0.7958171257707498, 0.7945834783075623, 0.7846970656839698, 0.7884578832145229, 0.7880398524352062, 0.7929362397795497, 0.7869226753861169, 0.794967277696136, 0.7750148414139548, 0.15565291495081768, 0.14060635037486957, 0.15459499347854688, 0.12416100590300228, 0.15739971060795943, 0.13837664390371096, 0.15758345095627957, 0.1759879463257099, 0.14898937175807148, 0.0784004578988583, 0.13641266189966916, 0.11497440992597052, 0.10714843196962609, 0.16182660673310423, 0.12775218777367958, 0.12298594215338166, 0.13305642621393143, 0.11653114736756576, 0.9811750535508116, 0.971947699657442, 0.9727518871355814, 0.9770638875223882, 0.9819859580941115, 0.9847938531181825, 0.9802735661033972, 0.9861628536116188, 0.9715735374428967, 0.71242757374399, 0.7242089722714506, 0.7167172259533707, 0.7098777271677774, 0.15048714201794477, 0.1726202546189044, 0.7341456368751691, 0.7017674301914119, 0.6800531823718007, 0.8668094404580076, 0.7798139287977002, 0.22391433262018723, 0.9000435424614803, 0.19306570646432852, 0.21315145687082315, 0.8439791302478683, 0.17737334514104308, 0.877818593990254, 0.13255839054593999, 0.287058014218321, 0.3565314034388487, 0.13357859077410061, 0.2623343290394806, 0.3318364107209879, 0.29562421228851776, 0.11787856489435977, 0.4464804651596672, 0.1212726365759047, 0.2584967509030983, 0.27131704015655833, 0.2496814248859136, 0.20387870338446523, 0.3063571747296343, 0.29466014917950323, 0.16578473445496966, 0.2253890383795959, 0.0610572203919264, 0.20271075493771806, 0.2198226196614944, 0.1532731890794159, 0.011975314083861877, 0.14298279302031447, 0.05937919342645037, 0.019609893878064222, 0.11200661208719342, 0.09618545027357228, 0.38538093439209264, 0.3782485975203944, 0.3172430252851903, 0.3081412677530294, 0.25809470224173925, 0.3211552822967445, 0.32366691370493084, 0.3631445288792319, 0.036908454314802164, 0.12069453546845943, 0.11842854053217722, 0.07897272033593394, 0.0964701188845134, 0.1201071790027678, 0.2790191329536209, 0.23755604280390052, 0.0743196277864061, 0.17593935312192932, 0.3474251253510503, 0.044821787840550464, 0.08810402113417748, 0.1477836079750794, 0.1196296862216848, 0.08360087785159098, 0.1451077394346303, 0.26138189970470316, 0.6199638265096459, 0.6398753570120135, 0.6502907915106916, 0.5889657221442997, 0.6889723926573865, 0.7279423390790023, 0.6660484505023854, 0.6811516724615496, 0.6546269658247391, 0.0753976717494812, 0.12235353623409317, 0.10594095805412784, 0.14656423310856137, 0.12097229693565859, 0.1721599465421445, 0.13320096736387455, 0.09538847030349296, 0.13079045991044425, 0.3566099825475222, 0.25676915908598574, 0.4111683877082649, 0.38725544970028447, 0.31130783623822955, 0.31576310691096, 0.15526078508838836, 0.33066040474483593, 0.16797616909696245, 0.39102501022222236, 0.30863549012525127, 0.5329858649306825, 0.3091373315095335, 0.4697811413921782, 0.24352818972310053, 0.3345533303446413, 0.28801535307380755, 0.6558948690805066, 0.19949470947936665, 0.2924958704993347, 0.306779263876254, 0.25544759518763105, 0.1964596582114716, 0.3354482293952059, 0.22444626559412018, 0.26748896001664557, 0.4438791919505397, 0.23068902415367332, 0.20803421747269035, 0.20560638294286537, 0.20943766040630463, 0.248034451825078, 0.2124963622446434, 0.25162383367609065, 0.20911283846793627, 0.22015201271225981, 0.1944805393565895, 0.1997475804947072, 0.24982153224109038, 0.20881733391321566, 0.18342629305497382, 0.24392850930390708, 0.24686693375277868, 0.22140914536617406, 0.24697164217988166, 0.18539133179861933, 0.901931976053651, 0.18403230648331081, 0.1681541496901504, 0.9186239617915406, 0.14075263810081073, 0.2040138092785675, 0.17752556098099592, 0.1693089209509202, 0.12793060948350488, 0.21143901994846048, 0.2113303734873908, 0.8447923658259091, 0.16854555867533239, 0.16846887922607134, 0.09382621189299756, 0.847353815820185, 0.10490711589074875, 0.1762404989492088, 0.1801770974807705, 0.1882950017492364, 0.19909065146154437, 0.1883741225590002, 0.16951225295556738, 0.18342405818261864, 0.19575620020322726, 0.1812939598385166, 0.11147358781701855, 0.09807211015593476, 0.09318208509277559, 0.11229463648638993, 0.08256275751842534, 0.10042915757141124, 0.1077520993773371, 0.08980811941252309, 0.0905611791321127]}, "mutation_prompt": null}
{"id": "c3857309-3439-4ef9-a223-48c7442dc3db", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        fitness_diversity = np.std(best_positions, axis=0).mean()\n        perturbation_scale = 0.4 + 0.6 * (1 - (fitness_diversity / (np.max(fitness_diversity) + 1e-5)))  # Enhanced\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.2 * (fitness_variation / (np.max(fitness_variation) + 1e-5))  # Line Changed\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:  # Line Changed\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improve exploration by dynamically adjusting mutation probability based on fitness improvement rate.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "093d1d01-fdc5-4cc2-a038-6fe83bc5a392", "metadata": {"aucs": [0.8691713406102533, 0.8729495108605491, 0.8666295683548755, 0.8749110645959208, 0.8735907311527373, 0.8680784788011842, 0.8711448035291955, 0.8739360878573901, 0.8813597385237045, 0.7826367508552442, 0.7549112911302529, 0.758882059822149, 0.7798945645336618, 0.7464942276797031, 0.7536007931610162, 0.7781640336753396, 0.7650675390919447, 0.7567945548178248, 0.1351194404939441, 0.5134141486163615, 0.1338022610651658, 0.1610569325932485, 0.1408694230147597, 0.1522242591120998, 0.15779479410566277, 0.18447196628033902, 0.48551909462355236, 0.10857891657321284, 0.15448083630551046, 0.105707166843093, 0.13242169648015767, 0.12420256447865463, 0.1343946184631144, 0.14229424386891187, 0.12527900640296752, 0.13976214707543955, 0.983902554545551, 0.9808215668168474, 0.984980303362041, 0.9780771700638751, 0.9821398312533616, 0.9848199114579642, 0.9859834679843642, 0.9878212565839475, 0.972486352048688, 0.6829911017108838, 0.6947335563911918, 0.6165008507969605, 0.7047944375416804, 0.6750183042020786, 0.7184724919001217, 0.6893845815541462, 0.6611481452612622, 0.681282622341933, 0.7949364734693845, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8485910366501705, 0.8286088558595615, 0.829951705930096, 0.26317454535858353, 0.29697528470901857, 0.2690256761165213, 0.13151194404114142, 0.30130742537127475, 0.18463846064509037, 0.368291728955365, 0.2903289073230315, 0.25483801388165606, 0.021690432538660542, 0.1313874718470992, 0.2748827791194116, 0.26797295408995325, 0.3057265846883327, 0.42023893944158086, 0.3289114212731261, 0.27689938697905514, 0.27374253168046037, 0.07571855629575364, 0.035688289772080495, 0.21460314650869472, 0.04344868065040752, 0.16608681501772204, 0.06099226090270404, 0.24044731754809334, 0.14963153412124597, 0.26868159888296517, 0.061963900862490484, 0.39575460968698395, 0.32142479915553734, 0.3326986490312087, 0.3316184956263547, 0.28502644397619836, 0.20457846190023443, 0.3259459665797386, 0.34171925549721205, 0.03372898146177028, 0.04877622934508308, 0.13505255177866549, 0.07875924905341858, 0.07589728560479958, 0.11333038144558683, 0.19198215961086407, 0.10422267168064459, 0.07116342797683306, 0.12207974431499546, 0.19937022510676838, 0.28793058583797526, 0.1638148470452916, 0.2205821329788149, 0.27834965174729487, 0.23559470517906722, 0.20542054639530893, 0.19614958562701468, 0.553386240714846, 0.6146066597074316, 0.675903379060616, 0.7016645504341201, 0.7129443581306562, 0.7093357880694877, 0.7336388781221375, 0.7052932679432052, 0.7054539483857163, 0.09918999616309598, 0.13452480584980075, 0.12038977817032082, 0.11791989505159184, 0.12240850712060547, 0.11234868793683073, 0.11383011075939609, 0.14725077400153064, 0.11495826805846843, 0.24735378415016795, 0.4654437315979597, 0.2810247946837333, 0.3493440646034659, 0.2075737897454646, 0.21659361244218667, 0.15498927372568938, 0.23015184648330578, 0.16448733927709003, 0.5105001923065378, 0.49236156750389837, 0.5506782149521368, 0.44691932321617034, 0.44269542321514177, 0.40765528021175623, 0.2874213332684493, 0.6430699343273719, 0.4303529727351435, 0.38117923180165103, 0.28041086159600537, 0.2871449542964801, 0.38368783818026897, 0.28641496208472705, 0.31527836937846876, 0.3610908295217118, 0.40836974431688733, 0.4344409152602362, 0.20351029214381056, 0.2389377895245891, 0.2127406032133402, 0.2147141336434949, 0.20363369033456402, 0.17762886374264086, 0.21192630650043398, 0.22514582195668964, 0.2023232850633564, 0.23753880324846155, 0.24300548876346006, 0.24135194262293047, 0.24310264949951732, 0.20064251935731314, 0.7484726018567261, 0.2186183974065944, 0.2363097996793243, 0.6794197015821946, 0.16510299107681603, 0.9001625927522217, 0.1584749522621065, 0.19776179109505476, 0.909979506795342, 0.16453167428130344, 0.7906827672841316, 0.178270306333698, 0.16905908968870276, 0.12805578772435366, 0.21014849073738173, 0.21066547191918994, 0.7867152976592473, 0.1685323207872611, 0.16798049394192127, 0.8136493766917823, 0.8279734617662282, 0.1048856106371453, 0.1905588779462103, 0.17755998882463986, 0.19110838924922324, 0.1862918742852102, 0.18696105968747534, 0.1915300711436556, 0.17887522898410713, 0.1947708672144064, 0.19772065794244187, 0.11609070604028093, 0.08726533899180666, 0.13369208669495325, 0.08291357828345258, 0.08455317977319521, 0.09175435176877522, 0.1176458400455449, 0.0844591077220046, 0.08953667072025895]}, "mutation_prompt": null}
{"id": "747b4da0-9b01-46a8-99c4-eaf47e9f64d6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)  # Single line changed\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.2 * (fitness_variation / (np.max(fitness_variation) + 1e-5))\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Improve diversity by adjusting perturbation scale based on positional variance rather than fitness variance.", "configspace": "", "generation": 92, "fitness": 0.3792637518343515, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "093d1d01-fdc5-4cc2-a038-6fe83bc5a392", "metadata": {"aucs": [0.8705217328048882, 0.8730231761230411, 0.866470522435896, 0.8755752548537814, 0.8730207793608158, 0.8686264647343258, 0.8712996380717517, 0.8741622158577453, 0.8791070477969292, 0.7850967558788873, 0.7516331327213086, 0.7567604641991685, 0.7768578868642659, 0.7611386378866748, 0.7640713690743245, 0.7766030392537473, 0.7659029649949782, 0.7560581996111204, 0.1351205055353064, 0.513642006680753, 0.1338025119265378, 0.1610168961491628, 0.1408694272703066, 0.1522285280283735, 0.1463955110823255, 0.184472046105972, 0.48525781585873917, 0.10857893237352745, 0.15448092408838643, 0.10570739667140983, 0.1326020396651535, 0.12420045992434203, 0.13439451690946314, 0.14230908703118894, 0.1252832291718149, 0.1397613270875936, 0.9839025543955241, 0.9808215667645609, 0.9849803034797192, 0.9780771704953287, 0.9821398312551249, 0.984819911458179, 0.9859834679832331, 0.9878212565856516, 0.972486352066952, 0.6899832284126466, 0.6909848436755639, 0.6300681936242664, 0.7024503528425914, 0.6681406327913801, 0.7210243105369922, 0.6914834034882003, 0.6620986041365382, 0.6774435002821702, 0.7949364734693845, 0.833402922501867, 0.7796107902296375, 0.8250520657166409, 0.27568011402315373, 0.19251507991049044, 0.8485910366501705, 0.8286088558595615, 0.829951705930096, 0.23360040103980517, 0.35393441148393767, 0.24058943024178747, 0.13147870940528106, 0.20057770670602282, 0.22843353110989884, 0.3497011173339615, 0.24403207329633614, 0.2502607947169391, 0.02169043021985695, 0.13136222274786047, 0.2649337750665378, 0.28017582362100213, 0.2966140825903424, 0.4264944527084975, 0.33226428792576235, 0.25811196435073214, 0.2727661021787525, 0.07965388175022559, 0.035740901004488346, 0.23058066311314018, 0.03445154211364354, 0.1840933842389768, 0.06027039288760083, 0.22415689178044973, 0.20116794626783607, 0.28390542968618526, 0.061766514752902735, 0.38794490908203383, 0.2965871147452649, 0.3212338824195843, 0.3471650590496428, 0.28501455764252237, 0.21103577793725825, 0.35575732497151946, 0.3811760183700036, 0.03367525665540272, 0.0487737546746253, 0.13469697744925213, 0.07895272231225303, 0.07588896362595443, 0.11557787914237927, 0.16197190208471535, 0.09724602074264344, 0.07117225592830778, 0.15847021264059347, 0.20122547868930407, 0.28422617875156386, 0.14591550100000628, 0.23906947952674162, 0.21004989316249467, 0.24728548779523774, 0.19928045597049038, 0.18710226594197255, 0.5658680935256679, 0.6601639654366507, 0.7059089827330465, 0.6824053424117854, 0.7410627102456986, 0.7057449415727199, 0.6970846618910466, 0.7117403660310184, 0.7049282892698212, 0.09919032278005435, 0.13452455692124754, 0.12039024450972702, 0.11964477241766014, 0.1224077993286915, 0.11234854682392836, 0.1132866325947971, 0.14725273075499024, 0.11495924784273448, 0.22600027301872172, 0.46389613664715723, 0.28082481943469884, 0.4802949951623442, 0.20757017212981155, 0.21719131509451617, 0.1592928740357774, 0.23588960570093864, 0.25216803703285195, 0.4512599072055288, 0.5135500931760624, 0.4328169641788122, 0.49291499491008095, 0.43399630699780223, 0.4118113825045485, 0.2866995071126991, 0.6890107247160497, 0.42233396793140776, 0.3225983771727233, 0.27948212184436116, 0.29105374261918804, 0.35037638446573305, 0.2886631593464234, 0.32392083530501936, 0.3644330675971805, 0.4475925639638826, 0.3655128687135837, 0.20786799320797877, 0.24139414398261938, 0.22843487636520077, 0.2084829926958146, 0.21834046593259537, 0.19644926157270803, 0.22653666987842414, 0.20182433256192844, 0.2194963748478419, 0.23754037565313968, 0.2430054140454515, 0.24204055461524598, 0.24310364188764655, 0.2006422357587011, 0.7467777130325823, 0.2186185881246957, 0.23630946089573968, 0.6827014072034874, 0.165101500981078, 0.9001673380910783, 0.15847495283954127, 0.19776150149169658, 0.9099789536606044, 0.1645316655105411, 0.7906827690006861, 0.1782703102824773, 0.16905908838949835, 0.12805578768372938, 0.21014846539602017, 0.21066546702919076, 0.7804613007390964, 0.16853231720019135, 0.16798050195519898, 0.8137121994249505, 0.8279726927410113, 0.10488560858261575, 0.18789717281414253, 0.18946261811152632, 0.1910594381034838, 0.18629934722380903, 0.18704954211856917, 0.19663426007122375, 0.16771293670546605, 0.19476715384301913, 0.19769553446183097, 0.11607526933641399, 0.08726036509748925, 0.13363662499908624, 0.08289991669968644, 0.0845574671126158, 0.09175401237871172, 0.117705584221663, 0.0844603340004374, 0.08955132325040394]}, "mutation_prompt": null}
{"id": "88585cf6-0674-48bb-b737-2f6d7386b0ce", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        # Line changed: Introduce velocity scaling based on positional diversity\n        velocities *= 1 + 0.1 * np.mean(diversity)  \n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)  # Single line changed\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.2 * (fitness_variation / (np.max(fitness_variation) + 1e-5))\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance exploration by incorporating velocity scaling based on diversity alongside positional variance.", "configspace": "", "generation": 93, "fitness": 0.36507181501735436, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "747b4da0-9b01-46a8-99c4-eaf47e9f64d6", "metadata": {"aucs": [0.8382622147486536, 0.8507656873056968, 0.8465437341454715, 0.8633388713122914, 0.8664733670070501, 0.8614052662466686, 0.8585563844348018, 0.8652344214296949, 0.853561302924811, 0.7373791666671716, 0.7521488715629876, 0.7278630001030513, 0.7258953279873716, 0.06316133480680819, 0.738532600302013, 0.670801089767371, 0.737443606874294, 0.7412030031407182, 0.4482918339079828, 0.5994639445310801, 0.2825680423635717, 0.13182370952945477, 0.14420305806197975, 0.12897998438520986, 0.1269285605092153, 0.13620427065020213, 0.12540449833927525, 0.12488607471212965, 0.1368150064505571, 0.11283148211234495, 0.14830878133217484, 0.09479485524892373, 0.12499862162274389, 0.13986038709875537, 0.12250266738117666, 0.12089052174440695, 0.9860810775729352, 0.9861055780717901, 0.9852047824923781, 0.9811652250049336, 0.9823047541972705, 0.986865470378234, 0.9866201312698921, 0.9880373559586971, 0.9770180140235227, 0.6491232986511482, 0.64493124892062, 0.6243325585885202, 0.6125084998912461, 0.6273893697259452, 0.6597214557834965, 0.6829280416563097, 0.660112490241028, 0.45706662673591936, 0.7616415129049044, 0.7234660616046789, 0.7061879428890936, 0.8366352649310836, 0.21230264722746295, 0.7867058979429679, 0.8467639186487964, 0.6991402420963141, 0.773700007833991, 0.2611657054874178, 0.24611057113295598, 0.24298043408475245, 0.12470606772850845, 0.32421340905391316, 0.24770745346726342, 0.2658565963124142, 0.5439703285771628, 0.37984512717326946, 0.12056243517037779, 0.1819605279842671, 0.128292236985317, 0.29539304494777496, 0.2527869349100993, 0.29079417638361793, 0.24348945234634745, 0.2693293902037833, 0.28528203832359, 0.08489023219405445, 0.1301928612924912, 0.14845589178081608, 0.1940411291429055, 0.021816949446215927, 0.2469325880398947, 0.19997603821209964, 0.11826020925837932, 0.192239640585816, 0.32093287387420544, 0.3626674317008908, 0.3621065758800537, 0.304360787207303, 0.2770910656777339, 0.32279378045389673, 0.4114208338570713, 0.29499371976185607, 0.38673375835617096, 0.0346543615663506, 0.04328335537593542, 0.12520361528585033, 0.07376807282318643, 0.1289668305937608, 0.08888691662377257, 0.09726414539605865, 0.06820548921370395, 0.16148011565142184, 0.17516993488236554, 0.20403865925123532, 0.11315391105326944, 0.17225209490732762, 0.25036800467974085, 0.1757288375846967, 0.08045716569304473, 0.16555328794548063, 0.05556425913228891, 0.6549400594312267, 0.6831185585462745, 0.669457584652041, 0.6463029762200136, 0.6605545284007207, 0.6260278575591893, 0.6652647476378963, 0.6670564180600165, 0.6555895619275544, 0.09940022976019791, 0.4117795251898766, 0.10661839240953308, 0.11973276222851781, 0.11816353716370742, 0.1187079168205104, 0.14655952830722485, 0.10376394445180781, 0.12716998044193484, 0.14226763308099633, 0.2009725069506062, 0.20991679975990052, 0.15921105292032423, 0.1417298788024216, 0.26171727124908173, 0.16354305405681258, 0.17834274160629626, 0.24271057206378532, 0.48612441147078667, 0.560222800937962, 0.4406674881803151, 0.394265858738827, 0.42409238207836675, 0.30391241688368287, 0.5245853214141911, 0.5643651608281437, 0.5348662581543762, 0.22990285385156684, 0.37919627120683785, 0.2994241183154225, 0.3581743109391373, 0.2937787597009164, 0.3181661421353774, 0.3698646568713063, 0.3307100604554367, 0.35219565670218156, 0.19187524431826652, 0.1836587190747202, 0.218292974931255, 0.19051624460897754, 0.20574193007405628, 0.19134374578909952, 0.2013418200582051, 0.19133471349256492, 0.2522054935631993, 0.4048102168529034, 0.23449480114209031, 0.20668736334696436, 0.7103932443326708, 0.23676672897620432, 0.20653420958078061, 0.20171985485563415, 0.20132254731724575, 0.1970732748794184, 0.08863343827780157, 0.8753788892423093, 0.16776280338484817, 0.44752477143957403, 0.8242673669795347, 0.1595985399040759, 0.15338172818039242, 0.1759148434466633, 0.1687685921188109, 0.27923786081890134, 0.16770909496619113, 0.16568004372026768, 0.6885367265576094, 0.6450964905006661, 0.6431650692051556, 0.19926672540893453, 0.8033926419426265, 0.20820295076322748, 0.1930490873288252, 0.1922785044595683, 0.18320683026928875, 0.18121989768088598, 0.18262253665411077, 0.19192243586326363, 0.19361875807875772, 0.18418838340011268, 0.1817119712843901, 0.07877166156289217, 0.09212079402714257, 0.07903795748225673, 0.07814351516748541, 0.08083563536974636, 0.084110111570598, 0.10803383121735877, 0.08305949912568145, 0.08407799994556353]}, "mutation_prompt": null}
{"id": "b63a6a4e-331e-4828-ae4e-8c9c893471d3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocity_scale = 0.5 + 0.5 * (self.current_evaluations / self.budget)  # New line\n        velocities = velocity_scale * (self.inertia_weight * velocities + cognitive_term + social_term)  # Modified line\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)  # Single line changed\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.2 * (fitness_variation / (np.max(fitness_variation) + 1e-5))\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance global exploration by introducing dynamic velocity scaling based on iteration progress.", "configspace": "", "generation": 94, "fitness": 0.23471184310567747, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "747b4da0-9b01-46a8-99c4-eaf47e9f64d6", "metadata": {"aucs": [0.9304577886937702, 0.6771852306978946, 0.6560731923298284, 0.9144617614661311, 0.9137482431055733, 0.8973286877794538, 0.9213676607020171, 0.9025307509620863, 0.9270229532789307, 0.21561231747996057, 0.07948162328705477, 0.02291585730995571, 0.09471950091866344, 0.30788794514196105, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036338665433249817, 9.999999999998899e-05, 0.12106736919082939, 0.1434021157565345, 0.1227801230376091, 0.13109881686521507, 0.10461029694473711, 0.11534810783563532, 0.1160490891996262, 0.16729185278785075, 0.11723010375091003, 0.0971945421261795, 0.07619497877990256, 0.08891918442712377, 0.07933992265155143, 0.160685244079678, 0.06911832160792541, 0.07640546260411707, 0.07971723742099002, 0.12284639312374224, 0.1313176628542717, 0.09919337001857587, 0.11237806243732607, 0.0961381283524303, 0.13414472094825358, 0.13309682245827348, 0.11373868757297478, 0.9504549666420937, 0.12164208923275022, 0.13865410284047153, 0.10168773686019472, 0.08484497938755087, 0.1715700230487195, 0.17898364211268458, 0.1341866118508246, 0.1881305066427179, 0.19839060792463536, 0.1352983070003977, 0.223627067968447, 0.16220960335900836, 0.3828059684821361, 0.30921574626559545, 0.22079159576725416, 0.36508335013932347, 0.22387551492867241, 0.224748980399478, 0.19586685468233633, 0.12805736171428128, 0.12837016143037072, 0.12813254490897996, 0.14212556935578702, 0.1523733853202024, 0.1297333049488003, 0.13170145626035779, 0.2638383554724516, 0.1445063759915174, 0.14137471263741241, 0.15118785697350323, 0.15677156612409093, 0.13141412791589013, 0.15840877974880296, 0.14657966579193593, 0.1296138578778191, 0.13328686314447336, 0.1349798449908718, 0.021349941460608757, 0.04225749066570128, 9.999999999998899e-05, 0.1630975601770659, 0.11030834530411993, 0.1354365962182812, 0.3420995728237899, 0.03994248077234985, 0.028629273688024814, 0.42948140162045556, 0.39520562079016364, 0.4133512197251541, 0.3563100299971881, 0.11918776121768693, 0.1822433886301641, 0.4180470714077209, 0.12845597390052788, 0.367657846721578, 0.04341460654605178, 0.24415240592034015, 0.13143102089359382, 0.08548201337751016, 0.13586630964691992, 0.14560826190460052, 0.2148295430576843, 0.2275404614733284, 0.1797894882286808, 0.09194361010779939, 0.12318458316339997, 0.11816012405566256, 0.054766733151877856, 0.11933481835309889, 0.19181396180847365, 0.08025327418750439, 0.2976724480299957, 0.11911452557404867, 0.4551587969074615, 0.6675941597941967, 0.5405475979267695, 0.6022003036716558, 0.3093979331059493, 0.5022527444620704, 0.5999113409708683, 0.40162094744041865, 0.5699518253593103, 0.09210581553760055, 0.13211335224202625, 0.10877922990390376, 0.14242786745921876, 0.1105329098635891, 0.15537729037215942, 0.14279635175236505, 0.0827883965588373, 0.09234481153763463, 0.48456715548806706, 0.3053184929565086, 0.514949709724047, 0.33038685137180235, 0.23418996061702313, 0.3145313354293079, 0.25679537883899517, 0.29679222876835265, 0.19143792300702533, 0.2562243585681886, 0.26639207524670294, 0.359872897200588, 0.2851885947088575, 0.4095214112199501, 0.3082480866017696, 0.3395154899273335, 0.24844784298530065, 0.2601062746176517, 0.17725673961655863, 0.22989452583657544, 0.2928283196449243, 0.304723640821151, 0.21177302384349028, 0.23642287238404247, 0.1320797291075, 0.22552434354745987, 0.2732851223814239, 0.23322248695888015, 0.2201345352298878, 0.23334724731759293, 0.21960604126905459, 0.19637988223940128, 0.2117971933325551, 0.26258667890428256, 0.22686729854713916, 0.23389164813400143, 0.18497335143722438, 0.182564486744486, 0.19893695979570902, 0.17977398218020613, 0.20958685711171632, 0.19285159936537521, 0.2001117108034568, 0.19212698440205456, 0.19992825416026294, 0.18800178227955822, 0.64157988751719, 0.15906139715243794, 0.15334957134338478, 0.2875057072623681, 0.16287442992326762, 0.9306040568891639, 0.17878125264268474, 0.16933849027453418, 0.8020408728957672, 0.29653134089815936, 0.2052316371809545, 0.20954189143431745, 0.6379927949888479, 0.16936846353605928, 0.0947287273372569, 0.3772703622613578, 0.27649162016608186, 0.1948412208252991, 0.17825729275096747, 0.18656097802938854, 0.18750935434139127, 0.20367150314305882, 0.21939891758061592, 0.19059662917704467, 0.17670427222827656, 0.1766957619028099, 0.08764486856496623, 0.10397798277377757, 0.08268317729849828, 0.1180603358856277, 0.08725164977161182, 0.09731479743441929, 0.10236204840245078, 0.11254654439768652, 0.10244542580227611]}, "mutation_prompt": null}
{"id": "baa83eea-aa10-47fb-a48e-62fcf95b2da2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)  # Single line changed\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.4 * (1 - self.current_evaluations / self.budget)  # Line changed\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance exploration by dynamically adjusting mutation probability based on evaluation progress.", "configspace": "", "generation": 95, "fitness": 0.3891473405341485, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "747b4da0-9b01-46a8-99c4-eaf47e9f64d6", "metadata": {"aucs": [0.8505627088958381, 0.8512466455685743, 0.8347639512759829, 0.8571383906009425, 0.8559227071707054, 0.8421931595274191, 0.8459677555013345, 0.8521673798467476, 0.8667468080033285, 0.7313881779407276, 0.731035822066803, 0.7366409345446867, 0.7512079293042503, 0.7761901455101239, 0.7310198497133564, 0.7275510081549272, 0.733987198491765, 0.7328396614702459, 0.4637735007026019, 0.15225979825521863, 0.13133457461103648, 0.15408971105773417, 0.14780074535835208, 0.14303888285342414, 0.3599674913982257, 0.1509808138426051, 0.14051536421641853, 0.10827820491925355, 0.1179827285575058, 0.1180169549650607, 0.1196192885046472, 0.11241813828645497, 0.12947970831279476, 0.11679053418109886, 0.1602107420114346, 0.11631730125502804, 0.9860075818742907, 0.9813547901431705, 0.980909052888153, 0.9815933552555339, 0.9802526087423779, 0.9856822614187654, 0.97770400840452, 0.9861147468719677, 0.9668137211733125, 0.6772869410155826, 0.6371236083036722, 0.6428801414268106, 0.6844122279144016, 0.6482982719798105, 0.6635743817450558, 0.6594845147917737, 0.6565989212882366, 0.652823086938853, 0.8051751816012995, 0.2225294568358145, 0.7854607956311138, 0.8546829706208545, 0.8616002828513076, 0.8569702963960506, 0.8375874130556182, 0.7838802486236344, 0.8295797129433864, 0.36203078681274414, 0.24648257513691674, 0.24579922215831773, 0.3827888123799791, 0.25342633433792494, 0.12903661989677662, 0.2587479364796199, 0.2461455844319166, 0.23334942835033456, 0.11774352415940481, 0.2363614240328178, 0.2559726084213757, 0.2941868371719861, 0.24585188759050858, 0.21972804440216964, 0.27159554820209486, 0.24093581553918475, 0.34902252157977387, 0.0776210622089546, 0.08040051925212921, 0.28024640773120546, 0.2322148683269225, 0.05500453534864369, 0.2509304017163857, 0.2924290760148348, 0.04612729183131303, 0.28508271415183917, 0.4296496442191585, 0.429955361026781, 0.4236213134726112, 0.4225411919945723, 0.2659316650246708, 0.3801123276580216, 0.3425834643686869, 0.4184139566169385, 0.26229565069685545, 0.04336795233370927, 0.11950879715636642, 0.09767073562076967, 0.0774583821315451, 0.19632040855841248, 0.07172937445303795, 0.23111975355149506, 0.18283162669737985, 0.06536831915676211, 0.230557291532001, 0.27361274816216496, 0.22917822094681706, 0.2465331540152227, 0.25197396596193744, 0.2488313403883976, 0.125548055675071, 0.24403625123355, 0.18886065376350292, 0.5476047529265374, 0.6688264738254883, 0.6651161622669544, 0.7083204164065475, 0.6876546932515558, 0.7130310037641998, 0.6728219179294395, 0.6712977364879374, 0.7128757375249122, 0.10692337777646865, 0.1299594727067952, 0.1085628000039236, 0.11121753463597162, 0.11657249159063299, 0.11655855907371804, 0.14980649524286704, 0.14625422551028766, 0.10948566596971598, 0.17533967612310375, 0.25937617071835073, 0.3712435356235354, 0.1544664918425246, 0.18466049612019741, 0.398338080545651, 0.19266989015343983, 0.20211536045857215, 0.2725755348396047, 0.47201153880111624, 0.4845780408369218, 0.42558406342276256, 0.4588900184651863, 0.5003466613088021, 0.4791667280794687, 0.5264248621270629, 0.2864522416830829, 0.5382977739187643, 0.20609576772961014, 0.32259807449898503, 0.39701402869057667, 0.30734123539074276, 0.4036544009444426, 0.2807872399804643, 0.36160743326374534, 0.36354026638477654, 0.3199428332353996, 0.2205274131302739, 0.22412348964980888, 0.19153048417397678, 0.21425879641582402, 0.21078601444796408, 0.2149130160090561, 0.20652414710896594, 0.26275906346055444, 0.24971303833535785, 0.20622527924909195, 0.49736820608552, 0.22933448347748675, 0.5737003883204941, 0.2116294848562117, 0.21064083453146953, 0.19645713063763792, 0.23592244161208253, 0.23390867240702906, 0.19597133519809395, 0.8438589155734071, 0.17297221858526302, 0.8248728606723333, 0.8727803911670594, 0.19566811319361932, 0.794296144242384, 0.17793499150446113, 0.8329406520234909, 0.12765500592736245, 0.16808500446152863, 0.21051440785726927, 0.8001054828168206, 0.16886528480345242, 0.7564164080233886, 0.19992955927080547, 0.8308173060790089, 0.7169391670113034, 0.1884013070066094, 0.19630697292772803, 0.17784224146565797, 0.17641819264395886, 0.1842687643263674, 0.20628895913164713, 0.18538987241583949, 0.20788685228667592, 0.19655440453651807, 0.08186299167556321, 0.11524738504449794, 0.1045450831814293, 0.0844464505718322, 0.08498657177541913, 0.09189402793846368, 0.10891258260336212, 0.08840504199608312, 0.08051496775319444]}, "mutation_prompt": null}
{"id": "18956fe1-26ea-4894-87c2-dd4631520bd6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive coefficient based on global best fitness relative to average\n        average_fitness = np.mean(personal_best_positions)  # Line changed\n        self.cognitive_coefficient = 1.5 + 0.5 * (average_fitness / (np.min(personal_best_positions) + 1e-5))\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.4 * (1 - self.current_evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance convergence by dynamically adjusting cognitive coefficient based on current global best fitness relative to average fitness.", "configspace": "", "generation": 96, "fitness": 0.38771786629759775, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "baa83eea-aa10-47fb-a48e-62fcf95b2da2", "metadata": {"aucs": [0.8373352872198025, 0.8543683012632295, 0.8384210781205675, 0.8525917662373086, 0.8587362958266975, 0.8423338611243791, 0.8433254518061553, 0.8306241435201216, 0.8617772790304009, 0.5148440845761604, 0.6189367122732298, 0.5558625971020169, 0.7460006341284242, 0.7576168874887717, 0.7496855217900212, 0.7139380576441652, 0.7365327467493272, 0.7428585655591959, 0.6044732536474307, 0.5340531365701964, 0.14991841278974094, 0.16456370878075688, 0.13104543089358178, 0.10208019859072759, 0.15541899420671412, 0.1597043828156458, 0.15757071763906494, 0.11369195254188103, 0.11720382015586461, 0.11963622144358177, 0.11618677386527765, 0.11851862689276982, 0.11216588039017716, 0.10418083809169698, 0.12079661900780336, 0.1149878665343178, 0.9860073721381967, 0.9813603333905507, 0.9809103921703577, 0.9815934643938448, 0.9801400530889053, 0.9856822614188431, 0.9777010029738822, 0.9861151085023978, 0.9668480357178457, 0.7309723973104538, 0.7282661969636604, 0.6715175869646113, 0.6756481897210593, 0.6636106003695557, 0.6993101611637988, 0.673326393012693, 0.6579205554810343, 0.6943592705563291, 0.8431916773953965, 0.7782591083522127, 0.8189617647425333, 0.8929227026431423, 0.817571932469975, 0.8568469216965936, 0.828320547525443, 0.8122005990157699, 0.8399018733206849, 0.37114937850049545, 0.2824131919677302, 0.25368926103481204, 0.2938360663776931, 0.5142152116180094, 0.1288803015074842, 0.2791014817912737, 0.3292853047301927, 0.2798672999563202, 0.12897663523926983, 0.21273191185759077, 0.23721026977854553, 0.3802712490150777, 0.22642464336782964, 0.2835127446057929, 0.3227165071729212, 0.24527522942793534, 0.42643660130345906, 0.06271853205293443, 0.06605052863478644, 0.18164013823976777, 0.24129116865266542, 0.12089093791115424, 0.008352022390891944, 0.18975459778721593, 0.2244548150272604, 0.34054029346339587, 0.39822774663704563, 0.4117567875630478, 0.406926195125913, 0.3731636055921401, 0.43149798231041314, 0.4336251003675198, 0.39777441009610626, 0.41331406343115573, 0.18965825468907682, 0.03307030321398907, 0.04667668007643366, 0.08965781987084298, 0.07356546076352766, 0.279887238361065, 0.07350208303105266, 0.135031610144853, 0.1728849644663718, 0.07137266389307662, 0.2397077308405171, 0.27688159449937877, 0.2204937383820409, 0.3132645012807789, 0.277840197950579, 0.2532453105111133, 0.08201459679438194, 0.24419434135627216, 0.23761341012070503, 0.6412357767782487, 0.6746550861553716, 0.6009064437682964, 0.6918160084331519, 0.7052975710556937, 0.6584403204825162, 0.6601250031537882, 0.6051995824051175, 0.6619216875604881, 0.08423711087507713, 0.11970540444488287, 0.1310914939848895, 0.12432182390227386, 0.11210178263062587, 0.12733761805983812, 0.12475203434444104, 0.21453290577504458, 0.23515993337925734, 0.22130295418017576, 0.1524954058797382, 0.2496996529800254, 0.1619190846343841, 0.2098535194660195, 0.2503680683010927, 0.1457274527000082, 0.17356640735041418, 0.21164699925624286, 0.4766663955451582, 0.4845503311288709, 0.3684045112220876, 0.3224047209768618, 0.5498477496545342, 0.5087148328988709, 0.6808595268605298, 0.558510788558308, 0.5003819657100144, 0.3616029133008092, 0.34673188041757275, 0.32221686919493797, 0.3669583995119712, 0.3847310708207067, 0.30809810255774484, 0.260995883038171, 0.33399833480348573, 0.3531086665744926, 0.23653633857756973, 0.20420967065091267, 0.21093288348536565, 0.21402402189329228, 0.20315838509343553, 0.18644998604228535, 0.20970038306699745, 0.2107673725906155, 0.22139137388722452, 0.6460208832040668, 0.20452016638053583, 0.21612037529745864, 0.19265224914947954, 0.2117164604562508, 0.21645571587678225, 0.1934506159803343, 0.2173131862165536, 0.23939324586104194, 0.1797033494771786, 0.8744634677187633, 0.1702915714689145, 0.8553295996930111, 0.871181053871334, 0.19565377964883168, 0.16276267843180614, 0.17813787677444304, 0.8553345161604465, 0.1277549873611895, 0.16813407692152338, 0.20879151607127766, 0.7785202792299661, 0.16895181897488842, 0.8053384944821147, 0.20617632909622863, 0.8348929674350444, 0.15420319323318932, 0.1844152104928486, 0.183955303779747, 0.18288999404962492, 0.18014607139988403, 0.17828384823712418, 0.20719564633201337, 0.18479805411999217, 0.19664119399999436, 0.1919236272620527, 0.08391860920823146, 0.10686359080945362, 0.12410173730819296, 0.131238444854352, 0.08227532365430357, 0.08460710460978804, 0.131037577679063, 0.08990065488676302, 0.08424485952621652]}, "mutation_prompt": null}
{"id": "2c33724e-7f93-4df3-bc3e-164052c9f598", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)  # Single line changed\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.4 * (1 - self.current_evaluations / self.budget)  # Line changed\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance exploration by dynamically adjusting mutation probability based on evaluation progress.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "baa83eea-aa10-47fb-a48e-62fcf95b2da2", "metadata": {"aucs": [0.8505627088958381, 0.8512466455685743, 0.8347639512759829, 0.8571383906009425, 0.8559227071707054, 0.8421931595274191, 0.8459677555013345, 0.8521673798467476, 0.8667468080033285, 0.7313881779407276, 0.731035822066803, 0.7366409345446867, 0.7512079293042503, 0.7761901455101239, 0.7310198497133564, 0.7275510081549272, 0.733987198491765, 0.7328396614702459, 0.4637735007026019, 0.15225979825521863, 0.13133457461103648, 0.15408971105773417, 0.14780074535835208, 0.14303888285342414, 0.3599674913982257, 0.1509808138426051, 0.14051536421641853, 0.10827820491925355, 0.1179827285575058, 0.1180169549650607, 0.1196192885046472, 0.11241813828645497, 0.12947970831279476, 0.11679053418109886, 0.1602107420114346, 0.11631730125502804, 0.9860075818742907, 0.9813547901431705, 0.980909052888153, 0.9815933552555339, 0.9802526087423779, 0.9856822614187654, 0.97770400840452, 0.9861147468719677, 0.9668137211733125, 0.6772869410155826, 0.6371236083036722, 0.6428801414268106, 0.6844122279144016, 0.6482982719798105, 0.6635743817450558, 0.6594845147917737, 0.6565989212882366, 0.652823086938853, 0.8051751816012995, 0.2225294568358145, 0.7854607956311138, 0.8546829706208545, 0.8616002828513076, 0.8569702963960506, 0.8375874130556182, 0.7838802486236344, 0.8295797129433864, 0.36203078681274414, 0.24648257513691674, 0.24579922215831773, 0.3827888123799791, 0.25342633433792494, 0.12903661989677662, 0.2587479364796199, 0.2461455844319166, 0.23334942835033456, 0.11774352415940481, 0.2363614240328178, 0.2559726084213757, 0.2941868371719861, 0.24585188759050858, 0.21972804440216964, 0.27159554820209486, 0.24093581553918475, 0.34902252157977387, 0.0776210622089546, 0.08040051925212921, 0.28024640773120546, 0.2322148683269225, 0.05500453534864369, 0.2509304017163857, 0.2924290760148348, 0.04612729183131303, 0.28508271415183917, 0.4296496442191585, 0.429955361026781, 0.4236213134726112, 0.4225411919945723, 0.2659316650246708, 0.3801123276580216, 0.3425834643686869, 0.4184139566169385, 0.26229565069685545, 0.04336795233370927, 0.11950879715636642, 0.09767073562076967, 0.0774583821315451, 0.19632040855841248, 0.07172937445303795, 0.23111975355149506, 0.18283162669737985, 0.06536831915676211, 0.230557291532001, 0.27361274816216496, 0.22917822094681706, 0.2465331540152227, 0.25197396596193744, 0.2488313403883976, 0.125548055675071, 0.24403625123355, 0.18886065376350292, 0.5476047529265374, 0.6688264738254883, 0.6651161622669544, 0.7083204164065475, 0.6876546932515558, 0.7130310037641998, 0.6728219179294395, 0.6712977364879374, 0.7128757375249122, 0.10692337777646865, 0.1299594727067952, 0.1085628000039236, 0.11121753463597162, 0.11657249159063299, 0.11655855907371804, 0.14980649524286704, 0.14625422551028766, 0.10948566596971598, 0.17533967612310375, 0.25937617071835073, 0.3712435356235354, 0.1544664918425246, 0.18466049612019741, 0.398338080545651, 0.19266989015343983, 0.20211536045857215, 0.2725755348396047, 0.47201153880111624, 0.4845780408369218, 0.42558406342276256, 0.4588900184651863, 0.5003466613088021, 0.4791667280794687, 0.5264248621270629, 0.2864522416830829, 0.5382977739187643, 0.20609576772961014, 0.32259807449898503, 0.39701402869057667, 0.30734123539074276, 0.4036544009444426, 0.2807872399804643, 0.36160743326374534, 0.36354026638477654, 0.3199428332353996, 0.2205274131302739, 0.22412348964980888, 0.19153048417397678, 0.21425879641582402, 0.21078601444796408, 0.2149130160090561, 0.20652414710896594, 0.26275906346055444, 0.24971303833535785, 0.20622527924909195, 0.49736820608552, 0.22933448347748675, 0.5737003883204941, 0.2116294848562117, 0.21064083453146953, 0.19645713063763792, 0.23592244161208253, 0.23390867240702906, 0.19597133519809395, 0.8438589155734071, 0.17297221858526302, 0.8248728606723333, 0.8727803911670594, 0.19566811319361932, 0.794296144242384, 0.17793499150446113, 0.8329406520234909, 0.12765500592736245, 0.16808500446152863, 0.21051440785726927, 0.8001054828168206, 0.16886528480345242, 0.7564164080233886, 0.19992955927080547, 0.8308173060790089, 0.7169391670113034, 0.1884013070066094, 0.19630697292772803, 0.17784224146565797, 0.17641819264395886, 0.1842687643263674, 0.20628895913164713, 0.18538987241583949, 0.20788685228667592, 0.19655440453651807, 0.08186299167556321, 0.11524738504449794, 0.1045450831814293, 0.0844464505718322, 0.08498657177541913, 0.09189402793846368, 0.10891258260336212, 0.08840504199608312, 0.08051496775319444]}, "mutation_prompt": null}
{"id": "87404b71-6b95-4448-af1c-c8e3b2e8f339", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        \n        # Dynamic velocity clamping\n        velocity_clamp = 0.1 + 0.9 * (diversity / (np.max(diversity) + 1e-5))\n        velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)  # Line changed \n        \n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.1 + 0.4 * (1 - self.current_evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Refine exploration by incorporating dynamic velocity clamping based on population diversity.", "configspace": "", "generation": 98, "fitness": 0.39498883889227543, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "baa83eea-aa10-47fb-a48e-62fcf95b2da2", "metadata": {"aucs": [0.8567794027748102, 0.8650043131143406, 0.8631221587888004, 0.8499733044226747, 0.8722391312332213, 0.8624320101175065, 0.8571224626659336, 0.8638542730413192, 0.8674781749623859, 0.767147069738761, 0.7606438657373693, 0.7608532999295807, 0.7292903468560892, 0.7682419323697545, 0.7284189472246809, 0.7481064052829984, 0.7552196356688798, 0.7519435863023344, 0.1527470765403619, 0.08705138978318605, 0.14470252437428932, 0.17141058130172493, 0.1452409300220705, 0.1780335829088221, 0.11490877414898282, 0.44399359152762785, 0.11379291816874515, 0.09456580352359323, 0.1145510519045656, 0.11962369671280426, 0.10096390087706042, 0.0937393881236509, 0.09562039408209988, 0.1019523214756125, 0.12944312047030293, 0.11043216010148915, 0.8975753553798876, 0.8632430431023292, 0.8741010179708611, 0.8965057193322798, 0.8831089112106209, 0.9096585530211132, 0.9026551188571793, 0.921787060972432, 0.9033061122264522, 0.6779948496842969, 0.7023107620932372, 0.7052007983709172, 0.7162205577539359, 0.7088092076538038, 0.6898184885112877, 0.6905091897064166, 0.6982089453172942, 0.6737741361493141, 0.8498285711285392, 0.8525330164352708, 0.16938312387470944, 0.8390705926028896, 0.8609441243472327, 0.8722276177614906, 0.7938072579719578, 0.6165449872603872, 0.23398270175614377, 0.2525839451780857, 0.23788584007985458, 0.13220821678665984, 0.27285530238127953, 0.2850945689998575, 0.3126368242052253, 0.30544207288773095, 0.3257554645513182, 0.28311542510785426, 0.12836063748519666, 0.28867273602989285, 0.26833825213832885, 0.13336169587853797, 0.32729904418671996, 0.4412441270370998, 0.30609612872418535, 0.1316420299911777, 0.1331583736823122, 0.2513622248285089, 0.2480168059289788, 0.3182464432109745, 0.2831889646490716, 0.3060893570429958, 0.30789885986584165, 0.2823143429786594, 0.26861182043179355, 0.28067065261120594, 0.5082340869822851, 0.37234955491191235, 0.3712608199311529, 0.34175457812093524, 0.2814296273885518, 0.40118203338527636, 0.40205390415036024, 0.4086690164479011, 0.3862179801443497, 0.11901289744495203, 0.18451897606456968, 0.13021959403176775, 0.08196414992096457, 0.1477586479574582, 0.15833116421997417, 0.15381502360833876, 0.1364444997403047, 0.0955640175710607, 0.28971857494241493, 0.16588007289756534, 0.2722459328841811, 0.3296190047153661, 0.282490242959465, 0.294355864514942, 0.0980735518778929, 0.1958998968378528, 0.2598021045946647, 0.6800781932534389, 0.6850178705622076, 0.6497546295206698, 0.6744412969002576, 0.648099895403518, 0.7410870551946236, 0.720521796257743, 0.7271791390427067, 0.6677806699186627, 0.1673899067732918, 0.11143091152817053, 0.13603318292721145, 0.1413348224701163, 0.1263718217248635, 0.1390013583394657, 0.13718661212487004, 0.1350829223146971, 0.12114887756517745, 0.2157616357754154, 0.19778921993492848, 0.1849386131206856, 0.17353230118149654, 0.20939483496900235, 0.22682405785438997, 0.19120425297773558, 0.2055539379835596, 0.24219499731829996, 0.4780607894522947, 0.533054306520482, 0.4679743177980755, 0.5201066984744835, 0.5461957475532474, 0.5743740303634159, 0.5577319090632018, 0.47312993623334965, 0.5617043503194774, 0.39699083826683446, 0.37819460617958545, 0.30460519550509935, 0.3807812517185095, 0.4006980023178377, 0.5059010314913435, 0.2400910342784639, 0.24288673678819128, 0.35340513595018574, 0.2171321193854, 0.22005324164469808, 0.23496312544599873, 0.20770720173024027, 0.28287628716371893, 0.2223977727010491, 0.23363637243555513, 0.23638377153551682, 0.22575084458658123, 0.20016224228559254, 0.18401633383576022, 0.5789992048402129, 0.21919300613256543, 0.21399895685319936, 0.23910720886985815, 0.19139108072181088, 0.21466786839181484, 0.2429658785626233, 0.17938755175845, 0.8668086984678944, 0.18342176485123185, 0.1937049377728779, 0.8724672617914567, 0.1957158191252404, 0.17713166418649384, 0.8582361296717778, 0.8640073594726826, 0.7793350053966461, 0.814504671845256, 0.7989656875396441, 0.8419124453743677, 0.16794920740247565, 0.16822927113581232, 0.8226679569429227, 0.8035338315156169, 0.16377140779629795, 0.2089578207147742, 0.18314453960317356, 0.19355354934743385, 0.18120518796446305, 0.19178235373919683, 0.17894418458383554, 0.19319148170869815, 0.19626570298915036, 0.21472566227829992, 0.08522494989928964, 0.09392505619538438, 0.09193991486106845, 0.09480152773436346, 0.09561802698860988, 0.0906454876113787, 0.11952780284495623, 0.09293036101244323, 0.09726234841782722]}, "mutation_prompt": null}
{"id": "326e658f-9f1b-4d8a-8a2f-46ef39ac5709", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.0 + 1.0 * np.random.rand()\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.apply_along_axis(func, 1, positions)\n        self.current_evaluations += self.population_size\n        return fitness\n\n    def update_velocities_and_positions(self, positions, velocities, \n                                        personal_best_positions, global_best_position):\n        r_p = np.random.uniform(0, 1, (self.population_size, self.dim))\n        r_g = np.random.uniform(0, 1, (self.population_size, self.dim))\n        \n        # Adjusted cognitive and social coefficients\n        self.cognitive_coefficient = 1.5 + 0.5 * (self.current_evaluations / self.budget)\n        self.social_coefficient = 1.5 - 0.5 * (self.current_evaluations / self.budget)\n        \n        cognitive_term = self.cognitive_coefficient * r_p * (personal_best_positions - positions)\n        social_term = self.social_coefficient * r_g * (global_best_position - positions)\n        \n        diversity = np.std(positions, axis=0)\n        adaptive_inertia = 0.4 + 0.1 * (diversity / (np.max(diversity) + 1e-5))\n        self.inertia_weight = adaptive_inertia * (1 - self.current_evaluations / self.budget)\n        \n        velocities = self.inertia_weight * velocities + cognitive_term + social_term\n        \n        # Dynamic velocity clamping\n        velocity_clamp = 0.1 + 0.9 * (diversity / (np.max(diversity) + 1e-5))\n        velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n        \n        positions += velocities\n        positions = np.clip(positions, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def mutation_strategy(self, position, best_positions, fitness_variance):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = best_positions[indices]\n        position_diversity = np.std(position)\n        perturbation_scale = 0.4 + 0.6 * (1 - (position_diversity / (np.max(position_diversity) + 1e-5)))\n        mutant = a + perturbation_scale * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_index = np.argmin(fitness)\n        global_best_position = positions[global_best_index]\n\n        while self.current_evaluations < self.budget:\n            positions, velocities = self.update_velocities_and_positions(\n                positions, velocities, personal_best_positions, global_best_position)\n\n            fitness_variation = np.clip(np.max(fitness) - np.min(fitness), 1e-5, None)\n            mutation_prob = 0.3 + 0.4 * (1 - self.current_evaluations / self.budget)  # Line changed\n\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    positions[i] = self.mutation_strategy(positions[i], personal_best_positions, fitness_variation)\n\n            fitness = self.evaluate_population(positions, func)\n            \n            better_indices = fitness < personal_best_fitness\n            personal_best_fitness[better_indices] = fitness[better_indices]\n            personal_best_positions[better_indices] = positions[better_indices]\n\n            global_best_index = np.argmin(personal_best_fitness)\n            global_best_position = personal_best_positions[global_best_index]\n\n        return global_best_position, personal_best_fitness[global_best_index]", "name": "HybridPSO_DE", "description": "Enhance diversity by increasing mutation probability, facilitating exploration in stagnant phases.", "configspace": "", "generation": 99, "fitness": 0.41146303371062487, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "87404b71-6b95-4448-af1c-c8e3b2e8f339", "metadata": {"aucs": [0.8258097905836126, 0.8390470172502793, 0.8415393574532521, 0.8366755967079887, 0.8295919054005156, 0.8080931744562159, 0.8282678569455011, 0.8392624908021392, 0.8368090117465933, 0.749170242459064, 0.7126492747611822, 0.742294907800156, 0.7054971995574343, 0.7421616914105857, 0.7385804078824603, 0.7408898618489046, 0.7301889712398308, 0.7202820616245317, 0.1430504774967838, 0.14494983457064392, 0.26986133570335824, 0.13136357175301472, 0.13295915397150126, 0.5156523236089277, 0.16318690482623133, 0.14769940406153004, 0.560485533480578, 0.12759631010808314, 0.09606217660465444, 0.12509123281129453, 0.11634589923832339, 0.12221829757485225, 0.11256773469585857, 0.12000587340496027, 0.11470980336174452, 0.11866818085401809, 0.9285831628574254, 0.7859349342385895, 0.9080130220286782, 0.8078855737663079, 0.810217956656508, 0.9089298848205534, 0.8791789028255059, 0.8954522818403737, 0.7708990430846513, 0.6020706062420383, 0.6504426287368644, 0.6446151567673559, 0.6345446422492722, 0.6650544141985059, 0.6471251251815262, 0.6688701627628322, 0.6491355094749106, 0.6612832444774588, 0.8275366124500825, 0.7362989085714784, 0.8706432806986473, 0.8527293655337337, 0.8677940915301587, 0.8461234888267581, 0.8597002229131137, 0.8405736559298626, 0.823507112509533, 0.25142806710817245, 0.21598799374678768, 0.2797494959518738, 0.2731886735488024, 0.34118187805711164, 0.22844048811403994, 0.34736310726502106, 0.12845638810765814, 0.3463521852533199, 0.13760925542703828, 0.2610823547156218, 0.267875503416266, 0.22904319952822683, 0.13016895458141642, 0.2868646138301363, 0.25713163223757973, 0.23097811558108128, 0.3372693138127122, 0.3370107793463576, 0.48555073923011705, 0.10556998224229863, 0.08900289727768818, 0.4185670465612773, 0.15399004791894344, 0.4334506751401864, 0.10051857590576141, 0.5214234262004753, 0.5820067776363902, 0.4099170618474275, 0.5961291581673692, 0.5891016257695385, 0.5313701071627737, 0.4291615467900822, 0.5818192861346537, 0.407134150440972, 0.5730076446820076, 0.1998048711969712, 0.2894825092942891, 0.08655269147810962, 0.30484782985483505, 0.28638850107562364, 0.2209874671679949, 0.10608198076403474, 0.201556558707346, 0.20622384344444566, 0.30049527704017787, 0.36133031167249696, 0.3748606518411406, 0.27883726419559884, 0.3395862787343833, 0.35643545642354235, 0.17662958096062975, 0.34898370005135426, 0.3985617376586681, 0.6362475062200644, 0.7643597913962925, 0.749194746915891, 0.7563530729324908, 0.730514976109186, 0.7516875554882763, 0.7792214777588994, 0.7088623047978786, 0.751713767456587, 0.1367059087260919, 0.11802206029846785, 0.11281854927409718, 0.1130666193190647, 0.15762052568622675, 0.10871193004549673, 0.11842912467421096, 0.11669976754150979, 0.12215422331610226, 0.15244962841647103, 0.1433528883295665, 0.16417234890185628, 0.15941142982137735, 0.19486648085465685, 0.14554415716038405, 0.1709514527773197, 0.1747861999348359, 0.1592697219601401, 0.5625027258255939, 0.5372798958302459, 0.48965697902408933, 0.5127743395069224, 0.49310546452674797, 0.5708674977487167, 0.6066226804032367, 0.6276717719622187, 0.5318172413884374, 0.36248619042131835, 0.3780885080340618, 0.4249074231590356, 0.4304717772355071, 0.35295522153036507, 0.40997003577457447, 0.40637687180601745, 0.42781708704390553, 0.42124164611159143, 0.2264468465423911, 0.23531806723171622, 0.2167377474888904, 0.22452372035400603, 0.20008544405728046, 0.22461162364073917, 0.2069749483193295, 0.23399115227000689, 0.22922576179412957, 0.4843343152329056, 0.2298145878383745, 0.2179978071342561, 0.21430793283262972, 0.19633115255429134, 0.21734453662437325, 0.637766958751473, 0.23756633864300514, 0.21645564424122254, 0.7658093433056743, 0.1656852880367392, 0.18504492500294623, 0.8698194027148212, 0.8227979662803353, 0.8270897876235082, 0.8068901210510397, 0.8261967732375721, 0.20033112196904335, 0.7476792957514075, 0.16739683123227989, 0.2075886254622531, 0.7601465236466826, 0.20767854068225577, 0.20956672587768854, 0.2045187900368206, 0.6933097858260991, 0.1657071725355157, 0.1920933315892407, 0.20771313145527315, 0.18678459688437166, 0.19887106977494928, 0.19927409613295544, 0.19939389866462198, 0.1921094622203804, 0.17521473008779498, 0.18543679132117297, 0.09169707558801587, 0.084739364929737, 0.09191026505628885, 0.09330805786594842, 0.0875143674210529, 0.09044079795578397, 0.07914500714098227, 0.08796622635171258, 0.10053271225680493]}, "mutation_prompt": null}
