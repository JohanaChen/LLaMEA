{"id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "solution": "import numpy as np\n\nclass HarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HarmonySearchOptimizer", "description": "Harmony Search Optimization algorithm inspired by musical improvisation where new solutions are generated by combining existing solutions and modifying them.", "configspace": "", "generation": 0, "fitness": 0.15708572479442415, "feedback": "The algorithm HarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.11.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4174114688791628, 0.490906662163201, 0.46289055766691645, 0.4067360585988167, 0.45432910131988224, 0.4391474309588963, 0.45774326258327924, 0.5476799336064024, 0.46916674939310143, 0.002461463430626698, 0.0433668580287746, 0.0010781287676956408, 0.012948663479736777, 0.004473748011398548, 0.1321527853769383, 9.999999999998899e-05, 0.0037240071325186364, 0.043826467338821784, 0.1635605002856606, 0.1856550100722406, 0.18243844235695872, 0.17469307316432026, 0.18032791888837107, 0.15245279457865124, 0.16310782279574365, 0.1508418117137027, 0.1533642550577755, 0.1713333840014568, 0.1667817082463291, 0.13819472120986298, 0.1419172656827561, 0.15834852682445877, 0.18129645835583097, 0.16793675204959435, 0.14438064569316977, 0.1305710491765687, 0.20123407717602382, 0.18888513116336403, 0.19876018107468563, 0.2429068178474637, 0.1846114354292966, 0.2203294934851866, 0.25578218130134667, 0.18397659729490767, 0.20036300435135845, 0.15163956435368386, 0.233278000488931, 0.18214202621684228, 0.18768547118433143, 0.1611892511264852, 0.16287023251323496, 0.13615988114106148, 0.16029963438231354, 0.17009629358040423, 0.21428212733288143, 0.13251105720291712, 0.1409164227476174, 0.18956750810486978, 0.17905244972922285, 0.24682186601212652, 0.14524138451858926, 0.21442868887134514, 0.15855588910285168, 0.11408416299828439, 0.15777311176453146, 0.12759666185351892, 0.12721525443546855, 0.1986105588833419, 0.1583539150511466, 0.12709287208337883, 0.19433341560265938, 0.14129562478759383, 0.12807229816850685, 0.10346036672315662, 0.1598265253304516, 0.12331186368508029, 0.12498027506495635, 0.13319115849235807, 0.12153493663744341, 0.12741892144132105, 0.15295865563388356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03584103432446939, 0.021992054789585547, 0.056152467519111404, 0.06303710801638429, 0.03831851888161142, 0.029746813913476555, 0.13044936540474716, 0.06465333058185874, 0.0503314339266161, 9.999999999998899e-05, 9.999999999998899e-05, 0.04736807161330836, 9.999999999998899e-05, 9.999999999998899e-05, 0.00021083227657348047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10754645590429923, 0.03838783192169415, 0.08744280118831105, 0.07831399831056662, 0.0390348882327054, 0.04449245912120692, 0.05907412602905515, 0.06899602607166833, 0.08059648393304364, 0.3564755002852452, 0.3664900607975756, 0.3415489854860687, 0.34103978739522633, 0.3657662600960728, 0.34523123673472644, 0.3986889596441052, 0.35136561732433635, 0.34828606562612874, 0.11997680504142172, 0.07873813496663129, 0.04966923195334205, 0.08833049415972749, 0.08582895649013245, 0.05745753918464236, 0.06287840943046319, 0.04700266620108562, 0.08585432433400653, 0.14221629740685038, 0.15474974894119364, 0.18042184415635165, 0.16438913000291488, 0.1868625781237152, 0.17560157150435096, 0.16987185271987304, 0.1190435736963551, 0.1549850583741016, 0.14235074360521016, 0.20186296813374172, 0.18935038173714214, 0.1876919700541667, 0.17276382429165205, 0.2283638777870628, 0.17790498212637518, 0.20916731157980772, 0.16790032879673455, 0.15167038486805506, 0.14013431775893892, 0.15393667499872787, 0.1785245985825602, 0.1727116258348751, 0.16878287149480853, 0.16636182708180858, 0.11187390206638448, 0.10278339181495699, 0.2266446758497338, 0.14241708579020962, 0.18260116878039057, 0.18340205300011725, 0.18968466088687896, 0.17759080477028744, 0.1913542996346861, 0.20623470391755305, 0.15381152023746925, 0.17570584965479685, 0.20987679570648898, 0.3033653574113335, 0.21388605867858046, 0.22418106133899107, 0.22553204240735636, 0.19314959072804705, 0.21910918916735356, 0.22164331163559414, 0.19785655673598346, 0.1521134666872478, 0.1681673465146012, 0.43001587460141943, 0.1989113745171187, 0.13765284039092418, 0.15135934938731277, 0.33151642683301275, 0.16615305246017598, 0.20053762178010714, 0.23280654851309435, 0.2066420526559688, 0.12232783333739938, 0.19984757593449798, 0.19741962076015107, 0.10346249053598278, 0.15405909977652377, 0.23374883168669625, 0.1740752492991371, 0.1694161823091428, 0.17807806130158266, 0.1955931423560805, 0.17507957262775486, 0.1752019099350035, 0.1593029363225098, 0.206777795467744, 0.18462417211483384, 0.08349619597951774, 0.07385268196635175, 0.08111578329716207, 0.08157492219642248, 0.11655388726663474, 0.0886909349571271, 0.06763259277905764, 0.07864463326789572, 0.047482201537582314]}, "mutation_prompt": null}
{"id": "3889f804-8235-4374-8235-655f22b29521", "solution": "import numpy as np\n\nclass HarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HarmonySearchOptimizer", "description": "Harmony Search Optimization algorithm inspired by musical improvisation where new solutions are generated by combining existing solutions and modifying them.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "metadata": {"aucs": [0.4174114688791628, 0.490906662163201, 0.46289055766691645, 0.4067360585988167, 0.45432910131988224, 0.4391474309588963, 0.45774326258327924, 0.5476799336064024, 0.46916674939310143, 0.002461463430626698, 0.0433668580287746, 0.0010781287676956408, 0.012948663479736777, 0.004473748011398548, 0.1321527853769383, 9.999999999998899e-05, 0.0037240071325186364, 0.043826467338821784, 0.1635605002856606, 0.1856550100722406, 0.18243844235695872, 0.17469307316432026, 0.18032791888837107, 0.15245279457865124, 0.16310782279574365, 0.1508418117137027, 0.1533642550577755, 0.1713333840014568, 0.1667817082463291, 0.13819472120986298, 0.1419172656827561, 0.15834852682445877, 0.18129645835583097, 0.16793675204959435, 0.14438064569316977, 0.1305710491765687, 0.20123407717602382, 0.18888513116336403, 0.19876018107468563, 0.2429068178474637, 0.1846114354292966, 0.2203294934851866, 0.25578218130134667, 0.18397659729490767, 0.20036300435135845, 0.15163956435368386, 0.233278000488931, 0.18214202621684228, 0.18768547118433143, 0.1611892511264852, 0.16287023251323496, 0.13615988114106148, 0.16029963438231354, 0.17009629358040423, 0.21428212733288143, 0.13251105720291712, 0.1409164227476174, 0.18956750810486978, 0.17905244972922285, 0.24682186601212652, 0.14524138451858926, 0.21442868887134514, 0.15855588910285168, 0.11408416299828439, 0.15777311176453146, 0.12759666185351892, 0.12721525443546855, 0.1986105588833419, 0.1583539150511466, 0.12709287208337883, 0.19433341560265938, 0.14129562478759383, 0.12807229816850685, 0.10346036672315662, 0.1598265253304516, 0.12331186368508029, 0.12498027506495635, 0.13319115849235807, 0.12153493663744341, 0.12741892144132105, 0.15295865563388356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03584103432446939, 0.021992054789585547, 0.056152467519111404, 0.06303710801638429, 0.03831851888161142, 0.029746813913476555, 0.13044936540474716, 0.06465333058185874, 0.0503314339266161, 9.999999999998899e-05, 9.999999999998899e-05, 0.04736807161330836, 9.999999999998899e-05, 9.999999999998899e-05, 0.00021083227657348047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10754645590429923, 0.03838783192169415, 0.08744280118831105, 0.07831399831056662, 0.0390348882327054, 0.04449245912120692, 0.05907412602905515, 0.06899602607166833, 0.08059648393304364, 0.3564755002852452, 0.3664900607975756, 0.3415489854860687, 0.34103978739522633, 0.3657662600960728, 0.34523123673472644, 0.3986889596441052, 0.35136561732433635, 0.34828606562612874, 0.11997680504142172, 0.07873813496663129, 0.04966923195334205, 0.08833049415972749, 0.08582895649013245, 0.05745753918464236, 0.06287840943046319, 0.04700266620108562, 0.08585432433400653, 0.14221629740685038, 0.15474974894119364, 0.18042184415635165, 0.16438913000291488, 0.1868625781237152, 0.17560157150435096, 0.16987185271987304, 0.1190435736963551, 0.1549850583741016, 0.14235074360521016, 0.20186296813374172, 0.18935038173714214, 0.1876919700541667, 0.17276382429165205, 0.2283638777870628, 0.17790498212637518, 0.20916731157980772, 0.16790032879673455, 0.15167038486805506, 0.14013431775893892, 0.15393667499872787, 0.1785245985825602, 0.1727116258348751, 0.16878287149480853, 0.16636182708180858, 0.11187390206638448, 0.10278339181495699, 0.2266446758497338, 0.14241708579020962, 0.18260116878039057, 0.18340205300011725, 0.18968466088687896, 0.17759080477028744, 0.1913542996346861, 0.20623470391755305, 0.15381152023746925, 0.17570584965479685, 0.20987679570648898, 0.3033653574113335, 0.21388605867858046, 0.22418106133899107, 0.22553204240735636, 0.19314959072804705, 0.21910918916735356, 0.22164331163559414, 0.19785655673598346, 0.1521134666872478, 0.1681673465146012, 0.43001587460141943, 0.1989113745171187, 0.13765284039092418, 0.15135934938731277, 0.33151642683301275, 0.16615305246017598, 0.20053762178010714, 0.23280654851309435, 0.2066420526559688, 0.12232783333739938, 0.19984757593449798, 0.19741962076015107, 0.10346249053598278, 0.15405909977652377, 0.23374883168669625, 0.1740752492991371, 0.1694161823091428, 0.17807806130158266, 0.1955931423560805, 0.17507957262775486, 0.1752019099350035, 0.1593029363225098, 0.206777795467744, 0.18462417211483384, 0.08349619597951774, 0.07385268196635175, 0.08111578329716207, 0.08157492219642248, 0.11655388726663474, 0.0886909349571271, 0.06763259277905764, 0.07864463326789572, 0.047482201537582314]}, "mutation_prompt": null}
{"id": "116b3673-6e4e-4967-b3eb-ebfcdb0de4aa", "solution": "import numpy as np\n\nclass DynamicPitchHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n                pitch_adjust_rate = 0.1 + 0.9 * ((np.mean(fitness_values) - new_fitness) / np.mean(fitness_values))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicPitchHarmonySearchOptimizer", "description": "Enhancing Harmony Search Optimization by incorporating a dynamic pitch adjustment probability based on fitness improvement.", "configspace": "", "generation": 2, "fitness": 0.15205333421629086, "feedback": "The algorithm DynamicPitchHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.11.", "error": "", "parent_id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "metadata": {"aucs": [0.4199519860481823, 0.48837107512663713, 0.45397510141910324, 0.4392002170618188, 0.45475017643591076, 0.4607972424407971, 0.45976762722344033, 0.5410884354602603, 0.45225284206867333, 9.999999999998899e-05, 0.008574576156360258, 0.00234211368121906, 0.00915566329366102, 0.002115171936383553, 0.07621284786139726, 9.999999999998899e-05, 9.999999999998899e-05, 0.012105764971137245, 0.1916261730794887, 0.1862975625211648, 0.18090559259859817, 0.17625318899816722, 0.18056024854519692, 0.14687420849797106, 0.17029557242296856, 0.15446312778522153, 0.1672766254524538, 0.17692896078335474, 0.16715494091916827, 0.15508476213882272, 0.1582489845222248, 0.15754650248339008, 0.18010040744411582, 0.18060284605928423, 0.14548575379565554, 0.13319097435892813, 0.10448506097684207, 0.1064335483592469, 0.10618584458106362, 0.2532277787324554, 0.1846458519417029, 0.20117575886101202, 0.25489712791046637, 0.18089040175663396, 0.19932330321527403, 0.1484277253877926, 0.24448488998492635, 0.22557046741601927, 0.21928679724940214, 0.21586432594264782, 0.13990658654255983, 0.1661572962689526, 0.14823792740811892, 0.14481512884779657, 0.1299102799694718, 0.11931197038330954, 0.11330220995244689, 0.14339785300917263, 0.18792880801558176, 0.29130051023192705, 0.12053932981560733, 0.21741044394543974, 0.17185350364110652, 0.17641914247117707, 0.12915348225455348, 0.13608546043032588, 0.16917763724681267, 0.11421165094685914, 0.12142180881384157, 0.156644357572009, 0.2611815674629263, 0.24737654652748142, 0.117154842950141, 0.19755586248107215, 0.16060313028593098, 0.13369840252272713, 0.1012425112945946, 0.14647542159045845, 0.14481801045490905, 0.14475871955300568, 0.11126108102911003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012499474394424559, 0.017535624268427585, 0.04679929947813721, 0.06169723227810775, 0.015306508230418459, 0.013598104587887239, 0.04414481379441004, 0.07901574807000833, 0.07528572300839875, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1118402546873889, 0.07024887132338986, 0.0916171510115702, 0.027420292975528948, 0.0036313018572351474, 0.036472263296255525, 0.06427997821332043, 0.05536892651166092, 0.029286340090353025, 0.3402748418654392, 0.3752247324436597, 0.3901712203845389, 0.3329249115710351, 0.3885586202286456, 0.3646283113429003, 0.34828974902936427, 0.3334024482402532, 0.34730981122631943, 0.0945613206230752, 0.10471672023841605, 0.07056005762856599, 0.07918687317268291, 0.053177710240172926, 0.10294783295811727, 0.09274957705856635, 0.06410054121482645, 0.07412634228925286, 0.13448311444735805, 0.20857741328484647, 0.1949266033552316, 0.16437981496097476, 0.13058808758056606, 0.11873178201052503, 0.169867703556284, 0.11821012343476656, 0.15503154288786158, 0.14998874753997393, 0.24104228289772822, 0.17455771705362455, 0.21948542146810301, 0.24980531846868137, 0.22134066669672126, 0.17789737577379006, 0.20916731157980772, 0.19013763628492986, 0.15116637507129105, 0.12228898024663248, 0.15872329083310566, 0.2055709722415059, 0.13492774887992165, 0.20685269384357496, 0.17039881374238286, 0.11177913759702929, 0.16067782664673957, 0.17418932055476566, 0.17788036008807828, 0.16378440291172103, 0.19192685908652207, 0.143328028182251, 0.18635080134499504, 0.19134579099453253, 0.17265020280114518, 0.15381152023746925, 0.20431601503105734, 0.21805381808321267, 0.1981467951564554, 0.2998903752013773, 0.20946715790142723, 0.20350762388841515, 0.20165641161226566, 0.1966315091806341, 0.21334903954394102, 0.1224327722041928, 0.13122193973358476, 0.19513700086845343, 0.18760204540565573, 0.22121399906054418, 0.16216098438615223, 0.15110086107428122, 0.14699479689257566, 0.15949424279037672, 0.21713424004167592, 0.10645000700255769, 0.16686638485049332, 0.12220512037551923, 0.19984757593449798, 0.20327595820082378, 0.15329734722321298, 0.10467524239956405, 0.09427634985049882, 0.1695406175335391, 0.18038589527424043, 0.17808112878435545, 0.17256202762113604, 0.1854796200542218, 0.18228240705526055, 0.15930203581842617, 0.19866420950437436, 0.18462417211483384, 0.06070713111398107, 0.07778029673813491, 0.06387330301065652, 0.06942528104505696, 0.08816519197818251, 0.06017655069939498, 0.05231086843415811, 0.07739523812762272, 0.07365964367354849]}, "mutation_prompt": null}
{"id": "816a28ab-281b-4d77-8368-d7dbf1f9fa3e", "solution": "import numpy as np\n\nclass HarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HarmonySearchOptimizer", "description": "Harmony Search Optimization algorithm inspired by musical improvisation where new solutions are generated by combining existing solutions and modifying them.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "metadata": {"aucs": [0.4174114688791628, 0.490906662163201, 0.46289055766691645, 0.4067360585988167, 0.45432910131988224, 0.4391474309588963, 0.45774326258327924, 0.5476799336064024, 0.46916674939310143, 0.002461463430626698, 0.0433668580287746, 0.0010781287676956408, 0.012948663479736777, 0.004473748011398548, 0.1321527853769383, 9.999999999998899e-05, 0.0037240071325186364, 0.043826467338821784, 0.1635605002856606, 0.1856550100722406, 0.18243844235695872, 0.17469307316432026, 0.18032791888837107, 0.15245279457865124, 0.16310782279574365, 0.1508418117137027, 0.1533642550577755, 0.1713333840014568, 0.1667817082463291, 0.13819472120986298, 0.1419172656827561, 0.15834852682445877, 0.18129645835583097, 0.16793675204959435, 0.14438064569316977, 0.1305710491765687, 0.20123407717602382, 0.18888513116336403, 0.19876018107468563, 0.2429068178474637, 0.1846114354292966, 0.2203294934851866, 0.25578218130134667, 0.18397659729490767, 0.20036300435135845, 0.15163956435368386, 0.233278000488931, 0.18214202621684228, 0.18768547118433143, 0.1611892511264852, 0.16287023251323496, 0.13615988114106148, 0.16029963438231354, 0.17009629358040423, 0.21428212733288143, 0.13251105720291712, 0.1409164227476174, 0.18956750810486978, 0.17905244972922285, 0.24682186601212652, 0.14524138451858926, 0.21442868887134514, 0.15855588910285168, 0.11408416299828439, 0.15777311176453146, 0.12759666185351892, 0.12721525443546855, 0.1986105588833419, 0.1583539150511466, 0.12709287208337883, 0.19433341560265938, 0.14129562478759383, 0.12807229816850685, 0.10346036672315662, 0.1598265253304516, 0.12331186368508029, 0.12498027506495635, 0.13319115849235807, 0.12153493663744341, 0.12741892144132105, 0.15295865563388356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03584103432446939, 0.021992054789585547, 0.056152467519111404, 0.06303710801638429, 0.03831851888161142, 0.029746813913476555, 0.13044936540474716, 0.06465333058185874, 0.0503314339266161, 9.999999999998899e-05, 9.999999999998899e-05, 0.04736807161330836, 9.999999999998899e-05, 9.999999999998899e-05, 0.00021083227657348047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10754645590429923, 0.03838783192169415, 0.08744280118831105, 0.07831399831056662, 0.0390348882327054, 0.04449245912120692, 0.05907412602905515, 0.06899602607166833, 0.08059648393304364, 0.3564755002852452, 0.3664900607975756, 0.3415489854860687, 0.34103978739522633, 0.3657662600960728, 0.34523123673472644, 0.3986889596441052, 0.35136561732433635, 0.34828606562612874, 0.11997680504142172, 0.07873813496663129, 0.04966923195334205, 0.08833049415972749, 0.08582895649013245, 0.05745753918464236, 0.06287840943046319, 0.04700266620108562, 0.08585432433400653, 0.14221629740685038, 0.15474974894119364, 0.18042184415635165, 0.16438913000291488, 0.1868625781237152, 0.17560157150435096, 0.16987185271987304, 0.1190435736963551, 0.1549850583741016, 0.14235074360521016, 0.20186296813374172, 0.18935038173714214, 0.1876919700541667, 0.17276382429165205, 0.2283638777870628, 0.17790498212637518, 0.20916731157980772, 0.16790032879673455, 0.15167038486805506, 0.14013431775893892, 0.15393667499872787, 0.1785245985825602, 0.1727116258348751, 0.16878287149480853, 0.16636182708180858, 0.11187390206638448, 0.10278339181495699, 0.2266446758497338, 0.14241708579020962, 0.18260116878039057, 0.18340205300011725, 0.18968466088687896, 0.17759080477028744, 0.1913542996346861, 0.20623470391755305, 0.15381152023746925, 0.17570584965479685, 0.20987679570648898, 0.3033653574113335, 0.21388605867858046, 0.22418106133899107, 0.22553204240735636, 0.19314959072804705, 0.21910918916735356, 0.22164331163559414, 0.19785655673598346, 0.1521134666872478, 0.1681673465146012, 0.43001587460141943, 0.1989113745171187, 0.13765284039092418, 0.15135934938731277, 0.33151642683301275, 0.16615305246017598, 0.20053762178010714, 0.23280654851309435, 0.2066420526559688, 0.12232783333739938, 0.19984757593449798, 0.19741962076015107, 0.10346249053598278, 0.15405909977652377, 0.23374883168669625, 0.1740752492991371, 0.1694161823091428, 0.17807806130158266, 0.1955931423560805, 0.17507957262775486, 0.1752019099350035, 0.1593029363225098, 0.206777795467744, 0.18462417211483384, 0.08349619597951774, 0.07385268196635175, 0.08111578329716207, 0.08157492219642248, 0.11655388726663474, 0.0886909349571271, 0.06763259277905764, 0.07864463326789572, 0.047482201537582314]}, "mutation_prompt": null}
{"id": "384fc512-a0ac-42f0-8494-3f4199bcf72f", "solution": "import numpy as np\n\nclass EnhancedHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, fitness_values):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate * (1 - (fitness_values[np.argmax(fitness_values)] - fitness_values.min()) / (fitness_values.max() - fitness_values.min())):\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, fitness_values)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHarmonySearchOptimizer", "description": "Enhancing Harmony Search Optimizer by incorporating dynamic pitch adjustment based on fitness landscape", "configspace": "", "generation": 4, "fitness": 0.03079676869890099, "feedback": "The algorithm EnhancedHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "metadata": {"aucs": [0.07181397830146763, 0.06432772651221763, 0.08237988959495246, 0.019583725566517884, 0.05267361210777377, 0.025288696900545027, 0.05140423906395497, 0.05163064099738546, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012186513362246743, 9.999999999998899e-05, 0.018248263482334326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.03775594762470191, 0.006487473152022916, 0.004562218041036625, 9.999999999998899e-05, 9.999999999998899e-05, 0.026279303607937843, 9.999999999998899e-05, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07840071328182474, 0.1070271971752389, 0.14838054695461433, 0.09425923977458062, 0.08051072568095674, 0.09580441870675127, 0.1240568991094797, 0.09716408355800721, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006101769545772684, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.07037543064596374, 0.06735693451091307, 0.05468846648487902, 0.09855305120349966, 0.06581597144687368, 0.05643121168494414, 0.05497932156064522, 0.04855804829477728, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.10359778603806002, 0.10847166301008526, 0.08299910073640826, 0.08326325451723493, 0.11420206329748472, 0.1001363042967901, 0.07784834048331069, 0.033318937593247444, 0.030850512655025697, 0.03464785118471059, 0.044650675553987496, 0.0154886331024634, 0.037140780888393565, 0.05648699256316181, 0.038530072755655564, 0.011873768353786729, 0.0916346253723066, 0.06032920214938475, 0.11089882950468877, 0.10289055837941885, 0.06747178230817008, 0.08176222879441697, 0.12245976138762271, 0.06494044806858634, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04385307240429104, 0.056143274529988574, 0.05626128006000852, 0.06718871428537254, 0.1207914665021157, 0.061750941843425444, 0.06088618922663591, 0.056615725614002965, 0.053674301379695866, 0.03824121102611444, 0.03967402848431323, 0.016401521055428026, 0.018606112313171663, 0.021600351495484005, 0.045511073114331335, 0.018965050090669178, 0.0158348977852244, 0.04143420019681854, 0.10096019244302157, 0.12017502569002791, 0.14763022729669195, 0.10735471808377628, 0.11402400224796383, 0.12465113207635137, 0.10056325222828677, 0.10862764757569365, 0.14689007985489466, 9.999999999998899e-05, 0.012204213037243616, 0.031393493129599714, 9.999999999998899e-05, 0.0058749879062220955, 0.00826091239954263, 0.00378771705097114, 9.999999999998899e-05, 0.007003257745281877]}, "mutation_prompt": null}
{"id": "8c2cd634-097e-492d-a169-7eee049c65fb", "solution": "import numpy as np\n\nclass EnhancedHarmonySearchOptimizer(HarmonySearchOptimizer):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n\n    def __call__(self, func):\n        def DE_crossover(population, target_idx):\n            r1, r2, r3 = np.random.choice(len(population), 3, replace=False)\n            mutant = population[r1] + self.mutation_factor * (population[r2] - population[r3])\n            crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n            trial = np.where(crossover_mask, mutant, population[target_idx])\n            return trial\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([self.generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = self.improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            trial = DE_crossover(harmony_memory, np.random.randint(harmony_memory_size))\n            new_fitness = func(trial)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = trial\n                fitness_values[index] = new_fitness\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHarmonySearchOptimizer", "description": "Integrate Differential Evolution crossover to enhance exploration and exploitation capabilities in Harmony Search Optimization.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedHarmonySearchOptimizer' object has no attribute 'generate_harmony'\").", "error": "AttributeError(\"'EnhancedHarmonySearchOptimizer' object has no attribute 'generate_harmony'\")", "parent_id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "metadata": {}, "mutation_prompt": null}
{"id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "solution": "import numpy as np\n\nclass HybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HybridHarmonySearchOptimizer", "description": "Utilizing Differential Evolution (DE) to enhance Harmony Search Optimization by introducing a new global search strategy.", "configspace": "", "generation": 6, "fitness": 0.24947431293488498, "feedback": "The algorithm HybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "43a0c1a3-78c2-4547-b946-c591edb16fbf", "metadata": {"aucs": [0.9207103127360965, 0.917911424391967, 0.9229704576946817, 0.7300982203317936, 0.9024123001223762, 0.7524318273379982, 0.9114299412682874, 0.8648095216949786, 0.7301379191287698, 0.3148255845256289, 0.1945670558771333, 0.3590435077552465, 0.8496105522103048, 0.8730359538499046, 0.4274713088519353, 0.8229670007693283, 0.6004463508776772, 0.8513539550134482, 0.1697009070422104, 0.1407899540039218, 0.13381193273863212, 0.1338824352963739, 0.18604688017133642, 0.10787768785772678, 0.13309183841306427, 0.0942338917634079, 0.1371416087431726, 0.1385728783220791, 0.08127136318413963, 0.12432672746693096, 0.12878812775588044, 0.10527927106318768, 0.10409545000545384, 0.11503878574704685, 0.13498723552109226, 0.08886475139094707, 0.9689696197725706, 0.9637100971168794, 0.978415965141646, 0.958824723664618, 0.9623714512628164, 0.9114851661495361, 0.9597080363555498, 0.9430572719933938, 0.829984276113875, 0.3276043547273084, 0.23042590118450457, 0.10049120944706869, 0.2482530115180389, 0.2172419103333466, 0.24238128221294253, 0.20244588359573312, 0.15160272282204545, 0.08941917300185886, 0.276628260020756, 0.13956652216211463, 0.13234317113252547, 0.3577380112448548, 0.28233689218836566, 0.219275370679043, 0.15387308996547433, 0.1636079609773089, 0.16908068186618253, 0.2080018431049211, 0.36888493878721296, 0.1940527155432522, 0.36445627540950565, 0.15964637001460846, 0.21682065892958613, 0.19286907940477216, 0.31841922127305256, 0.2890582140990611, 0.18665769705843882, 0.13361385292428074, 0.4023618465183054, 0.1548272470997386, 0.17148954953278006, 0.19190809639973683, 0.1723437991263358, 0.15154210854758132, 0.135876626342324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020481998530657464, 0.015292190454337495, 9.999999999998899e-05, 0.06661962526547416, 0.10389679576028521, 0.04011644386275237, 0.05959101813661505, 0.029523748966954755, 0.043530741498244985, 0.032922651787036794, 0.037952339152680925, 0.09258729857094006, 0.07143979120975796, 0.07524295437106321, 0.10779750710684077, 9.999999999998899e-05, 0.0481573905699042, 0.011651412421794904, 0.06725488872814989, 0.11900234848329816, 0.032453092032821096, 0.08032566888747283, 0.13351876065090762, 0.1856222456185488, 0.09876230590710688, 0.20081242582092496, 0.10985630407682256, 0.1772465135718727, 0.11653249478597139, 0.17074267611181426, 0.09531580501009806, 0.4847574548836806, 0.4164929960359308, 0.5513945257448972, 0.44065339956720107, 0.47393857890524405, 0.378397283459618, 0.4425281107375204, 0.4704992483901066, 0.3845430866337569, 0.07974319045679135, 0.08210766894614951, 0.06779300205769212, 0.11573264738523381, 0.08611880193177823, 0.0812326009098977, 0.07685966880226902, 0.13969191529499914, 0.09282314218734633, 0.14396346221916578, 0.12394864357870283, 0.18075187359097966, 0.10481757788134505, 0.10782933402781458, 0.18716451749426355, 0.10047447620462846, 0.12645068651435343, 0.19858640898246394, 0.2276166340642568, 0.23429607910277328, 0.24493905560566365, 0.2709475235007486, 0.18568829210260274, 0.2909795039619858, 0.22531749567505022, 0.25040743978247304, 0.20133370306744647, 0.25352754373407593, 0.2616913978717531, 0.3007805393314117, 0.23857417831159533, 0.17667430860930378, 0.24615852515526981, 0.2550417144473709, 0.194908728203537, 0.2140644195187399, 0.15184859593792388, 0.1587488089931075, 0.16784284953211592, 0.17097159460434963, 0.21812574246242034, 0.1558353582828682, 0.16470673401590263, 0.15407771158147754, 0.1644008395030473, 0.19322317304411074, 0.2540907519987897, 0.20791999305156394, 0.20128039160153166, 0.1941259236271915, 0.19949285355686408, 0.6255451065409978, 0.19199523699602317, 0.19374478073865653, 0.4400480894809595, 0.1637863807793417, 0.1222686072325867, 0.32293430745028606, 0.19732980345020013, 0.14749930014839374, 0.16065341938331312, 0.12383455219052408, 0.1592760682816763, 0.32286450019245294, 0.2265877853876006, 0.21252334959774954, 0.12809634112562196, 0.21249739588322725, 0.1694539484377645, 0.15123317808655667, 0.1313952295509786, 0.4231030037001837, 0.1766641133431851, 0.1564908612474306, 0.17082202117527956, 0.17394146296451962, 0.16194156692494466, 0.17447280495437312, 0.1594918029760678, 0.1503692992762079, 0.175886139882938, 0.06821818301913296, 0.06193061995177518, 0.06626146331511495, 0.06289205431313016, 0.06631395068106793, 0.06555335296072606, 0.061555638194420004, 0.05007329338979749, 0.04531335902564282]}, "mutation_prompt": null}
{"id": "490aefa4-c0aa-43e9-9b1a-8825d5b169ed", "solution": "import numpy as np\n\nclass HybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HybridHarmonySearchOptimizer", "description": "Utilizing Differential Evolution (DE) to enhance Harmony Search Optimization by introducing a new global search strategy.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.9207103127360965, 0.917911424391967, 0.9229704576946817, 0.7300982203317936, 0.9024123001223762, 0.7524318273379982, 0.9114299412682874, 0.8648095216949786, 0.7301379191287698, 0.3148255845256289, 0.1945670558771333, 0.3590435077552465, 0.8496105522103048, 0.8730359538499046, 0.4274713088519353, 0.8229670007693283, 0.6004463508776772, 0.8513539550134482, 0.1697009070422104, 0.1407899540039218, 0.13381193273863212, 0.1338824352963739, 0.18604688017133642, 0.10787768785772678, 0.13309183841306427, 0.0942338917634079, 0.1371416087431726, 0.1385728783220791, 0.08127136318413963, 0.12432672746693096, 0.12878812775588044, 0.10527927106318768, 0.10409545000545384, 0.11503878574704685, 0.13498723552109226, 0.08886475139094707, 0.9689696197725706, 0.9637100971168794, 0.978415965141646, 0.958824723664618, 0.9623714512628164, 0.9114851661495361, 0.9597080363555498, 0.9430572719933938, 0.829984276113875, 0.3276043547273084, 0.23042590118450457, 0.10049120944706869, 0.2482530115180389, 0.2172419103333466, 0.24238128221294253, 0.20244588359573312, 0.15160272282204545, 0.08941917300185886, 0.276628260020756, 0.13956652216211463, 0.13234317113252547, 0.3577380112448548, 0.28233689218836566, 0.219275370679043, 0.15387308996547433, 0.1636079609773089, 0.16908068186618253, 0.2080018431049211, 0.36888493878721296, 0.1940527155432522, 0.36445627540950565, 0.15964637001460846, 0.21682065892958613, 0.19286907940477216, 0.31841922127305256, 0.2890582140990611, 0.18665769705843882, 0.13361385292428074, 0.4023618465183054, 0.1548272470997386, 0.17148954953278006, 0.19190809639973683, 0.1723437991263358, 0.15154210854758132, 0.135876626342324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020481998530657464, 0.015292190454337495, 9.999999999998899e-05, 0.06661962526547416, 0.10389679576028521, 0.04011644386275237, 0.05959101813661505, 0.029523748966954755, 0.043530741498244985, 0.032922651787036794, 0.037952339152680925, 0.09258729857094006, 0.07143979120975796, 0.07524295437106321, 0.10779750710684077, 9.999999999998899e-05, 0.0481573905699042, 0.011651412421794904, 0.06725488872814989, 0.11900234848329816, 0.032453092032821096, 0.08032566888747283, 0.13351876065090762, 0.1856222456185488, 0.09876230590710688, 0.20081242582092496, 0.10985630407682256, 0.1772465135718727, 0.11653249478597139, 0.17074267611181426, 0.09531580501009806, 0.4847574548836806, 0.4164929960359308, 0.5513945257448972, 0.44065339956720107, 0.47393857890524405, 0.378397283459618, 0.4425281107375204, 0.4704992483901066, 0.3845430866337569, 0.07974319045679135, 0.08210766894614951, 0.06779300205769212, 0.11573264738523381, 0.08611880193177823, 0.0812326009098977, 0.07685966880226902, 0.13969191529499914, 0.09282314218734633, 0.14396346221916578, 0.12394864357870283, 0.18075187359097966, 0.10481757788134505, 0.10782933402781458, 0.18716451749426355, 0.10047447620462846, 0.12645068651435343, 0.19858640898246394, 0.2276166340642568, 0.23429607910277328, 0.24493905560566365, 0.2709475235007486, 0.18568829210260274, 0.2909795039619858, 0.22531749567505022, 0.25040743978247304, 0.20133370306744647, 0.25352754373407593, 0.2616913978717531, 0.3007805393314117, 0.23857417831159533, 0.17667430860930378, 0.24615852515526981, 0.2550417144473709, 0.194908728203537, 0.2140644195187399, 0.15184859593792388, 0.1587488089931075, 0.16784284953211592, 0.17097159460434963, 0.21812574246242034, 0.1558353582828682, 0.16470673401590263, 0.15407771158147754, 0.1644008395030473, 0.19322317304411074, 0.2540907519987897, 0.20791999305156394, 0.20128039160153166, 0.1941259236271915, 0.19949285355686408, 0.6255451065409978, 0.19199523699602317, 0.19374478073865653, 0.4400480894809595, 0.1637863807793417, 0.1222686072325867, 0.32293430745028606, 0.19732980345020013, 0.14749930014839374, 0.16065341938331312, 0.12383455219052408, 0.1592760682816763, 0.32286450019245294, 0.2265877853876006, 0.21252334959774954, 0.12809634112562196, 0.21249739588322725, 0.1694539484377645, 0.15123317808655667, 0.1313952295509786, 0.4231030037001837, 0.1766641133431851, 0.1564908612474306, 0.17082202117527956, 0.17394146296451962, 0.16194156692494466, 0.17447280495437312, 0.1594918029760678, 0.1503692992762079, 0.175886139882938, 0.06821818301913296, 0.06193061995177518, 0.06626146331511495, 0.06289205431313016, 0.06631395068106793, 0.06555335296072606, 0.061555638194420004, 0.05007329338979749, 0.04531335902564282]}, "mutation_prompt": null}
{"id": "a0617059-0ea6-47ea-b601-b7827b13dc2f", "solution": "import numpy as np\n\nclass EnhancedHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def artificial_immune_mutation(harmony_memory):\n            mutation_rate = 0.1\n            for i in range(len(harmony_memory)):\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_rate:\n                        harmony_memory[i][j] = np.clip(harmony_memory[i][j] + np.random.normal(0, 1), self.lower_bound, self.upper_bound)\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            artificial_immune_mutation(harmony_memory)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHybridHarmonySearchOptimizer", "description": "Enhancing the diversity of solutions by introducing a novel mutation mechanism inspired by artificial immune systems.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'differential_evolution' is not defined\").", "error": "NameError(\"name 'differential_evolution' is not defined\")", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {}, "mutation_prompt": null}
{"id": "1640bbe3-b28c-4688-bab6-f4034e28cf00", "solution": "import numpy as np\n\nclass EnhancedHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        def opposition_based_learning(harmony_memory, fitness_values):\n            for i in range(len(harmony_memory)):\n                opposite_harmony = self.lower_bound + self.upper_bound - harmony_memory[i]\n                opposite_fitness = func(opposite_harmony)\n                if opposite_fitness < fitness_values[i]:\n                    harmony_memory[i] = opposite_harmony\n                    fitness_values[i] = opposite_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            opposition_based_learning(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHarmonySearchOptimizer", "description": "Enhancing Harmony Search with Opposition-Based Learning to improve exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.2365943600338459, "feedback": "The algorithm EnhancedHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.728197835052929, 0.8543231845328566, 0.640742719717049, 0.630471431482761, 0.6371422278103198, 0.7332908681086223, 0.4443899707210265, 0.8570927993877663, 0.836886020060146, 0.7405701153806489, 0.6031661766494824, 0.4672040831150772, 0.7235877396928689, 0.772118304012335, 0.6575635746194628, 0.14168325788709135, 0.14255344447363094, 0.7991473716404477, 0.09552853275663398, 0.11777514052435067, 0.12192141263725242, 0.13078020281769986, 0.14267649778654834, 0.13040761435511083, 0.1615773185656426, 0.1171378012748755, 0.09531499017840273, 0.11227491157238656, 0.12172578190709205, 0.11370174834164193, 0.13402358262235559, 0.10373516641324099, 0.09815223015436436, 0.10572666660495722, 0.11159669371325531, 0.09615814212165519, 0.9142420017972909, 0.9213103108026038, 0.9557782993603826, 0.9210109692064142, 0.9658268253564297, 0.8889838111936518, 0.7781619769168779, 0.8238818365501636, 0.9098522261498742, 0.20633303081309784, 0.1527966106926566, 0.17522900151426257, 0.09084515890486566, 0.11243557939425286, 0.2556180992542981, 0.24780753705760095, 0.16548873399614472, 0.23688878893551868, 0.8388775187535014, 0.20914434891389977, 0.24201854407734835, 0.3664764156440916, 0.2717156697882227, 0.1266272876773279, 0.1269131181630737, 0.1599535569795305, 0.2334076943060991, 0.1387391218705789, 0.16208685890932562, 0.1305169247006226, 0.04680832148175307, 0.14041731211451502, 0.14205439411306653, 0.22440550188981911, 0.15116408862327757, 0.2806808528428776, 0.13268334826576433, 0.19900797337344178, 0.17881127892803284, 0.12429911501210478, 0.1980422131478048, 0.16306231689578654, 0.4023988532023711, 0.3315527182973388, 0.13065902163412413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002495826544438584, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032366777531984026, 0.05196561559002255, 0.15941583746138988, 0.04979807582947282, 0.06777793152384859, 0.016155545668057325, 0.13634164600293208, 0.046065364558723565, 0.12176216417531482, 0.19284089963868367, 0.13304371159240724, 0.09736662948753072, 0.03784406838559096, 0.06179830585147594, 0.08070067634153077, 0.1870549514859664, 0.11841700597768501, 0.25538904922293515, 0.060512308478935295, 0.0588609385345239, 0.0935316590547054, 0.09229195054491923, 0.2164230431142541, 0.0689487239791513, 0.08274068470830553, 0.19367916163768217, 0.09034160898467092, 0.4839281310476006, 0.3730419395517711, 0.3529319305184241, 0.4897154095921191, 0.4902913062843006, 0.4756552159144659, 0.49566120867110497, 0.4145491543591169, 0.4268890346071016, 0.06413920418040286, 0.06399399306441733, 0.0838866303236897, 0.09252992199903731, 0.121305727535305, 0.07356394959448631, 0.07185192812394214, 0.07667468923727261, 0.07793561882218436, 0.10440641585226162, 0.13447809244793318, 0.18301448878057913, 0.14253904760257008, 0.10453940880245283, 0.3426351294420049, 0.16918148008177836, 0.1356311866889941, 0.18128752924369496, 0.17072358011830324, 0.27630085130900117, 0.18223659950006998, 0.3025949010182918, 0.2403610394499498, 0.22011143258906118, 0.26533228283844756, 0.1969101260339956, 0.17295444759552336, 0.09832825980680304, 0.16628339908436807, 0.11048660411742672, 0.3048803452937816, 0.2729078702162627, 0.28723572376640294, 0.17195704328784867, 0.1275373150256952, 0.15876144225996636, 0.17980505345224007, 0.15515776471681308, 0.18082855363974126, 0.18317628173155087, 0.18999195350513387, 0.16239640022379032, 0.15686403143338723, 0.15401632823798095, 0.18449359670070997, 0.19336303117221576, 0.1870004707494073, 0.18429559803532136, 0.18046730092756913, 0.18780795325454547, 0.18029886776121007, 0.1778128336112641, 0.22010335542503934, 0.18449112722389327, 0.18346462374393901, 0.1774648831301514, 0.1962464290862238, 0.17145700545706277, 0.18082228657260813, 0.5143677945498333, 0.24701185784064084, 0.23927999760754382, 0.14669578018411356, 0.40371565516020536, 0.3205102570684596, 0.18003557799912284, 0.21124669434238152, 0.20848726483278912, 0.1679159036518627, 0.1506449148314798, 0.10253495370348487, 0.12872077772027846, 0.1686056171464494, 0.165167235996582, 0.15389316474494774, 0.16979926726298455, 0.15383419046386393, 0.15263707329266285, 0.1634720336767439, 0.16109675373067345, 0.15133186524898834, 0.07853763072833331, 0.06499262169739428, 0.07791205947797986, 0.06889372887951473, 0.07545919048774208, 0.09176901701438767, 0.05829163505866841, 0.057759390666205945, 0.0636842086711722]}, "mutation_prompt": null}
{"id": "821c1d95-82eb-4aa6-ba82-4dbef639e576", "solution": "# import numpy as np\n\nclass DynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        initial_pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n        \n        for _ in range(self.budget - harmony_memory_size):\n            pitch_adjust_rate = initial_pitch_adjust_rate * (1 - _ / self.budget)  # Dynamic pitch adjustment\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing HybridHarmonySearchOptimizer by incorporating a dynamic pitch adjustment rate for better exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.24753976074179343, "feedback": "The algorithm DynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.9206770757527379, 0.917911424391967, 0.9229704576946817, 0.47937424516604554, 0.9024123001223762, 0.7422204190100684, 0.9114482641183906, 0.8663524290013748, 0.7296335826375231, 0.32453312291470093, 0.17560516000133974, 0.35746118492080714, 0.8461253511471012, 0.8730359538499046, 0.4259877816645745, 0.8098526391252096, 0.5997389860421172, 0.8513539550134482, 0.16345171751157883, 0.14193392636813806, 0.12554528247762087, 0.13386523284966312, 0.190541930465695, 0.10878051253090815, 0.151587843912947, 0.09745775084412367, 0.15110120197289656, 0.13847563443884847, 0.08009116419099682, 0.12432672765104325, 0.12854197095840558, 0.10737765969040625, 0.11568093481997022, 0.1194450336532411, 0.13498830751367363, 0.08621444041010784, 0.9689696197725706, 0.9637100971168794, 0.978415965141646, 0.958824723664618, 0.9623714512628164, 0.9114851661495361, 0.9597080363555498, 0.9430572719933938, 0.829984276113875, 0.3264017279782303, 0.23033579870473264, 0.10500399819010564, 0.259413447662601, 0.21684938529928532, 0.2436741140000842, 0.20366342277987493, 0.15077813307415655, 0.08939348053256813, 0.276628260020756, 0.13956652216211463, 0.13072110554826144, 0.3577380112448548, 0.28184287812810616, 0.21922454774243272, 0.1563940106292443, 0.1636079609773089, 0.16908068186618253, 0.20765809476773334, 0.36886764392917115, 0.19405335073074081, 0.36564375511100866, 0.15949331940262945, 0.21684087279398356, 0.1930399082638058, 0.31842707200555365, 0.2895084747615442, 0.18621750152570238, 0.1336208039899882, 0.40236112948495617, 0.1548503673067695, 0.17151394275094067, 0.19190825027708913, 0.1728212222281782, 0.15193736357932552, 0.1358946086331534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02045010329230279, 0.014689224382139932, 9.999999999998899e-05, 0.0666196254075454, 0.1036494017595998, 0.04011644386275237, 0.05959101813661505, 0.029523748966954755, 0.04352787993702767, 0.032922651787036794, 0.037865961830908956, 0.09527834656451828, 0.07230043988538837, 0.057764642791844345, 0.10779753395989722, 9.999999999998899e-05, 0.0481328201194654, 0.011651412421794904, 0.06725488872814989, 0.1184303198925285, 0.032453092032821096, 0.08033877730926964, 0.1328128371590903, 0.18560883434755138, 0.09880007152383874, 0.19134623841609466, 0.10975003496229752, 0.17726695523590386, 0.1166436111204453, 0.1707116058875341, 0.0954055858090509, 0.4882119828455328, 0.4160893006436056, 0.5504694603066964, 0.4193189256074118, 0.47104369184943407, 0.37794256486063116, 0.4426770943314209, 0.4704998696069037, 0.38426884105765446, 0.07944949808465684, 0.08210766894614951, 0.06887521399227281, 0.11573264738523381, 0.08611811077520648, 0.07847680331317819, 0.07683726440638439, 0.1399367410855864, 0.09282314218734633, 0.14396346221916578, 0.12394864357870283, 0.18075187359097966, 0.10329017300584142, 0.1077757968992944, 0.18716451749426355, 0.10072921749441754, 0.127922931429725, 0.19858640898246394, 0.22626681147415306, 0.2459443611877573, 0.24497693371705787, 0.2717813200712874, 0.1856882842906511, 0.2909795039619858, 0.22467449257262528, 0.25044999305711213, 0.19804042971467062, 0.25352754373407593, 0.2616913978717531, 0.3007806663708451, 0.23703335772989165, 0.17823251236245674, 0.24616004720597895, 0.2551513248815399, 0.194908728203537, 0.21406516742831483, 0.15184859593792388, 0.1587488089931075, 0.16642811017768344, 0.1720385290740527, 0.21812574246242034, 0.15552246623627686, 0.1649599931988942, 0.15407771158147754, 0.17396413688671386, 0.19571810222445984, 0.2540907520726742, 0.2081265194480506, 0.2012803915952508, 0.1943738990701971, 0.19947964917423655, 0.48680150372539976, 0.19199523699602317, 0.1935213756726828, 0.45090864896208593, 0.16380803137664401, 0.1256793047661795, 0.2903283712757174, 0.19733807647069768, 0.14749930014931834, 0.16080153133253605, 0.12383455219052408, 0.1592760682816763, 0.32342966033444687, 0.22659787082861949, 0.2125233494256904, 0.1280478105704519, 0.21249691907639445, 0.1694411576672168, 0.14580731596339758, 0.13506176647258905, 0.42311157638934005, 0.1766641133431851, 0.1564908612474306, 0.17345744624825477, 0.1740074221037814, 0.16194156692494466, 0.17447280495437312, 0.15668219691418073, 0.15036929927620146, 0.17417502658865558, 0.06862854147165887, 0.06193061995177518, 0.06626146331511495, 0.0626893777296833, 0.06631395068106793, 0.06598042347373212, 0.06056399655980971, 0.05007329338979749, 0.04842087015777108]}, "mutation_prompt": null}
{"id": "66cc97e7-8d9c-4b64-a82b-019d3d618a3e", "solution": "import numpy as np\n\nclass HybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HybridHarmonySearchOptimizer", "description": "Utilizing Differential Evolution (DE) to enhance Harmony Search Optimization by introducing a new global search strategy.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.9207103127360965, 0.917911424391967, 0.9229704576946817, 0.7300982203317936, 0.9024123001223762, 0.7524318273379982, 0.9114299412682874, 0.8648095216949786, 0.7301379191287698, 0.3148255845256289, 0.1945670558771333, 0.3590435077552465, 0.8496105522103048, 0.8730359538499046, 0.4274713088519353, 0.8229670007693283, 0.6004463508776772, 0.8513539550134482, 0.1697009070422104, 0.1407899540039218, 0.13381193273863212, 0.1338824352963739, 0.18604688017133642, 0.10787768785772678, 0.13309183841306427, 0.0942338917634079, 0.1371416087431726, 0.1385728783220791, 0.08127136318413963, 0.12432672746693096, 0.12878812775588044, 0.10527927106318768, 0.10409545000545384, 0.11503878574704685, 0.13498723552109226, 0.08886475139094707, 0.9689696197725706, 0.9637100971168794, 0.978415965141646, 0.958824723664618, 0.9623714512628164, 0.9114851661495361, 0.9597080363555498, 0.9430572719933938, 0.829984276113875, 0.3276043547273084, 0.23042590118450457, 0.10049120944706869, 0.2482530115180389, 0.2172419103333466, 0.24238128221294253, 0.20244588359573312, 0.15160272282204545, 0.08941917300185886, 0.276628260020756, 0.13956652216211463, 0.13234317113252547, 0.3577380112448548, 0.28233689218836566, 0.219275370679043, 0.15387308996547433, 0.1636079609773089, 0.16908068186618253, 0.2080018431049211, 0.36888493878721296, 0.1940527155432522, 0.36445627540950565, 0.15964637001460846, 0.21682065892958613, 0.19286907940477216, 0.31841922127305256, 0.2890582140990611, 0.18665769705843882, 0.13361385292428074, 0.4023618465183054, 0.1548272470997386, 0.17148954953278006, 0.19190809639973683, 0.1723437991263358, 0.15154210854758132, 0.135876626342324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020481998530657464, 0.015292190454337495, 9.999999999998899e-05, 0.06661962526547416, 0.10389679576028521, 0.04011644386275237, 0.05959101813661505, 0.029523748966954755, 0.043530741498244985, 0.032922651787036794, 0.037952339152680925, 0.09258729857094006, 0.07143979120975796, 0.07524295437106321, 0.10779750710684077, 9.999999999998899e-05, 0.0481573905699042, 0.011651412421794904, 0.06725488872814989, 0.11900234848329816, 0.032453092032821096, 0.08032566888747283, 0.13351876065090762, 0.1856222456185488, 0.09876230590710688, 0.20081242582092496, 0.10985630407682256, 0.1772465135718727, 0.11653249478597139, 0.17074267611181426, 0.09531580501009806, 0.4847574548836806, 0.4164929960359308, 0.5513945257448972, 0.44065339956720107, 0.47393857890524405, 0.378397283459618, 0.4425281107375204, 0.4704992483901066, 0.3845430866337569, 0.07974319045679135, 0.08210766894614951, 0.06779300205769212, 0.11573264738523381, 0.08611880193177823, 0.0812326009098977, 0.07685966880226902, 0.13969191529499914, 0.09282314218734633, 0.14396346221916578, 0.12394864357870283, 0.18075187359097966, 0.10481757788134505, 0.10782933402781458, 0.18716451749426355, 0.10047447620462846, 0.12645068651435343, 0.19858640898246394, 0.2276166340642568, 0.23429607910277328, 0.24493905560566365, 0.2709475235007486, 0.18568829210260274, 0.2909795039619858, 0.22531749567505022, 0.25040743978247304, 0.20133370306744647, 0.25352754373407593, 0.2616913978717531, 0.3007805393314117, 0.23857417831159533, 0.17667430860930378, 0.24615852515526981, 0.2550417144473709, 0.194908728203537, 0.2140644195187399, 0.15184859593792388, 0.1587488089931075, 0.16784284953211592, 0.17097159460434963, 0.21812574246242034, 0.1558353582828682, 0.16470673401590263, 0.15407771158147754, 0.1644008395030473, 0.19322317304411074, 0.2540907519987897, 0.20791999305156394, 0.20128039160153166, 0.1941259236271915, 0.19949285355686408, 0.6255451065409978, 0.19199523699602317, 0.19374478073865653, 0.4400480894809595, 0.1637863807793417, 0.1222686072325867, 0.32293430745028606, 0.19732980345020013, 0.14749930014839374, 0.16065341938331312, 0.12383455219052408, 0.1592760682816763, 0.32286450019245294, 0.2265877853876006, 0.21252334959774954, 0.12809634112562196, 0.21249739588322725, 0.1694539484377645, 0.15123317808655667, 0.1313952295509786, 0.4231030037001837, 0.1766641133431851, 0.1564908612474306, 0.17082202117527956, 0.17394146296451962, 0.16194156692494466, 0.17447280495437312, 0.1594918029760678, 0.1503692992762079, 0.175886139882938, 0.06821818301913296, 0.06193061995177518, 0.06626146331511495, 0.06289205431313016, 0.06631395068106793, 0.06555335296072606, 0.061555638194420004, 0.05007329338979749, 0.04531335902564282]}, "mutation_prompt": null}
{"id": "3d477a3c-a37d-488f-9c26-973d24ddddb1", "solution": "import numpy as np\n\nclass HybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HybridHarmonySearchOptimizer", "description": "Utilizing Differential Evolution (DE) to enhance Harmony Search Optimization by introducing a new global search strategy.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.9207103127360965, 0.917911424391967, 0.9229704576946817, 0.7300982203317936, 0.9024123001223762, 0.7524318273379982, 0.9114299412682874, 0.8648095216949786, 0.7301379191287698, 0.3148255845256289, 0.1945670558771333, 0.3590435077552465, 0.8496105522103048, 0.8730359538499046, 0.4274713088519353, 0.8229670007693283, 0.6004463508776772, 0.8513539550134482, 0.1697009070422104, 0.1407899540039218, 0.13381193273863212, 0.1338824352963739, 0.18604688017133642, 0.10787768785772678, 0.13309183841306427, 0.0942338917634079, 0.1371416087431726, 0.1385728783220791, 0.08127136318413963, 0.12432672746693096, 0.12878812775588044, 0.10527927106318768, 0.10409545000545384, 0.11503878574704685, 0.13498723552109226, 0.08886475139094707, 0.9689696197725706, 0.9637100971168794, 0.978415965141646, 0.958824723664618, 0.9623714512628164, 0.9114851661495361, 0.9597080363555498, 0.9430572719933938, 0.829984276113875, 0.3276043547273084, 0.23042590118450457, 0.10049120944706869, 0.2482530115180389, 0.2172419103333466, 0.24238128221294253, 0.20244588359573312, 0.15160272282204545, 0.08941917300185886, 0.276628260020756, 0.13956652216211463, 0.13234317113252547, 0.3577380112448548, 0.28233689218836566, 0.219275370679043, 0.15387308996547433, 0.1636079609773089, 0.16908068186618253, 0.2080018431049211, 0.36888493878721296, 0.1940527155432522, 0.36445627540950565, 0.15964637001460846, 0.21682065892958613, 0.19286907940477216, 0.31841922127305256, 0.2890582140990611, 0.18665769705843882, 0.13361385292428074, 0.4023618465183054, 0.1548272470997386, 0.17148954953278006, 0.19190809639973683, 0.1723437991263358, 0.15154210854758132, 0.135876626342324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020481998530657464, 0.015292190454337495, 9.999999999998899e-05, 0.06661962526547416, 0.10389679576028521, 0.04011644386275237, 0.05959101813661505, 0.029523748966954755, 0.043530741498244985, 0.032922651787036794, 0.037952339152680925, 0.09258729857094006, 0.07143979120975796, 0.07524295437106321, 0.10779750710684077, 9.999999999998899e-05, 0.0481573905699042, 0.011651412421794904, 0.06725488872814989, 0.11900234848329816, 0.032453092032821096, 0.08032566888747283, 0.13351876065090762, 0.1856222456185488, 0.09876230590710688, 0.20081242582092496, 0.10985630407682256, 0.1772465135718727, 0.11653249478597139, 0.17074267611181426, 0.09531580501009806, 0.4847574548836806, 0.4164929960359308, 0.5513945257448972, 0.44065339956720107, 0.47393857890524405, 0.378397283459618, 0.4425281107375204, 0.4704992483901066, 0.3845430866337569, 0.07974319045679135, 0.08210766894614951, 0.06779300205769212, 0.11573264738523381, 0.08611880193177823, 0.0812326009098977, 0.07685966880226902, 0.13969191529499914, 0.09282314218734633, 0.14396346221916578, 0.12394864357870283, 0.18075187359097966, 0.10481757788134505, 0.10782933402781458, 0.18716451749426355, 0.10047447620462846, 0.12645068651435343, 0.19858640898246394, 0.2276166340642568, 0.23429607910277328, 0.24493905560566365, 0.2709475235007486, 0.18568829210260274, 0.2909795039619858, 0.22531749567505022, 0.25040743978247304, 0.20133370306744647, 0.25352754373407593, 0.2616913978717531, 0.3007805393314117, 0.23857417831159533, 0.17667430860930378, 0.24615852515526981, 0.2550417144473709, 0.194908728203537, 0.2140644195187399, 0.15184859593792388, 0.1587488089931075, 0.16784284953211592, 0.17097159460434963, 0.21812574246242034, 0.1558353582828682, 0.16470673401590263, 0.15407771158147754, 0.1644008395030473, 0.19322317304411074, 0.2540907519987897, 0.20791999305156394, 0.20128039160153166, 0.1941259236271915, 0.19949285355686408, 0.6255451065409978, 0.19199523699602317, 0.19374478073865653, 0.4400480894809595, 0.1637863807793417, 0.1222686072325867, 0.32293430745028606, 0.19732980345020013, 0.14749930014839374, 0.16065341938331312, 0.12383455219052408, 0.1592760682816763, 0.32286450019245294, 0.2265877853876006, 0.21252334959774954, 0.12809634112562196, 0.21249739588322725, 0.1694539484377645, 0.15123317808655667, 0.1313952295509786, 0.4231030037001837, 0.1766641133431851, 0.1564908612474306, 0.17082202117527956, 0.17394146296451962, 0.16194156692494466, 0.17447280495437312, 0.1594918029760678, 0.1503692992762079, 0.175886139882938, 0.06821818301913296, 0.06193061995177518, 0.06626146331511495, 0.06289205431313016, 0.06631395068106793, 0.06555335296072606, 0.061555638194420004, 0.05007329338979749, 0.04531335902564282]}, "mutation_prompt": null}
{"id": "a9914b9a-8df6-45c7-aba4-4a5eccc9b6fb", "solution": "import numpy as np\n\nclass HybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "HybridHarmonySearchOptimizer", "description": "Utilizing Differential Evolution (DE) to enhance Harmony Search Optimization by introducing a new global search strategy.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.9207103127360965, 0.917911424391967, 0.9229704576946817, 0.7300982203317936, 0.9024123001223762, 0.7524318273379982, 0.9114299412682874, 0.8648095216949786, 0.7301379191287698, 0.3148255845256289, 0.1945670558771333, 0.3590435077552465, 0.8496105522103048, 0.8730359538499046, 0.4274713088519353, 0.8229670007693283, 0.6004463508776772, 0.8513539550134482, 0.1697009070422104, 0.1407899540039218, 0.13381193273863212, 0.1338824352963739, 0.18604688017133642, 0.10787768785772678, 0.13309183841306427, 0.0942338917634079, 0.1371416087431726, 0.1385728783220791, 0.08127136318413963, 0.12432672746693096, 0.12878812775588044, 0.10527927106318768, 0.10409545000545384, 0.11503878574704685, 0.13498723552109226, 0.08886475139094707, 0.9689696197725706, 0.9637100971168794, 0.978415965141646, 0.958824723664618, 0.9623714512628164, 0.9114851661495361, 0.9597080363555498, 0.9430572719933938, 0.829984276113875, 0.3276043547273084, 0.23042590118450457, 0.10049120944706869, 0.2482530115180389, 0.2172419103333466, 0.24238128221294253, 0.20244588359573312, 0.15160272282204545, 0.08941917300185886, 0.276628260020756, 0.13956652216211463, 0.13234317113252547, 0.3577380112448548, 0.28233689218836566, 0.219275370679043, 0.15387308996547433, 0.1636079609773089, 0.16908068186618253, 0.2080018431049211, 0.36888493878721296, 0.1940527155432522, 0.36445627540950565, 0.15964637001460846, 0.21682065892958613, 0.19286907940477216, 0.31841922127305256, 0.2890582140990611, 0.18665769705843882, 0.13361385292428074, 0.4023618465183054, 0.1548272470997386, 0.17148954953278006, 0.19190809639973683, 0.1723437991263358, 0.15154210854758132, 0.135876626342324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020481998530657464, 0.015292190454337495, 9.999999999998899e-05, 0.06661962526547416, 0.10389679576028521, 0.04011644386275237, 0.05959101813661505, 0.029523748966954755, 0.043530741498244985, 0.032922651787036794, 0.037952339152680925, 0.09258729857094006, 0.07143979120975796, 0.07524295437106321, 0.10779750710684077, 9.999999999998899e-05, 0.0481573905699042, 0.011651412421794904, 0.06725488872814989, 0.11900234848329816, 0.032453092032821096, 0.08032566888747283, 0.13351876065090762, 0.1856222456185488, 0.09876230590710688, 0.20081242582092496, 0.10985630407682256, 0.1772465135718727, 0.11653249478597139, 0.17074267611181426, 0.09531580501009806, 0.4847574548836806, 0.4164929960359308, 0.5513945257448972, 0.44065339956720107, 0.47393857890524405, 0.378397283459618, 0.4425281107375204, 0.4704992483901066, 0.3845430866337569, 0.07974319045679135, 0.08210766894614951, 0.06779300205769212, 0.11573264738523381, 0.08611880193177823, 0.0812326009098977, 0.07685966880226902, 0.13969191529499914, 0.09282314218734633, 0.14396346221916578, 0.12394864357870283, 0.18075187359097966, 0.10481757788134505, 0.10782933402781458, 0.18716451749426355, 0.10047447620462846, 0.12645068651435343, 0.19858640898246394, 0.2276166340642568, 0.23429607910277328, 0.24493905560566365, 0.2709475235007486, 0.18568829210260274, 0.2909795039619858, 0.22531749567505022, 0.25040743978247304, 0.20133370306744647, 0.25352754373407593, 0.2616913978717531, 0.3007805393314117, 0.23857417831159533, 0.17667430860930378, 0.24615852515526981, 0.2550417144473709, 0.194908728203537, 0.2140644195187399, 0.15184859593792388, 0.1587488089931075, 0.16784284953211592, 0.17097159460434963, 0.21812574246242034, 0.1558353582828682, 0.16470673401590263, 0.15407771158147754, 0.1644008395030473, 0.19322317304411074, 0.2540907519987897, 0.20791999305156394, 0.20128039160153166, 0.1941259236271915, 0.19949285355686408, 0.6255451065409978, 0.19199523699602317, 0.19374478073865653, 0.4400480894809595, 0.1637863807793417, 0.1222686072325867, 0.32293430745028606, 0.19732980345020013, 0.14749930014839374, 0.16065341938331312, 0.12383455219052408, 0.1592760682816763, 0.32286450019245294, 0.2265877853876006, 0.21252334959774954, 0.12809634112562196, 0.21249739588322725, 0.1694539484377645, 0.15123317808655667, 0.1313952295509786, 0.4231030037001837, 0.1766641133431851, 0.1564908612474306, 0.17082202117527956, 0.17394146296451962, 0.16194156692494466, 0.17447280495437312, 0.1594918029760678, 0.1503692992762079, 0.175886139882938, 0.06821818301913296, 0.06193061995177518, 0.06626146331511495, 0.06289205431313016, 0.06631395068106793, 0.06555335296072606, 0.061555638194420004, 0.05007329338979749, 0.04531335902564282]}, "mutation_prompt": null}
{"id": "b312358f-37cc-45c4-bd76-49196113117e", "solution": "import numpy as np\n\nclass EnhancedHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        def particle_swarm_optimization(harmony_memory, fitness_values):\n            inertia_weight = 0.5\n            cognitive_weight = 1.5\n            social_weight = 1.5\n            personal_best_positions = np.copy(harmony_memory)\n            personal_best_scores = np.copy(fitness_values)\n            global_best_index = np.argmin(fitness_values)\n            global_best_position = np.copy(harmony_memory[global_best_index])\n\n            velocities = np.zeros_like(harmony_memory)\n            for i in range(len(harmony_memory)):\n                velocities[i] = inertia_weight * velocities[i] + \\\n                                cognitive_weight * np.random.rand() * (personal_best_positions[i] - harmony_memory[i]) + \\\n                                social_weight * np.random.rand() * (global_best_position - harmony_memory[i])\n                harmony_memory[i] += velocities[i]\n\n                fitness = func(harmony_memory[i])\n                if fitness < fitness_values[i]:\n                    fitness_values[i] = fitness\n                    personal_best_positions[i] = np.copy(harmony_memory[i])\n                    if fitness < fitness_values[global_best_index]:\n                        global_best_index = i\n                        global_best_position = np.copy(harmony_memory[i])\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            particle_swarm_optimization(harmony_memory, fitness_values)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHybridHarmonySearchOptimizer", "description": "Integrate Particle Swarm Optimization (PSO) to enhance the search and exploitation capabilities of the Hybrid Harmony Search algorithm.", "configspace": "", "generation": 14, "fitness": 0.14114865939492494, "feedback": "The algorithm EnhancedHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.17.", "error": "", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.2834457314942731, 0.28485166564555897, 0.3287233445051443, 0.2934235432329817, 0.2923912427514791, 0.3533218500866788, 0.39014532660424917, 0.29387383322070204, 0.2708082964437375, 0.16571325856787678, 0.04427832365959239, 0.01665037138191605, 0.12466723481505282, 0.10332028424627893, 9.999999999998899e-05, 9.999999999998899e-05, 0.12896764622460632, 9.999999999998899e-05, 0.1272807416744336, 0.14873333437770908, 0.10423602885295657, 0.10848214033543568, 0.09004072297792243, 0.09065063003380514, 0.08028627247885978, 0.10155176009855782, 0.11119647022595214, 0.11514744023758883, 0.11364491123665288, 0.07993885494837338, 0.07871123447886208, 0.07346011489007376, 0.09932430025600136, 0.09289339218227122, 0.09519409663107292, 0.07238364350653448, 0.965370726502033, 0.9782774224807924, 0.9784223965604516, 0.701874870676175, 0.9791410975631739, 0.897227509000955, 0.9119970637284911, 0.2885200211872464, 0.420904490084127, 0.13626035600389297, 0.07281056106753148, 0.03960710918221588, 0.07312096329565498, 0.12639772682285566, 0.08723246955566921, 0.098798037097939, 0.06903774441125954, 0.04630159512901433, 0.12958075203620578, 0.0800487123834398, 0.09596173485861403, 0.1099120749013548, 0.08531361551987615, 0.10527728177271511, 0.09810156582264518, 0.07825901375567268, 0.06983082384352945, 0.05083026301099558, 0.08935313416126922, 0.12270952968992466, 0.05734183785216318, 0.04220033833258219, 0.05900560165332447, 0.07421482534090396, 9.999999999998899e-05, 0.0342345056711838, 0.12961049451246343, 0.13148469079024339, 0.05939071209776903, 0.09898517311469623, 0.1325854917837025, 0.12003316829991639, 0.13216775974547057, 0.06614652980156266, 0.04348860459419923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09326563267406196, 0.0683820834590868, 0.05694289999977353, 0.06512804476217793, 0.003943296357424297, 0.0018301768748284486, 0.14198026275713305, 0.01628949235929411, 0.13018267040349674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03510134779145724, 0.004067691823648079, 0.0016150297090220533, 0.023369792032807757, 0.01720645688330713, 0.027005801645407335, 0.004106924283070801, 0.01664834303481111, 9.999999999998899e-05, 0.27761074117702345, 0.27807054484569294, 0.2467442944039947, 0.2219701233837056, 0.2761835689221468, 0.27463266446558043, 0.24829840892947475, 0.2844098637872625, 0.27200818535241866, 0.026440964834414937, 0.04096373025230149, 0.03786426741142446, 0.04999000800271314, 0.03421722256868176, 0.07368233571831384, 0.025057827059452586, 0.05404205554085617, 0.08031193196156106, 0.14562436944738633, 0.12654571364511125, 0.16428151729820295, 0.14000396807678084, 0.29587830258193915, 0.11179766952230963, 0.1305472382901438, 0.14815627582094837, 0.10744455134142095, 0.1405260174367462, 0.2015554205859974, 0.13508880650527555, 0.14928850296771667, 0.1742168769033382, 0.14943024462439858, 0.13534238141422905, 0.13097901491242425, 0.17773125655804145, 0.1179679750224144, 0.0651001557770895, 0.09316035298166914, 0.0941735522529501, 0.0871567859220097, 0.14519411534331506, 0.0996159173852681, 0.15050485710866746, 0.09975145029817978, 0.2495007420685953, 0.17366532008537594, 0.17284471566136594, 0.19754559729129983, 0.14766412578793586, 0.21962157241012115, 0.22836498532086957, 0.17049399115322428, 0.1909304072998933, 0.1678564323458802, 0.17639278686792692, 0.17230719083171875, 0.18990060283725885, 0.18772117980109282, 0.14374997409328882, 0.18041321602385796, 0.17898146740652032, 0.09828832043261881, 0.09510997174817426, 0.2595204516765415, 0.2371789520884343, 0.23297173022952256, 0.19854413509400548, 0.08820379762694952, 0.13989203134137584, 0.11326135355742395, 0.12234149152900375, 0.08059028828912196, 0.16792183225945223, 0.09918785133860508, 0.08038966098594558, 0.20135382903427868, 0.15218545084062973, 0.09367889558911324, 0.11753379068546688, 0.08456824810947006, 0.17344538101267337, 0.17201826670688347, 0.15977138514099354, 0.1789998304785111, 0.1733633449250288, 0.15395914283225864, 0.2111860405702478, 0.1815523867212553, 0.17367850627980497, 0.07600951760783714, 0.06417609990155726, 0.050550330168313895, 0.058147855140388116, 0.07224391387478712, 0.06450459685267029, 0.03507571747260896, 0.08253950162329893, 0.04217580876141236]}, "mutation_prompt": null}
{"id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "solution": "import numpy as np\n\nclass DynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:  # Updated dynamic pitch adjustment\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            # Update dynamic pitch adjustment based on fitness progress\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicPitchHybridHarmonySearchOptimizer", "description": "Improving HybridHarmonySearchOptimizer by incorporating a dynamic pitch adjustment rate based on fitness progress.", "configspace": "", "generation": 15, "fitness": 0.3491350875253059, "feedback": "The algorithm DynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "8433b4f3-03d1-4201-b367-7eb0b601e6d6", "metadata": {"aucs": [0.905558798039144, 0.9097283530878677, 0.8947657668590397, 0.8866985722799866, 0.8800074872924318, 0.857643122475788, 0.898590614787498, 0.9067534039544206, 0.8987044146867802, 0.8127429341669691, 0.8278048428924921, 0.7996147913390134, 0.8139074934705061, 0.8145627440730789, 0.7983126784616382, 0.8276656145062637, 0.8072208395717886, 0.8018102534619621, 0.6117286361607689, 0.15355533604657978, 0.5195058108470805, 0.1764317849473217, 0.7209764675195635, 0.5745522615600935, 0.1824056721861158, 0.5637095935656864, 0.17460449674200695, 0.140382175919039, 0.1764044507415301, 0.15539219769707346, 0.14693061718328082, 0.15200303740040944, 0.12953036120720496, 0.1380385022668228, 0.12901432239151223, 0.27353420344554213, 0.9683858086170448, 0.9723072875491571, 0.9636407149428854, 0.9522505639563735, 0.9721744995193924, 0.970707776159684, 0.9702909853541674, 0.9493770893001837, 0.9554680346111576, 0.7340675222691109, 0.6545524331325244, 0.6566656710013966, 0.6943986981800759, 0.7162478493991435, 0.7062336649841487, 0.6036456675698116, 0.6639180566725933, 0.6219720071470658, 0.24350800926743477, 0.679213679196355, 0.2240803556979768, 0.36003166733772785, 0.36075160417206886, 0.8363341885365483, 0.18067407352555198, 0.7920428961261166, 0.7742395239529175, 0.2994578655552317, 0.229519581246042, 0.2345966784410055, 0.2570806248901034, 0.27347952204878145, 0.279974490356486, 0.19839998148042826, 0.23723147536772293, 0.20426541778023555, 0.19776769024291896, 0.2474689727660374, 0.25554139708469337, 0.22553132667311715, 0.16146471750821023, 0.24523472672696367, 0.21232152745425714, 0.21614049022151816, 0.1606108426133922, 0.0669385342158495, 0.08846578932541893, 0.13297274486903754, 0.015251131904983062, 0.03429705518662651, 0.01394511315721425, 0.06852814748276104, 0.01486065970901762, 0.03413068749733117, 0.08681669291982685, 0.11165726900508488, 0.11355846126540059, 0.10509334844383267, 0.03443065907792875, 0.05753827882728224, 0.11352897847135757, 0.11252588120899198, 0.22361961824294652, 0.1368637547123701, 0.07627632027442866, 0.11039927449985154, 0.060988769548727895, 0.05276779332576442, 0.08144129843260473, 0.1395712998973493, 0.10508646647544173, 0.03730621611756724, 0.216023424828246, 0.21672333232587937, 0.24797387064097542, 0.2551326445308226, 0.2888749200048133, 0.2810358884754395, 0.16663188672104046, 0.227447652848337, 0.19467961175669113, 0.607120761813461, 0.62552889154573, 0.6165132971503788, 0.5501035731302952, 0.6040364757489652, 0.6140272939989706, 0.5802220367360331, 0.6061132447774112, 0.549974561074507, 0.09890399725341215, 0.12306643480955337, 0.12840094703777927, 0.09752195417690313, 0.1456232463051369, 0.09382683761059163, 0.10741246252882464, 0.12297742337956608, 0.11744814510793877, 0.11552839333877529, 0.132996581161683, 0.23800896233338786, 0.29855384735668267, 0.18511670915155198, 0.17883413570153261, 0.18907681127308074, 0.1627774684654696, 0.1449646022447274, 0.3822119361329258, 0.3659775865322952, 0.3129901808789214, 0.33574673938915545, 0.3178272230019835, 0.34841613592289133, 0.2840456110984376, 0.3563448878080504, 0.3290766790453865, 0.28577649756332846, 0.28894236498485504, 0.24769976461216092, 0.19172110662383024, 0.275625123059858, 0.31666031364416813, 0.3016080782614651, 0.18850226995046337, 0.2354397871499817, 0.21130769837914287, 0.23363819380092132, 0.2088818306685133, 0.18209161026389387, 0.20776033068535726, 0.2092179927782366, 0.21834218173869302, 0.18303725311458363, 0.21335685617893052, 0.5253979073379758, 0.21924202942553062, 0.22106751010446024, 0.23971426314407318, 0.2370204840458039, 0.2063852307566486, 0.22209331828364043, 0.1957340142853622, 0.22267817996972972, 0.6402263674965619, 0.2319938295417907, 0.1844599980482301, 0.6524496501124454, 0.19853327032196288, 0.810385786341635, 0.6765219699736429, 0.15824166624012037, 0.8169827180427631, 0.47174586427576826, 0.6866573837651092, 0.26971700283365097, 0.20602979958434997, 0.3149042776047172, 0.21055805323156151, 0.11081959490306459, 0.20382286215733825, 0.4470800953860047, 0.17039126411004968, 0.18054045177396805, 0.18209228674884503, 0.17675912014621808, 0.17543780910482676, 0.19374977061473753, 0.17788948683565087, 0.18939554760770283, 0.1889833699708563, 0.08146188573245494, 0.09501660608949458, 0.0938105977392959, 0.115486667756874, 0.10782034789667594, 0.07985214427792364, 0.07856417360242907, 0.1033161126723311, 0.0777790209937198]}, "mutation_prompt": null}
{"id": "f94f530d-bce9-4a03-afb0-a7e565a491d4", "solution": "import numpy as np\n\nclass ChaoticDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:  # Updated dynamic pitch adjustment\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def chaotic_mutation(harmony_memory, dim):\n            chaos_param = 0.1\n            for i in range(len(harmony_memory)):\n                new_harmony = np.copy(harmony_memory[i])\n                for j in range(dim):\n                    new_harmony[j] = (new_harmony[j] + chaos_param * np.sin(new_harmony[j])) % (2 * self.upper_bound) - self.upper_bound\n                harmony_memory[i] = new_harmony\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            chaotic_mutation(harmony_memory, self.dim)\n            # Update dynamic pitch adjustment based on fitness progress\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ChaoticDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing the search diversity by introducing a novel mutation strategy based on chaotic maps.", "configspace": "", "generation": 16, "fitness": 0.09229802434290012, "feedback": "The algorithm ChaoticDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "metadata": {"aucs": [0.16205757173798652, 0.19177175176271088, 0.16666648096145398, 0.1615377678883535, 0.15654206407050164, 0.15259092465313773, 0.16297393387130665, 0.16297588447680122, 0.16369461541528785, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04113424434488755, 0.045276885086363516, 0.03844023582717204, 0.07602579055312819, 0.08901768431022505, 0.07943977818299686, 0.04980062212380909, 0.03692669996526421, 0.04127540611899072, 0.028488132247174835, 0.025933528806571515, 0.027350417579487862, 0.0449753806273433, 0.044264810238180186, 0.0495777744608884, 0.025500636291255208, 0.02731337218363583, 0.035036492652377293, 0.06776930059890018, 0.06536732924565114, 0.07333084869078155, 0.07604193795087755, 0.06742815697072801, 0.07523108026555547, 0.07845442803038583, 0.07510420463948408, 0.06638044366289197, 0.12124155620570731, 0.11598240034494212, 0.1167415200052665, 0.08519484778480624, 0.056256085285355195, 0.09180936743433288, 0.11578247366923189, 0.07759408053550543, 0.08913803753489424, 0.11253124199477205, 0.10130933777094919, 0.09604815449297588, 0.13070869155464848, 0.13386891220648756, 0.11487222944526365, 0.10979802539026873, 0.09544311011403861, 0.07190493072861193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0073641817257683595, 9.999999999998899e-05, 9.999999999998899e-05, 0.03341625576657803, 0.013242659546648383, 0.013415069299241078, 0.006576757704142788, 9.999999999998899e-05, 9.999999999998899e-05, 0.012162381010315082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06189134081325032, 0.05501449270981107, 0.05245550792715581, 0.07218734258400905, 0.0822574562312538, 0.11025815566347741, 0.04834579930112681, 0.03703179903085585, 0.03939202270242492, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020889438770932411, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040433707727888235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20165548068679096, 0.21354308023266122, 0.22718275717986025, 0.18323809281807657, 0.18688777809596713, 0.18946785158950374, 0.19621125147565543, 0.182994817509192, 0.20584802825196424, 0.04997328912954613, 0.05702290562580925, 0.05615351182201955, 0.0669122335315202, 0.06205458443277079, 0.06946695954173443, 0.04485537421804986, 0.0675255246438764, 0.04328710740465447, 0.12490466581138826, 0.14318692829424595, 0.13272689335843824, 0.13921000214398882, 0.13872448146424154, 0.15075397732438633, 0.14645052308558193, 0.15413332188276185, 0.13319440720534403, 0.17986334240752055, 0.17793573020886067, 0.1693587535521357, 0.15666196658133558, 0.15709803252072885, 0.16180305620181512, 0.18626929394985503, 0.1766829898973148, 0.1750487819284512, 0.12975714464902177, 0.12897506967953198, 0.1241754433027058, 0.10191242242654186, 0.09941851790918865, 0.10426006122396525, 0.13723158801566337, 0.12064372775986454, 0.11836387365194001, 0.1577466879756736, 0.14836767004014528, 0.16985572224464418, 0.15848988143222886, 0.1527718990299649, 0.14741669962372494, 0.15799624351843689, 0.16256661382401016, 0.15366051101778044, 0.1350734441565382, 0.1547820226833968, 0.16073670957135533, 0.14139446069474215, 0.16095096362382277, 0.15256319753420777, 0.1561844677378127, 0.15437451008181546, 0.15049100263582582, 0.20635334934977045, 0.19401468490458396, 0.1772799606542158, 0.1606476492345431, 0.1985237175002108, 0.2172451718059799, 0.22367891028874565, 0.14737441438866283, 0.18492961882707581, 0.2083537574647799, 0.1655893376117874, 0.14877035010401085, 0.1328542689308464, 0.22197278971038903, 0.2213137652027748, 0.15691060769028775, 0.1699867874946036, 0.124997420408405, 0.1896658919165276, 0.18156239889923198, 0.20526980285132423, 0.18943711279504227, 0.19043774168665628, 0.1877141162385716, 0.17817713245487576, 0.17901912649293317, 0.1746436182255625, 0.05932086266246661, 0.0690834719964647, 0.06902439311157904, 0.06552840798054604, 0.07876785235547779, 0.07318307715015804, 0.08142281525347972, 0.06681368066622417, 0.06627175553787179]}, "mutation_prompt": null}
{"id": "d7f2368c-e9ec-4e2d-9d4d-89770fec5d43", "solution": "import numpy as np\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer(DynamicPitchHybridHarmonySearchOptimizer):\n    def local_search(self, harmony):\n        # Perform local search around the given harmony\n        new_harmony = np.copy(harmony)\n        step_size = 0.1\n        for i in range(self.dim):\n            new_harmony[i] = np.clip(new_harmony[i] + np.random.uniform(-step_size, step_size), self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([self.generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = self.improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            self.differential_evolution(harmony_memory, fitness_values)\n\n            # Introduce local search to exploit promising regions\n            for idx in range(harmony_memory_size):\n                candidate = self.local_search(harmony_memory[idx])\n                candidate_fitness = func(candidate)\n                if candidate_fitness < fitness_values[idx]:\n                    harmony_memory[idx] = candidate\n                    fitness_values[idx] = candidate_fitness\n\n            best_fitness = np.min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing the algorithm by introducing a local search mechanism to exploit promising regions in the search space.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedDynamicPitchHybridHarmonySearchOptimizer' object has no attribute 'generate_harmony'\").", "error": "AttributeError(\"'EnhancedDynamicPitchHybridHarmonySearchOptimizer' object has no attribute 'generate_harmony'\")", "parent_id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "metadata": {}, "mutation_prompt": null}
{"id": "f21f3df6-6110-46d8-9d92-c09c9c10733b", "solution": "import numpy as np\n\nclass DynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:  # Updated dynamic pitch adjustment\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            # Update dynamic pitch adjustment based on fitness progress\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicPitchHybridHarmonySearchOptimizer", "description": "Improving HybridHarmonySearchOptimizer by incorporating a dynamic pitch adjustment rate based on fitness progress.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "metadata": {"aucs": [0.905558798039144, 0.9097283530878677, 0.8947657668590397, 0.8866985722799866, 0.8800074872924318, 0.857643122475788, 0.898590614787498, 0.9067534039544206, 0.8987044146867802, 0.8127429341669691, 0.8278048428924921, 0.7996147913390134, 0.8139074934705061, 0.8145627440730789, 0.7983126784616382, 0.8276656145062637, 0.8072208395717886, 0.8018102534619621, 0.6117286361607689, 0.15355533604657978, 0.5195058108470805, 0.1764317849473217, 0.7209764675195635, 0.5745522615600935, 0.1824056721861158, 0.5637095935656864, 0.17460449674200695, 0.140382175919039, 0.1764044507415301, 0.15539219769707346, 0.14693061718328082, 0.15200303740040944, 0.12953036120720496, 0.1380385022668228, 0.12901432239151223, 0.27353420344554213, 0.9683858086170448, 0.9723072875491571, 0.9636407149428854, 0.9522505639563735, 0.9721744995193924, 0.970707776159684, 0.9702909853541674, 0.9493770893001837, 0.9554680346111576, 0.7340675222691109, 0.6545524331325244, 0.6566656710013966, 0.6943986981800759, 0.7162478493991435, 0.7062336649841487, 0.6036456675698116, 0.6639180566725933, 0.6219720071470658, 0.24350800926743477, 0.679213679196355, 0.2240803556979768, 0.36003166733772785, 0.36075160417206886, 0.8363341885365483, 0.18067407352555198, 0.7920428961261166, 0.7742395239529175, 0.2994578655552317, 0.229519581246042, 0.2345966784410055, 0.2570806248901034, 0.27347952204878145, 0.279974490356486, 0.19839998148042826, 0.23723147536772293, 0.20426541778023555, 0.19776769024291896, 0.2474689727660374, 0.25554139708469337, 0.22553132667311715, 0.16146471750821023, 0.24523472672696367, 0.21232152745425714, 0.21614049022151816, 0.1606108426133922, 0.0669385342158495, 0.08846578932541893, 0.13297274486903754, 0.015251131904983062, 0.03429705518662651, 0.01394511315721425, 0.06852814748276104, 0.01486065970901762, 0.03413068749733117, 0.08681669291982685, 0.11165726900508488, 0.11355846126540059, 0.10509334844383267, 0.03443065907792875, 0.05753827882728224, 0.11352897847135757, 0.11252588120899198, 0.22361961824294652, 0.1368637547123701, 0.07627632027442866, 0.11039927449985154, 0.060988769548727895, 0.05276779332576442, 0.08144129843260473, 0.1395712998973493, 0.10508646647544173, 0.03730621611756724, 0.216023424828246, 0.21672333232587937, 0.24797387064097542, 0.2551326445308226, 0.2888749200048133, 0.2810358884754395, 0.16663188672104046, 0.227447652848337, 0.19467961175669113, 0.607120761813461, 0.62552889154573, 0.6165132971503788, 0.5501035731302952, 0.6040364757489652, 0.6140272939989706, 0.5802220367360331, 0.6061132447774112, 0.549974561074507, 0.09890399725341215, 0.12306643480955337, 0.12840094703777927, 0.09752195417690313, 0.1456232463051369, 0.09382683761059163, 0.10741246252882464, 0.12297742337956608, 0.11744814510793877, 0.11552839333877529, 0.132996581161683, 0.23800896233338786, 0.29855384735668267, 0.18511670915155198, 0.17883413570153261, 0.18907681127308074, 0.1627774684654696, 0.1449646022447274, 0.3822119361329258, 0.3659775865322952, 0.3129901808789214, 0.33574673938915545, 0.3178272230019835, 0.34841613592289133, 0.2840456110984376, 0.3563448878080504, 0.3290766790453865, 0.28577649756332846, 0.28894236498485504, 0.24769976461216092, 0.19172110662383024, 0.275625123059858, 0.31666031364416813, 0.3016080782614651, 0.18850226995046337, 0.2354397871499817, 0.21130769837914287, 0.23363819380092132, 0.2088818306685133, 0.18209161026389387, 0.20776033068535726, 0.2092179927782366, 0.21834218173869302, 0.18303725311458363, 0.21335685617893052, 0.5253979073379758, 0.21924202942553062, 0.22106751010446024, 0.23971426314407318, 0.2370204840458039, 0.2063852307566486, 0.22209331828364043, 0.1957340142853622, 0.22267817996972972, 0.6402263674965619, 0.2319938295417907, 0.1844599980482301, 0.6524496501124454, 0.19853327032196288, 0.810385786341635, 0.6765219699736429, 0.15824166624012037, 0.8169827180427631, 0.47174586427576826, 0.6866573837651092, 0.26971700283365097, 0.20602979958434997, 0.3149042776047172, 0.21055805323156151, 0.11081959490306459, 0.20382286215733825, 0.4470800953860047, 0.17039126411004968, 0.18054045177396805, 0.18209228674884503, 0.17675912014621808, 0.17543780910482676, 0.19374977061473753, 0.17788948683565087, 0.18939554760770283, 0.1889833699708563, 0.08146188573245494, 0.09501660608949458, 0.0938105977392959, 0.115486667756874, 0.10782034789667594, 0.07985214427792364, 0.07856417360242907, 0.1033161126723311, 0.0777790209937198]}, "mutation_prompt": null}
{"id": "7b4186b2-381f-4d1b-a573-eef359343c54", "solution": "import numpy as np\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:  \n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        def chaotic_map(x, a=2.0, b=4.0):\n            return np.sin(a * x) * b\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_harmony += chaotic_map(new_harmony.sum())  # Integrate chaotic map for exploration\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing the exploration capability by incorporating a chaotic map for diversity and global search.", "configspace": "", "generation": 19, "fitness": 0.3294489118369737, "feedback": "The algorithm EnhancedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "metadata": {"aucs": [0.8855572945267368, 0.8925704769455102, 0.8792232722300651, 0.8740295108019217, 0.8662849536292961, 0.8720171365647258, 0.877649891150329, 0.8950235853659229, 0.8828693155602145, 0.7578923880564905, 0.7625855477611535, 0.7686964571659729, 0.7429812456087981, 0.7494546011211214, 0.7243486961965496, 0.7408682964076894, 0.760033753891166, 0.7457686338823344, 0.41045014710668615, 0.18104331818551178, 0.20818327470317521, 0.4270907346964201, 0.4100199370808957, 0.17654068588035365, 0.5462764705741179, 0.4490318682646909, 0.3202485167517225, 0.15508062830695546, 0.16904238752894285, 0.1330099347832875, 0.14281688144729177, 0.28920484667122814, 0.1438136246975903, 0.13484419289307292, 0.17312457283936833, 0.14745983944631935, 0.9812962451880931, 0.9624593644087275, 0.9696172108076637, 0.9685948715593234, 0.9760815989208217, 0.9675386520353768, 0.9658713523256303, 0.9660003624965681, 0.9715455928165, 0.6178707443861329, 0.6101674940142665, 0.6368969676924159, 0.6248646428277642, 0.5964775173516503, 0.5303024758629092, 0.5013746591975432, 0.5403858074888094, 0.5553673898833349, 0.2888405554014346, 0.5909531530919612, 0.4287134145649961, 0.5934348129875735, 0.6963668874347901, 0.46047577184176924, 0.773368276658924, 0.7190051516078463, 0.34424877930796205, 0.24011986335363888, 0.21047298114554247, 0.2727746744467767, 0.31167238170068223, 0.33947886190767496, 0.22534324071129708, 0.22659000734189094, 0.17774878402155647, 0.2734075810638572, 0.21869927746348772, 0.16331749662711226, 0.20796669551834035, 0.1756912935382896, 0.18130426716233272, 0.16988223690633109, 0.2094568114989016, 0.3470560138091664, 0.34880718558282586, 0.01638409863545931, 0.0035339472334677824, 0.012918833371590832, 0.03252979604619122, 0.007597668985302675, 0.01997931645535811, 0.025223405155567535, 0.029694549307273665, 0.02448451984267208, 0.1447994431149655, 0.11268858675633486, 0.10806077508595102, 0.11883687454391834, 0.08890768887080924, 0.06439333571542005, 0.185395650794704, 0.12239276218381856, 0.1317331801898879, 0.039836927766403796, 0.07741389428720336, 0.07375642654188519, 0.03864000071234186, 0.07390691028205709, 0.049675117476421615, 0.0737995250908352, 0.020633315259515284, 0.043435951562444064, 0.17518155295998072, 0.15184743119447153, 0.1644138882064552, 0.2357741099718219, 0.21022115631335836, 0.2108696540830407, 0.17961528114665593, 0.16561979069445898, 0.18388906947937722, 0.5991720793237499, 0.5893799900234882, 0.5777608079018774, 0.5737338132177279, 0.5674867163429554, 0.5403942120259888, 0.5904872610936591, 0.5952477709047663, 0.5910301342569724, 0.11709387905148105, 0.10922264067756116, 0.07898061770340914, 0.10687904911231105, 0.09565948807633962, 0.1028864565431189, 0.1199563621894848, 0.1096155965524298, 0.13134939483530483, 0.17832451925551507, 0.167233170417857, 0.15176290308278673, 0.15003702308105182, 0.19932976013629677, 0.16008704122293327, 0.13815971885523992, 0.17126692932202492, 0.16429593596211922, 0.33611420983780615, 0.30671507597526226, 0.3270941430831905, 0.30878520232833195, 0.31178070331163965, 0.30323283571765547, 0.2813325342864005, 0.33502537599685467, 0.30364610384286017, 0.2456100087760611, 0.22442798077028658, 0.2292529441402228, 0.21088712846749724, 0.2766724922933841, 0.2381004170112505, 0.22781511937901688, 0.21137353578963913, 0.20061129552913148, 0.2182652191202049, 0.21704692550622195, 0.20273823244106293, 0.1887925348303574, 0.21907332405993563, 0.19917992821793962, 0.18322524148850317, 0.199815601750436, 0.20423590714222017, 0.21519806715153034, 0.2074724689372932, 0.22850493416662376, 0.21542831276557417, 0.2295067907173518, 0.2252159489804726, 0.20996209552957612, 0.22054022309518084, 0.22934187925346283, 0.18644128160723772, 0.28058242211233675, 0.437991076112646, 0.6381150209698401, 0.3257872944079663, 0.48427505542896565, 0.2194647690792142, 0.309339984425571, 0.37042848349951174, 0.47035705981912734, 0.25842923901664483, 0.46010350840515735, 0.39914805497927885, 0.5507251748591531, 0.20636931953534232, 0.4601928737155223, 0.1985725096431391, 0.21936904773494048, 0.19357389304756734, 0.17818062065313445, 0.19721854711759457, 0.1809332750701842, 0.18553911979490556, 0.18278203341215937, 0.1776539353384523, 0.20595739138403868, 0.17643440113414233, 0.0911169561193701, 0.0832472576895017, 0.07984403267649942, 0.07913641788032888, 0.09324184932979951, 0.10493058502235231, 0.07278446851043796, 0.0956627513951922, 0.08705047299865276]}, "mutation_prompt": null}
{"id": "508ec8b0-1cc3-4a20-b38b-0551136c0428", "solution": "import numpy as np\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer(DynamicPitchHybridHarmonySearchOptimizer):\n    def __call__(self, func):\n        def local_search(harmony):\n            step_size = 0.1\n            new_harmony = np.copy(harmony)\n            for i in range(self.dim):\n                direction = np.random.choice([-1, 1])\n                new_harmony[i] += direction * step_size\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n            best_index = np.argmin(fitness_values)\n            if np.random.rand() < 0.2:  # 20% chance of applying local search\n                harmony_memory[best_index] = local_search(harmony_memory[best_index])\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]\n", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing the harmony memory update process by incorporating a local search mechanism to exploit promising regions.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'harmony_memory_size' is not defined\").", "error": "NameError(\"name 'harmony_memory_size' is not defined\")", "parent_id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "metadata": {}, "mutation_prompt": null}
{"id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 21, "fitness": 0.43452801771653915, "feedback": "The algorithm RefinedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.35.", "error": "", "parent_id": "b7b4411e-d9bc-4bb3-bb1a-830db398ebb1", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "8d181347-fd04-4557-adfb-849435af1506", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "15cc50c1-9c9e-4005-b72c-80428f5bb6ef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            mutation_scale = 0.1 + 0.9 * np.exp(-2.0 * (self.budget - harmony_memory_size) / self.budget)\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.clip(new_harmony[i] + mutation_scale * np.random.uniform(-1, 1), self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing diversity through adaptive mutation scaling to improve exploration capabilities", "configspace": "", "generation": 23, "fitness": 0.4249414651063469, "feedback": "The algorithm RefinedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.35.", "error": "", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.975895842386128, 0.9782509720800958, 0.9624559148705476, 0.975541868500765, 0.9793949827483629, 0.9522321870374009, 0.9767681472393793, 0.9747662366840478, 0.9509506412895123, 0.88569966280373, 0.735605347604023, 0.7466076091540752, 0.9020852449228465, 0.6824621889145588, 0.8063070972387448, 0.8026324236191597, 0.8599630257768602, 0.6745416063838381, 0.03209367247222761, 0.05102390082955477, 0.025807846067741003, 0.04220025354362822, 0.049993583604214686, 0.04846074183602045, 0.04080975928942121, 0.06722703412623199, 0.04834397592732198, 0.043418994193410776, 0.024572009737770517, 0.023992126937087188, 0.05832734590090527, 0.05412753860899411, 0.01665011039922104, 0.018649338087741274, 0.07167530423858848, 0.043491570334292406, 0.9725640283494988, 0.99021842484441, 0.9672957197105777, 0.9923929518687035, 0.9925130681433784, 0.9789529008839848, 0.9932954960319129, 0.9578215040494835, 0.9855556291337161, 0.42095267879572906, 0.3081709267858611, 0.3273814190410531, 0.47594574632460585, 0.49248247297156045, 0.5777500588393842, 0.27639473538232673, 0.12115377454947518, 0.5289229961173069, 0.14922684002684672, 0.09223950675392045, 0.11224498772852753, 0.15637712529926995, 0.14037043611174083, 0.24009214711733584, 0.08631708042010344, 0.1276375280225175, 0.13136551943437225, 0.9552683147752483, 0.8717072018500924, 0.8692782519532525, 0.9419657320040744, 0.9319877497156946, 0.8765744020941946, 0.9476174899048744, 0.9213953218605717, 0.8387114222088039, 0.8592971621376384, 0.9237900058195898, 0.8989471189824713, 0.9007869742405048, 0.7647664282408316, 0.8042443950565532, 0.9435627520811873, 0.9186522784018234, 0.9259715673996443, 0.5721792242182934, 0.8199885691064104, 0.6770253927446349, 0.2265538491217194, 0.6813762237827489, 0.6254897752006229, 0.887502851922114, 0.7533257126391378, 0.8329807967690604, 0.5605790569105162, 0.5227254860949049, 0.4218875395566274, 0.5331799212246059, 0.16274167694039754, 0.46516836694708064, 0.20924828518575822, 0.4781036919764824, 0.36974871500589856, 0.3095828868481191, 0.5222886089990445, 0.44359052058620796, 0.7709139462350696, 0.721814076591518, 0.6371098748127072, 0.38439415693916223, 0.4344590241660621, 0.3458065357296205, 0.4528687341508425, 0.4842621713131856, 0.5266823079740974, 0.5094858859817101, 0.6230160542599754, 0.44204155003965573, 0.5685490514727718, 0.5983597769858169, 0.4462617342751508, 0.9522691614021387, 0.9552575269893747, 0.9459469114436098, 0.8907518143182962, 0.9608648928088728, 0.9274725931647614, 0.9632304689045789, 0.9682674274963537, 0.9416909536340327, 0.01749089066664533, 0.028226349628390213, 0.041743399615744026, 0.06608450380781783, 0.043224535722574564, 0.03736496230531905, 0.036673181330626914, 0.05636819021399897, 0.06304476705906759, 0.23128042537864923, 0.1889572665745627, 0.15209230265358253, 0.2435657868783816, 0.1232883862739933, 0.12457811382259065, 0.11719907772387594, 0.10785559769640163, 0.12004234907452715, 0.12266585873392344, 0.13871319732009524, 0.11986959941412656, 0.1315677486568897, 0.14711678410876083, 0.12487441515444175, 0.1347050068758432, 0.12107783189198795, 0.13345563049360842, 0.08652096658531405, 0.08004294211501661, 0.060293192079715285, 0.08614970295828495, 0.08733948124995605, 0.0784942170593782, 0.06788570888762191, 0.06352887128588358, 0.0778336050429469, 0.1602224576199215, 0.22198382490844626, 0.177957536740057, 0.16663771346976142, 0.2078445220096179, 0.1730531958340673, 0.21704019387217555, 0.1577703104918453, 0.2361575400157664, 0.1815966205305206, 0.18143868632202464, 0.19376090934564127, 0.21386320558021432, 0.2087099230709759, 0.17828260927335327, 0.1965809805666141, 0.19186607697001956, 0.21815688457505344, 0.1584363019864613, 0.07609972595116765, 0.7500792685020408, 0.8636580620451615, 0.19986095528718428, 0.1090011029033291, 0.15483561131174084, 0.16805474522717012, 0.1674809170832079, 0.9670367246544314, 0.9690908587313782, 0.8557138037648825, 0.9339859359793571, 0.2012503319336464, 0.17969285800834145, 0.11247684277973424, 0.16260399316000662, 0.9717847904178938, 0.22325385432154632, 0.2418431745141929, 0.26098215832520133, 0.27882674489081705, 0.2538484532845833, 0.24220910295491993, 0.21742992682045148, 0.29503055759490626, 0.22334644662808978, 0.0661537676097409, 0.06078481990371476, 0.06533083275538099, 0.09868681426344794, 0.08247002584540386, 0.06795025478170813, 0.047792014312874165, 0.049835827733953564, 0.06607065944339197]}, "mutation_prompt": null}
{"id": "61c374d4-7e05-4183-8282-b704f05c0a4a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def levy_flight(step_size=0.1):\n            beta = 1.5\n            sigma = (gamma(1 + beta) * np.sin(np.pi * beta / 2) / (gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n            rand = np.random.standard_normal(self.dim) * sigma\n            levy = np.random.normal(0, 1, self.dim)\n            return step_size * rand / abs(levy)**(1 / beta)\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            # Integrate Levy flights for exploration\n            levy_step = levy_flight()\n            new_harmony = new_harmony + levy_step\n            new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHybridHarmonySearchOptimizer", "description": "Enhancing diversity by introducing a new mutation strategy that incorporates chaotic map with Levy flights.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'gamma' is not defined\").", "error": "NameError(\"name 'gamma' is not defined\")", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {}, "mutation_prompt": null}
{"id": "8294a2f5-b881-40c9-ac50-35448a66ebed", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    # Introduce Cauchy mutation\n                    new_harmony[i] += np.random.standard_cauchy() * (self.upper_bound - self.lower_bound)\n                    new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a novel adaptive mutation strategy based on Cauchy distribution to enhance exploration and diversity in the search process.", "configspace": "", "generation": 25, "fitness": 0.4016130909738188, "feedback": "The algorithm RefinedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.34.", "error": "", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9766213728504429, 0.9687338309337645, 0.9624559148705476, 0.9720963411869823, 0.9638774604557894, 0.9522321870374009, 0.9722760048165747, 0.9634905480766519, 0.9509506412895123, 0.6448303428387812, 0.8098554209956326, 0.6382509443144814, 0.34905728766742017, 0.8070974554732792, 0.4906504114083531, 0.9166084631243288, 0.7348273889445398, 0.4600992237354552, 0.10837674884634885, 0.04211324960659635, 0.04942935680787486, 0.06510380328380894, 0.025686986808856505, 0.05080997865904879, 0.048773472857748135, 0.03617666764129246, 0.03253825684204348, 0.05935575151714878, 0.02765900895630491, 0.029445892657080197, 0.04532738047161744, 0.0269889509564204, 0.033772017806744214, 0.05522517519086434, 0.03268772065889847, 0.02889215869896411, 0.9735591136216711, 0.9367111534768895, 0.9672957197105777, 0.9912086563411385, 0.967329759358183, 0.9789529008839848, 0.9937186265460305, 0.9875105078581328, 0.9855556291337161, 0.32980433518570296, 0.3169573672116942, 0.22353441828600784, 0.328329913291313, 0.32918270048092224, 0.2990529980774851, 0.6020222094170941, 0.439586394825247, 0.2815358286897699, 0.13754848959210797, 0.07342296296357509, 0.09158842814214718, 0.11207815328853832, 0.09818506015086237, 0.11141116746765733, 0.08062074393707686, 0.10585681911991829, 0.13916186793451923, 0.9457019404629431, 0.8445253985557377, 0.8568738833719703, 0.9495489884861726, 0.9446798572417099, 0.706815162925007, 0.94677656090256, 0.5968716097094415, 0.8237374179395559, 0.9456540642942904, 0.9381316253949629, 0.8941007456218547, 0.9390520660047326, 0.9447070613575819, 0.8864779414938717, 0.9567705334300937, 0.8737486574004147, 0.9259715673996443, 0.5704193865657223, 0.6174800563487123, 0.2670001362820714, 0.8316447596698318, 0.30514904490439454, 0.267961058100883, 0.6173715594326938, 0.4607542934473662, 0.5157750034547168, 0.1485319810805884, 0.25652815641036064, 0.4801278909949528, 0.14767257955686908, 0.12427105577421205, 0.4182895745092401, 0.19529879317010923, 0.12462682648729928, 0.1999345993448033, 0.2216549499844822, 0.22809327272684088, 0.4220598230211995, 0.6948049472602064, 0.7501168827800293, 0.4545685490716327, 0.1806771819565094, 0.18909108641689676, 0.15386067488126176, 0.44753187775939063, 0.38529415119061317, 0.5667816122975782, 0.6595778498848246, 0.6764742692473462, 0.5341108594454904, 0.5998514688356642, 0.42035299077867705, 0.5860492117389191, 0.9415717152221329, 0.9532650894999681, 0.9459469114436098, 0.9479672384087462, 0.951120869421587, 0.9321322828125163, 0.9596464719490755, 0.9394164766652717, 0.9416909536340327, 0.052887783689344325, 0.01190999026521189, 0.05211662409375406, 0.0952084912245662, 0.03588300894018126, 0.04083693174492764, 0.05278792663256904, 0.038960467754931005, 0.052767210261381425, 0.14337833196621008, 0.13265590645789638, 0.12753660702269065, 0.13203497403454367, 0.13857903954258655, 0.12744817861743196, 0.185058599524894, 0.15503140260215764, 0.13962018582598157, 0.14210134410445885, 0.13018453457317847, 0.13938001846300174, 0.15986220855264033, 0.12659169358360656, 0.15434681259298433, 0.14031673141778755, 0.11314757456532865, 0.15017297572110144, 0.08061174700987273, 0.0719012156553861, 0.06193630477337442, 0.07658314599218097, 0.06774979612118681, 0.07687878830227945, 0.09442325277591057, 0.05062425170131157, 0.08731407173998074, 0.18613685273542435, 0.13467294494595483, 0.17719596001056837, 0.18294051882709894, 0.1884482129953171, 0.2219842887921859, 0.17634700467003972, 0.140963816468064, 0.16861271037788106, 0.21132017358230804, 0.19882382269910315, 0.18524389661280338, 0.21514412371439706, 0.21137252961133823, 0.2007271974073762, 0.19758408380065107, 0.1973377971710656, 0.22161829071109762, 0.4865258625757176, 0.19375355253580218, 0.19916767250962908, 0.7485346120236631, 0.6010397188476888, 0.5455107710539464, 0.1745450421745649, 0.7589224441901858, 0.17499990742219107, 0.19088354432575372, 0.8784103582020868, 0.14391200898673961, 0.578066911985651, 0.4751716378935602, 0.775549223513997, 0.5748109234536594, 0.8027092911546551, 0.9717847904178938, 0.24202929034475107, 0.2671070005695301, 0.2518833907320256, 0.2833692187974428, 0.2600027322558617, 0.30933487214084243, 0.26710455847242764, 0.35435316679449147, 0.3014589267761477, 0.07948501378006645, 0.035738994815596725, 0.06891267813154067, 0.061118174059958785, 0.037003245962907605, 0.07242685319812026, 0.06336008779944691, 0.04494033444174472, 0.05241123588364316]}, "mutation_prompt": null}
{"id": "add3f39c-4fb5-4e6b-b0b8-e45efb927d7d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Population-based evolutionary strategy\n            for i in range(len(harmony_memory)):\n                local_search_harmony = minimize(func, harmony_memory[i], method='Nelder-Mead').x\n                local_search_fitness = func(local_search_harmony)\n                if local_search_fitness < fitness_values[i]:\n                    harmony_memory[i] = local_search_harmony\n                    fitness_values[i] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing local search by incorporating a population-based evolutionary strategy for better exploitation of the search space.", "configspace": "", "generation": 26, "fitness": 0.4235392412910049, "feedback": "The algorithm EnhancedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.36.", "error": "", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.973984241686686, 0.975296854331007, 0.9662749613844145, 0.9557008610947328, 0.9760955289527672, 0.964447295328587, 0.9607045882511415, 0.9599886029800262, 0.957299059977589, 0.755589694686571, 0.7553365199690648, 0.8530445437162384, 0.5261588040767093, 0.8714231089816686, 0.6417029789145862, 0.7123369917607373, 0.7557758904727245, 0.6456220184608172, 0.051799083280236524, 0.06372638527009766, 0.03018180709616025, 0.03656801876701232, 0.026236305732788012, 0.04375361896091634, 0.04273004129886726, 0.05425246346396728, 0.047703806188367004, 0.05298804227893528, 0.015686200438302822, 0.014995516880818682, 0.056059941211871744, 0.041390924063888224, 0.036470060258941395, 0.03062500906383958, 0.0414769197025906, 0.027920673970447174, 0.9337716071395711, 0.9823872207393749, 0.9673983270373665, 0.989096993563306, 0.9881221507010238, 0.9777592604501026, 0.9914841797544572, 0.987746562432584, 0.9848497512271087, 0.31377409781676024, 0.2630103114425929, 0.21013265262041636, 0.40338032131756507, 0.38001206633393214, 0.306993158167862, 0.4071085108684168, 0.2108904072978658, 0.3148664993364054, 0.11060051488455702, 0.05421042602994608, 0.08292338441477531, 0.12862482857917767, 0.03100063980568879, 0.06077899363985473, 0.058870355965830456, 0.0415966031875028, 0.09802074975390296, 0.9461517833706126, 0.9372212653122886, 0.9104264742751382, 0.9359200967942181, 0.9362540596053033, 0.8670585238948039, 0.7951585416423292, 0.9242635523354782, 0.9224806256640213, 0.9593926053867377, 0.85487042468312, 0.9390150009353948, 0.935143758343196, 0.934749543885111, 0.9305546508734814, 0.9393624669306767, 0.9562129078837268, 0.8278417601280857, 0.3766136194606783, 0.6901207494898633, 0.4470191308641118, 0.871744582509377, 0.6808970981866204, 0.4636425453183366, 0.9140939500725239, 0.8713882131795395, 0.594174686788851, 0.21021088953022704, 0.3363941546222049, 0.4898166742504574, 0.4097428549913097, 0.5670051788580921, 0.39075465119060515, 0.306183609299965, 0.4243045004677277, 0.45766897970763054, 0.2611311407637401, 0.44584897062328654, 0.35734828290488574, 0.6765174984758402, 0.8504628539167153, 0.7459191350816468, 0.32395355936375436, 0.41440508459458847, 0.20550366649032814, 0.6353629465071082, 0.7083187652139392, 0.5737557350359828, 0.5220342209053577, 0.5810797668874752, 0.6871440119182868, 0.6545313628449183, 0.48569381901952624, 0.5123537597547677, 0.9516433689170839, 0.9399791638219117, 0.9524325560348311, 0.9500951736309077, 0.9491533113585131, 0.9470439157291538, 0.9553893301707976, 0.9601450388035189, 0.9459157907408364, 0.01309448919517886, 0.0032113672494792356, 0.02553670935878871, 0.034105921105804016, 0.019589623007483348, 0.04873450157721204, 0.022642617824362943, 0.041792528039084065, 0.07186223692631721, 0.13072365752973003, 0.1591488958014634, 0.12674510949836604, 0.2179149286476494, 0.15291280199705304, 0.11820218011509787, 0.1112133343722298, 0.0923976276481282, 0.10976987627427892, 0.12825619466067162, 0.14375157110727743, 0.13066664802954642, 0.13006510925139958, 0.12926164423689057, 0.11940995713316283, 0.13912556751944283, 0.1236756514160674, 0.12187745681526596, 0.09080431507546505, 0.05831666034659244, 0.06380606723233595, 0.08315376644830963, 0.08699903518318064, 0.07810536887186859, 0.07334983303522569, 0.05978727158945152, 0.05962814760767121, 0.1914020224124663, 0.135222611121244, 0.16629458101657124, 0.18747717692619548, 0.1549591830807462, 0.17417882887450964, 0.19022935987641565, 0.14366307721053273, 0.156723284913311, 0.19847202797434882, 0.20676122449455614, 0.19911566314497176, 0.1948657609064638, 0.20067306754923886, 0.19795071744727943, 0.19714020001987342, 0.2017453420982941, 0.2123323280737075, 0.1578226209149166, 0.7960218680545919, 0.9493359388912755, 0.938711663396481, 0.19671612817206818, 0.1453662061756017, 0.18648137206077797, 0.18771472903907005, 0.17523829329751894, 0.8924803067994589, 0.872298958442058, 0.9261975830326672, 0.9048379899843542, 0.2137423258345812, 0.20494961080559504, 0.9514528373525172, 0.13554133789218936, 0.9623636449502226, 0.2541770525551451, 0.2612576202349164, 0.22865985697025426, 0.2311080838176255, 0.2673103366100189, 0.22102853381864795, 0.2579333853029959, 0.2930188774446265, 0.2567821969708046, 0.032091777206379124, 0.04405914396623811, 0.060100341985744876, 0.04761495826837758, 0.06061176408897395, 0.04560480267706646, 0.050826568027870556, 0.046040688484895176, 0.05235730875866451]}, "mutation_prompt": null}
{"id": "669bb8ff-9802-4bb2-8203-414c35d7ff38", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "b0dc5198-e5c1-43bc-82b8-7d91775e3348", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                # Introduce chaos-based perturbation\n                new_harmony[i] += np.random.uniform(-1, 1) * 0.1\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing diversification by incorporating a novel chaos-based perturbation in harmony memory.", "configspace": "", "generation": 28, "fitness": 0.4232654315266228, "feedback": "The algorithm RefinedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.35.", "error": "", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9787686200087543, 0.9790022791804156, 0.9424698063199333, 0.9719198600432227, 0.9731547363681875, 0.9494102807834817, 0.9776025972094847, 0.9757823410397118, 0.9391089546531809, 0.5988116914999153, 0.8933926952126141, 0.6942618103585684, 0.6718299248450321, 0.7592832655472823, 0.9006865810364052, 0.9095542427202631, 0.7566218289735933, 0.7714643473921453, 0.06364812983528167, 0.05904000250701724, 0.04911491990345296, 0.04010635780212102, 0.06998307296825845, 0.058380801781600544, 0.06993144012971331, 0.052017433730850327, 0.06527623792258697, 0.07148314111412879, 0.040067571046353834, 0.053972877901197314, 0.07372766716939227, 0.032204304002704354, 0.03177654307304201, 0.05835149132066053, 0.03075940249601028, 0.025767745768967676, 0.9805868881335615, 0.9902545537620274, 0.9886265395645423, 0.9927862268500056, 0.9925431086942201, 0.9863616270789983, 0.993135595764043, 0.987258365648991, 0.9877078574290562, 0.5283574404755857, 0.23399732830193842, 0.2098941251928138, 0.43422263285381646, 0.30750473966881686, 0.13876563942444786, 0.4180082541342869, 0.14726467723554393, 0.2487139616537588, 0.18207624187537352, 0.10355074423874555, 0.13047828401599804, 0.16170021264431012, 0.10131001663840922, 0.16694625655147555, 0.13774498441187044, 0.1565578330806109, 0.14443847741203064, 0.9484211060451665, 0.7588544165216174, 0.8492230523044614, 0.9398273617374662, 0.8717561272780423, 0.8605737385233048, 0.9479575758962734, 0.9271311846855097, 0.9379265298710265, 0.5740581257259247, 0.9196746682083132, 0.9202601916341263, 0.9405974362272264, 0.9273876875557727, 0.9376996659259472, 0.938711013708013, 0.9179668790134409, 0.9198434661494372, 0.6670127495952434, 0.9161259547154142, 0.6296704105415722, 0.3463143125167397, 0.12578833471197637, 0.6630284759418077, 0.6524223818082185, 0.6948477274743255, 0.6899462450439457, 0.29756454218635153, 0.3155839017405444, 0.25219311268357547, 0.17994683047225168, 0.17853605697749553, 0.11912627707263623, 0.2541327682191131, 0.2289228219425018, 0.21386627412785109, 0.19925991180700464, 0.2686333705365631, 0.260489864890425, 0.16372725701484103, 0.7671973260097905, 0.6793973887763729, 0.23274651645715771, 0.35060357650377194, 0.2822409302409803, 0.4277679153951418, 0.6118232043314797, 0.5442982583225435, 0.4936090024274341, 0.6867904190087446, 0.29224177964731524, 0.6471757657610705, 0.6851809679833135, 0.4708902305067424, 0.9566417666740314, 0.9575703132356952, 0.9419024128889378, 0.9506338607930346, 0.9608849188910672, 0.8998059943713725, 0.962355507130179, 0.9675506257718631, 0.9402867566195044, 0.04755981628097783, 0.09295626269400348, 0.02870876785868748, 0.13660730312064118, 0.0578288043422035, 0.0718996661964757, 0.041101255670826675, 0.04887264423746762, 0.08473245038948185, 0.10422043014074012, 0.14450105342061448, 0.12066509339419285, 0.12376825507981881, 0.15793085204141133, 0.17214843906331556, 0.1328012207401411, 0.11621662710395708, 0.11366474497209078, 0.15939767040792918, 0.14253182146519816, 0.1490923349105142, 0.15597589658159727, 0.17271828627122154, 0.15735036454399887, 0.13421989194713113, 0.14512591898963578, 0.15361057057782834, 0.09920000628804848, 0.10283184968239145, 0.06422741124016151, 0.10529174437491584, 0.0965438781540563, 0.10627762147109587, 0.08497667370711826, 0.09678497051621893, 0.09874181747437927, 0.1803757875216987, 0.14886197853614358, 0.18607034679663825, 0.1707809983967179, 0.2320835806012883, 0.21009000050206683, 0.20060607794593832, 0.17083160828440613, 0.23368730852984354, 0.19273863549395798, 0.23982757272605992, 0.20113184457285627, 0.24327530011398657, 0.22538338682669745, 0.20035338706165962, 0.20822086491768443, 0.2257941546648249, 0.19845142587329612, 0.7979599147065551, 0.6255085963962662, 0.18832415688582105, 0.816768704245644, 0.18188783669258224, 0.743050131409221, 0.16778374731094248, 0.47299851223042955, 0.8694371503389524, 0.26601717059754415, 0.9731701098895524, 0.7567608799815548, 0.779965021806603, 0.1819670752097341, 0.9064178231268701, 0.7083540655012321, 0.7944636988789736, 0.9656579023398865, 0.21607952765273164, 0.2356089140062726, 0.2576083787281549, 0.3185518705460839, 0.2757093816526478, 0.2521855653253058, 0.28700014428935106, 0.28616527303681105, 0.3341607939987773, 0.04907074273855783, 0.09340397881696771, 0.06635555569837237, 0.054439535767771496, 0.07086758684059202, 0.06101489929093207, 0.06545840384122292, 0.04418903079064673, 0.0671915912848885]}, "mutation_prompt": null}
{"id": "ce7cde34-a76e-4ee9-ad7b-b003329c9251", "solution": "class MultiPopulationDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(len(harmony_memory))])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        num_populations = 5\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        populations = [np.array([generate_harmony() for _ in range(harmony_memory_size)]) for _ in range(num_populations)]\n        fitness_values = [np.array([func(harmony) for harmony in population]) for population in populations]\n\n        for _ in range(self.budget - harmony_memory_size):\n            for i in range(num_populations):\n                new_harmony = improvise(populations[i], pitch_adjust_rate)\n                new_fitness = func(new_harmony)\n                if new_fitness < np.max(fitness_values[i]):\n                    index = np.argmax(fitness_values[i])\n                    populations[i][index] = new_harmony\n                    fitness_values[i][index] = new_fitness\n                differential_evolution(populations[i], fitness_values[i])\n\n            all_harmonies = np.concatenate(populations)\n            all_fitnesses = np.concatenate(fitness_values)\n\n            local_search_indices = np.argsort(all_fitnesses)[:harmony_memory_size]\n            for idx, harmony_idx in enumerate(local_search_indices):\n                population_idx = harmony_idx // harmony_memory_size\n                local_search_harmony = minimize(func, all_harmonies[harmony_idx], method='Nelder-Mead').x\n                local_search_fitness = func(local_search_harmony)\n                if local_search_fitness < fitness_values[population_idx][harmony_idx % harmony_memory_size]:\n                    populations[population_idx][harmony_idx % harmony_memory_size] = local_search_harmony\n                    fitness_values[population_idx][harmony_idx % harmony_memory_size] = local_search_fitness\n\n            best_fitness = min(all_fitnesses)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (all_fitnesses.sum() - best_fitness * len(all_fitnesses)))\n\n        best_index = np.argmin(all_fitnesses)\n        return all_harmonies[best_index]", "name": "MultiPopulationDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing diversity through a multi-population approach with differential evolution for improved global search capability.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 68, 9, '        best_index = np.argmin(all_fitnesses)\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 68, 9, '        best_index = np.argmin(all_fitnesses)\\n'))", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {}, "mutation_prompt": null}
{"id": "7e0a1eb5-bde7-4294-8c9b-e17054d2bfa4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "71d71fe4-9273-47eb-8988-e12c47048e99", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "6b16d263-c0b3-4d90-b10a-18374aa1d7e5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nimport pyswarms as ps\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Integrate Particle Swarm Optimization for exploration\n            optimizer = ps.single.GlobalBestPSO(n_particles=len(harmony_memory), dimensions=self.dim, options={'c1': 0.5, 'c2': 0.3, 'w': 0.9})\n            pso_best = optimizer.optimize(func, iters=10)\n            if pso_best[1] < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = pso_best[0]\n                fitness_values[index] = pso_best[1]\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by integrating Particle Swarm Optimization (PSO) to diversify the search space and increase global search capability.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'pyswarms'\").", "error": "ModuleNotFoundError(\"No module named 'pyswarms'\")", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {}, "mutation_prompt": null}
{"id": "3ecbb929-f0b7-4017-a390-bcea4b623649", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def chaos_optimization(harmony_memory, fitness_values):\n            chaos_factor = 0.1\n            for i in range(len(harmony_memory)):\n                new_harmony = harmony_memory[i] + chaos_factor * np.random.normal(0, 1, self.dim)\n                new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n                new_fitness = func(new_harmony)\n                if new_fitness < fitness_values[i]:\n                    harmony_memory[i] = new_harmony\n                    fitness_values[i] = new_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            chaos_optimization(harmony_memory, fitness_values)\n\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a novel chaos optimization technique to enhance exploration diversity in the search space.", "configspace": "", "generation": 33, "fitness": 0.42965253770041095, "feedback": "The algorithm RefinedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.36.", "error": "", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740008819642979, 0.9795740381336749, 0.9622820129915377, 0.9710601341797966, 0.9784476867715516, 0.952216149748076, 0.9657944835761592, 0.9771173859991796, 0.9509506412895123, 0.6657148336036005, 0.8945807932022802, 0.7109951066008708, 0.7455082094436474, 0.6616081264607856, 0.6995876758749509, 0.8728955816724994, 0.669764239444155, 0.8871240584630417, 0.10042455339236678, 0.031922531125984865, 0.06271273205225913, 0.017723451362546827, 0.0867916988323797, 0.01522660351008942, 0.04500990346168088, 0.03944618999206595, 0.029707846716095943, 0.03887714425405575, 0.03776334583018559, 0.026718208720977077, 0.057050225409325694, 0.007309679968085958, 0.014336726719632709, 0.01966762750250839, 0.04089405284774528, 0.0391897711024618, 0.9823322355087789, 0.9901846275045906, 0.9672997317472511, 0.9925459895470913, 0.9925130681433784, 0.9789483413498081, 0.9931292581273667, 0.9873201888958469, 0.9855521453540269, 0.22014437314695945, 0.4075303406749933, 0.27208092483303037, 0.32328454994520395, 0.19727214340007637, 0.3783941898066727, 0.35437265722010236, 0.2882498666641009, 0.19962166209579646, 0.11493048640123105, 0.07650376085261523, 0.08521733947201715, 0.10794639564108566, 0.11220530163962572, 0.07887530669773624, 0.08520641055922895, 0.04575372878875006, 0.09997014405700921, 0.9363985721448904, 0.9402744599750438, 0.8360025037666424, 0.9485076660392466, 0.8821180715300141, 0.8797797098308494, 0.9400138228293746, 0.7579425176781254, 0.87239393558769, 0.9308867494031405, 0.9202427659590157, 0.8970127754388497, 0.9218544282788891, 0.8685595489323993, 0.9378592041350248, 0.9464012301214331, 0.8469410867794989, 0.9259715673996443, 0.7995815120919225, 0.5827394256102935, 0.22747155077437664, 0.8300642435053729, 0.7344228633209908, 0.361314415611549, 0.8888150986724188, 0.38852992582361057, 0.3234216550780785, 0.2789294645402116, 0.2046872351071395, 0.20708921825338633, 0.31280447111854315, 0.37502099065301764, 0.19801559550848746, 0.3149414288643607, 0.6721220019788399, 0.25621944502503713, 0.46277985888759565, 0.6140757666866571, 0.44474577738407084, 0.7737545169948602, 0.6060032124783523, 0.8388527187212853, 0.29036860496210726, 0.3675433704076211, 0.2572222600436096, 0.4713264879190697, 0.6527927025046958, 0.45335603912366385, 0.5455964116896665, 0.5891979840669619, 0.5269550352752937, 0.5469329284356431, 0.3683684975949487, 0.6243794189913462, 0.9504501654297254, 0.9548298046821252, 0.9458756633263821, 0.9184739096255776, 0.9487279196925231, 0.9318506752882058, 0.9639157583539227, 0.9653574168860388, 0.9416915013015692, 0.023232715038808638, 0.009009907465309719, 0.012286165477875866, 0.040183157602909136, 0.022468938614631617, 0.04514892532359227, 0.03280880973657818, 0.011082020126936154, 0.05028621322897908, 0.15823756579081405, 0.1431011289759041, 0.15435191247782099, 0.16105689427137404, 0.1657162994024568, 0.13149162581938711, 0.13691163668381, 0.14586264352838785, 0.1214839205817374, 0.15404624551484725, 0.1281604292524664, 0.1426459009467902, 0.1547393368295692, 0.14172508569181141, 0.1290567518643817, 0.14466930332746653, 0.124956492686082, 0.12767794503622987, 0.06193727494393275, 0.06566899486573752, 0.08774868077030296, 0.08746426114283001, 0.07596604063772827, 0.07745926179583384, 0.09051328847302043, 0.053739318153030236, 0.07241986287414315, 0.18715156064653649, 0.15695137725556763, 0.21375319501598955, 0.19050421289899222, 0.16000640850411052, 0.19508103320563663, 0.18965689635094107, 0.12829451715989726, 0.2228584360721767, 0.2485379042184016, 0.26539915798925995, 0.18829949729183204, 0.2070249386626699, 0.36392502618369194, 0.1916589950672618, 0.1911370028633187, 0.18983270737803026, 0.2063422245003953, 0.17976164818819673, 0.9408844689533068, 0.8034744793203514, 0.3060850988112922, 0.888395989910999, 0.8749196322834398, 0.2052480074931866, 0.9431653427856724, 0.8688421505321714, 0.9258168242825482, 0.9695408991943227, 0.8200786976070769, 0.1994065195828041, 0.19516977226034482, 0.5516268361902414, 0.9369470384075111, 0.7022097240784738, 0.9717862388462619, 0.22224829827446824, 0.22856464242110386, 0.2402675171225057, 0.2489073553950969, 0.25163697021871445, 0.25062948717033984, 0.2744514529222043, 0.28480909745382965, 0.2601055782066898, 0.03535975039146799, 0.03256524119506665, 0.07590073918405482, 0.04585037813359616, 0.05155546170280578, 0.04817345254156025, 0.058563380969296475, 0.04323249737285528, 0.038882363251303675]}, "mutation_prompt": null}
{"id": "d5926820-83a2-4ea8-ab3e-bdb4cb5392c7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "7713488e-653d-4244-bf7c-ef20eea9e363", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, new_harmony, method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "RefinedDynamicPitchHybridHarmonySearchOptimizer", "description": "Incorporating a local search strategy using Nelder-Mead method to enhance exploitation of promising regions.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9740133401005157, 0.9800313093374419, 0.9624559148705476, 0.9710596039196546, 0.9792954813786414, 0.9522321870374009, 0.9657890925356354, 0.9776600536016963, 0.9509506412895123, 0.8709889776388754, 0.8618997290343642, 0.572285568895607, 0.907332193606721, 0.6227255098982136, 0.6248566751601721, 0.858004319566489, 0.7652254030107957, 0.39488445081018686, 0.05415264597480507, 0.05207966229402705, 0.033409015222710337, 0.0794537305598747, 0.07156490181485076, 0.060307969730049815, 0.07225348682212085, 0.045812457458218714, 0.06177368011644502, 0.038325506193689574, 0.036199498097742255, 0.031051896906339804, 0.045780627701190846, 0.04805759315215441, 0.035751609372275395, 0.03097867603969695, 0.039071402808521505, 0.04055702577678444, 0.9823322355087789, 0.99021842484441, 0.9672957197105777, 0.9925459895470913, 0.9925130681433784, 0.9789529008839848, 0.9931292581273667, 0.9873201888958469, 0.9855556291337161, 0.2857201269916777, 0.4229842392445644, 0.3148681761347335, 0.42335346731854684, 0.3614435816203584, 0.34290376757721064, 0.2356097102368414, 0.2543130076649446, 0.3432169802310995, 0.1653160350257149, 0.1697534643779911, 0.13178913474184395, 0.2245226183407698, 0.19452327466552388, 0.15232801656822592, 0.09851431402898325, 0.11808939057136336, 0.13904913595690527, 0.9363985721448904, 0.9402744599750438, 0.8527292005102669, 0.9485076660392466, 0.8471668452133987, 0.9201546289843652, 0.9400138228293746, 0.6927642295089116, 0.9070648125411972, 0.9308867494031405, 0.9202427659590157, 0.7842838855774695, 0.9218544282788891, 0.7940761153956681, 0.8612575211077793, 0.9464012301214331, 0.8436689274179302, 0.9259715673996443, 0.6539753248852749, 0.4185703644749882, 0.12326698591788066, 0.591084299815314, 0.7884897179140979, 0.5437004316036764, 0.8879214487082011, 0.8131082676985981, 0.7060112091061772, 0.7948399396223496, 0.2696757748366526, 0.23879676204845868, 0.6517093611850906, 0.7679881691538826, 0.36422043453401476, 0.2636040069157991, 0.1802781243148618, 0.6201772250733786, 0.38961283371887556, 0.19312369510582628, 0.28333381616507747, 0.8664407725117627, 0.7150248488953466, 0.8757031365917567, 0.2631407333662743, 0.15483934322880322, 0.19676126571520736, 0.30240963862644044, 0.4796796091042981, 0.49452534230651257, 0.4734391174306496, 0.5808027931526862, 0.5726920461481231, 0.5159007946540661, 0.45952626588518686, 0.515118024660624, 0.95044576090895, 0.9472350653668004, 0.9459469114436098, 0.9201550820098576, 0.9357013827780685, 0.9322013394278241, 0.963914429166095, 0.9653574168860388, 0.9416909536340327, 0.019710075469753785, 0.016954915323608155, 0.04844196546587065, 0.08946499973567568, 0.044762436794570926, 0.04156502696824005, 0.06856207737613418, 0.05616183881923498, 0.046320703218022174, 0.15201981860581915, 0.14772863764405997, 0.13568416880732426, 0.18144242750324124, 0.12643927572591618, 0.14408036493566467, 0.13408166986175696, 0.1383756972713125, 0.1228409277114717, 0.1422549670831269, 0.1592439331781481, 0.1339217568864275, 0.15412658698367454, 0.1420604694955615, 0.14295795654867738, 0.14146802991995522, 0.1370288040820784, 0.1216563952193992, 0.0723728714989178, 0.11081596476493738, 0.08846897280995958, 0.07028694789727119, 0.09966256296922926, 0.09982435210137153, 0.08159492286600156, 0.07694315803823015, 0.08170533097334887, 0.20303838952320874, 0.24033314746243195, 0.19689107929060723, 0.21018117277846093, 0.19526685267083244, 0.17142896685221254, 0.25571883606849344, 0.2496989147662494, 0.18343805399368707, 0.19571581791261206, 0.21723156983380643, 0.207123684416453, 0.21349270113354601, 0.22533061493334716, 0.23256920988779073, 0.20316954223109485, 0.19561920532971722, 0.19950835558200974, 0.4010308319897906, 0.35829834862508025, 0.7174024561656842, 0.5545076789530039, 0.673582520627781, 0.8276078626375614, 0.1864056778656451, 0.551839773351317, 0.7018425668770695, 0.77882491341196, 0.9695408991943227, 0.6163960426622818, 0.9019509378791093, 0.9102495786101825, 0.17350584991016182, 0.6692082553508621, 0.6316997147903385, 0.9717847904178938, 0.242345241747974, 0.2444671259752762, 0.25562174380287783, 0.2735346866103211, 0.23613968927297713, 0.20887166760151654, 0.25671099072466974, 0.28926123423593986, 0.3603514842773575, 0.08145568764246547, 0.05724864138629182, 0.07069888314692074, 0.0694185373674927, 0.052771450665737185, 0.0513085109430913, 0.07667245014549462, 0.05809051943325627, 0.06832606832062138]}, "mutation_prompt": null}
{"id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 36, "fitness": 0.468042042629644, "feedback": "The algorithm EnhancedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.39.", "error": "", "parent_id": "e4fbd6c1-c57f-48cb-8921-c7d1d783a232", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "220d4db6-d966-438b-a134-0d6dc910f7f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "12d5cd9b-14e5-4395-b49f-f5e88fa054f4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "52d8c5ce-8c36-4f42-b6c4-7f18c66747be", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "77e4ed43-bfd4-4a4e-a7c4-5d3470e58f8c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Dynamic learning rate adjustment based on individual harmony fitness\n            for i in range(harmony_memory_size):\n                if np.random.rand() < self.learning_rate:\n                    harmony_memory[i] += np.random.normal(0, 0.1, self.dim)\n                    fitness_values[i] = func(harmony_memory[i])\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Improving convergence by incorporating a dynamic learning rate adjustment mechanism based on individual harmony fitness.", "configspace": "", "generation": 40, "fitness": 0.22875551678031553, "feedback": "The algorithm EnhancedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.4863518191582632, 0.507186004198493, 0.5170805820259176, 0.4929482492080042, 0.461814493081553, 0.46885458048554407, 0.5008558475059278, 0.5060094675907008, 0.514940179058962, 0.0976970802570919, 0.11309893293937823, 0.1010756757462814, 0.08463874223978751, 0.07848791342013661, 0.12579899811064954, 0.10335592917670788, 0.0832415991855785, 0.1315878043164599, 0.11568657478310229, 0.1325126304228048, 0.11993032681168714, 0.13677314221001835, 0.11563821734572921, 0.12827637729233887, 0.12897949934542519, 0.13492168588707698, 0.1344968376970319, 0.10481299685035705, 0.10383206197646233, 0.11075901554370826, 0.10917678826002208, 0.10460432663652941, 0.10333496104206319, 0.12549891147075154, 0.10286663599532841, 0.10445578833005986, 0.9754639819766773, 0.9666212949336564, 0.9546828563934601, 0.9653502377958276, 0.9681445795727777, 0.9521819410995424, 0.9583484540191033, 0.9491279626220248, 0.944370556117471, 0.28472266333364027, 0.2506838042792705, 0.28975072425634485, 0.2851929078798586, 0.24310174786188532, 0.25726617578904054, 0.2873068425288998, 0.25212168371530563, 0.264362765004179, 0.2960341374565941, 0.28635126468856686, 0.2887304976871876, 0.318688977951873, 0.25326545921682264, 0.3762215603548028, 0.3877914869124335, 0.28635606019486015, 0.27792247316330687, 0.15951926543286588, 0.1674668973586262, 0.22017182652256284, 0.1827873998569297, 0.17697304143941162, 0.17902768996550145, 0.21468472990643506, 0.20965898464225652, 0.17348545524974157, 0.17888655475958326, 0.169591877132385, 0.15443193681497847, 0.16893398265771464, 0.16072292345400352, 0.1730449523120915, 0.15892080175259793, 0.14740275475728137, 0.18539591027286484, 0.00037452704116480717, 9.999999999998899e-05, 9.999999999998899e-05, 0.007242839639315712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00436465662310781, 0.1390274625153075, 0.10552082866388901, 0.13591065649462164, 0.026089385836984502, 0.037173495318394645, 0.07200076994304105, 0.06482771877258531, 0.08310420888314951, 0.08673776451999604, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12705440728821704, 0.11130596358742073, 0.11854968553298417, 0.1312398129882355, 0.11096616116553892, 0.13657802944097108, 0.10002077901003903, 0.11247647828709417, 0.09004454638185322, 0.4549575198892851, 0.4256334124075639, 0.4457552516090878, 0.4125473521424857, 0.4363703660027116, 0.4209258014733417, 0.41465573875827944, 0.42391534524589447, 0.43698828508460497, 0.09898137176412114, 0.10786150519145177, 0.09245530512924738, 0.11238030390779419, 0.0930114611336148, 0.10050045109118944, 0.11968601608593399, 0.12262480191597702, 0.10618869843680645, 0.16848516765434418, 0.1435106359526198, 0.21584583791954737, 0.2225962481299789, 0.1649114459244636, 0.20383936263191615, 0.16999338315253443, 0.1556999642858522, 0.2190601137178413, 0.286114438020696, 0.2921892289860819, 0.27768011310761376, 0.2961704814598449, 0.2829079783496472, 0.28362972932764874, 0.27251231630113726, 0.27357008187370535, 0.289902286247419, 0.2217364188973071, 0.2253461594639381, 0.20917553904029296, 0.22480196681145503, 0.23424246248810243, 0.2180476158261616, 0.2258006339677171, 0.2109026969959451, 0.23923346848716243, 0.2045039619304062, 0.19330641880204225, 0.22289714596636945, 0.19256540140082257, 0.20322392702782666, 0.21251848363354098, 0.20317762807809536, 0.21284762428004989, 0.20118869003942685, 0.19985376364017626, 0.20888239866975689, 0.2113161853461092, 0.1905578054160657, 0.26226704936353706, 0.22646934926062545, 0.20753869391430935, 0.20588738280156915, 0.214936468422795, 0.19923872928538788, 0.5828188376771368, 0.6884052372088647, 0.5590711082199942, 0.3938723721973306, 0.3384502870076146, 0.16117176466428407, 0.1774446701012492, 0.17101885779311565, 0.293336601430218, 0.26730591761455536, 0.5323961419000156, 0.20988952791682947, 0.1996339659878108, 0.20458249346333202, 0.3735571403954395, 0.30612558997894734, 0.27486113406097246, 0.18877162995556251, 0.18846065678398338, 0.1721718088758214, 0.18754808514168853, 0.17048398760729555, 0.18856660219379995, 0.17151944405086028, 0.17112254734648158, 0.18867802306433556, 0.08552381445966295, 0.0808820836984987, 0.08733286264783402, 0.07619570677326881, 0.07112426541017014, 0.08811538682806708, 0.0744950273147259, 0.07853408736820189, 0.08624115320782189]}, "mutation_prompt": null}
{"id": "6ebdd219-60b1-404c-ab27-4c82fe1be1fb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pitch_adjust_rate = 0.1\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < self.pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            self.pitch_adjust_rate = max(0.01, min(0.5, self.pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Improving the exploration-exploitation balance by incorporating a self-adaptive control parameter for pitch adjustment rate.", "configspace": "", "generation": 41, "fitness": 0.468042042629644, "feedback": "The algorithm EnhancedDynamicPitchHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.39.", "error": "", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "c6284257-59b7-4c6f-8ed0-3c2a8c5c20c4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchGeneticHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def genetic_search(harmony_memory, fitness_values):\n            pop_size = len(harmony_memory)\n            crossover_rate = 0.7\n            mutation_rate = 0.1\n            elite_size = 2\n\n            # Selection\n            elite_indices = np.argsort(fitness_values)[:elite_size]\n            elite_population = harmony_memory[elite_indices]\n\n            # Crossover\n            for _ in range(pop_size - elite_size):\n                idx1, idx2 = np.random.choice(pop_size, 2, replace=False)\n                parent1, parent2 = harmony_memory[idx1], harmony_memory[idx2]\n                child = np.where(np.random.rand(self.dim) < crossover_rate, parent1, parent2)\n                harmony_memory[idx1] = child\n\n            # Mutation\n            for i in range(pop_size):\n                if i not in elite_indices and np.random.rand() < mutation_rate:\n                    harmony_memory[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            genetic_search(harmony_memory, fitness_values)\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchGeneticHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel search mechanism inspired by genetic algorithms to diversify the population for better global search.", "configspace": "", "generation": 42, "fitness": 0.4304415658340905, "feedback": "The algorithm EnhancedDynamicPitchGeneticHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.37.", "error": "", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9715971332610678, 0.9771225175754592, 0.9722972434069853, 0.9720603994796251, 0.9711747556502093, 0.9607456389074189, 0.9694284262418601, 0.9725947502989896, 0.9740119285803512, 0.8215994497111705, 0.9192218164010285, 0.9037202973354395, 0.9233530810437658, 0.8563554072165205, 0.5498370338041838, 0.764494646792139, 0.9103629013693054, 0.894194701672744, 0.08241893239549791, 0.03600202984272871, 0.04346807159170818, 0.023815846882722536, 0.028259823638338122, 0.02160119966514762, 0.07532794067387294, 0.018352573486238866, 0.026305158609222, 0.11143418312857889, 0.012811588748541713, 0.019837738467408772, 0.07453319706041872, 0.0135112671235873, 0.011330943524837989, 0.042001384239339634, 0.0011284520892346217, 0.007385706569385753, 0.9563492582548954, 0.9940098793833294, 0.9822606166425609, 0.9933254785547313, 0.993752493315509, 0.9282936620637084, 0.9936774751737477, 0.933879172160494, 0.99037545627757, 0.23086386350341115, 0.5371395340578773, 0.3064866044478154, 0.5346016366630715, 0.6312133262393892, 0.3959231084649456, 0.6838145620801315, 0.3110836191171593, 0.2451594408743879, 0.10081250851133683, 0.04035169237064018, 0.06958059180272613, 0.14075355008281187, 0.12711883090952303, 0.04876229742674765, 0.0612186420965829, 0.020775966189171546, 0.08238778903644106, 0.9607326194047496, 0.9150087569719665, 0.8689318627105249, 0.9236210034041692, 0.9269549434092448, 0.8352326445940467, 0.9706418512068351, 0.9615472530549519, 0.7408738604573418, 0.9522207293373178, 0.9439490932973477, 0.3216669674476196, 0.7426423601078975, 0.9501655754802937, 0.9501030538685726, 0.9398161847867281, 0.6894153400982495, 0.9157969040502401, 0.31994377441618893, 0.2691462840137032, 0.861931187398032, 0.8511077365783014, 0.3070999715062268, 0.9069164422425946, 0.8671549987077989, 0.8084140886178777, 0.5163537729689494, 0.252499655723173, 0.49589589535571554, 0.7963668098676542, 0.9226044383727929, 0.4832949284777871, 0.15647128659396314, 0.265682211106829, 0.8584258656723437, 0.8780702870121271, 0.2978869534502644, 0.8437038074104186, 0.5036249866539309, 0.5199450491351099, 0.7447041972708084, 0.7904468327401108, 0.2680655705165498, 0.239910507728333, 0.6685040564812146, 0.8133749852375682, 0.6942357863051174, 0.7704107936628004, 0.7167423593730713, 0.7903964274935469, 0.7492009391257661, 0.40238671578609686, 0.26539719892776137, 0.5556936616184152, 0.9634678809278264, 0.9603730048068205, 0.961714470731026, 0.9418283634937531, 0.9586318296912409, 0.8869752468280523, 0.970389260976038, 0.9659967121299371, 0.9638080830610645, 0.060965053529486224, 0.04395804570085804, 0.011493345805088984, 0.04201090009510333, 0.011559914837379393, 0.05249987322661853, 0.033428293390381225, 0.008589880099930225, 0.07440242361890737, 0.13734584404183603, 0.10982084224354294, 0.12875165517198217, 0.22578017072809553, 0.1261157916558341, 0.21281803701933144, 0.12065213372087691, 0.15489151431178727, 0.1128454241773883, 0.12264761279991943, 0.13979478787209554, 0.12297720046038607, 0.1323873886165704, 0.14135591304366557, 0.13860411413962814, 0.143480112202364, 0.14225929666321957, 0.10891503593054264, 0.09344518763576193, 0.08719466428883604, 0.061860698481797094, 0.0896547425985793, 0.08828915420474581, 0.07799834947854745, 0.09927173281223334, 0.05726649826714292, 0.06800156376095079, 0.21670332210705767, 0.14378852266748166, 0.16917523757947217, 0.1428105497580382, 0.13905918546236062, 0.3071499842557823, 0.20416913001657, 0.15528352796285194, 0.22647741652827003, 0.17337112595638593, 0.184229010487734, 0.19873791959737863, 0.2014998322697924, 0.18738395560458876, 0.19031761649765133, 0.19985586250166387, 0.2125155530418117, 0.46637179651808414, 0.1683004277244201, 0.18862828352734673, 0.1480517331194232, 0.9770083797452651, 0.4999690559050217, 0.12066298449067758, 0.16810473222997757, 0.15860646723741845, 0.1482853022051448, 0.887493969422357, 0.11343746456302051, 0.1920010999597641, 0.972642835314236, 0.7626435085723492, 0.19282631219956037, 0.2747639742710559, 0.12303886785953178, 0.9049352565601523, 0.2848817950249879, 0.24595078854377472, 0.2521832295898998, 0.2428945992257976, 0.24827770153252782, 0.26187168909321035, 0.3080280839815206, 0.30925131324976163, 0.24665810083394268, 0.04223055003784071, 0.04922271387371002, 0.06511350412960415, 0.07011820356768161, 0.041759523356027284, 0.024447142131758803, 0.07424102717583791, 0.033945102124951165, 0.06848421027101959]}, "mutation_prompt": null}
{"id": "5ea076e4-0a8b-4c2d-ae5c-5a1cbac66b8e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "8ce92019-61c1-47f6-bc49-f87e47b08f04", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "84fe56b6-089d-4776-9cb0-e2c8f574e34f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom pyswarm import pso\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        def particle_swarm_optimization(func, x0):\n            lb = np.full(self.dim, self.lower_bound)\n            ub = np.full(self.dim, self.upper_bound)\n            xopt, _ = pso(func, lb, ub, swarmsize=10, maxiter=5)\n            return xopt\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = particle_swarm_optimization(func, harmony_memory[np.argmin(fitness_values)])\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing local search with a diversified ensemble of optimization methods including Particle Swarm Optimization.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'pyswarm'\").", "error": "ModuleNotFoundError(\"No module named 'pyswarm'\")", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {}, "mutation_prompt": null}
{"id": "46961f88-7b0c-4c9d-932b-788ba93cb950", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "b262c36e-5bf7-45b7-a2d6-bf29c4cbd24f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "d2cacc4f-003e-4dad-b5b7-5dcd659144f7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicPitchHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Chaotic optimization phase before local search\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicPitchHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaotic optimization phase before local search for improved global convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.038731517390969694, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6196988927251034, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8337326585004001, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.028117351664080137, 0.05861721986822577, 0.07434960310167005, 0.09170216177533252, 0.12392461722312587, 0.17779978407509112, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.08038664371938864, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1093093729801865, 0.08320506383290216, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.17654573889061453, 0.18976568988772602, 0.20022548331320444, 0.19076449291386188, 0.2084147158894899, 0.18463954761171741, 0.21806454816678356, 0.17565294945594745, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "3a594bd2-0199-47f1-a388-9e42828a0752", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Dynamic boundary adjustment for exploration\n            dynamic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            dynamic_harmony = np.clip(dynamic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            dynamic_fitness = func(dynamic_harmony)\n            if dynamic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = dynamic_harmony\n                fitness_values[index] = dynamic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicBoundaryHybridHarmonySearchOptimizer", "description": "Expanding the search space by incorporating a dynamic boundary adjustment strategy to allow exploration beyond the predefined bounds.", "configspace": "", "generation": 49, "fitness": 0.46831371975796304, "feedback": "The algorithm DynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.39.", "error": "", "parent_id": "94b35763-a0ab-4a33-bb28-84b902c8e34c", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.035275366135797404, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6193486577623988, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5570999849515219, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8351007359156524, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.02730508585770841, 0.05861721986822577, 0.07434960310167005, 0.09170216746669213, 0.12392461722312587, 0.1779704325023468, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.11855725475084322, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1324170024826854, 0.08320506383281567, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.1765458644453276, 0.1897633957988495, 0.20022548331320444, 0.19076449291386188, 0.20842041219806628, 0.18463954761171741, 0.2180690208964411, 0.17565240614175037, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "65775ef4-eb0c-442f-8377-17950d1690a3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Dynamic boundary adjustment for exploration\n            dynamic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.01 * np.random.standard_normal(self.dim)\n            dynamic_harmony = np.clip(dynamic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            dynamic_fitness = func(dynamic_harmony)\n            if dynamic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = dynamic_harmony\n                fitness_values[index] = dynamic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicBoundaryHybridHarmonySearchOptimizer", "description": "Expanding the search space by incorporating a dynamic boundary adjustment strategy to allow exploration beyond the predefined bounds.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3a594bd2-0199-47f1-a388-9e42828a0752", "metadata": {"aucs": [0.9738917856915941, 0.9780864391976278, 0.9772043613610818, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8754384408752929, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09016553070286537, 0.04670829218908712, 0.07173106717455813, 0.0612007594352566, 0.05894877677319965, 0.05618826016709333, 0.059969506859594235, 0.09573393441116518, 0.09684353663056222, 0.035275366135797404, 0.0638029102038834, 0.08157648637377246, 0.031006110046452706, 0.0637423283849552, 0.13149404664911513, 0.044321095343538564, 0.04114528166030873, 0.9552988576963667, 0.9910678383636552, 0.9812076902114585, 0.9921196038314217, 0.9927039586937012, 0.9647207439624044, 0.9926139801636096, 0.9235428085513988, 0.9902239169942929, 0.6193486577623988, 0.5986315987364585, 0.6747742409810099, 0.6257284661449045, 0.5645705206279542, 0.6123649505392035, 0.842194385597854, 0.7242611290529135, 0.6728393860472084, 0.11516166455521137, 0.07778156043502948, 0.1425423528356523, 0.1299084473693881, 0.156913827097371, 0.07668555302098734, 0.060180748749911084, 0.06202735385801039, 0.12734947047575973, 0.9596326194047496, 0.9283260890532472, 0.8798186102863775, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.13737830271004992, 0.9376015111612703, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.7890921321465936, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6681235057858506, 0.8712095814985141, 0.5056270169189296, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5570999849515219, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8351007359156524, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187001910686, 0.027887044385668025, 0.037739253808106166, 0.06742598630039343, 0.011546729673516554, 0.05246137606268697, 0.02730508585770841, 0.05861721986822577, 0.07434960310167005, 0.09170216746669213, 0.12392461722312587, 0.1779704325023468, 0.1378659441740432, 0.12384920074623351, 0.12044572868336523, 0.10998672613589511, 0.11855725475084322, 0.1549398509299601, 0.1428511728262134, 0.14871422040102245, 0.12434853025599801, 0.15111283240063877, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09318253787326247, 0.09607343190258, 0.06565820339943496, 0.08314989914919602, 0.07265116080705125, 0.11532002676817554, 0.1324170024826854, 0.08320506383281567, 0.07721625129401333, 0.19139193192204973, 0.1733257749068653, 0.16903272610848596, 0.14228075003935448, 0.21598900588919567, 0.20522403130464484, 0.19022247928351843, 0.15770776472339854, 0.16153070142436377, 0.19300366031836813, 0.17357962444599306, 0.19293237569175226, 0.1715609282321513, 0.1636138913185028, 0.17429273279774993, 0.15779673804399352, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.929157386772123, 0.09116923447348202, 0.9759821871348519, 0.20272898253032767, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.1601612560368001, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.1765458644453276, 0.1897633957988495, 0.20022548331320444, 0.19076449291386188, 0.20842041219806628, 0.18463954761171741, 0.2180690208964411, 0.17565240614175037, 0.27889510785821003, 0.03610083713363599, 0.047825129912296704, 0.06362824025363445, 0.04465634239222871, 0.06843650474900065, 0.048423792700227564, 0.06374515616085463, 0.04483716800127746, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "6c3151f8-433c-477f-922d-47bde2b46e20", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by incorporating a novel chaotic search mechanism for dynamic boundary adjustment.", "configspace": "", "generation": 51, "fitness": 0.4726600796673726, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.39.", "error": "", "parent_id": "3a594bd2-0199-47f1-a388-9e42828a0752", "metadata": {"aucs": [0.9738917856915941, 0.9762225996465299, 0.9774294623288086, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8796927694359761, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09015903696628935, 0.03227343845969133, 0.07500716184575373, 0.06978384482377076, 0.05549214952078896, 0.04930159434022574, 0.05996950688778924, 0.09838032236235073, 0.09684353663056222, 0.03532291049711733, 0.03201305188537795, 0.08157296207305476, 0.02150366875235521, 0.06374232831876159, 0.14476414664802684, 0.07352264921009466, 0.049000558664788474, 0.9310254336128314, 0.9910678383636552, 0.9812076902114585, 0.9918541290385127, 0.9927039586937012, 0.9647207439624044, 0.9923572466542198, 0.9235428085513988, 0.9902239169942929, 0.619270634954072, 0.6028202368396789, 0.6747742409810099, 0.6267691761616738, 0.5645705206279542, 0.6434941956343235, 0.8580637056504867, 0.7195699138775088, 0.6728393860472084, 0.12804586625590242, 0.07854231614377638, 0.1425423528356523, 0.16545614300837974, 0.15320588837491922, 0.13022748269393136, 0.06776654370087998, 0.057827712556487665, 0.13291114538545956, 0.9596326194047496, 0.137729993626027, 0.9460118000582384, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.9281411096562586, 0.9376015111612703, 0.9392624669306767, 0.9276318050467657, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.891283070100805, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6682077264143982, 0.8712095814985141, 0.8351203121801377, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5581201082969615, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8351007359156524, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.03766902778147918, 0.02762181694690513, 0.03773925345876228, 0.07198950888817546, 0.011547186693992795, 0.1134767548700718, 0.026608850576457233, 0.08782461369889738, 0.07434960310167005, 0.0917021696576299, 0.09697463977560505, 0.17807625693678997, 0.2259466067829501, 0.12384921161670592, 0.1733088641303866, 0.10998672613589511, 0.15024281695670438, 0.09869620694679959, 0.18523463510224591, 0.14871422040102245, 0.13922146264011714, 0.161175555890953, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09086770330274141, 0.0661550437693148, 0.07448124838939618, 0.10275261989068296, 0.07245226567810337, 0.11532002676817554, 0.09103606864324998, 0.08320506383285298, 0.12029331037492652, 0.19139193192204973, 0.1528002964448678, 0.16903272610848596, 0.14228075003935448, 0.2388000833529904, 0.14052688120789847, 0.19022247928351843, 0.16335155572235505, 0.16153072065300844, 0.1795584138597487, 0.17357962442512775, 0.19293237569175226, 0.1715609281903222, 0.17980881380113856, 0.18661364754323673, 0.15779673808750272, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.9372858034745402, 0.09116923447348202, 0.9759821871348519, 0.2026674736064934, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.16016125603677023, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.18843672801775524, 0.18976439076290164, 0.20022417051410712, 0.1907655530600254, 0.2084147158894899, 0.18463954761171741, 0.2180648849494634, 0.17565243474189263, 0.27889510785821003, 0.03912992893708611, 0.047825124565507804, 0.06362824025363445, 0.09206840530785487, 0.06846720851640387, 0.048423792700227564, 0.06649206282565123, 0.047689402476603804, 0.0413988046414282]}, "mutation_prompt": null}
{"id": "6b523764-3f2e-4bb8-aeba-7e563a1bab25", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pitch_adjust_rate = 0.1\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(len(harmony_memory))])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, self.pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Adaptive rate adjustment for exploration and exploitation\n            self.pitch_adjust_rate = max(0.01, min(0.5, self.pitch_adjust_rate + 0.1 * (fitness_values.sum() - np.min(fitness_values) * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration and exploitation by incorporating a novel search mechanism for adaptive rate adjustment in harmony memory.", "configspace": "", "generation": 52, "fitness": 0.3491350875253059, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.905558798039144, 0.9097283530878677, 0.8947657668590397, 0.8866985722799866, 0.8800074872924318, 0.857643122475788, 0.898590614787498, 0.9067534039544206, 0.8987044146867802, 0.8127429341669691, 0.8278048428924921, 0.7996147913390134, 0.8139074934705061, 0.8145627440730789, 0.7983126784616382, 0.8276656145062637, 0.8072208395717886, 0.8018102534619621, 0.6117286361607689, 0.15355533604657978, 0.5195058108470805, 0.1764317849473217, 0.7209764675195635, 0.5745522615600935, 0.1824056721861158, 0.5637095935656864, 0.17460449674200695, 0.140382175919039, 0.1764044507415301, 0.15539219769707346, 0.14693061718328082, 0.15200303740040944, 0.12953036120720496, 0.1380385022668228, 0.12901432239151223, 0.27353420344554213, 0.9683858086170448, 0.9723072875491571, 0.9636407149428854, 0.9522505639563735, 0.9721744995193924, 0.970707776159684, 0.9702909853541674, 0.9493770893001837, 0.9554680346111576, 0.7340675222691109, 0.6545524331325244, 0.6566656710013966, 0.6943986981800759, 0.7162478493991435, 0.7062336649841487, 0.6036456675698116, 0.6639180566725933, 0.6219720071470658, 0.24350800926743477, 0.679213679196355, 0.2240803556979768, 0.36003166733772785, 0.36075160417206886, 0.8363341885365483, 0.18067407352555198, 0.7920428961261166, 0.7742395239529175, 0.2994578655552317, 0.229519581246042, 0.2345966784410055, 0.2570806248901034, 0.27347952204878145, 0.279974490356486, 0.19839998148042826, 0.23723147536772293, 0.20426541778023555, 0.19776769024291896, 0.2474689727660374, 0.25554139708469337, 0.22553132667311715, 0.16146471750821023, 0.24523472672696367, 0.21232152745425714, 0.21614049022151816, 0.1606108426133922, 0.0669385342158495, 0.08846578932541893, 0.13297274486903754, 0.015251131904983062, 0.03429705518662651, 0.01394511315721425, 0.06852814748276104, 0.01486065970901762, 0.03413068749733117, 0.08681669291982685, 0.11165726900508488, 0.11355846126540059, 0.10509334844383267, 0.03443065907792875, 0.05753827882728224, 0.11352897847135757, 0.11252588120899198, 0.22361961824294652, 0.1368637547123701, 0.07627632027442866, 0.11039927449985154, 0.060988769548727895, 0.05276779332576442, 0.08144129843260473, 0.1395712998973493, 0.10508646647544173, 0.03730621611756724, 0.216023424828246, 0.21672333232587937, 0.24797387064097542, 0.2551326445308226, 0.2888749200048133, 0.2810358884754395, 0.16663188672104046, 0.227447652848337, 0.19467961175669113, 0.607120761813461, 0.62552889154573, 0.6165132971503788, 0.5501035731302952, 0.6040364757489652, 0.6140272939989706, 0.5802220367360331, 0.6061132447774112, 0.549974561074507, 0.09890399725341215, 0.12306643480955337, 0.12840094703777927, 0.09752195417690313, 0.1456232463051369, 0.09382683761059163, 0.10741246252882464, 0.12297742337956608, 0.11744814510793877, 0.11552839333877529, 0.132996581161683, 0.23800896233338786, 0.29855384735668267, 0.18511670915155198, 0.17883413570153261, 0.18907681127308074, 0.1627774684654696, 0.1449646022447274, 0.3822119361329258, 0.3659775865322952, 0.3129901808789214, 0.33574673938915545, 0.3178272230019835, 0.34841613592289133, 0.2840456110984376, 0.3563448878080504, 0.3290766790453865, 0.28577649756332846, 0.28894236498485504, 0.24769976461216092, 0.19172110662383024, 0.275625123059858, 0.31666031364416813, 0.3016080782614651, 0.18850226995046337, 0.2354397871499817, 0.21130769837914287, 0.23363819380092132, 0.2088818306685133, 0.18209161026389387, 0.20776033068535726, 0.2092179927782366, 0.21834218173869302, 0.18303725311458363, 0.21335685617893052, 0.5253979073379758, 0.21924202942553062, 0.22106751010446024, 0.23971426314407318, 0.2370204840458039, 0.2063852307566486, 0.22209331828364043, 0.1957340142853622, 0.22267817996972972, 0.6402263674965619, 0.2319938295417907, 0.1844599980482301, 0.6524496501124454, 0.19853327032196288, 0.810385786341635, 0.6765219699736429, 0.15824166624012037, 0.8169827180427631, 0.47174586427576826, 0.6866573837651092, 0.26971700283365097, 0.20602979958434997, 0.3149042776047172, 0.21055805323156151, 0.11081959490306459, 0.20382286215733825, 0.4470800953860047, 0.17039126411004968, 0.18054045177396805, 0.18209228674884503, 0.17675912014621808, 0.17543780910482676, 0.19374977061473753, 0.17788948683565087, 0.18939554760770283, 0.1889833699708563, 0.08146188573245494, 0.09501660608949458, 0.0938105977392959, 0.115486667756874, 0.10782034789667594, 0.07985214427792364, 0.07856417360242907, 0.1033161126723311, 0.0777790209937198]}, "mutation_prompt": null}
{"id": "85ecf971-4849-4d30-b597-c2f4d20e75f5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor, crossover_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values, mutation_factor, crossover_rate):\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        mutation_factor = 0.5\n        crossover_rate = 0.9\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor, crossover_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values, mutation_factor, crossover_rate)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  \n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n            mutation_factor = max(0.1, min(0.9, mutation_factor + 0.1 * (best_fitness - fitness_values.mean())))\n            crossover_rate = max(0.1, min(0.9, crossover_rate + 0.1 * (best_fitness - fitness_values.mean())))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration and exploitation balance by introducing a dynamic adaptation of mutation factor and crossover rate in the differential evolution step.", "configspace": "", "generation": 53, "fitness": 0.45836531973140704, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.39.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9738917856915941, 0.9762225996465299, 0.9774294623288086, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8796927694359761, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9267287558160944, 0.9180814354938476, 0.08065579057655592, 0.10791021166662595, 0.05664403675743357, 0.04542744903856677, 0.06288388894236085, 0.03888534534539845, 0.04886840672077564, 0.05664686356474613, 0.09780300597668123, 0.10324626441331697, 0.011560858871230817, 0.033836519696243905, 0.08190198481122646, 0.023238976522287014, 0.044168122899420625, 0.028777317332524754, 0.033277273177112376, 0.026663316479943577, 0.9310254336128314, 0.9910678383636552, 0.9812076902114585, 0.9918541290385127, 0.9927039586937012, 0.9647207439624044, 0.9923572466542198, 0.9235428085513988, 0.9902239169942929, 0.6192476905066391, 0.5957422451021943, 0.6748877766884545, 0.6200002570559212, 0.5645705206279542, 0.5867263584908398, 0.8247169636391187, 0.6938556338239923, 0.6745658148198941, 0.12590187732012492, 0.059816212165233584, 0.09188102100526907, 0.06905269514931534, 0.037533280328782115, 0.07831901891487447, 0.04745477234459372, 0.038947633074936316, 0.16459810264982133, 0.9596326194047496, 0.137729993626027, 0.9460118000582384, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595937030534, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.9281411096562586, 0.9376015111612703, 0.9392624669306767, 0.9276318050467657, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.891283070100805, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.628147881983945, 0.8203633993632828, 0.6680225267395239, 0.8712095814985141, 0.8351203121801377, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5566235024679624, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8207384104689868, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.016909187043181784, 0.002690705025017115, 0.03773925366129438, 0.037397415724988226, 0.014409525490594155, 0.05246137606268697, 0.026163063728635305, 0.05058762757294899, 0.07434960310167005, 0.1499476440290458, 0.17762962037356467, 0.09694014957285912, 0.22585883214364944, 0.12384914808225933, 0.12044575825715165, 0.10998672613589511, 0.0817139031780274, 0.09869606978216183, 0.11804671085131757, 0.14740551977091565, 0.11750832923477106, 0.1872523100780793, 0.13666069340623943, 0.13121415987436236, 0.13912306635922156, 0.13790208319385333, 0.1294395195386202, 0.08042131887828186, 0.04535521399905407, 0.05693686202765824, 0.09494138627071247, 0.07025900238572669, 0.06959298681035286, 0.07086449458772404, 0.06253737386843072, 0.09526300549370914, 0.19139193192204973, 0.11636317299638721, 0.16903272610848596, 0.14228079686581163, 0.1354383098847759, 0.1390940488292699, 0.24979365078554772, 0.16335155572235505, 0.16153068256361114, 0.17317963213247445, 0.1735796233044421, 0.19293237569175226, 0.1715609233627372, 0.17980881251577707, 0.1866136460872112, 0.15779673782610004, 0.18039773025501016, 0.17660288688905934, 0.13745916194029906, 0.09630104781599946, 0.1987812109590691, 0.9759821871348519, 0.20266747364894022, 0.11489993631599404, 0.1602886507541723, 0.12741178944939424, 0.16016125580122098, 0.08347418595068323, 0.11335577983763634, 0.9647958345788371, 0.08347991445274816, 0.11300854239003588, 0.2148602793890364, 0.09483398077815941, 0.08284637396927663, 0.9716889255672222, 0.1765457737639341, 0.18976348084553396, 0.2002230490407274, 0.19076457363065658, 0.2084147158894899, 0.18463951640861198, 0.21806515468402587, 0.17565219428170753, 0.278895729162428, 0.04547584748908484, 0.04782512636438219, 0.06362823837587217, 0.04465633648281564, 0.06846720851640387, 0.048423792700227564, 0.028972095722843205, 0.047689402476603804, 0.04139880161356668]}, "mutation_prompt": null}
{"id": "c3fbef06-79d6-4e21-8254-8080e1662e96", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Optimizing pitch adjustment rate dynamically\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values)))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by incorporating a novel chaotic search mechanism for dynamic boundary adjustment while optimizing pitch adjustment rates dynamically.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 67, 9, '        best_index = np.argmin(fitness_values)\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 67, 9, '        best_index = np.argmin(fitness_values)\\n'))", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {}, "mutation_prompt": null}
{"id": "63c72c51-703d-42d6-b4da-cdc068d983fb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] += np.random.uniform(-1, 1) # Adaptive pitch adjustment\n                    new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Introducing a novel adaptive pitch adjustment mechanism to enhance exploration and improve convergence speed.", "configspace": "", "generation": 55, "fitness": 0.4708612275664012, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.39.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9738917856915941, 0.9762225996465299, 0.9774294623288086, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8796927694359761, 0.9085500234538825, 0.9503851223408467, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9266332709294354, 0.9180814354938476, 0.07219948584746505, 0.0738863827307481, 0.043016796260718415, 0.05335175636363909, 0.05023528952688672, 0.04987336950025201, 0.058474084179125585, 0.06464038238929082, 0.08574812957536271, 0.07711548137696067, 0.003921600724140828, 0.04941288860716708, 0.09501712559341413, 0.0260338014949566, 0.046501558349321015, 0.07702107006772585, 0.0025314762124615253, 0.015449456901989622, 0.9310254336128314, 0.9910678383636552, 0.9812076902114585, 0.9918541290385127, 0.9927039586937012, 0.9647207439624044, 0.9923572466542198, 0.9235428085513988, 0.9902239169942929, 0.6204933524562979, 0.6011233416414188, 0.6747742409810099, 0.427017733347826, 0.5677835608759112, 0.6411620944867289, 0.8138265158090583, 0.7447047136931526, 0.7046151743474064, 0.14400063277453423, 0.0950676119313637, 0.15055926305071898, 0.14351105809088516, 0.1655211426927541, 0.20424451507917007, 0.07748840455022177, 0.03481342092465034, 0.16338736847287816, 0.9596326194047496, 0.137729993626027, 0.9460118000582384, 0.9225210034041691, 0.9338938831742777, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.9281411096562586, 0.9376015111612703, 0.9392624669306767, 0.9276318050467657, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.891283070100805, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.6831780874855489, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6289211772294514, 0.8203633993632828, 0.6680225267395239, 0.8712095814985141, 0.8351203121801377, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7659128089171087, 0.9336204406156917, 0.5797425691853716, 0.6458998832030196, 0.6841822289120442, 0.8443785014027162, 0.8207384104689868, 0.7685571692485891, 0.7514918808940905, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9653547660482676, 0.9654309338839271, 0.9628411730222575, 0.016909187001910686, 0.02817216400923006, 0.037739253821876595, 0.07198950890453704, 0.04037454556643061, 0.05246137606268697, 0.040513420182704096, 0.05859758003598858, 0.07434960310167005, 0.15719634682436412, 0.11898878672166391, 0.07866556060932905, 0.22585537543075584, 0.12384923103480283, 0.12044580140961103, 0.10998672613589511, 0.15416450145702332, 0.09869620453218264, 0.1376776193734549, 0.1572039131804862, 0.11750832923477106, 0.13236099745971475, 0.12828045830929347, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.13896044854609702, 0.06383868353717703, 0.10448167905872141, 0.05693686202765824, 0.08314989914919602, 0.1318533642762617, 0.06959298681391446, 0.11626733180892657, 0.10431849777084568, 0.1014638911190997, 0.19139193192204973, 0.11636317299638721, 0.16903272610848596, 0.22577966430110374, 0.2388000833529904, 0.15906761769282407, 0.19022247928351843, 0.16335155572235505, 0.16153072076592268, 0.1855700317463661, 0.18511586810822, 0.19293237569175226, 0.17156092807041712, 0.17980881385534342, 0.1866136472475297, 0.1646547371782373, 0.18039773025501016, 0.17660288688905934, 0.1199143158014021, 0.07667141560017265, 0.948088823014083, 0.9759821871348519, 0.2026674736064934, 0.10915137387938445, 0.16028485276045645, 0.12741178944916087, 0.1601612560521668, 0.9337043297076998, 0.11335577983763634, 0.9647958345788371, 0.08347991445274816, 0.11300854239419511, 0.2148602793890364, 0.0949605186709066, 0.08284637397166139, 0.9716889255672222, 0.24770342649446075, 0.1897633957988495, 0.20022555101784978, 0.19076071496572622, 0.5150751146507982, 0.18463954761171741, 0.21463350981696472, 0.17565270684374956, 0.27889510785821003, 0.034385089982287176, 0.047825124565507804, 0.06362824025363445, 0.04465634430931298, 0.06846720851640387, 0.048423792700227564, 0.03844712678912088, 0.047689402476603804, 0.04139880378216676]}, "mutation_prompt": null}
{"id": "01f6c498-fb1f-4457-aa11-dcc60f0903b0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by incorporating a novel chaotic search mechanism for dynamic boundary adjustment.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9738917856915941, 0.9762225996465299, 0.9774294623288086, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8796927694359761, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09015903696628935, 0.03227343845969133, 0.07500716184575373, 0.06978384482377076, 0.05549214952078896, 0.04930159434022574, 0.05996950688778924, 0.09838032236235073, 0.09684353663056222, 0.03532291049711733, 0.03201305188537795, 0.08157296207305476, 0.02150366875235521, 0.06374232831876159, 0.14476414664802684, 0.07352264921009466, 0.049000558664788474, 0.9310254336128314, 0.9910678383636552, 0.9812076902114585, 0.9918541290385127, 0.9927039586937012, 0.9647207439624044, 0.9923572466542198, 0.9235428085513988, 0.9902239169942929, 0.619270634954072, 0.6028202368396789, 0.6747742409810099, 0.6267691761616738, 0.5645705206279542, 0.6434941956343235, 0.8580637056504867, 0.7195699138775088, 0.6728393860472084, 0.12804586625590242, 0.07854231614377638, 0.1425423528356523, 0.16545614300837974, 0.15320588837491922, 0.13022748269393136, 0.06776654370087998, 0.057827712556487665, 0.13291114538545956, 0.9596326194047496, 0.137729993626027, 0.9460118000582384, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.9281411096562586, 0.9376015111612703, 0.9392624669306767, 0.9276318050467657, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.891283070100805, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6682077264143982, 0.8712095814985141, 0.8351203121801377, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5581201082969615, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8351007359156524, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.03766902778147918, 0.02762181694690513, 0.03773925345876228, 0.07198950888817546, 0.011547186693992795, 0.1134767548700718, 0.026608850576457233, 0.08782461369889738, 0.07434960310167005, 0.0917021696576299, 0.09697463977560505, 0.17807625693678997, 0.2259466067829501, 0.12384921161670592, 0.1733088641303866, 0.10998672613589511, 0.15024281695670438, 0.09869620694679959, 0.18523463510224591, 0.14871422040102245, 0.13922146264011714, 0.161175555890953, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09086770330274141, 0.0661550437693148, 0.07448124838939618, 0.10275261989068296, 0.07245226567810337, 0.11532002676817554, 0.09103606864324998, 0.08320506383285298, 0.12029331037492652, 0.19139193192204973, 0.1528002964448678, 0.16903272610848596, 0.14228075003935448, 0.2388000833529904, 0.14052688120789847, 0.19022247928351843, 0.16335155572235505, 0.16153072065300844, 0.1795584138597487, 0.17357962442512775, 0.19293237569175226, 0.1715609281903222, 0.17980881380113856, 0.18661364754323673, 0.15779673808750272, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.9372858034745402, 0.09116923447348202, 0.9759821871348519, 0.2026674736064934, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.16016125603677023, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.18843672801775524, 0.18976439076290164, 0.20022417051410712, 0.1907655530600254, 0.2084147158894899, 0.18463954761171741, 0.2180648849494634, 0.17565243474189263, 0.27889510785821003, 0.03912992893708611, 0.047825124565507804, 0.06362824025363445, 0.09206840530785487, 0.06846720851640387, 0.048423792700227564, 0.06649206282565123, 0.047689402476603804, 0.0413988046414282]}, "mutation_prompt": null}
{"id": "44e8a01e-b156-4bdc-9656-afead52c506b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def adaptive_differential_evolution(harmony_memory, fitness_values, mutation_factor, crossover_rate):\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        mutation_factor = 0.5\n        crossover_rate = 0.9\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            adaptive_differential_evolution(harmony_memory, fitness_values, mutation_factor, crossover_rate)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving population diversity and exploration by implementing a dynamic mutation strategy based on adaptive differential evolution.", "configspace": "", "generation": 57, "fitness": 0.4726600796673726, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.39.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9738917856915941, 0.9762225996465299, 0.9774294623288086, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8796927694359761, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09015903696628935, 0.03227343845969133, 0.07500716184575373, 0.06978384482377076, 0.05549214952078896, 0.04930159434022574, 0.05996950688778924, 0.09838032236235073, 0.09684353663056222, 0.03532291049711733, 0.03201305188537795, 0.08157296207305476, 0.02150366875235521, 0.06374232831876159, 0.14476414664802684, 0.07352264921009466, 0.049000558664788474, 0.9310254336128314, 0.9910678383636552, 0.9812076902114585, 0.9918541290385127, 0.9927039586937012, 0.9647207439624044, 0.9923572466542198, 0.9235428085513988, 0.9902239169942929, 0.619270634954072, 0.6028202368396789, 0.6747742409810099, 0.6267691761616738, 0.5645705206279542, 0.6434941956343235, 0.8580637056504867, 0.7195699138775088, 0.6728393860472084, 0.12804586625590242, 0.07854231614377638, 0.1425423528356523, 0.16545614300837974, 0.15320588837491922, 0.13022748269393136, 0.06776654370087998, 0.057827712556487665, 0.13291114538545956, 0.9596326194047496, 0.137729993626027, 0.9460118000582384, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.9281411096562586, 0.9376015111612703, 0.9392624669306767, 0.9276318050467657, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.891283070100805, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6682077264143982, 0.8712095814985141, 0.8351203121801377, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5581201082969615, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8351007359156524, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.03766902778147918, 0.02762181694690513, 0.03773925345876228, 0.07198950888817546, 0.011547186693992795, 0.1134767548700718, 0.026608850576457233, 0.08782461369889738, 0.07434960310167005, 0.0917021696576299, 0.09697463977560505, 0.17807625693678997, 0.2259466067829501, 0.12384921161670592, 0.1733088641303866, 0.10998672613589511, 0.15024281695670438, 0.09869620694679959, 0.18523463510224591, 0.14871422040102245, 0.13922146264011714, 0.161175555890953, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09086770330274141, 0.0661550437693148, 0.07448124838939618, 0.10275261989068296, 0.07245226567810337, 0.11532002676817554, 0.09103606864324998, 0.08320506383285298, 0.12029331037492652, 0.19139193192204973, 0.1528002964448678, 0.16903272610848596, 0.14228075003935448, 0.2388000833529904, 0.14052688120789847, 0.19022247928351843, 0.16335155572235505, 0.16153072065300844, 0.1795584138597487, 0.17357962442512775, 0.19293237569175226, 0.1715609281903222, 0.17980881380113856, 0.18661364754323673, 0.15779673808750272, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.9372858034745402, 0.09116923447348202, 0.9759821871348519, 0.2026674736064934, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.16016125603677023, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.18843672801775524, 0.18976439076290164, 0.20022417051410712, 0.1907655530600254, 0.2084147158894899, 0.18463954761171741, 0.2180648849494634, 0.17565243474189263, 0.27889510785821003, 0.03912992893708611, 0.047825124565507804, 0.06362824025363445, 0.09206840530785487, 0.06846720851640387, 0.048423792700227564, 0.06649206282565123, 0.047689402476603804, 0.0413988046414282]}, "mutation_prompt": null}
{"id": "1798ae96-1cc9-4154-81c6-a9e1f8447e2b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by incorporating a novel chaotic search mechanism for dynamic boundary adjustment.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9738917856915941, 0.9762225996465299, 0.9774294623288086, 0.9819857218227465, 0.9691807043689608, 0.9643504398491269, 0.9683848792172001, 0.9834683475679484, 0.9810562941818454, 0.9133713045079022, 0.8796927694359761, 0.9085500234538825, 0.949780507863244, 0.9278355515687032, 0.9519031821294754, 0.93029627177076, 0.9271579037181066, 0.9180814354938476, 0.08064343544046881, 0.09015903696628935, 0.03227343845969133, 0.07500716184575373, 0.06978384482377076, 0.05549214952078896, 0.04930159434022574, 0.05996950688778924, 0.09838032236235073, 0.09684353663056222, 0.03532291049711733, 0.03201305188537795, 0.08157296207305476, 0.02150366875235521, 0.06374232831876159, 0.14476414664802684, 0.07352264921009466, 0.049000558664788474, 0.9310254336128314, 0.9910678383636552, 0.9812076902114585, 0.9918541290385127, 0.9927039586937012, 0.9647207439624044, 0.9923572466542198, 0.9235428085513988, 0.9902239169942929, 0.619270634954072, 0.6028202368396789, 0.6747742409810099, 0.6267691761616738, 0.5645705206279542, 0.6434941956343235, 0.8580637056504867, 0.7195699138775088, 0.6728393860472084, 0.12804586625590242, 0.07854231614377638, 0.1425423528356523, 0.16545614300837974, 0.15320588837491922, 0.13022748269393136, 0.06776654370087998, 0.057827712556487665, 0.13291114538545956, 0.9596326194047496, 0.137729993626027, 0.9460118000582384, 0.9225210034041691, 0.9082853125451057, 0.8965391273692024, 0.9695418512068351, 0.1382318366805303, 0.13915595938321335, 0.9592926053867377, 0.929947482491463, 0.9286368376353586, 0.935043758343196, 0.9281411096562586, 0.9376015111612703, 0.9392624669306767, 0.9276318050467657, 0.9258715673996443, 0.8638347060212708, 0.8445616466000138, 0.9304464428524956, 0.867356216450877, 0.8746597647400076, 0.891283070100805, 0.9134597790571801, 0.9177411287367072, 0.7402082146472572, 0.8749925559171037, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.6221881257063671, 0.8203633993632828, 0.6682077264143982, 0.8712095814985141, 0.8351203121801377, 0.8264821033361527, 0.8000453547348813, 0.7874123611685615, 0.87916176207461, 0.7567365588437198, 0.9336204406156917, 0.5581201082969615, 0.6458998832030196, 0.6841822289120442, 0.8296967726370701, 0.8351007359156524, 0.7685571692485891, 0.7230266130744463, 0.7445438852074575, 0.7950972423387109, 0.7803917588517075, 0.7615915041966432, 0.753413301054325, 0.9624540585342032, 0.9694663603966148, 0.9313330267280842, 0.9523840728660549, 0.9458141461108547, 0.9503725640667103, 0.9638269187261921, 0.9652672116087233, 0.9628411730222575, 0.03766902778147918, 0.02762181694690513, 0.03773925345876228, 0.07198950888817546, 0.011547186693992795, 0.1134767548700718, 0.026608850576457233, 0.08782461369889738, 0.07434960310167005, 0.0917021696576299, 0.09697463977560505, 0.17807625693678997, 0.2259466067829501, 0.12384921161670592, 0.1733088641303866, 0.10998672613589511, 0.15024281695670438, 0.09869620694679959, 0.18523463510224591, 0.14871422040102245, 0.13922146264011714, 0.161175555890953, 0.11985827438776941, 0.18151686070469364, 0.13912306635922156, 0.12605013838970536, 0.1294395195386202, 0.09086770330274141, 0.0661550437693148, 0.07448124838939618, 0.10275261989068296, 0.07245226567810337, 0.11532002676817554, 0.09103606864324998, 0.08320506383285298, 0.12029331037492652, 0.19139193192204973, 0.1528002964448678, 0.16903272610848596, 0.14228075003935448, 0.2388000833529904, 0.14052688120789847, 0.19022247928351843, 0.16335155572235505, 0.16153072065300844, 0.1795584138597487, 0.17357962442512775, 0.19293237569175226, 0.1715609281903222, 0.17980881380113856, 0.18661364754323673, 0.15779673808750272, 0.18039773025501016, 0.17660288688905934, 0.13745916195713448, 0.9372858034745402, 0.09116923447348202, 0.9759821871348519, 0.2026674736064934, 0.10915137387938445, 0.1602886507541723, 0.12741178944916087, 0.16016125603677023, 0.9214352895044573, 0.11335577983763634, 0.9647958345788371, 0.22274259958150833, 0.11300854239419511, 0.2148602793890364, 0.09483398082982963, 0.08284637396876493, 0.9716889255672222, 0.18843672801775524, 0.18976439076290164, 0.20022417051410712, 0.1907655530600254, 0.2084147158894899, 0.18463954761171741, 0.2180648849494634, 0.17565243474189263, 0.27889510785821003, 0.03912992893708611, 0.047825124565507804, 0.06362824025363445, 0.09206840530785487, 0.06846720851640387, 0.048423792700227564, 0.06649206282565123, 0.047689402476603804, 0.0413988046414282]}, "mutation_prompt": null}
{"id": "d1be67ad-15ef-4959-95f7-4a08312e01f6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.search_radius = 0.1\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + self.search_radius * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Adaptive search radius local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead',\n                                            options={'initial_simplex': np.array([harmony_memory[np.argmin(fitness_values)] + self.search_radius * np.random.standard_normal(self.dim) for _ in range(self.dim + 1)])}).x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving local search strategy by incorporating a novel adaptive search radius mechanism for enhanced exploitation.", "configspace": "", "generation": 59, "fitness": 0.44401653790672263, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.36.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9835242055859638, 0.978804318728242, 0.9781415926701056, 0.9773386636929412, 0.9711621697220212, 0.9565788945278332, 0.9774808781778641, 0.9792919738932826, 0.9688576211104573, 0.7567939953696063, 0.9215236070531828, 0.8768307726867678, 0.8242422539853539, 0.9183763513400796, 0.8798148659084725, 0.9149345778692596, 0.9280472952586794, 0.9095368726108353, 0.08135422974802664, 0.12943557026583108, 0.07154697431288459, 0.0683283181816351, 0.0675515681230261, 0.07014362750999004, 0.07988007431300503, 0.0860707377036628, 0.09286750612733563, 0.07606421671004426, 0.02319947680475487, 0.040787355933632585, 0.0693681077647631, 0.054058243871180855, 0.06778221837994114, 0.03447540073045807, 0.044186508632816146, 0.017882030456533138, 0.9941031470636752, 0.9883310738663353, 0.9938096440182053, 0.9857330019979851, 0.9933560766596939, 0.9826416639362866, 0.9900165814530296, 0.9902265190220984, 0.9039221350208979, 0.7100534151941204, 0.6207452354303271, 0.5605597851849149, 0.6557755989647303, 0.6069169385410351, 0.5873124253180494, 0.6307980002192999, 0.715607025824567, 0.5436449259292034, 0.2114542371951591, 0.1213408872776226, 0.1696190797280036, 0.15477324295813455, 0.18605595936397434, 0.15797712442233824, 0.1708011834747305, 0.08442307407512384, 0.23546614478058503, 0.9478363830573489, 0.9502595608021088, 0.9283781728239275, 0.9036288517066763, 0.13886641980535042, 0.886634557181826, 0.9591095664159788, 0.9416441338833349, 0.13895543289809553, 0.9593632096497837, 0.943504658249668, 0.9253573793475569, 0.9475632697620051, 0.13900579300993599, 0.9628573345906208, 0.9567212927332467, 0.9222846063168662, 0.9338389934583358, 0.910811837623214, 0.9142401869846102, 0.7390115664473276, 0.818841944667472, 0.8932110461644197, 0.8806457080848404, 0.924732921943775, 0.9164117924432671, 0.8775802539949924, 0.5754776970209865, 0.5426983101305278, 0.5859563988170657, 0.7784802350862939, 0.6853753039480276, 0.43131920736779095, 0.48280752668663685, 0.39775846117157454, 0.49423592813493256, 0.5399871667418483, 0.42703447225429414, 0.512036491776621, 0.5062039227489625, 0.7282462260095031, 0.5659138473816554, 0.3191730286860346, 0.39605655063009526, 0.49085447592403253, 0.3498170252757975, 0.6794964241517651, 0.529693330652657, 0.6403077742954599, 0.4547975715754614, 0.41162753888726045, 0.48608886866101375, 0.2789927233059354, 0.3592021267576263, 0.9529424790826102, 0.9694830696058844, 0.9695174162879843, 0.9298608384427987, 0.9521585246363242, 0.9643387015206157, 0.9698487350300005, 0.9498155835488219, 0.9518197864900481, 0.03313870261388807, 0.04353359790347622, 0.04667394100252309, 0.0348621549134317, 0.017161646164285393, 0.09381736932078055, 0.0338647087195828, 0.06461040485275249, 0.07431923712559896, 0.1895661512702581, 0.28778856918219553, 0.22926668835509512, 0.40174816573884586, 0.14500393478629736, 0.2431386039034218, 0.2771222473972531, 0.19622926576903088, 0.14576034168114893, 0.1374993897990242, 0.3241383723423893, 0.12493772629954458, 0.17432815588168415, 0.14334354887465184, 0.22175079741275217, 0.18675576290969353, 0.16936507492321284, 0.1294340328631166, 0.05594914471636725, 0.07787982115433167, 0.07188000019330354, 0.09094072831957034, 0.0900865480807661, 0.1313452652541377, 0.08915601239063531, 0.12821989899232944, 0.12376031538179466, 0.2374662937141111, 0.17954977995731114, 0.24286056495732933, 0.19710146311339316, 0.17319347922278816, 0.17052253275328055, 0.25799068380757617, 0.2150747139253637, 0.2019096016434131, 0.18599035168546896, 0.18473056516816344, 0.218829617913179, 0.17220792766823212, 0.17218133675435787, 0.18141247967558105, 0.17679810045493527, 0.2093975857919007, 0.21300225987323362, 0.13720701327962814, 0.9202867862786813, 0.16994307994873614, 0.17392244760257958, 0.20246291371342173, 0.11011221266785365, 0.16004840771355755, 0.11528266623718586, 0.16005787638864144, 0.927114467459684, 0.1135052350835174, 0.9794386556631117, 0.08331838465258734, 0.11336150753326235, 0.2134854726229639, 0.09515540079050189, 0.1411165698543262, 0.9729342022651337, 0.24202102227567324, 0.29248602922212097, 0.21797245195034343, 0.2640323132080763, 0.23868437515969454, 0.2594447704746876, 0.43055895484998397, 0.25646436465945033, 0.2711055533281307, 0.04910768588429293, 0.06735321503831404, 0.07814548502195229, 0.06463380134147212, 0.09816251488673677, 0.08038175405407433, 0.044210789264990336, 0.05472571068513121, 0.0482845867706726]}, "mutation_prompt": null}
{"id": "aa38b3d4-da50-4a82-9400-3727291cfc8b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def levy_flight_mutation(base_harmony):\n            levy_alpha = 1.5\n            levy_beta = 0.5\n            levy = levy_alpha * np.random.standard_cauchy(self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / levy_beta))\n            mutated_harmony = base_harmony + 0.1 * levy\n            return np.clip(mutated_harmony, self.lower_bound, self.upper_bound)\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Levy flight mutation for enhanced exploration\n            levy_harmony = levy_flight_mutation(harmony_memory[np.argmin(fitness_values)])\n            levy_fitness = func(levy_harmony)\n            if levy_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = levy_harmony\n                fitness_values[index] = levy_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence by introducing a novel mutation strategy based on Levy flights for enhanced exploration.", "configspace": "", "generation": 60, "fitness": 0.3166231074453314, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9087794562221326, 0.9052809808943294, 0.9167459771757688, 0.8843288492286957, 0.9012216505520457, 0.898211979312421, 0.8910416718109712, 0.8924764951961605, 0.8950485817605586, 0.7832323873092526, 0.7719228585910104, 0.8091214393001336, 0.8079579467505271, 0.7735631689087268, 0.8089159056658705, 0.7900115467095876, 0.8011203661883683, 0.8030675502457837, 0.1311186292288683, 0.5306132528660775, 0.15651649400478185, 0.18974730530978778, 0.1260295896845668, 0.1443581100888357, 0.15487081710872264, 0.11919333674909827, 0.14642438098101773, 0.14561696436335037, 0.1120482838468626, 0.10970200521546991, 0.15235801799549464, 0.11416835883291387, 0.1509866713961916, 0.11640215078663874, 0.17732870503287468, 0.11325126987386647, 0.9702299427987718, 0.9638592071319514, 0.9849858024984064, 0.9677197822794767, 0.9557171564454767, 0.9777862581887943, 0.9560454312673304, 0.9762340576347337, 0.9819779756034867, 0.6100420324520583, 0.46588550342815105, 0.5236778184495027, 0.6044347668198327, 0.62201486064802, 0.6271814965477984, 0.26798654367593944, 0.484886842543795, 0.3610305896765399, 0.1989194460721011, 0.14169789757361373, 0.15455896953188586, 0.3557489095371411, 0.1854299034941036, 0.22067503413633416, 0.23579337900975683, 0.14340478530594591, 0.17945668702441708, 0.32764643603420796, 0.6369573768776093, 0.18835621109976264, 0.44342390634173967, 0.48065989569128764, 0.3786073163283068, 0.22765360717081928, 0.2624951098435627, 0.22763025056599873, 0.13499756693797604, 0.13574307407780384, 0.13043091557745468, 0.16457880539463965, 0.24060771708524376, 0.29067959988951086, 0.23116011405873205, 0.19124558642187617, 0.20665414899737822, 9.999999999998899e-05, 0.007140234080151631, 9.999999999998899e-05, 0.0033076429506001537, 0.08452064596319142, 0.16374710002466364, 0.02204479529936576, 0.10426854092385729, 0.007756452925273827, 0.1230433622784678, 0.02931159965147767, 0.15553636155131367, 0.10826244017763453, 0.09884551848906209, 0.010216517264734049, 0.13496510813027307, 0.05645801228483127, 0.15244410246114026, 0.15192160236480978, 0.049313685763410886, 0.1472358650922082, 0.11511345219041136, 0.2070946587490563, 0.12886020814722143, 0.09730393755146816, 0.12842402174246303, 0.07406751532966394, 0.26056488811201195, 0.17598672032824292, 0.18158495008531184, 0.1591861116779706, 0.18802026000096161, 0.25697392962277343, 0.0984566863509686, 0.15604546688436216, 0.19072877755928153, 0.6089352631521048, 0.6281993945196092, 0.5924904548739851, 0.5699828792243136, 0.547305856707073, 0.5061345934278723, 0.5811546192683053, 0.5693230006686597, 0.6266108925796198, 0.08269136230460916, 0.11612707630234076, 0.09413832233156338, 0.11561656152439859, 0.09286969834236292, 0.12459612323289293, 0.09293292499878703, 0.13506661045746438, 0.1190311142452003, 0.23464864174441669, 0.6300113290251839, 0.20633385705301288, 0.3139669275373864, 0.1733026899457265, 0.22233569147541554, 0.3053346958163238, 0.16761493574456543, 0.4172648470294664, 0.23240115272677853, 0.29526287080242175, 0.4382877318203843, 0.2927468248071272, 0.2762060714972965, 0.37038626940593034, 0.212813707662575, 0.38662720098919723, 0.18615495927175707, 0.22083108071595237, 0.29103416215724753, 0.25299296523508397, 0.2700285929143351, 0.31801428691826117, 0.3042216723170481, 0.18689297321290488, 0.2106993755168921, 0.22304433738290708, 0.2128811602126991, 0.22851613914534585, 0.22150152331865314, 0.2072197051831245, 0.20007532721670185, 0.4875420339360488, 0.2094138950137483, 0.20649668570115953, 0.2865005962078381, 0.22628613462866154, 0.2558079669491493, 0.19429058463873905, 0.2526607286124821, 0.22407278813142717, 0.20088948931943118, 0.24900002150415546, 0.2154046343191146, 0.19196887807872776, 0.18691767940478443, 0.2203951552869331, 0.15835968652501742, 0.7659133637579343, 0.2000047491612077, 0.15227047868825905, 0.158893032763044, 0.24421654283133132, 0.1767798979445222, 0.8025560824343582, 0.5840432920704933, 0.20941616009642883, 0.20392422004111477, 0.21291734199954682, 0.21313872016655255, 0.09472925035403001, 0.1402841786026544, 0.6744163142361888, 0.1953126169361148, 0.21455617668700477, 0.1842774243801275, 0.21338812540246477, 0.18715178788282716, 0.18127405666817642, 0.1904662552850621, 0.19714005255756595, 0.1889744532245352, 0.10399918814692377, 0.10017647539789831, 0.12281762599756019, 0.12053205629512742, 0.09643370326550627, 0.10075931628028867, 0.12940095524068407, 0.0870565516538021, 0.0858603041558712]}, "mutation_prompt": null}
{"id": "1498075a-5377-4f49-8b9a-20ba68becb00", "solution": "import numpy as np\n\nclass EnhancedDynamicBoundaryMultiSwarmPSOOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_swarms = 5\n\n    def __call__(self, func):\n        def initialize_swarm():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def update_swarm_position(swarm, swarm_best, global_best):\n            inertia_weight = 0.5\n            cognitive_weight = 1.5\n            social_weight = 1.5\n            velocity = np.zeros(self.dim)\n            for i in range(self.dim):\n                cognitive_component = cognitive_weight * np.random.rand() * (swarm_best[i] - swarm[i])\n                social_component = social_weight * np.random.rand() * (global_best[i] - swarm[i])\n                velocity[i] = inertia_weight * velocity[i] + cognitive_component + social_component\n                swarm[i] = np.clip(swarm[i] + velocity[i], self.lower_bound, self.upper_bound)\n\n        swarm_size = 10\n        swarms = [np.array([initialize_swarm() for _ in range(swarm_size)]) for _ in range(self.num_swarms)]\n        swarm_bests = [swarm[np.argmin([func(p) for p in swarm])] for swarm in swarms]\n        global_best = min(swarm_bests, key=func)\n\n        for _ in range(self.budget - self.num_swarms * swarm_size):\n            for i in range(self.num_swarms):\n                for j in range(swarm_size):\n                    update_swarm_position(swarms[i][j], swarm_bests[i], global_best)\n                    if func(swarms[i][j]) < func(swarm_bests[i]):\n                        swarm_bests[i] = swarms[i][j]\n                        if func(swarms[i][j]) < func(global_best):\n                            global_best = swarms[i][j]\n\n        return global_best", "name": "EnhancedDynamicBoundaryMultiSwarmPSOOptimizer", "description": "Improving exploration and exploitation balance by introducing a multi-swarm particle swarm optimization approach with dynamic swarm size adaptation.", "configspace": "", "generation": 61, "fitness": 0.25438237922529167, "feedback": "The algorithm EnhancedDynamicBoundaryMultiSwarmPSOOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.26.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.8835586293006295, 0.86956763413002, 0.8778123347384146, 0.8727533046664756, 0.15707507861770686, 0.8718107071910048, 0.8580603246531264, 0.8663747632097025, 0.8777896569747512, 9.999999999998899e-05, 0.0422308817004583, 0.7540843383686133, 0.7433777574723142, 0.7594074478388572, 0.755418697483839, 0.663742119547456, 0.05875778645132601, 0.7341685894886638, 0.13969836354045817, 0.06028231482322843, 0.143730760105248, 0.15709148704093645, 0.13065421747467465, 0.18302786870850707, 0.06056971494336538, 0.08844838919162357, 0.05496500338878507, 0.1270469369638173, 0.10368179587673565, 0.051190843519062, 0.0940996893954622, 0.09849581901964999, 0.11253443522528561, 0.09522829606847649, 0.08557159368979705, 0.09354598644489365, 0.9912237892435731, 0.9861684669168789, 0.9934659971550427, 0.9900741183673694, 0.9907008491466518, 0.9829367725247431, 0.9890112133776869, 0.9902762987962463, 0.9821582037133162, 0.7516675920671919, 0.7425869307897222, 0.05895999104679939, 0.682725197205746, 0.15009956342994957, 0.15338766357686473, 0.08816367823523685, 0.7058970388089032, 0.08879327016514105, 0.18708196900615925, 0.17008433224141994, 0.24069220316901307, 0.19194530275402288, 0.11412763372597656, 0.20804666585748155, 0.3540848664974514, 0.12614725935953064, 0.10233932112508937, 0.22148952282404621, 0.17621782809027975, 0.22823758797089833, 0.10821182552220221, 0.131213674900292, 0.13137181574932832, 0.22720072161442117, 9.999999999998899e-05, 0.23196537187588762, 0.23179278430653172, 0.21782150477870343, 0.2200805753708398, 0.248868321795774, 0.2342388411435511, 0.13218875084822324, 0.22339556293227614, 0.22593524485610517, 9.999999999998899e-05, 0.005513168018418724, 9.999999999998899e-05, 9.999999999998899e-05, 0.032236071029148716, 9.999999999998899e-05, 9.999999999998899e-05, 0.06400431901967463, 0.049995932366974194, 9.999999999998899e-05, 0.04983794084368909, 0.043400891290378385, 0.04406498500265499, 0.0724116290984641, 0.07942187045369264, 0.019894023510105607, 0.012328400442224274, 0.06701938678276786, 0.02705140846114895, 0.11085225181825831, 0.049054935983830594, 0.04963496738356721, 0.14795755254610798, 0.07710269189562946, 0.21546043708110374, 0.15245688935407342, 0.10096904312323818, 0.07256919640063808, 0.19887625383556828, 9.999999999998899e-05, 0.05799488319338819, 0.1676769322732422, 0.04001439001041618, 0.01729982069017244, 0.08050332582058417, 0.048140241576546394, 0.08278945795899295, 0.5179259996900963, 0.5697705032538376, 0.5361632672333414, 0.5264540106524039, 0.18174759500346094, 0.5742972073684174, 0.5551559530765158, 0.5406414874078305, 0.6229304930146288, 0.0563744018344321, 0.07083844698134034, 0.088458626989665, 0.11333385494958748, 0.06319505090720068, 0.12222242411770601, 0.061290111473405906, 0.06865492584869748, 0.06290970932974105, 0.16158789376868699, 0.2668407894180973, 0.17232862764032275, 0.2537997960026651, 0.2626355012718171, 0.1905355881892309, 0.20666934461593622, 0.2047914992626847, 0.22449308062206264, 0.23321731320956307, 0.15549995265811833, 0.2953960682715976, 0.5525494997301537, 0.28997606884655747, 0.3436705584711306, 0.1886291196948071, 0.3339857587938838, 0.18312229411469694, 0.23350746611743167, 0.17227850449552684, 0.19732653752861284, 0.24699612333488707, 0.1507613655183535, 0.2111465721792407, 0.18132644646870633, 0.27499517064308565, 0.16647323128887725, 0.20358852028241758, 0.1506719471273782, 0.2045542595012354, 0.1495985514383994, 0.24908663722910573, 0.1633890247060279, 0.25985530839728144, 0.23480153990358754, 0.2551900375148516, 0.22289892731419358, 0.19387775084100922, 0.19092039769318325, 0.20926126303904802, 0.18665587866096833, 0.2494881379602083, 0.25242002181741885, 0.20353155724834526, 0.18488140671242204, 0.18098130117261457, 0.10893807127088329, 0.15348356023616794, 0.9142315907773058, 0.19996782618901676, 0.19928185458568304, 0.14220804157477374, 0.16395558802827692, 0.14153037106425526, 0.632252016468551, 0.21242145749539754, 0.07348093402895062, 0.10372356738083033, 0.20839004014964435, 0.15430369510457587, 0.0936695673584299, 0.10452245709385333, 0.12947101766458147, 0.2122163691998421, 0.1511465032114273, 0.2042965246379741, 0.18260568968079338, 0.2669657124666007, 0.19468396098245966, 0.20311983617544338, 0.23399228957652152, 0.2706847767026894, 0.08437261423605835, 0.07272065834130115, 0.07453583988632506, 0.04719595387119768, 0.0902498197486995, 0.0892895273782659, 0.08496613775663753, 0.07850534825194444, 0.07029499683827001]}, "mutation_prompt": null}
{"id": "d1fc1c8f-3534-405e-acb2-e1922500a085", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = 0.5\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            # Enhanced dynamic boundary adjustment using chaos\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)  # Applying boundary check\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            # Local search using Nelder-Mead method\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            # Opposition-based learning for solution enhancement\n            opposition_harmony = self.lower_bound + self.upper_bound - harmony_memory\n            opposition_fitness = func(opposition_harmony)\n            if opposition_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = opposition_harmony\n                fitness_values[index] = opposition_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving exploration and exploitation balance by incorporating a novel opposition-based learning mechanism for solution refinement.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {}, "mutation_prompt": null}
{"id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 63, "fitness": 0.47881467238685516, "feedback": "The algorithm ImprovedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.39.", "error": "", "parent_id": "6c3151f8-433c-477f-922d-47bde2b46e20", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "a0d3497e-4d2f-431b-a09b-096a160034a7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "d95783c1-ce5d-488d-893d-2b96a2e0ff0c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factors):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] += mutation_factors[i] * np.random.uniform(-1, 1)\n                    new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values, mutation_factors):\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factors[i] * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        mutation_factors = np.random.uniform(0.001, 0.1, self.dim)\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factors)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values, mutation_factors)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n            mutation_factors = np.clip(mutation_factors * (1 + 0.01 * (fitness_values - best_fitness)), 0.001, 0.1)\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing algorithm diversity by introducing a dynamic mutation strategy based on individual fitness.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 5 is out of bounds for axis 0 with size 5').", "error": "IndexError('index 5 is out of bounds for axis 0 with size 5')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {}, "mutation_prompt": null}
{"id": "af29a7c9-3128-4d5c-8c82-37fa0f3c8ca2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, global_best, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        global_best = harmony_memory[np.argmin(fitness_values)]\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, global_best, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n            global_best = harmony_memory[np.argmin(fitness_values)]\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a global best memory for better solution exploitation.", "configspace": "", "generation": 66, "fitness": 0.47881467238685516, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.39.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "388a17c3-5e50-413c-a272-073f281385aa", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "e2206a5a-34c3-4778-9342-976563934d8a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + 0.1 * np.random.standard_normal(self.dim)  # Introducing chaotic search\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a chaotic search mechanism to diversify the population.", "configspace": "", "generation": 68, "fitness": 0.4773097836021591, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.39.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9762383970915357, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.08166230459300317, 0.05804475990271407, 0.07300900372637587, 0.0628152491305527, 0.08218379380863394, 0.07892837764300453, 0.06684663440769234, 0.07448549148193595, 0.05062540189477749, 0.07077009967734282, 0.038251710934612326, 0.019197991652327606, 0.08653768226191227, 0.017106154352160008, 0.025080261524059955, 0.02040947772917656, 0.06866132412211612, 0.01814670522186168, 0.9552988576963667, 0.8829917862453015, 0.9893171488156962, 0.9922683777199423, 0.990855029120333, 0.9317806454590759, 0.9926139801636096, 0.9893248790617548, 0.9901031912100832, 0.44806853131615376, 0.5974942329409254, 0.7046483468776928, 0.46082873748588105, 0.5645705206279542, 0.5824546388860861, 0.5864505077791697, 0.7465488897255647, 0.700465182414346, 0.16089887610909626, 0.04826247060846722, 0.10952404406037075, 0.16471807041830266, 0.060168879613038184, 0.08156427710174652, 0.08750638423528856, 0.12478963744859906, 0.1336965458157663, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.1369813171432297, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6549637931253247, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8207384104689868, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7794642195195072, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.04302842088213876, 0.04000373492975362, 0.006900434608598349, 0.023908169210314245, 0.04104832580898876, 0.05246137606268697, 0.09560795855401616, 0.0163739378688047, 0.07434960310167005, 0.11497519764528152, 0.15472886618885895, 0.13872295473997442, 0.22585946916551192, 0.12885704211784632, 0.22612935439626825, 0.10953204029188635, 0.20963014315269735, 0.09869618912417244, 0.14966134348467952, 0.16999985493875924, 0.12925282822308382, 0.13236099745971475, 0.13676755076937663, 0.13773125102220585, 0.1484766995429866, 0.1477683345162395, 0.14246580740897774, 0.0917571777246885, 0.08500917707788413, 0.10196525183769067, 0.13776317141335148, 0.0846728230971936, 0.10377041495762174, 0.09207954286760811, 0.09148002070030725, 0.05715999133976035, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.12022667341253601, 0.1497610133300954, 0.19022247928351843, 0.11984930067445443, 0.16153068256361114, 0.1731796329867129, 0.19970425590516994, 0.19293237569175226, 0.18471993251352814, 0.1704295710885222, 0.1767800450888113, 0.15779673788658277, 0.18039773025501016, 0.16728912426783515, 0.11991431578873757, 0.1784334458747875, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944927234, 0.16016457086002955, 0.15766962177675414, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8255834420646704, 0.2148602793890364, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976357495126417, 0.20022448579104635, 0.21246758137503552, 0.2084147158894899, 0.18463951640861198, 0.20545382567373116, 0.17565250752170947, 0.27890287235142575, 0.04165909576535454, 0.047825124565507804, 0.06362823989879685, 0.04536329961700225, 0.05260880498048737, 0.05973558424653058, 0.03140679355679987, 0.06054607488499364, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "24be031e-e2b3-4d22-80a2-6c5f2b80b089", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def select_crowded_harmony(harmony_memory, fitness_values, num_select):\n            sorted_indices = np.argsort(fitness_values)\n            return harmony_memory[sorted_indices[:num_select]], fitness_values[sorted_indices[:num_select]]\n\n        def mutate_harmony(harmony, mutation_rate):\n            mutated_harmony = np.copy(harmony)\n            for i in range(self.dim):\n                if np.random.rand() < mutation_rate:\n                    mutated_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            return mutated_harmony\n\n        harmony_memory_size = 10\n        mutation_rate = 0.5\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = mutate_harmony(harmony_memory[np.random.randint(harmony_memory_size)], mutation_rate)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n\n            selected_harmonies, selected_fitness = select_crowded_harmony(harmony_memory, fitness_values, harmony_memory_size // 2)\n\n            for i in range(harmony_memory_size):\n                base, target = selected_harmonies[i % (harmony_memory_size // 2)], selected_harmonies[i]\n                donor = base + np.random.uniform() * (target - selected_harmonies[np.random.choice(harmony_memory_size // 2)])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < 0.9:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < selected_fitness[i % (harmony_memory_size // 2)]:\n                    selected_harmonies[i % (harmony_memory_size // 2)] = trial\n                    selected_fitness[i % (harmony_memory_size // 2)] = trial_fitness\n\n            harmony_memory[:harmony_memory_size // 2] = selected_harmonies\n            fitness_values[:harmony_memory_size // 2] = selected_fitness\n\n            best_index = np.argmin(fitness_values)\n            best_harmony = harmony_memory[best_index]\n\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - func(best_harmony) * len(fitness_values))))\n\n        return best_harmony", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing diversity through a novel crowding-based selection mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 5 is out of bounds for axis 0 with size 5').", "error": "IndexError('index 5 is out of bounds for axis 0 with size 5')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {}, "mutation_prompt": null}
{"id": "206fff73-eefb-402a-8f07-175210942d82", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "f7e91373-e1ae-4fde-84ba-9fb0fcb543a3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "cf00b946-a9bb-4b6d-a0b9-b884d402a596", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicMutationHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:  # Dynamic Mutation Factor Update\n                    mutation_factor = 0.1 + 0.8 * np.exp(-0.01 * mutation_factor)\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicMutationHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a dynamic mutation factor based on fitness evaluations.", "configspace": "", "generation": 72, "fitness": 0.4766464386457802, "feedback": "The algorithm DynamicMutationHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.39.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.0643089145219854, 0.03303645936826616, 0.03802647093559153, 0.08986746110788957, 0.08218379382839791, 0.01324776373914649, 0.0658329387343285, 0.07448549148193595, 0.04220301935274606, 0.08183862780531581, 0.004606059565490206, 0.022578639751658525, 0.06760340379095264, 0.020162502852006048, 0.018123417969310496, 0.034925513449593715, 0.07813560840478218, 0.004026888901660253, 0.9552988576963667, 0.8829917862453015, 0.9887535711152688, 0.9922683777199423, 0.9900782840015994, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7694508931550176, 0.7183089545955903, 0.24875762045775518, 0.5923802126384488, 0.6399580271012794, 0.6060125904630765, 0.6997240785835788, 0.6749074973026108, 0.12535359565213766, 0.05578404748987631, 0.09800043926384061, 0.11178390948959804, 0.06813642470980918, 0.03547082004821345, 0.1145816566117619, 0.1703939100649886, 0.22533729120935342, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6558033345017316, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6469270596836949, 0.6952824748870581, 0.8417285553049376, 0.8227909342341688, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.06846532075726697, 0.004289876666636494, 0.023908169210314245, 0.04152586498475008, 0.05246137606268697, 0.09560795821750712, 0.016373937648767933, 0.07434960310167005, 0.09170216809691323, 0.17790420985814404, 0.12456288269203264, 0.22585996527177032, 0.2371964121251543, 0.17311426013675335, 0.10955357200180638, 0.0940409636416425, 0.10042711117330838, 0.1724292796462491, 0.12846595144614026, 0.12925282822308382, 0.13236099745971475, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14523241528153663, 0.1303647570893265, 0.08394075359863706, 0.15659381367527514, 0.09053121415571364, 0.11705460469454498, 0.08706733762118568, 0.09845111508427984, 0.07086449458772404, 0.09735575253533912, 0.07822452436874938, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.15513393252919927, 0.16153072247931233, 0.17317963213247445, 0.19970425603153186, 0.19293237569175226, 0.1847199326237654, 0.18974517945503977, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577972966, 0.11826715749417649, 0.9829313241908405, 0.9776356523484185, 0.20266747369464455, 0.10915137387938445, 0.9886957914355664, 0.12741178945424914, 0.16016457082619107, 0.15766962178636168, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.16322888124570722, 0.21486027951930542, 0.1691775051282084, 0.08284637397127514, 0.9716889255672222, 0.28643533328840753, 0.1897647060582065, 0.20022536020959714, 0.212474636411912, 0.2084147158894899, 0.18463951640861198, 0.20545193914525184, 0.17565212997633795, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.05973558299064041, 0.031406794843936714, 0.06640816195460597, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "e6b62741-c9c4-4b65-94ef-aa07a86baf69", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "4e179202-78c1-44c3-8ece-87c50395f990", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            global_best_harmony = harmony_memory[np.argmin(fitness_values)]\n            global_best_fitness = func(global_best_harmony)\n            for i in range(len(harmony_memory)):\n                if i != np.argmin(fitness_values):\n                    harmony_memory[i] = 0.3 * global_best_harmony + 0.7 * harmony_memory[i]\n                    fitness_values[i] = func(harmony_memory[i])\n\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - global_best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a chaotic perturbation and global-best update mechanism during the optimization process.", "configspace": "", "generation": 74, "fitness": 0.15059649705060407, "feedback": "The algorithm EnhancedHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.11.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.46373155233430474, 0.5241582922783855, 0.4260487767009624, 0.34781148253241667, 0.39481780024660174, 0.35116581804993763, 0.40923173938851143, 0.40516425912723275, 0.3745389959342731, 0.04874145140731978, 0.06750526617000618, 0.04890433575242592, 0.04381767783485413, 0.04571252855480956, 0.028390807471560975, 0.000685539518254008, 0.005745833401875844, 9.999999999998899e-05, 0.051688931000331784, 0.11498435734316914, 0.0732430650288447, 0.11613546171787581, 0.07306614034562409, 0.061833215351229986, 0.0782620207338165, 0.07227847263996157, 0.06358452168914241, 0.034950303123692184, 0.057369533678363394, 0.039631586690776044, 0.08356882142165378, 0.049236493115747515, 0.055615982923961416, 0.07386284291535139, 0.0796999793097426, 0.02456062931840275, 0.14308035109685802, 0.13869409580515568, 0.5376805615091685, 0.1527580847777823, 0.10247404881515376, 0.14533286409727775, 0.14673687699227433, 0.10393212569256305, 0.24047859243808745, 0.22206670703482678, 0.16489615981621542, 0.15529165647632603, 0.23387504246013302, 0.20116450131938435, 0.19848685985798276, 0.25198773224944004, 0.1355881200133242, 0.08047773830170557, 0.18344766687710012, 0.11260115673608684, 0.16381396444415353, 0.16884449345254893, 0.0808154790692357, 0.065839735072596, 0.1293742344040445, 0.22547533878164272, 0.14978627223428198, 0.21894281264431115, 0.1942539430396304, 0.21094415326047178, 0.06651128903550108, 0.18996896378214467, 0.08970561602024174, 0.1522827138624594, 0.12644843162042885, 0.12509770704992784, 0.19654557948192952, 0.12893186762508357, 0.12033680908083189, 0.1351127532525792, 0.15009586202174285, 0.1787577634160663, 0.1395881386668616, 0.17473815528653325, 0.1436377636572128, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030040126881113793, 9.999999999998899e-05, 9.999999999998899e-05, 0.05299138032783668, 0.03384808899847269, 0.08701134393758114, 0.06135424181052618, 0.13173357442343714, 0.030956762361825207, 0.09866673618354416, 0.06206868103346119, 0.05381047112754911, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029845575405966773, 9.999999999998899e-05, 9.999999999998899e-05, 0.053243218303395956, 0.0752870989017067, 0.10119805991579922, 0.06229837183246678, 0.09130532053579121, 0.04754150675651814, 0.06829407559863487, 0.05290036205651427, 0.05282642861547915, 0.051745603370192295, 0.4034547745081344, 0.4066921761174519, 0.401562141152892, 0.3667359223353015, 0.31318705246676604, 0.2855604442684263, 0.40540587788906723, 0.43162264597723343, 0.4019714813581784, 0.12790546181406648, 0.02393338231978359, 0.05547506286257908, 0.04170232792131323, 0.09807130091007388, 0.08059806584522011, 0.12442256824238995, 0.13653101222278907, 0.07991977533465033, 0.13921239724375045, 0.14313382572448585, 0.17472205723395995, 0.15236927296394986, 0.1322243434993694, 0.11725795636693215, 0.13555461086782672, 0.17398027534602512, 0.15753266845857672, 0.19647385749655588, 0.2661360222539577, 0.15305665845259842, 0.18495679468192572, 0.20873636108097715, 0.19368695089411847, 0.1567977699757992, 0.18633125027981157, 0.14685603382329027, 0.11524556255677088, 0.14497939303969665, 0.10490488862206093, 0.19508957064786214, 0.12446486881738561, 0.16817169121826314, 0.10919484552721426, 0.14456567103399998, 0.13987178880446804, 0.25276021805885973, 0.18484320152319456, 0.2559373397392092, 0.24574127670921253, 0.20882010451081912, 0.1997543475298026, 0.2648197335041088, 0.19267776193047148, 0.2708630131277271, 0.16994920755611187, 0.16435421080539103, 0.15598656453064197, 0.16494770401435965, 0.18250372730066633, 0.17299374076368657, 0.1586962303828423, 0.18071369486909938, 0.15987299076426698, 0.18734659365008388, 0.18638922073910857, 0.18733610209960838, 0.4420576774959618, 0.20139632486049364, 0.16993094898212713, 0.5433101828246976, 0.1851971916517371, 0.14820149064158816, 0.28682441235610945, 0.1585836949468118, 0.23219452059645718, 0.11729532239838958, 0.18463787795349673, 0.18634260408214443, 0.1956367648111884, 0.1640164042692922, 0.36437212850126455, 0.21606198552238087, 0.18775724069627253, 0.2031065506607701, 0.19292994683109432, 0.20484539129384916, 0.23833085304947377, 0.19395694605946545, 0.20795474646061407, 0.20743024745798033, 0.07275300396546847, 0.06169344239926444, 0.05746721492430462, 0.07193743870005997, 0.06531328413597604, 0.10302776950757453, 0.06188053743790456, 0.06765556426431774, 0.06682650043155935]}, "mutation_prompt": null}
{"id": "d503b84c-c398-4ea1-9888-f80b4ff81869", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "49b7cfb5-7c6d-4351-817f-8d41fc80acba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "6e004a2e-dd4e-46d2-8f3a-04c370cd1945", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "5cdc0e93-f1d5-44dc-b669-70185abc8a8b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "6818967e-4524-49f4-8a75-a6f82e54f367", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "bec2fd55-bcc2-4a85-bcdc-1e49941b3237", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom pyswarm import pso\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            def objective(x):\n                return func(x)\n\n            options = {'c1': 0.5, 'c2': 0.3, 'w':0.9}  # PSO parameters\n            lb = [self.lower_bound] * self.dim\n            ub = [self.upper_bound] * self.dim\n            pso_harmony = pso(objective, lb, ub, swarmsize=10, maxiter=10, debug=False, **options)\n            pso_fitness = func(pso_harmony)\n            if pso_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = pso_harmony\n                fitness_values[index] = pso_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel hybridization strategy involving Particle Swarm Optimization.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'pyswarm'\").", "error": "ModuleNotFoundError(\"No module named 'pyswarm'\")", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {}, "mutation_prompt": null}
{"id": "19ef4cf8-551b-4c8a-8bb6-17effca4c690", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "dca3c83f-cf96-4a4c-9dbd-0fc6bde0583e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "9945a465-8a46-4836-bbe7-541a1b427469", "solution": "class EnhancedDynamicBoundaryHybridHarmonySearchOptimizer(ImprovedDynamicBoundaryHybridHarmonySearchOptimizer):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.dynamic_bound_factor = 0.1\n\n    def __call__(self, func):\n        def dynamic_boundary_adjustment(harmony_memory, fitness_values):\n            nonlocal dynamic_bound_factor\n            for i in range(len(harmony_memory)):\n                for j in range(self.dim):\n                    if np.random.rand() < dynamic_bound_factor:\n                        harmony_memory[i][j] = np.random.uniform(self.lower_bound, self.upper_bound)\n                        fitness_values[i] = func(harmony_memory[i])\n\n        dynamic_bound_factor = 0.1\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            dynamic_boundary_adjustment(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n            dynamic_bound_factor = max(0.01, min(0.5, dynamic_bound_factor - 0.05 * best_fitness))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by incorporating a novel dynamic boundary adjustment mechanism.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'generate_harmony' is not defined\").", "error": "NameError(\"name 'generate_harmony' is not defined\")", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {}, "mutation_prompt": null}
{"id": "02cc9610-9e5f-4345-bbc3-045717f37b82", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)  # Adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            if np.random.rand() < 0.1:  # Dynamic population resizing\n                harmony_memory = np.vstack((harmony_memory, generate_harmony()))\n                fitness_values = np.append(fitness_values, func(harmony_memory[-1]))\n\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing dynamic population resizing and adaptive mutation strategy.", "configspace": "", "generation": 84, "fitness": 0.46268335816885114, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.38.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9715677954838887, 0.9653132233025726, 0.9712877653123525, 0.9704902775528654, 0.9689912211097612, 0.9666917782023318, 0.9757403260375722, 0.9751992149053955, 0.9787208393481583, 0.9133713045079022, 0.8794030725747308, 0.9272118707349255, 0.921502516594382, 0.9422018259412931, 0.9519031821294754, 0.8799893592301714, 0.9240088468806968, 0.8230535831754563, 0.07295177374809558, 0.06157061480981063, 0.0627088903639893, 0.036270681022996354, 0.13728786798392523, 0.10398018393763364, 0.04643817326848132, 0.09809169068311219, 0.06587969664881488, 0.08176072144580482, 0.045277512671675124, 0.07301902431322738, 0.07447250237274405, 0.017697183468891153, 0.011778025823222404, 0.035454227734610155, 0.06669756371089808, 0.06136485154923499, 0.9552988576963667, 0.9753267592103745, 0.9812076902114585, 0.9922683777199423, 0.9937219458770272, 0.9627733359967346, 0.9926139801636096, 0.923265885524992, 0.9893075455018472, 0.44806853131615376, 0.6428894592626176, 0.6249834418988076, 0.39881107894675527, 0.5182889444440029, 0.45772675568888677, 0.6326031071664442, 0.703390502340415, 0.6783729710006506, 0.12674592420018838, 0.06887177155863589, 0.07612756255675546, 0.37444353153886, 0.12670547425774237, 0.10820914229807677, 0.12680510813268897, 0.12366574329239721, 0.14664876291735818, 0.13897304335112182, 0.13631348225776296, 0.8798186102863775, 0.9294010798400196, 0.9256549434092448, 0.9455159428528853, 0.9695418512068351, 0.13903148819223565, 0.9283265113295603, 0.9592926053867377, 0.9406606841264952, 0.9619765064293411, 0.935043758343196, 0.9387222667537106, 0.9551445596137857, 0.9392624669306767, 0.9582066206489328, 0.9258715673996443, 0.8972567936611746, 0.9295342139331848, 0.8967419774565203, 0.8200617667766177, 0.8688074226704691, 0.9049370648015076, 0.9134597790571801, 0.7957032128297702, 0.9000579078212105, 0.6846773947761005, 0.9181854420000639, 0.850264013564896, 0.8205552357537464, 0.6996276169556144, 0.7381360198215204, 0.6680225267395239, 0.8376758469886355, 0.876007523697635, 0.7024053703012769, 0.7997032365507505, 0.7874123611685615, 0.87916176207461, 0.840042131636831, 0.8724108927161622, 0.6696376071848931, 0.6348067558648985, 0.5151512273160906, 0.8417285553049376, 0.8203841591954126, 0.7685571692485891, 0.7914813747434708, 0.7688464517224465, 0.7873537472700926, 0.7803917588517075, 0.761288012475999, 0.7496385936415559, 0.785017841733084, 0.9642247360354557, 0.9736571744696911, 0.9523840728660549, 0.9666396567106226, 0.9279629195027717, 0.9653547660482676, 0.9468155445483846, 0.9628411730222575, 0.039164066049850565, 0.04109571283652291, 0.07214183144978037, 0.030092667423661235, 0.05566859121805223, 0.05246137606268697, 0.09533230536513515, 0.002986720339649085, 0.07434960310167005, 0.20953795713393786, 0.11642263521424834, 0.11555453174158736, 0.22585917356679297, 0.12383753341188108, 0.30251128473397904, 0.12552571118552946, 0.1565342000134562, 0.0986962289108928, 0.15463458340697722, 0.12845947599155993, 0.14329819077917505, 0.18119139928448835, 0.19384396478740284, 0.16518670262463075, 0.13912306635922156, 0.12431310124376482, 0.13292867583696244, 0.08328772241742732, 0.1696008716630415, 0.09909273791886009, 0.10420533246055497, 0.13017852571696642, 0.09791614314035668, 0.1006629669321939, 0.09806663783410308, 0.08070091284191583, 0.19139193192204973, 0.14726758929289085, 0.16903272610848596, 0.20859943231011657, 0.18239216620878207, 0.14998937126627387, 0.19022247928351843, 0.2341144524100549, 0.1615307196008684, 0.1792208741934539, 0.19966362987156838, 0.18093845449804336, 0.1847199321771813, 0.17039504508121006, 0.16045581980212953, 0.15779673792511273, 0.1803613823046153, 0.18693156531403943, 0.11991431581114231, 0.1603765451368463, 0.13729408361072637, 0.1732124115833048, 0.20265098968881845, 0.12355553082445891, 0.17365734367740882, 0.12739751807779176, 0.1040316661230225, 0.1576512853205364, 0.11302122290968941, 0.9754421716559539, 0.9715631957408526, 0.18708740826787496, 0.2148602793890364, 0.16936181991607935, 0.09486514233884169, 0.9716889255672222, 0.16217071114414316, 0.16582013037993493, 0.20022459542787352, 0.20687089308580597, 0.18978485369856846, 0.18463954081755973, 0.23799034004993935, 0.21077772786694227, 0.27889510785821003, 0.04754180295875654, 0.0478179705532803, 0.056055392067278054, 0.04521315728332698, 0.053822411952889504, 0.07714587767728665, 0.044299571043193264, 0.03041261037412968, 0.07274318485411002]}, "mutation_prompt": null}
{"id": "0f595d22-d5bc-4416-9095-86d38963d34b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony(population_size):\n            return np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        population_sizes = [10, 20]\n        pitch_adjust_rates = [0.1, 0.2]\n        harmony_memories = [generate_harmony(pop_size) for pop_size in population_sizes]\n        fitness_values = [np.array([func(harmony) for harmony in harmony_memory]) for harmony_memory in harmony_memories]\n\n        for _ in range(self.budget - max(population_sizes)):\n            for i in range(len(population_sizes)):\n                new_harmony = improvise(harmony_memories[i], population_sizes[i], pitch_adjust_rates[i], 0.5)\n                new_fitness = func(new_harmony)\n                if new_fitness < np.max(fitness_values[i]):\n                    index = np.argmax(fitness_values[i])\n                    harmony_memories[i][index] = new_harmony\n                    fitness_values[i][index] = new_fitness\n                differential_evolution(harmony_memories[i], fitness_values[i])\n\n            best_fitnesses = [min(fitness) for fitness in fitness_values]\n            pitch_adjust_rates = [max(0.01, min(0.5, rate + 0.1 * (fitness.sum() - best * len(fitness)))\n                                   for rate, fitness, best in zip(pitch_adjust_rates, fitness_values, best_fitnesses)]\n\n        best_indices = [np.argmin(fitness) for fitness in fitness_values]\n        best_harmonies = [harmony_memory[best_index] for harmony_memory, best_index in zip(harmony_memories, best_indices)]\n        return min(best_harmonies, key=func)", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by incorporating a multi-population approach with adaptive parameters and a dynamic boundary adjustment mechanism.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError(\"closing parenthesis ']' does not match opening parenthesis '(' on line 58\", ('<string>', 59, 118, '                                   for rate, fitness, best in zip(pitch_adjust_rates, fitness_values, best_fitnesses)]')).", "error": "SyntaxError(\"closing parenthesis ']' does not match opening parenthesis '(' on line 58\", ('<string>', 59, 118, '                                   for rate, fitness, best in zip(pitch_adjust_rates, fitness_values, best_fitnesses)]'))", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {}, "mutation_prompt": null}
{"id": "dd53f310-e894-49b3-81fa-1a44b533df6a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "2b46e578-681a-40d8-aff3-615602918867", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicPopulationSizeHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(len(harmony_memory))])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        population_update_rate = 0.1\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            if np.random.rand() < population_update_rate:\n                harmony_memory = np.vstack([harmony_memory, generate_harmony()])\n                fitness_values = np.append(fitness_values, func(harmony_memory[-1]))\n\n            best_index = np.argmin(fitness_values)\n            best_fitness = fitness_values[best_index]\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        return harmony_memory[best_index]", "name": "DynamicPopulationSizeHybridHarmonySearchOptimizer", "description": "Incorporating a dynamic population size adaptation strategy for improved exploration and exploitation in the harmony search optimization.", "configspace": "", "generation": 87, "fitness": 0.238282747071364, "feedback": "The algorithm DynamicPopulationSizeHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.556967366684235, 0.7235816629430556, 0.5998449834294863, 0.5655305831825455, 0.6402593241145588, 0.5508244128319449, 0.5838043842367168, 0.6814313431182667, 0.5631934832213673, 0.28145744185391497, 0.3944574699680997, 0.2732416168245315, 0.34275502586961104, 0.4112757268074946, 0.2610532076798562, 0.3098706450302606, 0.3852210707063638, 0.2791556103252406, 0.15369909504556822, 0.22612836331063413, 0.14613961609539328, 0.15642927247356075, 0.16054246608285083, 0.24241089827545415, 0.13287798962335928, 0.15391304650841542, 0.12832371911643825, 0.11582918609269888, 0.11640666604896543, 0.12373952244367648, 0.13377422595877342, 0.12310496842741814, 0.11435628362343175, 0.13197354288762564, 0.12444275635434665, 0.12157535878633041, 0.9721992272195092, 0.9906786418240332, 0.9668873508896922, 0.9591892672302499, 0.9797761140619541, 0.955206537242377, 0.947326954293625, 0.9786985420037264, 0.9690613509592447, 0.21389994304560622, 0.2685138138341172, 0.23127496283954663, 0.2343260392718951, 0.28814630346246306, 0.237229180512894, 0.20584362443170134, 0.23535039910875422, 0.20133119236463015, 0.25516132653104395, 0.25301419185193896, 0.24162375662760904, 0.27564558588824306, 0.2956670788882608, 0.34623269364493925, 0.24799409416202733, 0.32445806805715727, 0.28722021257998276, 0.20360832770168824, 0.19123470369819984, 0.16753197275371745, 0.12626916893142992, 0.1761937073208295, 0.16997761232267783, 0.1360140599069135, 0.18645465640113956, 0.1514795850550339, 0.2044640683088469, 0.17116528434918232, 0.1648255502460686, 0.20424200238146806, 0.22372956558980073, 0.25321598888044405, 0.18019915168174827, 0.18398473110868718, 0.20340287689186798, 0.001075355093367425, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012235576257597636, 0.0006983065131229704, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044726651880343526, 0.11273246299877004, 0.10543915124930625, 0.1413282845611018, 0.07603554440027671, 0.07447683940275607, 0.05877583520995011, 0.10154432192629026, 0.12911540460936943, 0.08346481592114419, 9.999999999998899e-05, 0.00988052229546943, 0.0009290564330792783, 9.999999999998899e-05, 0.0016077631882841503, 9.999999999998899e-05, 9.999999999998899e-05, 0.03318514222586599, 9.999999999998899e-05, 0.10800299286612514, 0.10215876997838336, 0.11646413177239578, 0.10636770717970867, 0.143270455510626, 0.12464516502580714, 0.09707831103760167, 0.09837581579114485, 0.09153674926180633, 0.45623560295850807, 0.4668590891533011, 0.4385831949416965, 0.42074264820617735, 0.4334593880711516, 0.4333700071859321, 0.4248132209743041, 0.5004143319599383, 0.45056547917625267, 0.08767231577863077, 0.11336868211603268, 0.10926676618593023, 0.0889382427061437, 0.09435058996950607, 0.08039715308593443, 0.11015833547809617, 0.12653338546268245, 0.10292839593697134, 0.15627066431836611, 0.15668805278481235, 0.1892179166761906, 0.1393267201526467, 0.17392709337553247, 0.16592195836576562, 0.15259296735476668, 0.16761629478837325, 0.17948638892927538, 0.2385526433758015, 0.24016276104433232, 0.2256413594628237, 0.23921825494906857, 0.2732799975919048, 0.24678708207146105, 0.22267943825399505, 0.24881459191761035, 0.2500462051344433, 0.19768469065682115, 0.1880330075552915, 0.17495722075135023, 0.2062073791381408, 0.1969819287338641, 0.21719651535365947, 0.1947243086818441, 0.19854960638979247, 0.1749757213964851, 0.19393741073895898, 0.20679936343974326, 0.2070966679878533, 0.19796297157899567, 0.21456940342263897, 0.1934582361258258, 0.19579594872043238, 0.19440379877417668, 0.20518153320466093, 0.19738707779496467, 0.21109878036491903, 0.2219861469652793, 0.19800205688317596, 0.2137140552903939, 0.2219384497418655, 0.25650230978366284, 0.21467304004063825, 0.19863674853912516, 0.18829550095742786, 0.41873013633538647, 0.33113643520442015, 0.3394499327507512, 0.29149662075472216, 0.3935613205193227, 0.38948858502789585, 0.23768980227826397, 0.23224559147911228, 0.2958276363236704, 0.296684785174238, 0.34969462663601225, 0.2048269770441965, 0.24075471552008165, 0.19580668031609194, 0.29437437699642477, 0.20842332940881558, 0.36914112630104023, 0.19418560686184927, 0.17460171187737672, 0.18452425466324485, 0.17332314625451561, 0.1752987539718468, 0.20869838542252128, 0.1805315288682401, 0.17859163434451897, 0.19231751372010275, 0.07486600438782354, 0.11018522140989828, 0.10595295857835718, 0.07125853770946511, 0.07601160574852839, 0.08535770912529006, 0.0869161521135906, 0.09080342236602157, 0.09599852671732445]}, "mutation_prompt": null}
{"id": "0f75999c-ada0-4d80-80e4-93d1dd17e6c4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiPopulationEnhancedHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        population_size = 5\n        pitch_adjust_rate = 0.1\n        harmonies = [np.array([generate_harmony() for _ in range(population_size)]) for _ in range(5)]\n        fitness_values = [np.array([func(harmony) for harmony in pop]) for pop in harmonies]\n\n        for _ in range(self.budget - 5*population_size):\n            for pop_idx in range(len(harmonies)):\n                harmony_memory = harmonies[pop_idx]\n                fitness_vals = fitness_values[pop_idx]\n\n                new_harmony = improvise(harmony_memory, population_size, pitch_adjust_rate, 0.5)\n                new_fitness = func(new_harmony)\n                if new_fitness < np.max(fitness_vals):\n                    index = np.argmax(fitness_vals)\n                    harmony_memory[index] = new_harmony\n                    fitness_vals[index] = new_fitness\n                differential_evolution(harmony_memory, fitness_vals)\n\n            best_harmonies = [harmonies[i][np.argmin(fitness_values[i])] for i in range(len(harmonies))]\n            best_fitnesses = [np.min(fitness_values[i]) for i in range(len(fitness_values))]\n\n            for i in range(len(harmonies)):\n                for j in range(len(harmonies[i])):\n                    harmonies[i][j] = best_harmonies[np.random.randint(len(best_harmonies))]\n\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (np.sum(fitness_values) - np.sum(best_fitnesses)))\n\n        best_index = np.unravel_index(np.argmin(fitness_values, axis=None), np.shape(fitness_values))\n        return harmonies[best_index[0]][best_index[1]]", "name": "MultiPopulationEnhancedHybridHarmonySearchOptimizer", "description": "Enhancing the exploration capability by incorporating a multi-population strategy for improved diversity and convergence.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 69, 9, '        best_index = np.unravel_index(np.argmin(fitness_values, axis=None), np.shape(fitness_values))\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 69, 9, '        best_index = np.unravel_index(np.argmin(fitness_values, axis=None), np.shape(fitness_values))\\n'))", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {}, "mutation_prompt": null}
{"id": "ffaab034-bea3-49b9-987f-b1e67297e039", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "9d95f11a-ed31-4872-8de9-6aa3a2009e52", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim))\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "ImprovedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Improving convergence and exploration by incorporating a self-adaptive mutation factor and a novel opposition-based learning mechanism.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9745973037058712, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8692295391248286, 0.9242105198534202, 0.9180814354938476, 0.09389667398002166, 0.06325787750680933, 0.06106595734671505, 0.07495875895260307, 0.12683588615841968, 0.01324776373914649, 0.09545722035104409, 0.07448549148193595, 0.03731623133370865, 0.08503809643851579, 0.03967416427909831, 0.024970255010857367, 0.07582287235716301, 0.017957298972607116, 0.019851683780878426, 0.04806145108978377, 0.02374522121001843, 0.04102310922171515, 0.9552988576963667, 0.940554442873736, 0.9887535711152688, 0.9922683777199423, 0.990855029120333, 0.9423399455568122, 0.9926139801636096, 0.9893248790617548, 0.9901381288330955, 0.44806853131615376, 0.7958671387877957, 0.7018139933283132, 0.37154762975936584, 0.639765159219027, 0.6399580271012794, 0.6060125904630765, 0.72636859520062, 0.6749074973026108, 0.11745902070457015, 0.03888908794816359, 0.09774229719401195, 0.20946292382327292, 0.07447324341046946, 0.05114771956568365, 0.12249894690814656, 0.10308476540169309, 0.22387881025143053, 0.1392247351671524, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.9114635426806758, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6572118476365894, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7753660126922622, 0.87916176207461, 0.7901397325507059, 0.9222640290914431, 0.6291400055903296, 0.6458998832030196, 0.6952824748870581, 0.8417285553049376, 0.8293209519900324, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7803917588517075, 0.7615915041966432, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.008308495428588136, 0.05443619065859073, 0.038333024041125485, 0.03142724424011889, 0.04104832564123939, 0.05246137606268697, 0.09560795844500403, 0.016373937820285955, 0.07434960310167005, 0.09170216809691323, 0.13455126802751805, 0.12456288269203264, 0.22585996371072103, 0.1941641899109986, 0.17311426013675335, 0.10947568095061289, 0.16564491159923378, 0.10042709722519672, 0.1395765762775072, 0.1395433462052893, 0.12925282822308382, 0.1995875802871956, 0.13674666914270306, 0.13773125102220585, 0.13912306635922156, 0.14589657576788717, 0.15075863371816833, 0.08487342296348777, 0.08500912501552915, 0.09053121415571364, 0.11705460469454498, 0.09713436700409461, 0.13378889521676796, 0.07086449458772404, 0.06253737386843072, 0.08696431406893956, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228089916976527, 0.10862372411289356, 0.187260352098661, 0.19022247928351843, 0.13221225262708436, 0.18350420054053473, 0.17317963213247445, 0.19970425602727948, 0.19293237569175226, 0.18471993262468334, 0.1704295710885222, 0.1767800450888113, 0.1577967380342259, 0.18039773025501016, 0.16728912426783515, 0.11991431577529366, 0.07753468858634582, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178945523934, 0.16016457082661095, 0.15766962178356192, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.05926251213241307, 0.21486027951702003, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.28643533328840753, 0.18976529620425497, 0.20022447630624507, 0.2124738919422069, 0.2084147158894899, 0.18463951640861198, 0.20545452767508798, 0.18478400877406975, 0.27889510785821003, 0.04165909576535454, 0.07168935199387239, 0.06362823795771255, 0.045363296526321206, 0.027627420020718607, 0.059735582428249834, 0.031406794803682914, 0.0883319610495853, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "248ee693-2b99-4186-9d67-49595c4cccb0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 91, "fitness": 0.48482598447447994, "feedback": "The algorithm EnhancedDynamicBoundaryHybridHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.39.", "error": "", "parent_id": "cbbf3430-2531-4dde-be7a-7d28a09030b8", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "14ce837b-2ddf-458b-8e67-9e1726a69945", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass DynamicHarmonyMemorySizeEnhancedHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values)))\n\n            harmony_memory_size = max(5, min(20, int(len(harmony_memory) * (1 + 0.1 * (best_fitness - fitness_values.mean())))))  # Self-adaptive harmony memory size adjustment\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "DynamicHarmonyMemorySizeEnhancedHybridHarmonySearchOptimizer", "description": "Enhancing exploration and exploitation by incorporating a self-adaptive harmony memory size adjustment mechanism.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 74, 13, '            harmony_memory_size = max(5, min(20, int(len(harmony_memory) * (1 + 0.1 * (best_fitness - fitness_values.mean())))))  # Self-adaptive harmony memory size adjustment\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 74, 13, '            harmony_memory_size = max(5, min(20, int(len(harmony_memory) * (1 + 0.1 * (best_fitness - fitness_values.mean())))))  # Self-adaptive harmony memory size adjustment\\n'))", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {}, "mutation_prompt": null}
{"id": "eaf95c5c-375d-4ef0-970f-4906aa8a3e5a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "23ba75c7-46a7-40aa-b732-3c57f2496f05", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "d1558661-9fcb-436b-ae02-1b95ca1dc536", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "5540fc39-bae5-4665-b348-45385e2a4e0d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "0c51f6b6-c91f-4d75-aed0-18dff365a32d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "09261abc-6b6c-4370-a072-5f47b23114b7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
{"id": "23251ef0-a9c5-4d28-b310-25c71dbe6439", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicBoundaryHybridHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def generate_harmony():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, mutation_factor):\n            new_harmony = np.copy(harmony_memory[np.random.randint(harmony_memory_size)])\n            for i in range(self.dim):\n                if np.random.rand() < pitch_adjust_rate:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < mutation_factor:\n                    new_harmony[i] = self.lower_bound + self.upper_bound - new_harmony[i]  # Opposition-based learning\n            return new_harmony\n\n        def differential_evolution(harmony_memory, fitness_values):\n            mutation_factor = np.random.uniform(0.1, 0.9)  # Self-adaptive mutation factor\n            crossover_rate = 0.9\n            for i in range(len(harmony_memory)):\n                target_idx = np.random.choice(list(set(range(len(harmony_memory))) - {i}))\n                base, target = harmony_memory[i], harmony_memory[target_idx]\n                donor = base + mutation_factor * (target - harmony_memory[np.random.choice(range(len(harmony_memory)))])\n\n                trial = np.copy(base)\n                for j in range(len(trial)):\n                    if np.random.rand() < crossover_rate:\n                        trial[j] = donor[j] if np.random.rand() < 0.5 else base[j]\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness_values[i]:\n                    harmony_memory[i] = trial\n                    fitness_values[i] = trial_fitness\n\n        harmony_memory_size = 10\n        pitch_adjust_rate = 0.1\n        harmony_memory = np.array([generate_harmony() for _ in range(harmony_memory_size)])\n        fitness_values = np.array([func(harmony) for harmony in harmony_memory])\n\n        for _ in range(self.budget - harmony_memory_size):\n            new_harmony = improvise(harmony_memory, harmony_memory_size, pitch_adjust_rate, 0.5)\n            new_fitness = func(new_harmony)\n            if new_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = new_harmony\n                fitness_values[index] = new_fitness\n            differential_evolution(harmony_memory, fitness_values)\n\n            chaotic_harmony = harmony_memory[np.random.randint(harmony_memory_size)] + 0.1 * np.sin(np.random.standard_normal(self.dim)) + np.random.uniform(-0.5, 0.5, self.dim)  # Novel chaos-based perturbation\n            chaotic_harmony = np.clip(chaotic_harmony, self.lower_bound, self.upper_bound)\n            chaotic_fitness = func(chaotic_harmony)\n            if chaotic_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = chaotic_harmony\n                fitness_values[index] = chaotic_fitness\n\n            local_search_harmony = minimize(func, harmony_memory[np.argmin(fitness_values)], method='Nelder-Mead').x\n            local_search_fitness = func(local_search_harmony)\n            if local_search_fitness < np.max(fitness_values):\n                index = np.argmax(fitness_values)\n                harmony_memory[index] = local_search_harmony\n                fitness_values[index] = local_search_fitness\n\n            best_fitness = min(fitness_values)\n            pitch_adjust_rate = max(0.01, min(0.5, pitch_adjust_rate + 0.1 * (fitness_values.sum() - best_fitness * len(fitness_values))))\n\n        best_index = np.argmin(fitness_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicBoundaryHybridHarmonySearchOptimizer", "description": "Enhancing exploration by introducing a novel chaos-based perturbation strategy to diversify the search process.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "248ee693-2b99-4186-9d67-49595c4cccb0", "metadata": {"aucs": [0.9693201955965358, 0.9767946199537643, 0.9712877653123525, 0.9753318072061515, 0.9772607530290911, 0.9523486483879323, 0.969616510509468, 0.9769100683568037, 0.9780756190851546, 0.9133713045079022, 0.8796927694359761, 0.9195324914997387, 0.921502516594382, 0.9278355515687032, 0.9567396321155395, 0.8721068619858323, 0.9242105198534202, 0.9180814354938476, 0.07713317420900856, 0.08587587369461103, 0.0565025339655747, 0.037230500841635705, 0.08218379379486374, 0.07258514267533478, 0.03683493435165741, 0.07448549148193595, 0.08646080480302776, 0.06709645716789492, 0.023450452191177473, 0.014452109057641604, 0.06760340359638772, 0.01931198203653839, 0.020935497763478583, 0.031107499410431005, 0.07356664153410197, 0.010472641677614414, 0.9552988576963667, 0.8829917862453015, 0.9859985508742157, 0.9922683777199423, 0.990855029120333, 0.9880541509528737, 0.9926139801636096, 0.9893248790617548, 0.9902840200913525, 0.44806853131615376, 0.4337665321794879, 0.7044180655192389, 0.21515366234289768, 0.5657490161185138, 0.6242342218667496, 0.6855810584112965, 0.7076802341853417, 0.6728393860472084, 0.1773774649653913, 0.09006836512100957, 0.1635057666072084, 0.21542516221628394, 0.14561106073648677, 0.1629343185700458, 0.07950194711190084, 0.12183349240889052, 0.13423125574588124, 0.13922473515495037, 0.9665033027934753, 0.9393703721290712, 0.9304212441294393, 0.9258549434092448, 0.9673575494320006, 0.9695418512068351, 0.1382318366805303, 0.9434983953707203, 0.9592926053867377, 0.954250612294858, 0.9291528719846329, 0.935043758343196, 0.9624237306017651, 0.9551445596137857, 0.9392624669306767, 0.9234773798766137, 0.9258715673996443, 0.8625501913683966, 0.7851232585468022, 0.8916511492485024, 0.8623684661115778, 0.8690909815956416, 0.9049370648015076, 0.9134597790571801, 0.8289172378321903, 0.8840570148397129, 0.8008542215317018, 0.9184497867478091, 0.850264013564896, 0.8205552357537464, 0.7845248948313333, 0.7698429507624869, 0.6562117761300018, 0.8712095814985141, 0.876007523697635, 0.7024053703012769, 0.7414467543483616, 0.7801226606852454, 0.8919606631643033, 0.7901397325507059, 0.8413390260323786, 0.6291400055903296, 0.6458998832030196, 0.6866757336096188, 0.8417285553049376, 0.8323955353411567, 0.8215790982369849, 0.8063853832864784, 0.8266250075670379, 0.8099545742216173, 0.7942318692229333, 0.7699785481816673, 0.7737756523325201, 0.9634718596554022, 0.9593906563158155, 0.9655882970969767, 0.9523840728660549, 0.9659444303104846, 0.9593443898721828, 0.9653547660482676, 0.9258731853788144, 0.9256242875194415, 0.03891738781765486, 0.02024685515333602, 0.007212755271940652, 0.0331846513921773, 0.041048325803634156, 0.05246137606268697, 0.09560795828491242, 0.03554344614822347, 0.07434960310167005, 0.13233742934845272, 0.23737504704514012, 0.12456288269203264, 0.2258819197355244, 0.12384923926678348, 0.10952675276764168, 0.10947570115578686, 0.12237782538114028, 0.09869619736313273, 0.17234980319159598, 0.17078391578924834, 0.12925282822308382, 0.1511066736525285, 0.15607113616399038, 0.17468350694478518, 0.13912306635922156, 0.14503809959045444, 0.11239666358554878, 0.06824850172636998, 0.08500917707788413, 0.06733166841327443, 0.0831498991492019, 0.09399510458953209, 0.10471696625367, 0.10532074235674205, 0.09654406841092733, 0.10615391422368992, 0.19139193192204973, 0.13344418866347185, 0.16903272610848596, 0.14228075003935448, 0.16365065458748018, 0.14976119721117176, 0.19022247928351843, 0.17371950235442712, 0.18873438005572551, 0.17317963243579593, 0.1997042559614327, 0.19293237569175226, 0.18471993287003807, 0.189398596272765, 0.1767800450888113, 0.1577967379287888, 0.18039773025501016, 0.17715501678372025, 0.11991431579933198, 0.9081974617271253, 0.9829313241908405, 0.9776356523484185, 0.2026674736064934, 0.10915137387938445, 0.9886957914355664, 0.12741178944916087, 0.16016457084950309, 0.15766962178494082, 0.11335577983763634, 0.9620857281763135, 0.9715631957408526, 0.8253012119166078, 0.21486027958751464, 0.1691775051282084, 0.17045091899586295, 0.9716889255672222, 0.2871332729699535, 0.18976604637250472, 0.20022239931779895, 0.21247796411163422, 0.2084147158894899, 0.18463951640861198, 0.20545434176203548, 0.1756524590930365, 0.2789086906614887, 0.05828369995911087, 0.07243243849402803, 0.06362823795771255, 0.04536329714304188, 0.06258393969413467, 0.062222220852695465, 0.048526911212859125, 0.05842898245739092, 0.041381282058659985]}, "mutation_prompt": null}
