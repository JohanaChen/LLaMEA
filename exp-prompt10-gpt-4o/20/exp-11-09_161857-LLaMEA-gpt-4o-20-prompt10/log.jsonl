{"id": "25394fce-c394-4345-bf30-378e4aa82975", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.22361337798955228, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "0b5a8cee-46e1-4fbb-9780-77736c7ad4f5", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Slightly increased for faster convergence\n        self.c2 = 1.7  # Slightly increased for faster convergence\n        self.w_max = 0.9  # Adaptive inertia weight\n        self.w_min = 0.4\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # Calculate adaptive inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * function_evaluations / self.budget)\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation with adaptive F\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                F = self.F_base + np.random.rand() * 0.5  # Adaptive F within [0.5, 1.0]\n                mutant = self.positions[a] + F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid Particle Swarm and Differential Evolution algorithm with adaptive velocity and mutation strategies to improve convergence speed in black box optimization problems.", "configspace": "", "generation": 1, "fitness": 0.18892371122107732, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.4923933732094633, 0.4595867184051884, 0.45594318643820697, 0.5156836273416191, 0.5321812150553987, 0.49666049981636384, 0.4730410224346884, 0.486267618245687, 0.5056719001048477, 0.14571608717145224, 0.04273291376673438, 0.19272938204808288, 0.15012464915260204, 0.1714328975634225, 0.14193816848441942, 0.16486959562093106, 0.1063493113459737, 0.16582546726300518, 0.10367239354497193, 0.09283472423673556, 0.07392514375124137, 0.07017878421078727, 0.07854916827433212, 0.06424532742186417, 0.08179219352482636, 0.06933706146553686, 0.07759597352402636, 0.06139235051238334, 0.06815365460837164, 0.08398583619344713, 0.055325076516420824, 0.09764801258345002, 0.07179330566977826, 0.08218208743490452, 0.0573970205963773, 0.0759003040989461, 0.9774267265554865, 0.986131105603586, 0.9852050455567466, 0.977360989628713, 0.9826937747405592, 0.9849455720054322, 0.9858563642213605, 0.9862859401186197, 0.9852872911205502, 0.13388198731331813, 0.12700297080539513, 0.1953970126576341, 0.152169420552687, 0.12656330959924067, 0.10886934364145018, 0.14978650228329948, 0.15298981108453136, 0.16413550693784706, 0.14957606231703302, 0.20395958678674075, 0.18744944350508663, 0.23568389129353473, 0.15394209889015875, 0.18337913394461058, 0.19161920090225648, 0.1834310045752955, 0.20168648968922642, 0.12481420599573634, 0.10987678676043111, 0.11924502745579757, 0.06538688055586661, 0.10879425704322787, 0.09110540366290676, 0.11371141280982844, 0.10351522111209266, 0.11094270451800126, 0.1367523643036611, 0.0924718856941501, 0.1240525694552913, 0.11080858992868614, 0.11987272870524901, 0.09829079342235514, 0.11674860114239749, 0.11089796121184281, 0.10347426648314995, 9.999999999998899e-05, 9.999999999998899e-05, 0.003663437714116813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018786224269764507, 0.044096328433462784, 0.054010067047432275, 0.05253280289810969, 0.021602525215560275, 0.027592460059377877, 0.023111919087566823, 0.04862061534838302, 0.03127066263928191, 0.06169303404002768, 0.010221068835923885, 0.05680530460434363, 0.05147303525459357, 0.02813241507386044, 0.06206859367699891, 0.038045778032777755, 0.038293615784232626, 0.02670013454426079, 0.03136442868650191, 0.0690944595276255, 0.10572852832235824, 0.019323813260883838, 0.02964734801288904, 0.0929332814019832, 0.10401081623477293, 0.045066907165074555, 0.05757835640885367, 0.05954036929684703, 0.3501544949202453, 0.33057015104665344, 0.366385014551194, 0.36467465476352134, 0.36682605529555556, 0.37337677101116706, 0.3629482808350606, 0.38201985911939573, 0.3596629128709816, 0.07930666668466568, 0.09238992315912198, 0.07205588031091137, 0.07893244767975938, 0.06825666436910449, 0.08468821530562909, 0.07467490630604812, 0.1017399544198242, 0.058276734701357746, 0.14175863756011864, 0.13841756533813643, 0.14946918645442098, 0.15931885521840172, 0.15682828336897814, 0.13735379730309227, 0.12516623981425057, 0.1336709854105793, 0.14951514959545753, 0.21825870056743146, 0.2645264316564828, 0.19978035110447112, 0.24063576755055727, 0.24728111938719666, 0.23946043933665917, 0.28230780531631494, 0.26034651506666606, 0.2268845585300786, 0.16443101768790602, 0.16407740091942213, 0.17398257851561139, 0.16165588776179152, 0.18718989509986728, 0.151814172899571, 0.13551056828084407, 0.16752014597391462, 0.1400045478436368, 0.17077506702887946, 0.2027193528652822, 0.1737725833420556, 0.1970128071877939, 0.16581934569781465, 0.16860978963301188, 0.17101808228595805, 0.17934015510972023, 0.18054648519566385, 0.16975994858552934, 0.1744292955801291, 0.17406028041682053, 0.1980520185951874, 0.18371687398977476, 0.1669698250656304, 0.16869685775923338, 0.1836218895270164, 0.1770559217210279, 0.1564281447307676, 0.557999556399664, 0.5253154377505769, 0.1680471876022671, 0.1973528173221396, 0.13784383014747037, 0.14474462367759278, 0.301941015025486, 0.1696326464168758, 0.16208114641365867, 0.16643662716651342, 0.33698870089228006, 0.4109048761642108, 0.21668616718408384, 0.19668721143704748, 0.13772658032210383, 0.20475379133456795, 0.14364440960981573, 0.1663109081838866, 0.1804284833246116, 0.18743561245016993, 0.19259330868128666, 0.17756967833642956, 0.18246834293747627, 0.17874359252417493, 0.18779317516682403, 0.1824230250536958, 0.061507859114722674, 0.0657086496166297, 0.06187765582311333, 0.05583157557666707, 0.07790303868413118, 0.058788143482464306, 0.06399203659787023, 0.06270036333999074, 0.06281460750021184]}, "mutation_prompt": null}
{"id": "76a1fdef-5395-4e5b-a3a7-a4e58fe67950", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "75ab6e43-49f0-47ed-a88c-0007c0f5fe33", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "3c702525-ed72-4bff-9276-4ada9d010793", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "d7f86838-2adf-4f28-8019-80a200b73d68", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "6a4d4df0-1043-4293-8c98-f37e0653454f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "4f8014be-1040-465e-8577-5b3980720bff", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "f7b9f472-86e5-4075-9530-55e1e10c3278", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.positions[i])\n                \n                trial_score = func(trial)\n                function_evaluations += 1\n                \n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n            \n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm and Differential Evolution algorithm that adapts exploration and exploitation via dynamic swarm topology changes to efficiently solve black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.6108889537676128, 0.6046268192394664, 0.652996407737003, 0.64803918563727, 0.6571405335262617, 0.6183280311814945, 0.6082952983185039, 0.6105122375175037, 0.6371653795560661, 0.2897505531726028, 0.26449562742564214, 0.18485843311890515, 0.24442105845598983, 0.037814177748380806, 0.2446412077379878, 0.26807377027793544, 0.05212076116409403, 0.3019296702971944, 0.07146440336933557, 0.10333084492361688, 0.12174103311987872, 0.09394363371375092, 0.11693949764099876, 0.09772231786647445, 0.12447960281027204, 0.077052734530339, 0.10286182328856408, 0.0971019043209399, 0.11412332440729167, 0.08483187728251562, 0.08639150704488252, 0.11676812106617585, 0.1042964429694393, 0.09654232628576898, 0.10996431259657946, 0.11536732272021777, 0.9777357947019015, 0.9851813807236549, 0.9838150450790234, 0.9685065801664521, 0.9756910076382224, 0.9688226562345548, 0.9844983625900214, 0.9775557290085704, 0.9850617454333188, 0.15755134595448106, 0.29804992543973396, 0.20079597781519765, 0.2126778210910777, 0.1381298519189973, 0.1379507630361182, 0.21134876693805105, 0.21230139517041602, 0.24405398039008486, 0.2078982563731282, 0.3056594599746514, 0.31513082094863754, 0.24326776271909367, 0.16042099424464085, 0.18967404510608687, 0.2056033841299244, 0.2423883581897993, 0.2546107064163625, 0.14620386924848316, 0.17382033529227647, 0.18150660350391923, 0.12712635297499342, 0.1485187910793333, 0.2968955609845768, 0.1453450460983391, 0.0961585832169154, 0.15047490938243713, 0.1641705445254985, 0.16811204259269674, 0.18784284048315758, 0.18040947248203998, 0.15881342210045335, 0.16905296025840122, 0.13094725261674744, 0.08834990514437635, 0.15595665098868272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031922357416295233, 0.002803171894648182, 9.999999999998899e-05, 0.01757208323120596, 0.02693926171729677, 0.08549682440104045, 0.06538967472617585, 0.16082661308756518, 0.007341861289549501, 0.012299468604263342, 0.07807938467852904, 0.07544981809324147, 0.05271319588580958, 0.032150251632145244, 0.07377931862758957, 0.057750811341920394, 0.033899094139150154, 0.058603710420672694, 0.09778093362712481, 0.04814003906931941, 0.12919966107850123, 0.04588090806296974, 0.10199938125191899, 0.04619884589312473, 0.05100413293930961, 0.10651455751618555, 0.14646036261264295, 0.16408588249974132, 0.11054504189789127, 0.07089468486194783, 0.09518794207130976, 0.07378187365528488, 0.4387149555326919, 0.4291799065081052, 0.4190544127761263, 0.4287360656214272, 0.43559102631748825, 0.4699064983217415, 0.46056061637196033, 0.46837130320620646, 0.41280650878334413, 0.09100362269078377, 0.11257043971975, 0.08490152500745485, 0.08521155035593908, 0.08163375773050541, 0.08432316103581106, 0.09861181190261392, 0.08835875200826704, 0.11164638957495587, 0.1593690399649984, 0.1279457760076217, 0.15219212042691255, 0.1518956069247248, 0.135142880664053, 0.15674731940658349, 0.13760232319423538, 0.13725929661930403, 0.14748134453131112, 0.3281775004021542, 0.3125037640587829, 0.3397483438496107, 0.2899445174326055, 0.28563816043442536, 0.2906806909735211, 0.31740867294836994, 0.29660516142868687, 0.2913198243055115, 0.21611489632548642, 0.1863033437719266, 0.21298072714649074, 0.17935655226123493, 0.2413360118203124, 0.21084132193738903, 0.24274112453024077, 0.26859132653475504, 0.15482033109860893, 0.17400920218736737, 0.1960444007214881, 0.18176549942143616, 0.18611465380835213, 0.17370467423481117, 0.19181466754710885, 0.1857216304303373, 0.17747469290712103, 0.17465351575759835, 0.20002929931833535, 0.21472062390634983, 0.20771975687126298, 0.1830405411027175, 0.23185695624832092, 0.1838103630567146, 0.16886907020072417, 0.17319051209044356, 0.18969668310670817, 0.18336254351802228, 0.16690828969215532, 0.7688811879909669, 0.16052301430697624, 0.1611098161736858, 0.1659688850007891, 0.6364383382473137, 0.15685465766745255, 0.13889632716768008, 0.2068714716062796, 0.1675558758165816, 0.1246540934787056, 0.3486222715372934, 0.3068531590657032, 0.3235029574128844, 0.16204570166697563, 0.10436988491054633, 0.41555081490569723, 0.18199873832702795, 0.18765755893824176, 0.17573945652520484, 0.17601638711688972, 0.22069563160730843, 0.17490936846891436, 0.18992558030078566, 0.1779901719043997, 0.17358894525036972, 0.06869100260995498, 0.06440581175292082, 0.07797907189398279, 0.07377690166753814, 0.07116122704467831, 0.0926706292106555, 0.06467896039945153, 0.0731013803516436, 0.07279728403319519]}, "mutation_prompt": null}
{"id": "07ab7333-275f-41de-bef7-225b647d5e12", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9  # Increased inertia weight for better exploration\n        self.F = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # New adaptive factor for inertia weight\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with diversity check\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.1:  # Check for diversity to prevent premature convergence\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid PSO and DE algorithm incorporating adaptive velocity dampening and diversity monitoring to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": 0.272554214535014, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "25394fce-c394-4345-bf30-378e4aa82975", "metadata": {"aucs": [0.7825144267322933, 0.7877247069662254, 0.7699644084296233, 0.7892730268335701, 0.18958097377221428, 0.8048650155708141, 0.7918882592106772, 0.7960619954846122, 0.7999561839709606, 0.03643404527325933, 9.999999999998899e-05, 0.5809249091424116, 0.041165727442456945, 0.04116279920658761, 0.5439765332795731, 0.6123019832247596, 0.5938521932164753, 0.6285517003756792, 0.16283385610719614, 0.1320891823068714, 0.1522479481237088, 0.1350839731324064, 0.145597250194745, 0.6200320250594599, 0.1468587580799322, 0.12260034038056744, 0.17108150988833126, 0.16161139782777045, 0.11567234419103511, 0.1421364036233066, 0.1293965773542035, 0.10611388358422957, 0.08722454252281009, 0.12564671030793628, 0.6327209926703579, 0.13206163369220847, 0.9858235531193961, 0.9902323294003548, 0.9869352185182751, 0.9807313469159475, 0.9819396075796222, 0.9730844955211564, 0.9907452793447761, 0.9904422009206381, 0.99003641531476, 0.5258133264268294, 0.5857094622785264, 0.5604324252861133, 0.5662326879576167, 0.15023242106498635, 0.14696883472651767, 0.12387642882472516, 0.5950947130616662, 0.518886621615188, 0.35696638839563866, 0.22022938960276195, 0.35160138393437124, 0.26499121781231694, 0.16100781634823214, 0.19077885333466005, 0.1481311934544507, 0.38143758332885525, 0.21986667743557287, 0.190938352158472, 0.2190826949659851, 0.1272969921324819, 0.12489184821150523, 0.18889547255724848, 0.3471442172227307, 0.24319213749874524, 0.194485149424664, 0.23859995680474333, 0.22057621812389783, 0.18257165576896872, 0.12176296625794403, 0.25774354418160694, 0.23109069923398395, 0.14320086590545766, 0.09833609806758081, 0.11670780776273604, 0.21795779333339904, 0.005810753500281263, 0.00027601094047224883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01296332180105908, 9.999999999998899e-05, 0.05436767306195345, 0.06056898574155478, 0.05539623743246014, 9.999999999998899e-05, 0.03972303770624419, 0.08760017751099736, 0.044756294484268655, 0.06214471981600378, 0.041665563122303184, 0.2164911666659306, 0.1391100289169721, 0.0417633000115295, 0.07967407607285093, 0.07708452806778754, 0.06596333603237059, 0.25891630964395607, 0.24841078682402928, 0.0857875431083237, 0.12502637832908636, 0.06274041771365158, 0.09834986419896086, 0.13573697557557773, 0.058995327077130066, 0.07023960530046802, 0.15906475466294667, 0.07628130555674417, 0.053953523022582384, 0.505989110501869, 0.5134090980089809, 0.5533491132321412, 0.49823295201045725, 0.516718016746551, 0.5211928226769964, 0.5152531704798188, 0.5704348889389691, 0.5308649937990527, 0.1090918854015046, 0.15229969920140285, 0.06548681940253986, 0.11758306519761097, 0.1080445158090646, 0.11563104963510029, 0.12445863043730132, 0.13407654335161512, 0.07358324434329355, 0.2168737656562083, 0.25317356909210287, 0.21975842716562788, 0.27699968173952527, 0.2618782506656233, 0.28649264837655286, 0.26341197374655356, 0.22783850619791213, 0.35509219185717555, 0.42532386453486115, 0.32657964796397176, 0.22058310530077097, 0.2947291055402801, 0.3852649601794955, 0.4950120810279518, 0.19413607389197773, 0.5377963490582192, 0.3547470978688757, 0.22468760766774876, 0.21193208865990987, 0.22364575838780887, 0.25600376401301606, 0.2684057627517191, 0.329758672294141, 0.15973052424102274, 0.30192784207570245, 0.1473676989177506, 0.1915455611619341, 0.17636476527119227, 0.21942908795465466, 0.23547394275157485, 0.1908409575665766, 0.21621840389310631, 0.2332765422124401, 0.2513132618852062, 0.24299340336974762, 0.197039656700428, 0.20605010057954054, 0.23447079214682587, 0.24015123841832298, 0.23235155636400573, 0.21110940272826006, 0.23929388186415768, 0.2032278477893532, 0.1961444634882643, 0.130828502460822, 0.1677379776498107, 0.8885305268957763, 0.16574474065842293, 0.15591490510845285, 0.16791330425062911, 0.12320254906724182, 0.16613279261245384, 0.13749706522779703, 0.20807838685138702, 0.16848022693413334, 0.5961219046158673, 0.6092489118579127, 0.12215336098305685, 0.4654417701549223, 0.16624433307858122, 0.10457137387567361, 0.4209433543929717, 0.2233791999492557, 0.20972760782326205, 0.18875822645334517, 0.19509081267969364, 0.18979004220271123, 0.19939203580040532, 0.19012742091785817, 0.20849645439786424, 0.1917183215840691, 0.09358047119971213, 0.09009351852408287, 0.09730501964236848, 0.08631665712976155, 0.09112805477146957, 0.086044073691252, 0.09374264854110281, 0.09624583070907333, 0.08026989246359206]}, "mutation_prompt": null}
{"id": "72de8b31-75eb-4121-a4d4-17f003338e0b", "solution": "import numpy as np\n\nclass OptimizedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Adjusted social component\n        self.w = 0.8  # Adjusted inertia weight for better balance\n        self.F = 0.4  # More aggressive mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Updated adaptive factor for inertia weight\n        self.dynamic_shrink = int(0.7 * self.population_size)  # Dynamic swarm size adjustment\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            current_pop_size = min(self.population_size, self.budget - function_evaluations)\n            scores = np.apply_along_axis(func, 1, self.positions[:current_pop_size])\n            function_evaluations += current_pop_size\n            \n            for i in range(current_pop_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(current_pop_size, self.dim)\n            r2 = np.random.rand(current_pop_size, self.dim)\n            self.velocities[:current_pop_size] = (self.w * self.velocities[:current_pop_size] +\n                                                  self.c1 * r1 * (self.personal_best_positions[:current_pop_size] - self.positions[:current_pop_size]) +\n                                                  self.c2 * r2 * (self.global_best_position - self.positions[:current_pop_size]))\n            self.positions[:current_pop_size] += self.velocities[:current_pop_size]\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions[:current_pop_size], axis=0))\n            for i in range(current_pop_size):\n                if diversity < 0.15:  # More lenient diversity check\n                    indices = list(range(current_pop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n            \n            self.positions[:current_pop_size] = np.clip(self.positions[:current_pop_size], self.lower_bound, self.upper_bound)\n            self.population_size = max(self.dynamic_shrink, 10)  # Reduce swarm size over time\n\n        return self.global_best_position", "name": "OptimizedHybridPSO_DE", "description": "An optimized hybrid PSO and DE algorithm with dynamic swarm size adjustment and adaptive parameter tuning to enhance convergence efficiency.", "configspace": "", "generation": 10, "fitness": 0.26746693081843165, "feedback": "The algorithm OptimizedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "07ab7333-275f-41de-bef7-225b647d5e12", "metadata": {"aucs": [0.8342572129185236, 0.8379963868612337, 0.8121707369804985, 0.8499304256686039, 0.8299665346694131, 0.833471000073279, 0.17456031180489207, 0.8230423817847011, 0.8248423298495421, 9.999999999998899e-05, 0.7490264405741613, 0.7408067643245542, 0.7245637262590168, 0.7110264340291681, 0.7303894148400758, 0.007680510992458922, 0.7286272687630211, 0.7383890573550285, 0.17680640550062143, 0.16655910699522536, 0.11788067024552307, 0.07472835730230398, 0.16583948169345297, 0.0734729599046603, 0.1425370991174656, 0.16202148948210127, 0.12982515344401746, 0.11284279108582818, 0.14599177171993682, 0.12952275501273447, 0.1257858788226477, 0.13124116977045963, 0.1399631656383895, 0.14929477823937198, 0.12758762434637483, 0.3228197602270788, 0.9885962862407367, 0.991945443242432, 0.9909680778261957, 0.9831743994499278, 0.9858525459489328, 0.9854819396816352, 0.992160118174541, 0.9919434433943042, 0.989653230008465, 0.05883456235232443, 0.5306990396617064, 0.4939000643895459, 0.4785715150085591, 0.1493980664660166, 0.24343614478734144, 0.12409383717000222, 0.46472099729420857, 0.44205615153165867, 0.1601640122623429, 0.2544454059954053, 0.2803804260646049, 0.19202433360110838, 0.18681878541082164, 0.19021052114940162, 0.7658098140528558, 0.23268432428117214, 0.7357589199495227, 0.23861153836150018, 0.1527529977416361, 0.16856523417597602, 0.13115613645997803, 0.15435882556501201, 0.2772225107418229, 0.1189962692333032, 0.1497006035534798, 0.16664179102831345, 0.12532171808261117, 0.192409916150872, 0.19692316720784175, 0.1237722507624276, 0.20645505707899847, 0.12765666090556183, 0.05534422413048834, 0.20628344496276751, 0.127935646845993, 9.999999999998899e-05, 9.999999999998899e-05, 0.005102303916408757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005459330846267929, 0.0510047186324224, 0.06430374836986053, 0.1340505535213271, 0.005952942276426287, 0.016958938887966513, 0.041353544988362634, 0.04620701197085786, 0.054465295653119083, 0.005178973309602597, 0.13265871461838974, 0.038576629351826486, 0.04653670348094474, 9.999999999998899e-05, 0.0723243701218953, 0.07403098178423684, 0.23296196664322577, 0.22186253075393347, 0.09303465307622805, 0.04036908494373348, 0.09664044028289975, 0.06832809975840048, 0.03731305835562759, 0.23813274686969899, 0.03635982838119345, 0.22289525569364532, 0.07491972054913165, 0.22551773956794408, 0.49958105363094096, 0.5194718553675155, 0.5144737132786703, 0.4944304364911293, 0.5227438097248587, 0.514258847049051, 0.514595342526951, 0.5331348975057211, 0.5347196618587133, 0.07638909776189451, 0.11424369815499635, 0.0642852050764251, 0.10681447929142818, 0.13343545957062874, 0.16200311906130394, 0.10428595308556521, 0.11927717783492664, 0.08700702226613632, 0.18597224064550277, 0.17862474874303313, 0.23001981494351964, 0.22190966649089872, 0.21516475684641823, 0.17295300417357518, 0.3211909231943001, 0.20376081614278696, 0.21899852407475107, 0.21399381784381044, 0.254095228316343, 0.21408243530837534, 0.2840510900077976, 0.31926603491120153, 0.31585463361803057, 0.40480300245502854, 0.29607082950976993, 0.4459116342108933, 0.1910429900677194, 0.08263121539689822, 0.191472811626609, 0.1725131074967694, 0.2892299117574909, 0.2806577088445942, 0.15522596834834035, 0.24988896387060722, 0.2525392127316366, 0.18337586428066477, 0.20248009321982285, 0.22188076795062484, 0.19440940809271412, 0.20476685510143056, 0.22272455990900886, 0.23537950483140058, 0.22545729129620706, 0.19513716358547395, 0.1948860276078418, 0.18990019255994206, 0.22017275324688268, 0.19155591874723743, 0.23178541346940196, 0.19895570482086955, 0.2168715418043956, 0.18794897353440798, 0.2119594323098538, 0.13055342603756692, 0.20589740884206753, 0.1944185383338899, 0.16773309859048657, 0.17650251309531506, 0.12218596596466491, 0.15851294858466103, 0.1750440701837297, 0.15952090641934336, 0.20913466521327917, 0.16806441493931434, 0.6691250513327165, 0.8617976080137077, 0.19631422149948097, 0.1678357858630789, 0.1630198509262678, 0.19780265469692593, 0.4933780368989821, 0.18347394285979512, 0.20425131521056517, 0.20516473217476683, 0.20327931083922346, 0.19059106104082135, 0.1943069316442546, 0.17999325180629644, 0.18792276666550234, 0.20953796320694973, 0.0787170256808436, 0.08451936905948787, 0.09224466821302268, 0.06499157886004814, 0.07754132288194082, 0.09106898283079568, 0.10040056946719922, 0.09023761816829667, 0.07829245196792345]}, "mutation_prompt": null}
{"id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 11, "fitness": 0.29641060516874246, "feedback": "The algorithm EnhancedHybridPSO_DE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "07ab7333-275f-41de-bef7-225b647d5e12", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "6c05c345-8243-4716-bcc4-465f24864fe0", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1_init = 1.7\n        self.c2_init = 1.3\n        self.c1_final = 1.3  # Dynamic cognitive component\n        self.c2_final = 1.7  # Dynamic social component\n        self.w = 0.6  # Lower initial inertia for faster reaction\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.95  # Faster reduction for inertia weight\n        self.mutation_adjustment = 0.25\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Dynamic adjustment of attraction coefficients\n            t = function_evaluations / self.budget\n            c1 = self.c1_init * (1 - t) + self.c1_final * t\n            c2 = self.c2_init * (1 - t) + self.c2_final * t\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               c1 * r1 * (self.personal_best_positions - self.positions) +\n                               c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.12:  # Enhanced diversity threshold\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved_V2", "description": "An optimized hybrid PSO-DE algorithm with dynamic attraction factors and enhanced diversity-driven mutation for accelerated convergence.", "configspace": "", "generation": 12, "fitness": 0.26633820674668546, "feedback": "The algorithm EnhancedHybridPSO_DE_Improved_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.9046015834961938, 0.9024711005169685, 0.8996476486373138, 0.9008916370461274, 0.899085416244924, 0.9050810438604315, 0.9064850348693414, 0.9120615314738058, 0.9024012718115428, 0.22376447603482896, 0.0750092920612282, 0.24745780568180376, 0.24391502587141112, 0.21232973531336963, 0.2783620425755582, 0.7926456345383606, 0.4447126267332293, 0.3459709068465171, 0.18673493629170046, 0.18161456104021267, 0.18369580316039846, 0.1322046840138419, 0.15857299411468262, 0.09194039349718974, 0.123852991047674, 0.13251902620113343, 0.11590857131054166, 0.09443957733643715, 0.1109135927758278, 0.1607515399845555, 0.06924833121419438, 0.09081972559841267, 0.08551394656746303, 0.09638861887116468, 0.1092170284752394, 0.11529072488695147, 0.9745579026523359, 0.9856168469355838, 0.9808630425492579, 0.9739787686104774, 0.9770758990900748, 0.9599617342346171, 0.9878873833370211, 0.9822248539976995, 0.9859553207337112, 0.17497131988936143, 0.5146961516450295, 0.30459429089233625, 0.3553131435337499, 0.3090726619322548, 0.25616783082961914, 0.6043005985449166, 0.3086079838020809, 0.45415020549094365, 0.22814792452938082, 0.17146145379439037, 0.22453929452698052, 0.20667504667244974, 0.21387761503707647, 0.19332360212726496, 0.15213781872569998, 0.9075829654435468, 0.2354471487496933, 0.13563469223332447, 0.1601217054673536, 0.1332687657621131, 9.999999999998899e-05, 0.21471252669142227, 0.16700326742855576, 0.1602815657864941, 0.16371261761665623, 0.152674621208703, 0.1610353411220532, 0.19866006574489015, 0.17599847226646836, 0.13472661100992223, 0.17258526333722224, 0.14854495504175824, 0.13099712205942482, 0.1287603813135616, 0.19940903488041628, 0.004452981773582221, 9.999999999998899e-05, 0.013880651999560123, 9.999999999998899e-05, 9.999999999998899e-05, 0.042355323671406375, 0.019986331125119938, 9.999999999998899e-05, 9.999999999998899e-05, 0.05362397662076723, 0.08100149328175954, 0.08266741649135889, 9.999999999998899e-05, 0.05807262624092291, 0.021133474205043412, 0.07097831773886787, 0.09746734771232912, 0.0225131633111334, 0.09223049558411989, 0.1232428768982683, 0.051382889569119516, 0.09623596313092608, 0.16282931591193084, 0.07917959677960151, 0.12072179391164262, 0.14653955659506324, 0.1480587997788685, 0.20795102871099158, 0.14052819604972266, 0.05717273483848917, 0.09686786201179143, 0.2799312058798803, 0.0716249936153186, 0.08355076895620406, 0.12449392629174305, 0.18566115337211564, 0.5397924541659942, 0.5721511129092369, 0.5146576355423393, 0.5737482472145441, 0.5409823517945602, 0.6348704584924465, 0.5944775106749305, 0.5286778017878174, 0.5781630143040267, 0.08248070978308841, 0.07354942543552734, 0.06611960777653436, 0.09340131767686466, 0.07942904828068109, 0.13178854210365976, 0.15509562367602703, 0.10125260006762637, 0.10864312002599186, 0.24867949415188806, 0.1999654373186408, 0.23053012370416093, 0.1878676744184946, 0.40311986157206414, 0.2385003945437325, 0.25301412408400015, 0.22182595647446146, 0.20548439348658398, 0.1861977384228075, 0.1909907660233352, 0.2636645476268519, 0.4275106356452354, 0.5264568103325504, 0.27757320669375707, 0.47318029514388105, 0.2937889053969117, 0.3411922437176086, 0.36278226135006353, 0.10359609674064851, 0.24967070780225498, 0.1406907071175152, 0.28257173503869537, 0.21721750470149048, 0.16929037752695442, 0.2634556305509762, 0.22196111006417418, 0.22038079237367192, 0.1947722231666884, 0.3006724300701742, 0.26806675869545027, 0.2166507876422623, 0.2324086827240328, 0.2458348798362585, 0.23425459288773076, 0.2315036044256139, 0.22636663135918822, 0.1992818507915416, 0.1953206185703229, 0.21163973821108317, 0.17947906650474688, 0.20007889990132377, 0.23002945945595998, 0.2087921765478773, 0.18663463054964846, 0.14823752369169452, 0.16885183032702622, 0.8740229397400466, 0.1851191508607991, 0.16759855131890433, 0.16865166397137255, 0.12341955815937322, 0.16709279881786754, 0.18601830306440503, 0.2124293607720994, 0.16971420110761049, 0.1273005812097805, 0.5451264833390528, 0.12761597475548514, 0.2938318246960049, 0.16859100957026607, 0.10514707240389687, 0.40817228348469003, 0.22784939682596028, 0.2182195367633316, 0.21651565319554245, 0.2076873085753096, 0.18228401115472392, 0.19024803425530834, 0.19939889815245893, 0.20997585160113086, 0.1893909990913354, 0.11112859562414468, 0.07599763644574908, 0.08311300139536093, 0.09772754144052864, 0.06761299868551429, 0.09060827954551443, 0.08910372370315633, 0.08874681964503794, 0.06940317548224817]}, "mutation_prompt": null}
{"id": "f4f759c5-88f2-4fc6-9aa4-3e3d3824d6d3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Gaussian:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Slightly adjusted cognitive coefficient\n        self.c2 = 1.5  # Balanced social coefficient for exploration-exploitation trade-off\n        self.w = 0.6  # Reduced inertia weight for focused exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.95  # More aggressive adaptation for inertia weight\n        self.velocity_clamp = 0.1  # New parameter for velocity clamping\n        self.gaussian_mutation_sd = 0.1  # Standard deviation for Gaussian mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity and clamping\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with Gaussian mutation\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + 0.4 * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    # Introduce Gaussian mutation\n                    if np.random.rand() < 0.2:\n                        mutant += np.random.normal(0, self.gaussian_mutation_sd, self.dim)\n                        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Gaussian", "description": "An enhanced PSO-DE hybrid algorithm integrating adaptive velocity clamping and Gaussian mutation for accelerated convergence.", "configspace": "", "generation": 13, "fitness": 0.16687638345395822, "feedback": "The algorithm EnhancedHybridPSO_DE_Gaussian got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.12.", "error": "", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.7287413102018341, 0.4462627868943937, 0.688526361418492, 0.4783097711870934, 0.41219753300092943, 0.4281319947587876, 0.38836170044593843, 0.36791599682175924, 0.6220157548759382, 0.17392130580473386, 0.16629092463393957, 0.18258434358709996, 0.26231810197735106, 0.5126297702830847, 0.19938625850332847, 0.02531014057092562, 0.33116966177765506, 0.10590486974728086, 0.1423032715446212, 0.08224050990004705, 0.08264961044926544, 0.0774456109376872, 0.08099283907193278, 0.09243883396432506, 0.14117354761167467, 0.09025818561776122, 0.11832558032079543, 0.10417072488921808, 0.08751363391811462, 0.133068304887776, 0.10044970881940385, 0.05433477570610501, 0.0853975936701139, 0.06190054675584944, 0.04398505337667957, 0.10068404569146683, 0.2851495424398348, 0.40096143525439654, 0.15774681378652333, 0.08971516087965614, 0.08796559528017878, 0.10569680783738711, 0.14840740691175103, 0.11820068823148178, 0.09694488747195151, 0.17469232498490705, 0.18981972582333184, 0.12218583216104284, 0.18057045805039273, 0.18881306114653462, 0.08196449274854001, 0.14521996866546105, 0.1847029784765194, 0.13969452999308818, 0.1910093133761146, 0.12823861349412868, 0.15934721407323482, 0.11546090132930986, 0.09788181110733729, 0.1961918859131806, 0.1522992444381429, 0.1551501731224777, 0.1456740348449117, 0.24531087598171675, 0.12922112226461435, 0.11680062398159008, 9.999999999998899e-05, 0.15177857325967148, 0.24213427445619828, 0.18655272654892396, 0.13567182097599084, 0.1789832523981606, 0.1103400585667419, 0.12271837208381131, 0.13480578599661242, 0.12431128493741506, 0.23642772805712176, 0.1484341254031356, 0.2384069300066075, 0.5995280153523864, 0.112002747432292, 0.011268308505085423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008425145871187478, 0.20588426359035783, 0.1366860090124672, 0.18085541985278464, 0.12491353629030488, 0.05770976539159001, 0.10459527117157907, 0.11496919121245641, 0.11586178037547379, 0.09280892116224748, 0.12293864185222225, 0.07368335048271402, 0.13372681970716804, 0.04412820435554754, 0.07708284686409606, 0.03291037328608415, 0.18730126225053978, 0.03734040065268396, 0.08245235700945008, 0.062016650156989095, 0.029974561064064265, 0.04106764678858288, 0.048159451553858146, 0.23668206262824687, 0.034414464074434714, 0.03643252781938622, 0.041668529200522775, 0.10892823301259924, 0.32068939397915874, 0.3713569401865471, 0.3862299494181053, 0.32312324583053, 0.2995669776909248, 0.3680845264803605, 0.4494681670140558, 0.36882111315974575, 0.4085535727771711, 0.07879050198461357, 0.07358521168689292, 0.050185133178372365, 0.122763207658669, 0.09371419126897962, 0.0780550842991743, 0.09416110583553527, 0.06406557124187184, 0.049968672391379365, 0.12856540817051954, 0.15956843663716447, 0.17639333961649095, 0.16816669617399949, 0.16270465231840825, 0.1625530332285402, 0.12698243283660104, 0.1548099694543884, 0.15325050300007803, 0.1692444804867297, 0.21518096504009365, 0.1828965871921493, 0.16864968716847883, 0.21062805641629256, 0.24124983995281168, 0.2071968378056409, 0.20142578052622928, 0.1593324326347303, 0.11882396993701172, 0.07848711443607903, 0.2001917295835709, 0.13407178976477885, 0.2030193624018275, 0.1896226254563147, 0.12341210228398436, 0.17878844395099802, 0.1736151734222563, 0.21488190444617972, 0.21611698487197162, 0.21300431596960478, 0.22318998547186142, 0.24383660495640025, 0.23288920416684322, 0.2151598796954287, 0.22783062769232276, 0.2278265778233517, 0.16813384086698047, 0.16550363509041055, 0.18852101574382263, 0.16735233228689572, 0.19129975833385482, 0.23352251143627134, 0.16576356775606982, 0.1937165848931881, 0.19115170941024184, 0.15000775566457158, 0.15223378813558375, 0.1626909372564791, 0.16283651494224027, 0.12967286760928687, 0.21666548129129637, 0.12233455218346845, 0.12105805851570728, 0.14022311769266926, 0.15306924772865205, 0.2191791175952731, 0.14638076443003012, 0.339503117567039, 0.15851404747230757, 0.17911886418868184, 0.16098733236278495, 0.09214173098944523, 0.19302302897808987, 0.20142134944377632, 0.19240488723361449, 0.1741671005483879, 0.2268875022572926, 0.197329878872899, 0.21825327783062853, 0.19236662876823407, 0.19493372308296641, 0.2006437963732245, 0.0731160032661965, 0.09456404840854504, 0.09707854844897124, 0.08675166065333106, 0.09150243787081103, 0.08108265597553854, 0.08353693277867902, 0.09084005227992276, 0.0809327821054574]}, "mutation_prompt": null}
{"id": "7bb78d43-0fb9-4ec5-a6a8-ced2cb27e421", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "976c2072-5076-43fe-bf9f-1e9588c868e6", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "249a1382-3f63-44bd-beb0-0940fe0bcdfb", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "3f58916c-85a6-40d7-95e3-aa62093ca5a4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "a0dcd504-d09d-4d9e-b304-f0a74f7d7aa0", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "d2ed52a9-bd68-4024-a95a-dfa24bc6019b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "ce3fe933-17fe-4bdc-a4be-ddf7994192c0", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.7  # Increased cognitive coefficient\n        self.c2 = 1.3  # Decreased social coefficient for better exploration\n        self.w = 0.7  # Reduced inertia weight for faster exploitation\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Slightly raised threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Improved", "description": "A modified hybrid PSO-DE algorithm with adaptive mutation scaling and enhanced personal-best re-evaluation strategy for accelerated convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.8621772597714059, 0.8574569176523298, 0.8671540221238623, 0.869433390488679, 0.8677948003878011, 0.8641070770157119, 0.8573767647185337, 0.8693815328529115, 0.8626111999902126, 0.08863049709849347, 0.7453328841351773, 0.7295230500870947, 0.5763733636198312, 0.7476740477507973, 0.7765861709779325, 0.16966245484889608, 0.7553880659480834, 0.5820050876652975, 0.14104117768435298, 0.18089782607415106, 0.1506769535351854, 0.12960711632010247, 0.13859762387727115, 0.15800156672287413, 0.15741211284610912, 0.1101462740693776, 0.1437662662566761, 0.14342642105405246, 0.15897291001185765, 0.11403143503745372, 0.09099482309658524, 0.13683265027802505, 0.10850272249437365, 0.1037323641138268, 0.11521687331818686, 0.14189857678553874, 0.9724973634976765, 0.9860569560431516, 0.9846814563986265, 0.9734258261679101, 0.9776858128660214, 0.9642105199576789, 0.9880074727053756, 0.9858808832643866, 0.9861480682095923, 0.6073725114264062, 0.719396152750082, 0.4995650887791355, 0.7185590487042939, 0.4025201008138468, 0.687684111064408, 0.6488607675410138, 0.7177897814391898, 0.7137301919594453, 0.13040136347044629, 0.17148811325285584, 0.2127982698352796, 0.20725438686401187, 0.16036920509547492, 0.1728806964607218, 0.15005260694574685, 0.35159434613736174, 0.22156989591473042, 0.1631813560815012, 0.20107858263376288, 0.12712664913167626, 9.999999999998899e-05, 0.33343149118143833, 0.1844135344896375, 0.3436691401474653, 0.15765258029439533, 0.1583818284275179, 0.2093758439188621, 0.1299110900318161, 0.19728201452648852, 0.18603925773226104, 0.1514622300707471, 0.14572988179404223, 0.15812144300902287, 0.12388134698709452, 0.2188240777390411, 0.015617710912904648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0462088535045998, 0.04895798365524373, 9.999999999998899e-05, 0.013166510065917958, 0.022397658083621708, 0.1157889579565301, 0.06276526800566551, 0.016382140546832624, 0.08942904649520678, 0.027692575466325753, 0.07855535743335584, 0.06285903010123328, 0.11544612468212267, 0.07306783950306295, 0.19563513245975384, 0.07452819952564116, 0.09106578711139446, 0.14968120398011175, 0.07378244509500853, 0.09654141753732859, 0.1640657721795724, 0.47883087412507597, 0.10647280327609987, 0.14665197636100002, 0.0318773604406517, 0.056872238891933935, 0.10525450025607097, 0.1296351630987227, 0.08172943176797276, 0.08201102637453639, 0.24982850912293475, 0.583018938455089, 0.5838631106086457, 0.5968551814062042, 0.5522017658376099, 0.5619862474608808, 0.5310490674060042, 0.5703965541012022, 0.5853092749173792, 0.5791423555263269, 0.06902612474199399, 0.10427225270789986, 0.11304562436132948, 0.07926600281839968, 0.12041353847781577, 0.15467814886775433, 0.13080186790566217, 0.1591132487068897, 0.11405768525913695, 0.493961314910109, 0.1289415741285156, 0.2909376156747666, 0.18863172626522384, 0.2504579310358541, 0.1927870544318474, 0.16948323570344925, 0.17383772066532, 0.29173944093470117, 0.38058157871242315, 0.20482076173966524, 0.32218382032048176, 0.451579057861658, 0.43374528063057316, 0.5240518838044166, 0.5529429579263417, 0.6707343148121744, 0.5804935298619273, 0.3482545204378602, 0.10015356955118437, 0.2852624244949924, 0.17974558875395452, 0.3355842440286658, 0.26138716092946823, 0.16086351289836953, 0.2858059735872862, 0.1803458429183965, 0.2016565934082568, 0.24951585118250796, 0.24232130493696635, 0.2363473063332987, 0.22824894953974006, 0.2318820951631616, 0.2404196102464352, 0.20533791853400463, 0.21687856113636816, 0.20100280209330101, 0.2519420274182549, 0.25141309656762956, 0.19936489656604195, 0.2011199722267636, 0.2255296922611666, 0.20856296634034166, 0.1984532605007463, 0.1788348110606348, 0.1311177309987821, 0.16849104383181224, 0.9268967770489203, 0.11936583335671203, 0.12610756808986756, 0.168228399649628, 0.5226214420431343, 0.17652388106132333, 0.16803305636833998, 0.2111763861368291, 0.16980458501718843, 0.12739623407500567, 0.5302612776895421, 0.12622159710604897, 0.28434459064655593, 0.16823672692183378, 0.10501756277987928, 0.5555065356497142, 0.1983483498789288, 0.19424288254415978, 0.20774300492446607, 0.21108551595738378, 0.17597245418570606, 0.18522741494099715, 0.2269672119265812, 0.2107866559317677, 0.20981766576476146, 0.08319358991847314, 0.07639928537003671, 0.10752599762860604, 0.0984933383378448, 0.08560232783471566, 0.09447395003870096, 0.09812157894190365, 0.08974166438357023, 0.11108773288006324]}, "mutation_prompt": null}
{"id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 21, "fitness": 0.2965109021421226, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "376512f7-4cb8-4c69-b8d4-cde95c070ba1", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "fe2d01d4-7f9c-4c70-b5f3-03adb6222631", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "89c83e81-335c-4c56-a790-bde483ad1cff", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "c81a1e6b-8429-412f-8756-64a30ee7c9d4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "c11fb93e-38a0-4043-b033-7816340bb5c3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "9e912513-0aab-48b1-9e05-3502bda9160d", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased population for better exploration\n        self.c1 = 2.1  # Further increase cognitive coefficient\n        self.c2 = 0.9  # Further decreased social coefficient\n        self.w = 0.5  # Further lowered inertia weight for faster convergence\n        self.F_base = 0.5  # Increased mutation factor for better exploration\n        self.CR = 0.9  # Increased crossover rate for more frequent updates\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.abs(np.sin(np.linspace(0, np.pi, self.population_size)[:, None]))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Refined", "description": "A refined hybrid PSO-DE with enhanced chaotic initialization, adaptive parameter refinement, and dynamic diversity control for accelerated convergence.", "configspace": "", "generation": 26, "fitness": 0.27176095864096655, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.887580647304737, 0.880897661268074, 0.8783158065922496, 0.8769207728428462, 0.8768033681660291, 0.8699408947418381, 0.8821527880203187, 0.8796792417878879, 0.8821960027982332, 9.999999999998899e-05, 0.1137566369266444, 0.7473945852180657, 0.1790429362013436, 0.705792666447751, 0.7644028931530235, 0.07234891737216587, 0.11833587076332641, 0.6717840222286846, 0.1370514738514894, 0.18289883204944768, 0.14127254802314215, 0.10054382379567306, 0.1161024390545925, 0.13138576673038826, 0.1755032179403062, 0.11698737198587039, 0.1599813871515029, 0.09897592059873184, 0.10633112532371924, 0.1089594758089999, 0.1172792588074455, 0.1591156507200594, 0.10590648238829403, 0.12983381275823935, 0.1141940753600389, 0.136843105048007, 0.916459228839666, 0.9730111827632439, 0.9060399627046034, 0.9254006827118151, 0.8839104812359783, 0.22691312816587128, 0.952523344736856, 0.9711519692381694, 0.969523358356754, 0.29699976433398256, 0.27079411320936286, 0.5803353009413259, 0.6684161153871131, 0.4053518548540447, 0.35690589700214337, 0.46056473166822, 0.14406126977152922, 0.16945972330289172, 0.873044666799607, 0.1380311909981239, 0.22868809876026774, 0.211755151418361, 0.1930310484984208, 0.15851174648480215, 0.23010324098227675, 0.12732213853448537, 0.1813076857995658, 0.1492058765093841, 0.1634585365699437, 0.13159465723209018, 0.19174293480894877, 0.17149660801083233, 0.18096315116559292, 0.2069181650803581, 0.13150186065717628, 0.16803816690544282, 0.12987894230972197, 0.22381966494265937, 0.18891357386950935, 0.15525562319045438, 0.16240149720882469, 0.1342183547801724, 0.13102899701416604, 0.15496939110528352, 0.13552948069247794, 9.999999999998899e-05, 9.999999999998899e-05, 0.06204417673351381, 9.999999999998899e-05, 9.999999999998899e-05, 0.05441391839448184, 0.10573352926691337, 9.999999999998899e-05, 9.999999999998899e-05, 0.12439858750950283, 0.07848833093331142, 0.11554197429416513, 0.06757700932832378, 0.03741825974286239, 0.049842832014238225, 0.034057030900773166, 0.08733810794787311, 0.023993558043160945, 0.07830760275922088, 0.07977493764031529, 0.21020624117834108, 0.09361195656686216, 0.0938909278956962, 0.11488749601897763, 0.11457948335915824, 0.09650666843342393, 0.15872157823119382, 0.0769626337774445, 0.09845266066830938, 0.18619638692130558, 0.15514653236486142, 0.045373201035080135, 0.18628479940337417, 0.09837689358357926, 0.22635581253208947, 0.11867429094620874, 0.5627374244326384, 0.5891247402756906, 0.5378137891406836, 0.5729987309749038, 0.5440766770381356, 0.5598893809383806, 0.6039971771048287, 0.5901042340504303, 0.5886140951326926, 0.09625965397528657, 0.10457340415456107, 0.09351946199992867, 0.17883665678395677, 0.15888945684975753, 0.14361812084657954, 0.15607795405849734, 0.12405211633625823, 0.1382146852662649, 0.40802263040967124, 0.26731019347684304, 0.1761466380995127, 0.3353964959564584, 0.25001965073449806, 0.28793592571496707, 0.19174185520502318, 0.253104011620054, 0.18332742901125698, 0.15701293768077562, 0.36514986844298514, 0.36763336345111286, 0.20952834299674172, 0.3938106182646657, 0.5580577570885901, 0.3899460829268978, 0.2762110994497837, 0.25210537128050614, 0.36094990049328257, 0.23140260731653184, 0.28675091736669955, 0.13935320264173, 0.26861705035543615, 0.2437984651358578, 0.4488164647408658, 0.3355095157184813, 0.21162076611293779, 0.2081724698978511, 0.2542646462834427, 0.24147162061743987, 0.2391939235573185, 0.22789443547984334, 0.19920819564714198, 0.25421537768772073, 0.23818265404084127, 0.2707507507866693, 0.22227831051979352, 0.19694847716792951, 0.20027011826854368, 0.25043563373454614, 0.1998248741487525, 0.2259244700993639, 0.20393432058117156, 0.25140765963765466, 0.2246138216820548, 0.18787712097192522, 0.9292480111935493, 0.18848126436429957, 0.164540348007164, 0.19862585948262979, 0.16863534152367188, 0.15417459842286663, 0.5741511898386538, 0.17417166330172473, 0.6313344556382181, 0.21361921205543155, 0.16706284888728784, 0.2128994240487082, 0.10512012050181019, 0.2127255195683676, 0.16785757298820203, 0.1680342318178386, 0.09444997368462227, 0.2013728787837945, 0.17598819131767685, 0.19774557273511817, 0.19565405827236837, 0.1827261157492991, 0.22247821045258553, 0.1918221612455554, 0.18410754639091165, 0.20958158027354312, 0.11781147284509552, 0.13955092957123527, 0.0866007195102918, 0.08414184776076783, 0.10153679423372564, 0.09747886343089662, 0.09027942405535416, 0.09569082413084418, 0.08020098129676734]}, "mutation_prompt": null}
{"id": "dcccdb4c-5ff5-4e6d-8551-d1db1437e032", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for better exploration\n        self.c1 = 1.5  # Fine-tuned cognitive coefficient for balanced personal attraction\n        self.c2 = 1.5  # Increased social coefficient for enhanced convergence\n        self.w = 0.7  # Slightly increased inertia weight for improved exploration\n        self.F_base = 0.5  # Adjusted mutation factor for DE\n        self.CR = 0.9  # Higher crossover probability for effective diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None] * 0.5)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Increased parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined hybrid optimization algorithm combining enhanced PSO and DE with chaotic initialization and adaptive strategies for improved convergence efficiency.", "configspace": "", "generation": 27, "fitness": 0.23826610721204525, "feedback": "The algorithm RefinedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8048472888948691, 0.7959058302771622, 0.7682179810808774, 0.7771079242098466, 0.7398214596573905, 0.7617724900137974, 0.8007263682468974, 0.7922471541805907, 0.7729416830921756, 9.999999999998899e-05, 0.47000572041704025, 0.04813653057082479, 0.5912255915302576, 0.5643543712637148, 9.999999999998899e-05, 0.2753328701342581, 0.634300144350876, 0.0473472131149798, 0.12350326439701875, 0.07531189275443995, 0.07136767240135866, 0.060118348636222785, 0.14406512268240934, 0.10210240049102925, 0.09236634386887799, 0.12025740278657104, 0.1387633948909548, 0.0845962274218871, 0.07794104838427318, 0.09139835252674056, 0.049569433080422276, 0.012685447333424804, 0.026531925775389764, 0.04611968647103626, 0.031181624954788822, 0.07523037672717636, 0.9663232753295055, 0.9837789157634089, 0.9771419139576242, 0.967424287086675, 0.9664172932520712, 0.9822465654800981, 0.9828406657050598, 0.9885742552967737, 0.9838410771797573, 0.6047903829437093, 0.2817697606495715, 0.05929006370406664, 0.6301158175123767, 0.5402960746741671, 0.4919649068701084, 0.08976046940858418, 0.12416062858600596, 0.40947747119014033, 0.666551319533766, 0.7955252617500381, 0.21789995509409277, 0.18992562370042876, 0.2622473561910943, 0.18642304526817166, 0.12343090517938415, 0.7649344134871531, 0.09018087561591914, 0.1510656899266487, 0.183211522723134, 0.1991265342044043, 0.21217742513967508, 0.10574333179728634, 0.15933819441502073, 0.166910594245539, 0.1541211840262966, 0.16931145075437726, 0.18655866717696046, 0.1419385517022107, 0.19709992550231104, 0.12067540900146045, 0.08198676591753595, 0.15626595722933434, 0.19817749739991852, 0.1371735576964671, 0.2155435815676966, 9.999999999998899e-05, 9.999999999998899e-05, 0.011918114613142072, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024542735001522153, 0.06686324227840157, 0.053279821429978225, 0.005414827149751722, 9.999999999998899e-05, 0.05536478698239555, 9.999999999998899e-05, 0.04838646320968221, 0.012092836067792323, 0.048065786105244146, 0.028321840622238192, 0.010767540599746606, 0.02475528903718982, 9.999999999998899e-05, 0.06002813556906872, 0.004485424842430752, 0.15276614506982478, 9.999999999998899e-05, 0.2731350838077159, 0.07150443771116011, 0.04571946372292457, 0.010736741583937115, 0.006275268108259846, 9.999999999998899e-05, 0.0028764956280156184, 0.07671601070225298, 0.21521673326509694, 0.09845314464564603, 0.5042943489653439, 0.4760895277247801, 0.4474113669540646, 0.473627201506154, 0.47826577007346016, 0.45001671184389214, 0.49554613276277026, 0.402302882279701, 0.5288635138046025, 0.07073150147900853, 0.05760769690677792, 0.023502258297822154, 0.10202143885120674, 0.13394956639256417, 0.14824957602540667, 0.10463110389435426, 0.10898711383760695, 0.10524630474145047, 0.22710240153874162, 0.12351725541708747, 0.2641869022836123, 0.24788723554644854, 0.21795155295009594, 0.17445789086741292, 0.10385674904034226, 0.1758478422294133, 0.15449285148151015, 0.4432551264407376, 0.5037393233034326, 0.2438382464464055, 0.30295162947054144, 0.15981576346745607, 0.41431616454296527, 0.1371618821353865, 0.4619696292977433, 0.3488418947576757, 0.14160596074027743, 0.36726220113204067, 0.2156847836476823, 0.21870461731940471, 0.18338462118764376, 0.3131464958805409, 0.07865712116808021, 0.29130854700406883, 0.14647275559539708, 0.1773169181876192, 0.19707236309600307, 0.21362150293630222, 0.154592760808546, 0.17636666474350005, 0.22721353129196475, 0.20409530545150123, 0.2146232960365747, 0.16219969296313796, 0.1648470955640181, 0.16438018004888655, 0.16648428954833505, 0.2084210459381839, 0.23221375849567105, 0.20468945337840017, 0.2026987765194348, 0.1908663810923159, 0.20126976969646626, 0.14917932812044088, 0.18165579399766996, 0.1871726524770455, 0.1299214854179399, 0.193384535644873, 0.1676418242027825, 0.13036249516782172, 0.13992137044238295, 0.17082367625349448, 0.17193482624058365, 0.20974444246721868, 0.08228361333319012, 0.2651937977810006, 0.15043005169169243, 0.4624995853084194, 0.09265097647778908, 0.1037631590073752, 0.14232372892316292, 0.17197131627024442, 0.192604293193964, 0.1918561087358036, 0.17906960888540813, 0.1819758725666163, 0.18548451238227204, 0.18328288443280794, 0.17875220638320244, 0.1978941351772694, 0.07657720388304534, 0.07644232054128208, 0.09291278680521586, 0.08344695218047504, 0.06019981519480311, 0.05889942395022141, 0.09948429102049738, 0.08757878447183443, 0.06017967653292833]}, "mutation_prompt": null}
{"id": "65b0c45f-3efa-4a4f-9458-fff47d59874e", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "d2a291bd-e07b-4c22-a99c-bba913007666", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "8083b1ce-2f43-4a8f-b496-778adda9a0e4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "36bbb3c2-cd1b-4cea-83bb-2f505e3baae2", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "2f371ad4-d1d3-46cc-981c-56a89bdd41a9", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "da9452fd-1681-459f-a0fe-9256565255c4", "solution": "import numpy as np\n\nclass AdvancedHybridPSO_DE_LocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population for better exploration\n        self.c1 = 1.8  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 0.9  # Adjusted social coefficient\n        self.w = 0.5  # Adjusted inertia weight for better convergence dynamics\n        self.F_base = 0.5  # Slightly increased mutation factor\n        self.CR = 0.9  # Slightly increased crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive inertia weight\n        self.local_search_intensity = 0.1  # Local search intensity parameter\n\n    def __call__(self, func):\n        function_evaluations = 0\n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + 0.3 * (1 - (scores[i] / (self.global_best_score + 1e-9)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n                        \n            for i in range(self.population_size):\n                local_search_vector = np.random.uniform(-self.local_search_intensity, self.local_search_intensity, self.dim)\n                candidate_position = self.positions[i] + local_search_vector\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                function_evaluations += 1\n                if candidate_score < scores[i]:\n                    scores[i] = candidate_score\n                    self.positions[i] = candidate_position\n                    if candidate_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = candidate_score\n                        self.personal_best_positions[i] = candidate_position\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "AdvancedHybridPSO_DE_LocalSearch", "description": "An advanced hybrid optimization strategy combining chaotic PSO-DE with local search enhancement and adaptive exploration for faster convergence.", "configspace": "", "generation": 33, "fitness": 0.2566982347753341, "feedback": "The algorithm AdvancedHybridPSO_DE_LocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.7905491869769112, 0.7995894868168393, 0.7956265986628962, 0.8162331978446011, 0.7813472284163767, 0.7997950982539117, 0.8182949691391952, 0.8077789881703893, 0.8143959261129503, 0.15261903353677386, 0.5221171058386469, 0.21086783180016355, 9.999999999998899e-05, 9.999999999998899e-05, 0.2532223498801983, 9.999999999998899e-05, 0.05430703568917927, 9.999999999998899e-05, 0.1372509042376041, 0.14530617699681847, 0.11081560120885692, 0.08851224030275373, 0.1267923297972775, 0.09255137034912242, 0.1609425276266847, 0.1697985466519778, 0.14040832130035197, 0.07593629453985473, 0.07623334565092177, 0.10196095531307237, 0.07432354323004453, 0.09000592197546975, 0.10422107368230149, 0.10319724091353233, 0.09598614200689115, 0.055152152976961744, 0.7851445757640789, 0.9464633319738998, 0.9033798724489437, 0.9336296447158247, 0.3816448239477749, 0.8897807665124629, 0.9618478250333892, 0.9022066095968898, 0.9554531146399404, 0.4979036696785635, 0.4795369401400582, 0.5329674679795902, 0.46272676025712356, 0.39511097325812616, 0.4402374983084276, 0.42482365155883883, 0.4180510794706567, 0.25606815685758477, 0.14699376245708407, 0.11133158728989678, 0.22212023664660085, 0.20156568093356886, 0.36411576721293626, 0.2623698711202046, 0.2047734343607699, 0.15283678555995206, 0.17556520018763933, 0.16540243250816733, 0.17830033330835537, 0.18267124845703542, 0.16303331851554104, 0.20365819629311144, 0.18375148055583312, 0.20396901278054136, 0.00020667724988565617, 0.17519581693574005, 0.1357059579928802, 0.18333634511777386, 0.22086340480256572, 0.15119675928450194, 0.12429839775471396, 0.13197395845544801, 0.16299350097536258, 0.16082596923869408, 0.1906883600900825, 0.031849301786270545, 0.007213649536737421, 0.061308276775868364, 9.999999999998899e-05, 9.999999999998899e-05, 0.03702859509376755, 0.06556315654468725, 9.999999999998899e-05, 0.0869751591394532, 0.12092985142872037, 0.09337274414395436, 0.07690408164403983, 9.999999999998899e-05, 0.03447909958696904, 0.052803604193962794, 0.01688855520814836, 0.03213117374509944, 0.037222685341770756, 0.20875054876575683, 0.13904479785839718, 0.07612827217781237, 0.0790459110839834, 0.13642058371031907, 0.17327605347230635, 0.11251904787675826, 0.1904813991196702, 0.1385659601341691, 0.14969729932565023, 0.05836214332302769, 0.11401610902758152, 0.06592541218581993, 0.06933105871047174, 0.15507159902670242, 0.2906768432411323, 0.12634397944550146, 0.0776344438848171, 0.542071902386233, 0.5564427889850964, 0.5308835249463464, 0.5291298269776854, 0.5128363522366053, 0.5558015644549721, 0.5791150816088109, 0.5363070037951438, 0.5300903144486235, 0.07659140239646989, 0.1303634266203133, 0.12572146402209816, 0.10243139607448848, 0.11299477999399532, 0.10657888207940269, 0.1045603040409867, 0.07530680757380126, 0.1016296478853892, 0.331915404504183, 0.33141174027931186, 0.23594009872949395, 0.1836544759890817, 0.35275537748660213, 0.17379905626969394, 0.17940828806242592, 0.25440998952325977, 0.22112341588275441, 0.31699583407616727, 0.18588280389628498, 0.384921356862297, 0.2204068228411581, 0.49517471074942354, 0.5067698954148808, 0.4699341106362541, 0.26632980577879284, 0.21862184556011566, 0.22587250200554143, 0.22906072739420058, 0.1730947421633544, 0.31807580381905687, 0.21530349139354343, 0.36256425012513316, 0.1469880990680814, 0.21297676265372445, 0.13097730533605467, 0.2452456164703336, 0.20908260686452929, 0.23244474756878308, 0.19203979659542514, 0.2105746748964663, 0.23349437675050455, 0.22893813969386723, 0.184037031758159, 0.1916858667214587, 0.21796637594722856, 0.19023828383666064, 0.20250229501659633, 0.1959712937253183, 0.7184942077573347, 0.20500324792053626, 0.22052750352779849, 0.21761839601768984, 0.18434920089163576, 0.12731931978990474, 0.16673769097968272, 0.8918320374365931, 0.8893407055108473, 0.14986849188584206, 0.15555311713949793, 0.1616410350177273, 0.1656528396277045, 0.15707014373264172, 0.09458096016536655, 0.4993507013981211, 0.4377702567403243, 0.3304212262328968, 0.4791218259771748, 0.20862997328689714, 0.16771554254455678, 0.4262346814441319, 0.09360550659619948, 0.18285099479073597, 0.2056147390686942, 0.18631155257596488, 0.18770697251227064, 0.1749465681958483, 0.17286033532357437, 0.22311741009294828, 0.20286450670713008, 0.21150130348377083, 0.08699902309035967, 0.09816056410567053, 0.1059549355117615, 0.09486998524163626, 0.11533502704121179, 0.0881952935370004, 0.0942745374185322, 0.07704509279435967, 0.09270458482101152]}, "mutation_prompt": null}
{"id": "577dd4db-bc44-4f4e-a67a-1ebec69ad942", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Levy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.8  # Adjusted cognitive coefficient for better personal exploration\n        self.c2 = 1.2  # Adjusted social coefficient for stronger global attraction\n        self.w = 0.7  # Slightly increased inertia weight for better exploration\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98\n        self.mutation_adjustment = 0.30\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities + self.levy_flight((self.population_size, self.dim))\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Levy", "description": "A hybrid algorithm combining adaptive PSO-DE with chaotic and levy flight dynamics to enhance exploration and convergence speed.", "configspace": "", "generation": 34, "fitness": 0.15714545993163423, "feedback": "The algorithm EnhancedHybridPSO_DE_Levy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.2503564761411624, 0.251361580166789, 0.27098520586926667, 0.2699152982622943, 0.24468061379997585, 0.25888893595218687, 0.2728665112654689, 0.2574278009433798, 0.24999900517943308, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08024588503027663, 0.06875755154194862, 0.06887399778483705, 0.07127795640136336, 0.06797455427674481, 0.0871666534540525, 0.07815473663250627, 0.07920982278932531, 0.063426489677885, 0.05610363254859241, 0.07200541874912614, 0.08377741697674623, 0.05126610311156832, 0.047915876122904044, 0.05845607831006727, 0.06208488680293034, 0.07262695488527948, 0.052735773483893134, 0.9836526574420041, 0.9820386761871289, 0.9803420120112749, 0.9728921596046375, 0.9678833812059777, 0.9839254535135998, 0.9850550617113715, 0.9888487644147459, 0.9815836622707389, 0.13538274915833348, 0.13540081304317264, 0.13242075845268142, 0.12110875646816455, 0.13711330840688474, 0.14637282728863465, 0.15648166012988762, 0.19480233372572286, 0.1428713473117097, 0.18580714846392699, 0.17398701827663987, 0.17327084866453102, 0.19750323826030403, 0.16626401621409337, 0.2286091533281378, 0.2055889616377321, 0.16230926820773262, 0.20034713384560254, 0.07829946727656001, 0.054056594202654185, 0.06174745481562838, 0.06972295707812248, 0.047043974146573464, 0.0723568308034157, 0.06665702808281349, 0.04552481742786407, 0.061867200587763405, 0.06912008567400296, 0.06412329868149813, 0.061021809773544766, 0.04217500892920467, 0.05934604838463742, 0.053211554805697614, 0.008390895715821856, 0.065639777446584, 0.05312390266575562, 0.0013764489535693647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07704716978190884, 0.05029833332115563, 0.03672627636044978, 0.08702167787603199, 0.033397824585109426, 0.021320069250765794, 0.03371077966104208, 0.052947261408916924, 0.06903537187946474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016679573160913952, 0.017116281876005113, 0.024160616936885315, 0.006694022835420199, 0.02548608249696771, 0.0232269982392036, 0.012200265939649069, 0.024163164130279968, 0.019604097227459705, 0.25135829342067884, 0.24809476171253786, 0.256846965209942, 0.2595515425620777, 0.25511528336904, 0.29460713808575334, 0.23958335309363843, 0.23461294919654918, 0.2630426221450033, 0.07828968097483191, 0.07818797435444558, 0.08053234611019378, 0.07468172931213335, 0.08163498260620328, 0.07180509078641995, 0.05924345482044302, 0.06556945720011664, 0.0729487628614559, 0.14849667291877922, 0.15075535249980387, 0.1552561263123423, 0.14425741977215367, 0.13614368297806845, 0.14898174679235932, 0.14095438724046094, 0.15570842420550124, 0.13788792939978411, 0.19650258400236242, 0.20683077712734044, 0.1932511696888881, 0.17690602632683605, 0.1780325242205799, 0.20225693270356238, 0.202185782213664, 0.19822060752685788, 0.2006681051829281, 0.1470593400989817, 0.1502677685863255, 0.13881759975121366, 0.12841613585808986, 0.14164357769318903, 0.1326966854074566, 0.15063735671258038, 0.1492245551730499, 0.15198253688771035, 0.20170879136320352, 0.1885061579210715, 0.18437517136149573, 0.17545503903126958, 0.17886421816322506, 0.19784092113887763, 0.17640296813202894, 0.18189753671388453, 0.18239987721624562, 0.1660447009650977, 0.1638745806683446, 0.16851413612869914, 0.16435131866685482, 0.18003920442538035, 0.1636658208112487, 0.15583613245999572, 0.16220833426908265, 0.1558901404928833, 0.2912908142984514, 0.2853270058855887, 0.1794386255214966, 0.26631452468148686, 0.2610735406705974, 0.23517110420798304, 0.1859252992068242, 0.281471090296613, 0.162112453810759, 0.17222407326745637, 0.1643566734878259, 0.13735657532554146, 0.27189144776454666, 0.1742424887106354, 0.318778823227602, 0.15548859515163316, 0.2838570493942769, 0.2498569592795088, 0.23362418096574378, 0.18933900960361194, 0.17844920075805748, 0.1808008225299197, 0.18780651871584297, 0.18397827203736838, 0.17284848274667075, 0.21508154400502544, 0.1857169224404306, 0.08119212856836333, 0.06658981854627566, 0.06791545770359075, 0.0672445937011451, 0.07257831586628583, 0.05939917478357437, 0.06779733498359475, 0.0651227130439922, 0.07548905718874033]}, "mutation_prompt": null}
{"id": "7647ab64-acf3-4cb5-9974-c8276a29ece3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.2  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 0.8  # Decreased social coefficient to reduce premature convergence\n        self.w = 0.7  # Slightly higher inertia weight for better exploration\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n        self.learning_rate_adjustment = 0.5  # New adaptive learning rate adjustment\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening and learning rate\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.velocities *= np.exp(-self.learning_rate_adjustment * (scores / self.global_best_score))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Adaptive", "description": "Introducing adaptive learning rates, enhanced mutation strategies, and strategic parameter tuning to boost convergence speed and effectiveness.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,5) (50,) (50,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,5) (50,) (50,5) ')", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {}, "mutation_prompt": null}
{"id": "01ce78b9-c4e9-46f1-b93d-297331d4037c", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Adjusted social coefficient for balanced exploration\n        self.w = 0.7  # Slightly increased inertia weight for better initial exploration\n        self.F_base = 0.5  # Increased base mutation factor for DE\n        self.CR = 0.9  # Increased crossover rate for more exploration in DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced initial velocity range\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for finer control of inertia weight\n        self.mutation_adjustment = 0.4  # Increased parameter for adaptive mutation\n        self.resample_threshold = 0.1  # New parameter for resampling strategy\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < self.resample_threshold:\n                    random_position = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.dim)\n                    self.positions[i] = random_position\n                    scores[i] = func(random_position)\n                    function_evaluations += 1\n                else:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "An enhanced hybrid metaheuristic combining adaptive PSO-DE with chaotic initialization, dynamic parameter tuning, and strategic population resampling for improved convergence speed.", "configspace": "", "generation": 36, "fitness": 0.2255033641161628, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.4711119212235614, 0.48381542645992737, 0.4834893387165913, 0.46474177682515794, 0.4781030296628255, 0.4936109416240523, 0.4749565067199626, 0.5123459237040278, 0.4698233479808114, 0.20616968346195175, 0.28704620653245205, 0.22108621837504294, 0.31726566870117634, 0.24593567622901114, 0.18465409443002523, 0.04481557352105714, 0.25760772263323284, 0.27005187094608296, 0.12342158587111829, 0.13083686961918994, 0.15390904236313252, 0.1710731899974317, 0.0795185505592253, 0.14761483824787724, 0.13978477055160288, 0.11243531085761826, 0.1253522328803851, 0.10570008237312356, 0.10223784218626297, 0.08524508173545586, 0.13551883925358998, 0.11064421083720377, 0.10220672798656283, 0.1166020274838846, 0.10120965267928017, 0.1077972287364588, 0.9827600973321513, 0.9738727788480225, 0.9816423266982618, 0.9583210336455797, 0.966378884010627, 0.9778217717204521, 0.9747244932989411, 0.9869155195855869, 0.9828574289725143, 0.4338785837826049, 0.3135048836409252, 0.30934065538281885, 0.3803948295713442, 0.41464825664155913, 0.36249273667548676, 0.31345171219594237, 0.26949537133457746, 0.19362437620497797, 0.7052851225903607, 0.3395005043956145, 0.21772330128866269, 0.19247246539889762, 0.18953815785755335, 0.16005785692075203, 0.5995913312012351, 0.11859599953109068, 0.42751974460011566, 0.15638738941400843, 0.26521155272745467, 0.15587468981716046, 0.11585247848792968, 0.11563250125927405, 0.1833856585014042, 0.14616947427239324, 0.1531439799705937, 0.1603065813818313, 0.16229781574777702, 0.12554666334794606, 0.12016850323566364, 0.15101901794807604, 0.17180395238215607, 0.0979954195155085, 0.08526830719533496, 0.19507933613715078, 0.15274770632822765, 0.04188802685961823, 9.999999999998899e-05, 9.999999999998899e-05, 0.00025251043609408885, 0.03811759449081653, 0.017485277008167044, 0.0037425254097188665, 0.009320006132151892, 9.999999999998899e-05, 0.07498715543157963, 0.04492639415378252, 0.0338792520925546, 0.03332095180822803, 0.05290834899503227, 0.049032298176957534, 0.0788453720296598, 0.021065536735943358, 0.038309703219147395, 0.01907173960353281, 0.04269877791343446, 0.02547304386784477, 9.999999999998899e-05, 0.01414095040648844, 0.014159060195222062, 0.004216728736527564, 0.008071816663298481, 0.010084544409220353, 0.15216788105218204, 0.06742545045653991, 0.1012220708109044, 0.09605604712132387, 0.028161933466751, 0.03398824799024658, 0.045785401446395535, 0.07234374971643998, 0.04969068991443493, 0.3864524665831369, 0.42202799512284805, 0.41049117768651167, 0.4258712587319795, 0.4274069795966958, 0.4094972948322768, 0.41540750348617494, 0.4021128475750051, 0.4087977584806386, 0.11502874008154162, 0.07139556416467019, 0.12411389995804833, 0.11343257231612291, 0.11038509089530146, 0.11147956301317741, 0.11193918669586456, 0.06755849605622155, 0.13479655003296032, 0.24479305771435333, 0.18767032874737055, 0.19789666504601022, 0.16528467857011997, 0.16377751116438066, 0.16943437542959527, 0.1705092991452355, 0.24625732111826903, 0.13917365721252195, 0.27431236480679044, 0.3092928004463448, 0.2857006471960495, 0.27451718778432366, 0.22558159153717183, 0.19596566115550174, 0.24676440042741932, 0.30478030626426267, 0.28879305519468623, 0.22738590836646777, 0.2476150862939167, 0.24683560028277585, 0.16868995501875683, 0.18458673823152694, 0.21224671568372444, 0.2484722139847253, 0.25144563787139274, 0.17287997597539673, 0.2001218392837657, 0.1925093397670694, 0.1714770491495623, 0.23401123225572962, 0.19574624835571264, 0.18572075338363214, 0.19053743295816283, 0.24557429690024069, 0.21954270487274352, 0.20597917719211623, 0.1875170807526081, 0.19858652965997625, 0.18718603108209408, 0.24140037614627308, 0.21166084567318677, 0.2128037879413931, 0.19712330666234557, 0.3363841904895535, 0.19380903861458987, 0.1768566042162849, 0.18575421958127514, 0.6581959065323748, 0.19199327826438506, 0.49908340703707477, 0.20833706055829448, 0.16588415978410098, 0.1519006927201132, 0.3289162696224349, 0.16784535856420857, 0.15222311761773943, 0.21080985151403642, 0.20461757668362301, 0.4666970500542572, 0.15199753984101205, 0.20819366764693825, 0.16312242964249268, 0.18123208825876969, 0.1855958476573225, 0.17145343207991115, 0.1832080684242703, 0.18297007719523029, 0.20089385332188991, 0.1826496521091665, 0.17454079143382573, 0.17600563655805723, 0.0833730876969132, 0.07564214190118368, 0.0868294417467792, 0.11953786845107328, 0.07716296054104133, 0.08118019698600443, 0.0850262034799496, 0.07703594456527985, 0.08413286997169256]}, "mutation_prompt": null}
{"id": "d1ed5263-7ba2-4494-bcc0-4d4b8be2cd74", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.8  # Slightly adjusted cognitive coefficient\n        self.c2 = 1.2  # Increased social coefficient for better exploration\n        self.w = 0.7  # Adjusted inertia weight for balance between exploration and exploitation\n        self.F_base = 0.5  # Increased base mutation factor for diversity\n        self.CR = 0.9  # Increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.tan(np.arange(1, self.population_size + 1)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for more dynamic adaptation\n        self.mutation_adjustment = 0.25  # Reduced effect for mutation control\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with refined velocity update\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with refined mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-9)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined hybrid optimization algorithm merging adaptive PSO and DE with improved chaotic dynamic behaviors and diversity control for enhanced convergence speed.", "configspace": "", "generation": 37, "fitness": 0.2673675951020623, "feedback": "The algorithm RefinedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8613439484589395, 0.8490940710749705, 0.8538061248717481, 0.8539315481340266, 0.859381637181595, 0.8454595523448849, 0.8585925273795384, 0.8552015504456032, 0.8589921673017864, 0.17847265947574142, 0.07631678364742911, 0.7305717609489514, 0.18111288569226947, 0.7430506073702694, 0.23934496527318683, 0.683227163950838, 0.741496281579672, 0.6559423866270665, 0.13065327990765285, 0.10487366047980118, 0.16827324581336378, 0.12747760679990783, 0.15843323501127293, 0.12832794968308592, 0.12977093513310478, 0.18584740824038648, 0.13000615587491482, 0.13027177739552953, 0.15570875749502244, 0.11116270458332334, 0.09501653506994623, 0.15276839640372442, 0.136834922943896, 0.09738958948133658, 0.11970004187491068, 0.11428564081856418, 0.9720056702258765, 0.9917195551323235, 0.9761631728331903, 0.9684576979360274, 0.9941756577304888, 0.9806564312163016, 0.9860943099821773, 0.9901472895813684, 0.9942078782555176, 0.27314518239136987, 0.17454833148228788, 0.05785798081620541, 0.5263422865683982, 0.16662052473503497, 0.6613187260139393, 0.527642678107413, 0.08775571682104422, 0.7050783132653747, 0.09650249524882237, 0.2251975486993164, 0.8510064388799292, 0.19016252677399903, 0.16085336156559804, 0.21178195275463685, 0.17313507412841322, 0.1492269378729969, 0.2285457641690133, 0.12975097827665327, 0.14898992912695774, 0.13689614160653618, 0.16119418117357587, 0.1317748039535097, 0.29721866893806936, 0.21494076282940466, 0.19755823053324406, 0.1950022331784329, 0.07293535422095554, 0.1464916972963325, 0.16461151630773185, 0.14372510961443585, 0.2060117550755799, 0.1510617508843236, 0.20497017673063822, 0.1313774253835609, 0.18058327104558536, 0.0019068858825478374, 9.999999999998899e-05, 0.003788264931227636, 9.999999999998899e-05, 0.0484233913305141, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014733494362555, 0.1065452748949427, 0.13101315829111915, 0.059909551782589054, 0.0419621093180409, 0.024404722440179882, 0.062475230431928375, 0.06019399870616393, 0.11052886729150502, 0.029705281960310415, 0.2708700472119864, 0.07320371184554275, 0.16505051116173453, 0.08930437059184537, 0.08651046010766728, 0.0936337792317139, 0.11813543416536199, 0.19101496680688412, 0.16147478138881122, 0.06506265197827399, 0.07561059069152054, 0.11144191370401135, 0.037845781101051634, 0.0381627784707147, 0.006941082518120534, 0.08118933775710391, 0.13935905970410967, 0.08150019708409562, 0.5322321120658577, 0.5440802190546984, 0.5481624095149733, 0.568400573050519, 0.5619843875820176, 0.5513071078293683, 0.5603086196247904, 0.5561145631309665, 0.5568306048133176, 0.0782087048870237, 0.07352947319491854, 0.0930983639636479, 0.11398513959953072, 0.09069468993598895, 0.15536104758562708, 0.09536059775578143, 0.12183942097174016, 0.10989627957343506, 0.2945618343757347, 0.15300654407385406, 0.18497565429368779, 0.25302577303242024, 0.16320394989810194, 0.2574990939853309, 0.22117927221098366, 0.25873992786845734, 0.30327948629560364, 0.2559831097121008, 0.25573703809680826, 0.42711418091900055, 0.20631161710332035, 0.27430358610010785, 0.30384755119219775, 0.16899200956184446, 0.2218006381283013, 0.3973478342776774, 0.2884509196703612, 0.2628140233139511, 0.3286671573199649, 0.263193219804266, 0.3569696572593718, 0.2942961656952606, 0.15354260014301313, 0.20501530972056248, 0.18519370409448088, 0.21272901113258869, 0.1896224708911659, 0.2053354623080973, 0.1986029383516823, 0.2279738647378533, 0.24886472294570938, 0.22327325932390063, 0.23652730422079526, 0.28647735573692523, 0.22190502314595395, 0.19041715928749847, 0.83025120387669, 0.1981106189676789, 0.19907746836206852, 0.22723690033468769, 0.2473020187037287, 0.24845950360946212, 0.21419689209195247, 0.136194566879422, 0.16620868891643237, 0.18835498220807678, 0.1771561084251263, 0.16353541054879295, 0.33973538196222575, 0.09888655417134173, 0.16995643055173992, 0.3487702775878433, 0.1017828231275697, 0.20833824283933378, 0.19184480022084371, 0.21109452458996403, 0.10415626308646297, 0.21183455298796217, 0.1554517025897465, 0.11215674870032433, 0.15496652474984274, 0.1976156953031798, 0.19627229030095084, 0.2078043041280756, 0.20144783422150325, 0.21563595028673122, 0.21816471462804887, 0.20013397191579574, 0.2037511514089434, 0.18710835360560274, 0.0817842399865173, 0.11887837287832059, 0.10305328078722364, 0.10101928425109907, 0.09727321368815434, 0.14102383419603615, 0.1015538258456512, 0.08840974560056925, 0.17325090328556414]}, "mutation_prompt": null}
{"id": "f209166f-918a-42a7-8c0e-ac19e4225969", "solution": "import numpy as np\n\nclass EnhancedPSO_DE_Chaotic_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient\n        self.c2 = 1.5  # Adjusted social coefficient\n        self.w = 0.7  # Slightly increased inertia weight\n        self.F_base = 0.5  # Adjusted base mutation factor\n        self.CR = 0.9  # Increased crossover rate for higher diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Opposition-Based Learning for better initial diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        opposite_positions = self.lower_bound + self.upper_bound - self.positions\n        self.positions = np.where(np.random.rand(self.population_size, 1) < 0.5, self.positions, opposite_positions)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly increased adaptive factor\n        self.mutation_adjustment = 0.4  # Enhanced parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n\n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n\n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.3:  # Slightly adjusted threshold for diversity\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedPSO_DE_Chaotic_OBL", "description": "A hybrid PSO-DE algorithm with chaotic opposition-based learning and enhanced adaptive parameters for faster convergence.", "configspace": "", "generation": 38, "fitness": 0.28719686284682816, "feedback": "The algorithm EnhancedPSO_DE_Chaotic_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8621473747879127, 0.850393443811555, 0.8415602551827394, 0.3943736287156394, 0.29881431070277864, 0.8436598280528358, 0.8629964130057735, 0.8401674302019204, 0.8516159041901259, 9.999999999998899e-05, 0.7014978979917647, 0.742355441649656, 0.6912371439452724, 0.7382836923913221, 0.5499285949826285, 0.6852516591232997, 0.0074718077347173395, 0.6911300750604383, 0.1759520260435935, 0.11567874384848342, 0.128995012057181, 0.11633366199315409, 0.13188659876693276, 0.15104797357149524, 0.13256927459467605, 0.12345638032576989, 0.15637454680335483, 0.09795260804623651, 0.11113629612469356, 0.11478595019134485, 0.1674841753682298, 0.1102519069768596, 0.10755276291432725, 0.11020166967831391, 0.07977278227668017, 0.17815554330072614, 0.9819367788949751, 0.9893482246306641, 0.9825417040019802, 0.9803774415148593, 0.984166362111698, 0.9844359478180578, 0.9879651224125532, 0.9862554498596293, 0.9817052859230329, 0.05957648319457731, 0.7374119595094987, 0.6803196647491506, 0.5800207065498868, 0.680896800095921, 0.718600033886895, 0.6659837443034933, 0.627663657066122, 0.6361787779616221, 0.16955191872681008, 0.2275789897243884, 0.1710566827737221, 0.19356728625406627, 0.27860530819028895, 0.2127269828752315, 0.38368956825279366, 0.19247179998675779, 0.8370742257307252, 0.1484539552826898, 0.23100310406370927, 0.12270118705334332, 0.13049617759132148, 0.12564980627545896, 0.33424702506993287, 0.2012137118027808, 0.15474464099130059, 0.20317170382280558, 0.18938522264213709, 0.19598920089558025, 0.1836504628355924, 0.21038138624074842, 0.14275098695696364, 0.16560843062761432, 0.1870665228413706, 0.2533648181187699, 0.15127802270859958, 0.015340597336278905, 9.999999999998899e-05, 0.029470491949886712, 9.999999999998899e-05, 9.999999999998899e-05, 0.005087416782894816, 9.999999999998899e-05, 9.999999999998899e-05, 0.03677851834378876, 0.038749926164103665, 0.08899636429705737, 0.10784563193793528, 0.032662062914592616, 0.02766364982172398, 0.0643281050395561, 0.10494407572463171, 0.050909541548764925, 0.03734336860880416, 0.03273202660954799, 0.06270660580197618, 0.032682866870752836, 9.999999999998899e-05, 0.0726137900273145, 0.07196587580243996, 0.09488004368852776, 0.09147799422749814, 0.07226736154640512, 0.25276224571875805, 0.021869264602652594, 0.16883154171337267, 0.03803596519841834, 0.21048374396599578, 0.09067652699481332, 0.05593313359333263, 0.05152946074276221, 0.081851342136813, 0.5571540917140079, 0.5388939309017461, 0.5463837645432142, 0.5502582893299715, 0.5560984714802282, 0.5513867601785758, 0.5630028640527915, 0.6388939206255478, 0.5553226855007172, 0.09649586715204661, 0.09777525736726389, 0.061875204624103786, 0.128099351076572, 0.1427434922813463, 0.13313950026340593, 0.0566419086210348, 0.09889257332502088, 0.08720093104103765, 0.17215456689800324, 0.3502487002091178, 0.30928141843905954, 0.1962625120765007, 0.18873835779884196, 0.2321304111798419, 0.1344232587541887, 0.3578808606266193, 0.26593307021390644, 0.2606536069971208, 0.1450868560198223, 0.23479959291343866, 0.3981843856792361, 0.4924874792428312, 0.2994728130649428, 0.49641817842092695, 0.2880454455547561, 0.6653897069612051, 0.3038890935420705, 0.26426357233522724, 0.2188302772964379, 0.33701833184671237, 0.346052899578735, 0.21483838305547887, 0.17148404968081088, 0.19495642490645548, 0.20504220476517399, 0.23057511230427863, 0.2529348300907063, 0.21488893648730978, 0.3181188349167624, 0.20229916415422367, 0.22702549509654057, 0.2030739586984891, 0.23776723898169072, 0.21712946990803328, 0.19887714682141, 0.18457165687174726, 0.18420787511857206, 0.19228020191446438, 0.17001180163902752, 0.19037876371974494, 0.19808446933929558, 0.1973428787292918, 0.19750296238306697, 0.13131853566441332, 0.20063671782988823, 0.9112642901269017, 0.20011361898583824, 0.16747536903482485, 0.9304571510136141, 0.9118467897197614, 0.13141431169538131, 0.11608852390117697, 0.11239829652148636, 0.16892851518344032, 0.12751779765638405, 0.5738936565385395, 0.15517016640779824, 0.34399834312195876, 0.16600418293728703, 0.10500053638996598, 0.1677698770590791, 0.2027218809345579, 0.18543212820185595, 0.19312014340591466, 0.21612827685074676, 0.18514552807515872, 0.18749980568261904, 0.1950777157884992, 0.21045186494017964, 0.20097675396209613, 0.10976083229206435, 0.08131701141944958, 0.1069695926819424, 0.09548484525457424, 0.0975806262018144, 0.08767577144455174, 0.17127199505151514, 0.0946461421567103, 0.12121303452819643]}, "mutation_prompt": null}
{"id": "96cf1e21-1b33-4262-866b-aa889a8cac7b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased population for better diversity\n        self.c1 = 1.7  # Adjusted cognitive coefficient\n        self.c2 = 1.3  # Adjusted social coefficient for balanced exploration and exploitation\n        self.w = 0.7  # Adjusted inertia weight\n        self.F_base = 0.5  # Increased base mutation factor\n        self.CR = 0.85  # Modified crossover rate for more trial solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for better coverage\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * (np.random.rand(self.population_size, self.dim) - 0.5) * np.sin(np.arange(self.population_size)[:, None] * np.pi / 2)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Enhanced parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity damping\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Optimized threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds and introduce chaotic perturbations\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            chaotic_perturbation = np.sin(function_evaluations * np.pi / self.budget)\n            self.positions += chaotic_perturbation * np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_V2", "description": "Integrating adaptive chaotic maps and enhanced selection mechanisms for improved convergence speed and solution accuracy.", "configspace": "", "generation": 39, "fitness": 0.20576303432575674, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.5269668044796634, 0.5111348535960971, 0.5286075500527765, 0.5182205034463465, 0.5321534528870802, 0.5031533697888071, 0.5184736928445421, 0.4995664327068593, 0.5159559415677496, 0.014671212682368928, 0.034771792316035666, 0.028524347929025917, 0.10480927350136349, 9.999999999998899e-05, 0.0019078976068674924, 0.05476065681172515, 0.004946957571562605, 0.04929961348424572, 0.10951312280673842, 0.0878589117250802, 0.10610693317181963, 0.03367503453254084, 0.12151037852098123, 0.06793127142556299, 0.050065807550932706, 0.10491428940183545, 0.08972450673322763, 0.14424561664216762, 0.07998973157000311, 0.11181623089764559, 0.12685348357434345, 0.09625261428415721, 0.10353028640381412, 0.06395783179169012, 0.09008754193164892, 0.1107092136649711, 0.9527129036636223, 0.9496842977482818, 0.9605232985296661, 0.8788482702409344, 0.9817639775487843, 0.9459892529908082, 0.9769304735530684, 0.9794524910525678, 0.9642929652465945, 0.29104930877755897, 0.2977535614692849, 0.2177357961022337, 0.35336179163834125, 0.32693421640869735, 0.3122812371826078, 0.29779866490457474, 0.3208097417954384, 0.31412490031889473, 0.4840924778275165, 0.059451520837157434, 0.059325101684582826, 0.20790450452458142, 0.12760261084988145, 0.03262952331145319, 0.14945601261458374, 0.10807484526561695, 0.14844314447101692, 0.1822286082568596, 0.31667653220060943, 0.1746424411973967, 0.11799340269289571, 0.19737673195214533, 0.12584981293395503, 0.0816366777556603, 0.10046653561744245, 0.17446291009649773, 0.05175539495484227, 0.20692183935672404, 0.13883739664708172, 0.18155985081922588, 0.16190963991283747, 0.19744409245984829, 0.22256242411776672, 0.20379693746429295, 0.18462638136788556, 9.999999999998899e-05, 0.08133846705892778, 9.999999999998899e-05, 9.999999999998899e-05, 0.04955458544686808, 0.029653073188292134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08825792468315252, 0.032392126186506, 0.03352775557963994, 0.014256422483864828, 0.01803460104846033, 0.01833988278070464, 0.001653467863953706, 0.039127595392582815, 0.02443140555532919, 0.0006480172627220115, 0.002067878836745529, 0.0008027589996034701, 0.001245316582606626, 0.0030168334554636633, 0.00030520523860033677, 0.0015968439901882236, 0.0030540254108827325, 0.0023320881873525323, 0.06180956907970192, 0.058375201535457166, 0.04776115175547513, 0.03750161961393261, 0.05728752559183414, 0.15464589343271817, 0.08487784458600667, 0.08300242958221637, 0.0785149714667085, 0.4532059295284031, 0.39430154239875115, 0.4663712956763728, 0.42940652819494785, 0.4444805844999924, 0.4043891031658766, 0.4482858354826048, 0.4493467269948338, 0.46985785709376837, 0.09421772363303449, 0.10822281422888846, 0.004748841191951181, 0.04510099871478446, 0.1514448657095514, 0.1374646146025711, 0.11570077151408986, 0.1381882014786554, 0.17552943728464487, 0.1895894954716334, 0.3059971877372549, 0.1298125537739907, 0.1982539936938269, 0.2014062075580103, 0.2397243931483849, 0.16189714193282978, 0.15891711186116864, 0.2032578913936186, 0.13757490472616007, 0.19433240354124492, 0.1105313947150498, 0.3316955221942167, 0.25869994049774636, 0.20946630952573342, 0.30675495026587085, 0.30907267114629655, 0.14223319063825657, 0.12344529365566737, 0.15661020380056512, 0.21702250407474222, 0.1197821873135807, 0.18806411734226336, 0.26102370486038473, 0.0725946326651814, 0.2621916563545049, 0.08635187683583478, 0.2235622171146685, 0.20830166634955072, 0.20189194942858102, 0.21934498422817228, 0.2490306293086395, 0.19579946219793876, 0.1702414538151492, 0.1886048184792286, 0.20584481716748837, 0.23946386819019527, 0.21320724423285042, 0.2043069606979847, 0.18928927819477281, 0.2200323510098645, 0.20538924415179705, 0.21493718963700625, 0.18692302895454915, 0.23305847315911676, 0.7941033656355121, 0.13461027158170058, 0.6850314287045218, 0.15044051567032635, 0.16637958490178262, 0.1659355838860873, 0.16532683815479177, 0.14851641726849463, 0.15229996318416195, 0.029259331445986803, 0.09600048764690894, 0.11204001332584324, 0.5512334815173465, 0.5575291757398884, 0.10012315399937999, 0.21021152926162368, 0.16530010017058538, 0.20835754854863087, 0.1746001528535771, 0.18417968358165437, 0.19123275951773677, 0.18235101868460069, 0.18162620743677294, 0.17627630596388066, 0.18811524919394407, 0.18056434322570036, 0.18434342804937587, 0.09502580751358214, 0.07916707916616383, 0.08311098923669491, 0.11482180463187563, 0.07362139393564049, 0.09234648188088357, 0.06443452635271407, 0.07923854531984076, 0.07470995659885449]}, "mutation_prompt": null}
{"id": "7f868f87-bb10-4802-8192-7af1b7d257f3", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased population size for better exploration\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration and exploitation\n        self.c2 = 1.2  # Adjusted social coefficient for improved convergence\n        self.w = 0.7  # Balanced inertia weight\n        self.F_base = 0.5  # Increased base mutation factor\n        self.CR = 0.9  # Slightly increased crossover rate for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        # Enhanced Sobol sequence initialization for better coverage of search space\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly reduced adaptive factor for gradual change\n        self.mutation_adjustment = 0.3  # Balanced parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with improved coefficients\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))\n                mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_score = func(trial)\n                function_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE", "description": "A refined hybrid approach using enhanced initialization, adaptive learning coefficients, and less chaotic yet diverse mutation for faster convergence.", "configspace": "", "generation": 40, "fitness": 0.2611047603067489, "feedback": "The algorithm RefinedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.7467859034308804, 0.6500570689925667, 0.7544925819333097, 0.7210270742325972, 0.7577076344641, 0.7578987736744544, 0.7734739953806709, 0.7710264846521865, 0.7174229460517545, 9.999999999998899e-05, 0.48501305197443856, 0.04783052995001014, 0.44684244445494137, 0.477440494212373, 0.05754021159880307, 9.999999999998899e-05, 0.5548505847326693, 9.999999999998899e-05, 0.08825275245436004, 0.10077910306016546, 0.09550808338178651, 0.12922691530634112, 0.07300724038757456, 0.3523962565579246, 0.14079545524200898, 0.11169349418839736, 0.3437303644618529, 0.09924288610024379, 0.12049046002588071, 0.09404323609278331, 0.09645179168955598, 0.10629613895537782, 0.11870902288247909, 0.0928176171413857, 0.10351088680104115, 0.12224990069778063, 0.9626740802048327, 0.9807252118756692, 0.9722459149287301, 0.9718784687768082, 0.9722017250084887, 0.9733213387672751, 0.9728958688273045, 0.9621350460163363, 0.9622295541231345, 0.3447479325079116, 0.44073175643788987, 0.48625685077646563, 0.3383880456502678, 0.472842739192614, 0.24246502451359664, 0.08646781116969215, 0.4488592445025773, 0.3588062417945582, 0.20356890278814987, 0.7044930577263528, 0.7306466990702526, 0.26430880165470816, 0.18811019795126394, 0.19767640917950324, 0.6932173917462701, 0.7249902814969555, 0.6048075226502558, 0.1534861414345463, 0.1341013619320809, 0.11257433985306542, 0.12347536532653758, 0.17491346498910676, 0.14950258742507927, 0.13084902561592704, 0.17261626376348282, 0.1354437195968603, 0.10124077842375467, 0.09537882112805418, 0.17760704726636267, 0.16973340522503988, 0.12706215682840594, 0.1544439557265299, 0.16558769708444376, 0.14907373798863433, 0.09241097195709758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06942964535774443, 0.017154186163009788, 0.06325806040631055, 0.061406774522013596, 0.012353811631584222, 0.051092713611965546, 0.03042604485779543, 0.05286548136186353, 0.09345879110662259, 0.0022477745863798138, 0.10909559150114656, 0.13662213659130318, 0.1672828666970061, 0.07248376604063889, 0.06497192272547159, 0.0772721071376562, 0.05017277491393857, 0.04040111553215031, 9.999999999998899e-05, 0.13650687010728357, 0.132093398908818, 0.07405694504863292, 0.07926398715754801, 0.06150134412397934, 0.1823488440922839, 0.06503137199778553, 0.04485478165880652, 0.051775326284953516, 0.4449374533217967, 0.5469302210274722, 0.43689276818332035, 0.511008029729459, 0.5061745851507642, 0.5304506271988176, 0.512549444478499, 0.5465630017943373, 0.5848681213287101, 0.11430690993396952, 0.09778219534527366, 0.0932126182946782, 0.09905525329655251, 0.11709194827220581, 0.1282109733101937, 0.09451038551514868, 0.1140753136620638, 0.11700522863989116, 0.16818027365100752, 0.15902083289282387, 0.14948967135842972, 0.14749172913808162, 0.21432132467131382, 0.14747008060239164, 0.33452633804470644, 0.2986274239239872, 0.1963817577280107, 0.34187512862240943, 0.2726348704431072, 0.3765671947045921, 0.27305104737638053, 0.4289013886557479, 0.44925834050905356, 0.40497766616992914, 0.45650199093318156, 0.4136390442547112, 0.18244209832227065, 0.22120843741502028, 0.20722821400067992, 0.1847088879371116, 0.261269214298954, 0.24780317066000357, 0.1703519118398077, 0.24221954843572502, 0.28105653069974157, 0.18865740871054104, 0.19057288528495875, 0.21017038199417026, 0.24308887884901664, 0.1939641746864752, 0.21320536948097735, 0.21644105304348427, 0.19606401156760345, 0.19001603471246453, 0.21449502081420135, 0.30734789741040736, 0.20809694334729378, 0.18706363092752487, 0.20144303182282042, 0.20395625527853967, 0.2292542236001791, 0.19434111139536503, 0.19081471175638187, 0.1294761965150637, 0.16540279575047157, 0.8480684019148028, 0.15964940041065334, 0.19763292538131905, 0.1636588952024216, 0.5782027607212796, 0.16101000801879217, 0.7348038030635531, 0.15881079016344934, 0.16848824810175844, 0.5945054401225256, 0.5588800165375978, 0.125968166161061, 0.16675925879541686, 0.19975771243613438, 0.2013853327534616, 0.1518359457627203, 0.18943958543444206, 0.18739854634130793, 0.17319280429056783, 0.1837153160304189, 0.18589182484911548, 0.18854987705196413, 0.19849364809439596, 0.20469690455338518, 0.1842503376824478, 0.07877889386175652, 0.07480725123752341, 0.07853336230330132, 0.07853994980205115, 0.08230294270869853, 0.07615116277018752, 0.08219399387509019, 0.10089594722085915, 0.09024477969276745]}, "mutation_prompt": null}
{"id": "1a8c66c2-4a67-48f3-99db-004bccd64b40", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "3d532875-51a8-4c4d-9207-904ba938105a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "8ff463cc-95ad-4e14-873d-9698a674aabe", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population for better exploration\n        self.c1 = 1.7  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.3  # Adjusted social coefficient for better convergence\n        self.w = 0.7  # Increased inertia for more sustained exploration\n        self.F_base = 0.5  # Increased base mutation factor for broader search\n        self.CR = 0.9  # Increased crossover rate for higher diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        # Refined Chaotic Initialization using cosine for improved spread\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.linspace(0, np.pi, self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # More pronounced adaptive factor for inertia\n        self.mutation_adjustment = 0.4  # Enhanced parameter for mutation scaling\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity and enhanced weight damping\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Differential Evolution Mutation and Crossover with adaptive scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))  # Add small epsilon to avoid division by zero\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined hybrid PSO-DE algorithm with enhanced chaotic initialization, adaptive parameters, and diversity management for accelerated convergence.", "configspace": "", "generation": 43, "fitness": 0.2805965929360076, "feedback": "The algorithm RefinedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8368481467592328, 0.8350271375970545, 0.8307224202634987, 0.8174669505599099, 0.8230761777913558, 0.8246750610728735, 0.8211734452567534, 0.8353588603956691, 0.8382118400416118, 0.5820956783056297, 0.5776727524842638, 0.6615295683207731, 0.634956938317606, 0.6554264000493579, 0.594793258614466, 0.7099921923669172, 0.2786750920755934, 0.6166645140573773, 0.15045760257073415, 0.17354508093394905, 0.15642790707672738, 0.13659311370174054, 0.18076118893380166, 0.13721555869509428, 0.15267368753761834, 0.18414742608590973, 0.12059228842320358, 0.10631965735260096, 0.08300428333513787, 0.14760251430586635, 0.08380927723478038, 0.12950336966449072, 0.11796924437562428, 0.10556130907630645, 0.10389144196294053, 0.09944702851735021, 0.9659559504051578, 0.9836585159416016, 0.9817573547947833, 0.9679376364480798, 0.9713777583947496, 0.983827203569157, 0.988399531438112, 0.9845637049372209, 0.9836941309641049, 0.4051966447958546, 0.6333604874278307, 0.5981177563308849, 0.657651717624073, 0.6427334492057832, 0.6665383861184184, 0.6543282548475599, 0.6560671094588756, 0.621094654782345, 0.2225108236078327, 0.22650238738307216, 0.13663885490151806, 0.18941867888288066, 0.1595159592444767, 0.19125460292181573, 0.2368991625369249, 0.21887549985832344, 0.23366672200191185, 0.12170713635039832, 0.21704767355857046, 0.12896063009271108, 0.1704372290553101, 0.15756822413352767, 0.1870924233580481, 0.18624760471170343, 0.21943707413508484, 0.17607202358214724, 0.208947907893416, 0.18934560362040787, 0.12235155407308007, 0.1292015650993148, 0.13467909684162638, 0.15909016072694593, 0.159185771949781, 0.09765180816633878, 0.12741101319404702, 0.00788350333042509, 0.07072184515481017, 0.04954757855462777, 9.999999999998899e-05, 0.0007554972749392874, 0.03456547801275811, 0.01384639751719019, 9.999999999998899e-05, 9.999999999998899e-05, 0.1135767596715801, 0.07112307979265131, 0.1910729321001573, 0.08616067857603482, 0.060794058213517355, 0.033411557262011615, 0.06379922624220913, 0.06107406664453496, 0.011006794717823731, 0.03616701698264935, 0.03136893978244648, 0.03141499985280083, 0.08832139467371214, 0.16545019011252393, 0.08483611532804847, 0.18002962998653493, 0.10421575278531892, 0.10546436155321282, 0.1130383519416166, 0.028985765124532326, 0.14836888169393858, 0.1237213484985783, 0.11623648634165529, 0.042573063782151976, 0.12964162415563774, 0.08054293690519665, 0.05159104583014451, 0.5432682840378169, 0.5861153359232261, 0.5889064465593616, 0.5637891258713013, 0.5454230068997554, 0.20670759498297375, 0.5595067800469746, 0.5656950378483335, 0.5511055764601441, 0.0673070654638328, 0.05971599646229897, 0.13810096498841007, 0.1540914096506002, 0.08928205565505343, 0.11856642193720635, 0.11526007157184104, 0.1507501825396419, 0.09807322845547295, 0.2531651224679605, 0.15641370770373875, 0.22149175194806392, 0.14455232758844527, 0.3966421250801935, 0.18577870198140167, 0.1616023695022163, 0.23826166785444947, 0.25194978612111696, 0.4014124646525161, 0.35482757218218697, 0.4757050907910233, 0.28183276392307766, 0.3216263515597829, 0.27004401717835413, 0.43514951800950696, 0.5253500684558844, 0.3297141466975849, 0.24198350265989677, 0.1827726366284087, 0.23287831192558828, 0.21592996608855153, 0.251658991620485, 0.284779997672728, 0.26593261655848177, 0.22590040523345645, 0.23131367573129546, 0.2454200501695789, 0.2572572411474022, 0.21839470253141313, 0.23766192309578227, 0.23214638802669474, 0.23361803358674782, 0.21236428956741626, 0.22865712323603982, 0.20492590899299123, 0.17904028787589854, 0.19814190390488984, 0.19588678931025172, 0.1964130617267389, 0.20981523280636627, 0.18920028387877685, 0.2488191909646621, 0.22383406788737858, 0.2395716975620641, 0.12966804435487933, 0.13539664628462178, 0.1847463104166086, 0.16673683528683503, 0.12670383309470157, 0.16812007615274926, 0.16635438741219155, 0.16939989378678288, 0.38599697636610075, 0.12532090904854143, 0.39363631725064974, 0.1429495850245428, 0.21043784802482346, 0.4678629015822786, 0.21201228330833488, 0.4636723288621466, 0.11257861440847716, 0.19757653123890107, 0.2113173808748966, 0.21488183721947962, 0.19944289580556174, 0.2245466596073742, 0.21865335249061668, 0.1864496553330668, 0.2036766729322177, 0.1981874412313407, 0.20852186163699848, 0.0976713486412093, 0.10503559240831983, 0.08842971765641827, 0.09273567475439526, 0.10463341742037646, 0.12517236644738583, 0.10229134287113739, 0.07467402747689356, 0.07239687614845547]}, "mutation_prompt": null}
{"id": "1644cb4b-7653-4e5b-8072-59e619e8fabc", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration-exploitation\n        self.c2 = 1.5  # Adjusted social coefficient for balanced exploration-exploitation\n        self.w = 0.7  # Slightly higher inertia weight for better exploration\n        self.F_base = 0.5  # Increased base mutation factor for more aggressive mutation\n        self.CR = 0.9  # Increased crossover rate for higher mixing\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for more gradual velocity reduction\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation to encourage diversity\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.std(self.positions, axis=0).mean()\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined adaptive hybrid PSO-DE algorithm with enhanced chaotic initialization and diversity-driven parameter adjustments for accelerated convergence.", "configspace": "", "generation": 44, "fitness": 0.28937756185251423, "feedback": "The algorithm RefinedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.28.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8574765499791153, 0.8458959671764441, 0.8414538752703218, 0.8486683299509704, 0.8662948056005587, 0.8454260011659356, 0.8516961571645228, 0.8395928487355933, 0.8552811541234286, 9.999999999998899e-05, 0.7013502514452363, 0.6432031680473383, 0.7199691310800139, 0.730362637714917, 9.999999999998899e-05, 0.6497265034247655, 0.6634451815831317, 0.047202953142957305, 0.09687877481617035, 0.1370167151024032, 0.10743782365456422, 0.0747129725029354, 0.1130548851606622, 0.1041448288707143, 0.10885161163762169, 0.7301757569078825, 0.07191660076222872, 0.13665376996378786, 0.11291993094433272, 0.08354439336438102, 0.07372527369508663, 0.10439378050660886, 0.03448668913122288, 0.10747387638384243, 0.10781273334106367, 0.13534312559290684, 0.9858416287444934, 0.9835784444773911, 0.9817355917397129, 0.9774395426691327, 0.96776086358983, 0.9855013169669272, 0.9805356898327919, 0.9869488148282727, 0.9827451758912897, 0.6375474930796057, 0.23038908500943822, 9.999999999998899e-05, 0.559786945366119, 0.14990790336876214, 0.6591157717358294, 0.12430974660707161, 0.08822356695687428, 0.0884101654605538, 0.8027467890452971, 0.13720386176365373, 0.7894650095844263, 0.860457414146835, 0.2709490981891979, 0.19009426749373004, 0.8526538326814467, 0.8814580670926563, 0.2346208816135268, 0.18859491936389527, 0.24365476565909572, 0.12658497346878816, 0.19850201970983072, 0.12530750909094934, 0.4759421005083997, 0.18918459313125902, 0.183351967978313, 0.18583952502188084, 0.1269259744314275, 0.13101593797754907, 0.22961876678971538, 0.2022198668958084, 0.19772727339720297, 0.17592307438564203, 9.999999999998899e-05, 0.12599357761316754, 0.12232239518617039, 0.06585328205220553, 9.999999999998899e-05, 0.014315847502934909, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07254908087044476, 0.07431455349507665, 0.01793354943237735, 0.09287169689439778, 0.05494373095486482, 0.056688984819428856, 0.042979752581555064, 0.10778473299911295, 0.05938626400032987, 9.999999999998899e-05, 0.14055034822961165, 0.12032773942247155, 9.999999999998899e-05, 0.07340112444716473, 0.08327361491987217, 0.22129922000456959, 0.1906487085533829, 0.3020504400396705, 0.1544658260642755, 0.25413819327352927, 0.010883009686289413, 0.024810852478688528, 0.014855142774293784, 0.03806194751762482, 0.16658029997675805, 0.08084435604455176, 0.0557023257905237, 0.5336120871371289, 0.5361949483304334, 0.5508669470656761, 0.5645075628759197, 0.5486762400093039, 0.5399234181212982, 0.5982221042310787, 0.5575047422389103, 0.6048434533346456, 0.10364251778107625, 0.063888506643758, 0.06553645971688016, 0.09642220645112087, 0.1043701507545236, 0.1544147648956008, 0.10898829756015271, 0.09156551809597624, 0.09344367742598514, 0.3672390966843434, 0.23784992801235672, 0.18776094861578418, 0.2410125392869651, 0.18087118992138917, 0.1969351281219367, 0.16721967336165222, 0.26782075793495486, 0.26025988626441854, 0.21312647763278347, 0.2570283562352582, 0.258708509503788, 0.20121550480194383, 0.24869396691366308, 0.3342026394001345, 0.3074277123295118, 0.6828148099300017, 0.38326980744616324, 0.334582053487568, 0.17118141971689604, 0.1381845220222212, 0.20212579873650882, 0.25278923330221803, 0.21166899932567784, 0.13663295869120773, 0.23090896216591084, 0.22772785057647937, 0.2169166377937416, 0.23990471832580462, 0.2208976678148259, 0.2004577838363799, 0.23101934430934412, 0.19773975892701978, 0.22154547725424123, 0.2235989935396996, 0.28250044958389153, 0.20771447007209876, 0.1806498363532928, 0.1900342470799138, 0.22588694826040734, 0.18729674345889125, 0.22481629713245244, 0.1707669903082566, 0.7714634854754472, 0.20271325348473013, 0.8983438176469883, 0.9035281170542705, 0.21094878726322897, 0.9179285987422708, 0.19995314394096364, 0.16761363200143897, 0.2100812941890967, 0.11703988118593645, 0.1543461931552409, 0.11146159705902159, 0.16851634513201186, 0.15487259073384885, 0.21181917207428402, 0.21110641487108073, 0.5213469916253758, 0.16598653182025713, 0.5844126840859796, 0.15452879410893605, 0.19678609818198034, 0.19841794505543398, 0.19146797769387103, 0.21378419763746992, 0.2306997515352074, 0.22275220253102257, 0.20484893278131244, 0.2064664908969689, 0.19279374346453715, 0.0852022415586211, 0.08545417413050838, 0.11172858130055086, 0.14042870640428484, 0.10023121411191238, 0.08671428907996637, 0.08391057568875038, 0.10677880490249592, 0.11290751908266117]}, "mutation_prompt": null}
{"id": "015f2521-873d-48d9-9962-efd046df55be", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "5e62c50b-128c-423b-9c59-3ff36ab14ee3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration-exploitation\n        self.c2 = 1.5  # Adjusted social coefficient for balanced exploration-exploitation\n        self.w = 0.7  # Slightly higher inertia for better initial exploration\n        self.F_base = 0.5  # Increased base mutation factor for DE\n        self.CR = 0.9  # Increased crossover rate to enhance DE trial generation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization using a logistic map for better diversity\n        chaotic_sequence = np.random.rand(self.population_size)\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.array([4 * x * (1 - x) for x in chaotic_sequence])[:, None]\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly more aggressive decay to inertia\n        self.mutation_adjustment = 0.4  # Increased adjustment for mutation factor\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "A hybrid PSO-DE algorithm incorporating chaotic map initialization, adaptive learning factors, and diversity-preserving strategies for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {}, "mutation_prompt": null}
{"id": "6684bdc8-d0c1-4be4-882f-1a48c6a8ac9d", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1_initial = 2.5  # Adaptive cognitive coefficient for personal space exploration\n        self.c2_initial = 0.5  # Adaptive social coefficient for global convergence\n        self.w = 0.7  # Slightly increased inertia weight for better exploration\n        self.F_base = 0.3  # Adjusted DE factor for more controlled mutation\n        self.CR = 0.9  # Higher crossover rate for better genetic diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Improved Chaotic Initialization\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.abs(np.sin(np.arange(self.population_size)[:, None] * np.pi))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.97  # Updated adaptive factor for inertia weight\n        self.mutation_adjustment = 0.3  # Adjusted parameter for adaptive mutation\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.learning_rate_decay = 0.995  # Decay rate for learning coefficients\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n\n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # PSO Update with adaptive velocity and learning rates\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Decay learning coefficients\n            self.c1 *= self.learning_rate_decay\n            self.c2 *= self.learning_rate_decay\n\n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Lower threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_V2", "description": "Enhanced Hybrid PSO-DE with improved chaotic initialization, adaptive learning rates, and stronger convergence control.", "configspace": "", "generation": 47, "fitness": 0.027687246787592486, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.03161612256867885, 0.04036508585956633, 0.027891577237561305, 0.026819420233461067, 0.03304510298542662, 0.03273193502915017, 0.07250225965943113, 0.08927967169553541, 0.08018986502605818, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006396903983493796, 0.003017680591014371, 0.002545140818891567, 0.03765268632495122, 0.02999526751445114, 0.03492279103728013, 0.04001803009805571, 0.040190414828173204, 0.04236877062389266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05265968782059316, 0.057538630792684176, 0.05122756928447847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07175693612352518, 0.07523969177868783, 0.06361030639030829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09096082436030006, 0.09290345638130526, 0.08253910623414706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010484317047781966, 0.008744593204188855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13942693329680933, 0.13745663387483964, 0.1139881804710976, 0.09163752687877169, 0.09548148852603355, 0.09181277206384297, 0.2192244906991636, 0.20969003829565003, 0.2846057191942728, 0.10925556644268197, 0.10004908126088607, 0.10337427641944574, 0.007853156395489114, 0.008296589626011208, 0.015532461188113356, 0.0636110171840395, 0.05773921038864194, 0.051567907383894274, 0.009992168959904513, 0.0003485229481752228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027433287477479862, 0.08727248997826187, 9.999999999998899e-05, 0.013824432873759895, 0.028497256988231467, 0.008022225781259884, 0.06404555208884555, 0.06710105757215001, 0.0412176148029475, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021768081184860733, 0.021319491849354555, 0.020477724183656898, 0.037263769207971253, 0.10137239350984928, 0.05915445657119767, 0.03371726894997551, 0.03477520523078348, 0.028527352810870044, 0.018316251406406248, 0.020888288281166623, 0.016724462990085343, 0.02642087223576106, 0.0784079682158817, 0.028536825530681154, 0.006923805099433578, 0.00884779427754856, 0.00792434253739882, 0.20067023517966054, 0.18974837434336655, 0.2104331440040772, 0.21266435581418952, 0.19757963880682072, 0.19696642837072165, 0.19834681019044076, 0.23117566229844133, 0.19015868378860845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05]}, "mutation_prompt": null}
{"id": "677d71f7-a2db-4237-a01c-cd6074cf5e14", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "2cd1c4dd-026b-4da7-b5ee-0d8811a71f62", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "b0abb9a1-76ba-4653-ad6e-5d41b5ad0cff", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "c7b37663-1506-4c89-bc64-ca06ec0f0648", "solution": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced attraction\n        self.c2 = 1.5  # Adjusted social coefficient to enhance exploration\n        self.w = 0.7  # Slightly increased inertia weight for better exploration\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for better exploration\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None] * np.pi)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Slightly adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "ImprovedHybridPSO_DE", "description": "ImprovedHybridPSO_DE using enhanced chaotic initialization, adaptive mutation, and diversity-based dynamic operators.", "configspace": "", "generation": 51, "fitness": 0.13239018091517732, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.21.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8366109217518842, 0.8149693967174116, 0.8212973924282971, 0.29103984729005095, 0.17252313482047232, 0.2751896299967731, 0.8387290917836328, 0.8281226131246627, 0.8413585649230579, 0.078696354786717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5881354549558541, 0.02938909934538847, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013228318179772103, 0.0009431998949192, 0.0420982215641067, 0.009428390618863136, 0.011361660402189, 0.036261504030890124, 9.999999999998899e-05, 0.045927777730410124, 9.999999999998899e-05, 0.021913499987124885, 0.005095733852134798, 0.02380179210179889, 0.01123909512693555, 0.004817702655473877, 0.03831434621602148, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5137877053711766, 0.08100660882913269, 0.8056507775084454, 0.8997693299242715, 0.9343106767556086, 0.7448083029888626, 0.929445043925826, 0.9465907897214645, 0.9562981386543784, 0.05354942109870231, 9.999999999998899e-05, 0.6936074884653008, 0.2830057383125997, 0.1438368836478645, 0.012014109436356724, 0.08231452636271785, 9.999999999998899e-05, 0.0836044005456339, 0.0034871115640178196, 0.057176396879935254, 0.05883774309541545, 0.04187387217856198, 0.03209453567709697, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001260366075885977, 0.1552670890681176, 0.19025490391033195, 0.18281818662960647, 9.999999999998899e-05, 0.1221708582691623, 0.0215620898398855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20644712126194165, 0.1247191468799963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2229126704711334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03287548883521918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029006423220308664, 0.0455047651401177, 0.03415517341668217, 0.007280435339249158, 0.000947864233746043, 0.04379464172288405, 0.020331759361665203, 0.015090817033982407, 0.004152129329817789, 0.030840991994776745, 0.03290720519691148, 0.03183385090532864, 0.07089239758015231, 0.06670100583524907, 0.06673869795592002, 0.08412848987049859, 0.21041414684343895, 0.1428077487820083, 0.04108121056805358, 0.053141734995039824, 0.04028318761358496, 9.999999999998899e-05, 0.07712247703756347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07834750991291095, 0.13697394511335992, 0.1846748888619102, 0.13487784518831758, 0.16338865755211718, 0.17140099792350483, 0.5045067429661634, 0.47488116942873626, 0.33506355601611304, 0.49636869695675667, 9.999999999998899e-05, 0.006321717504018443, 0.07413445071036184, 0.010030276131644644, 0.07007981955955489, 0.02211973300432546, 0.04777088046638678, 0.04070528613229851, 0.09226574254635811, 0.14015136253036398, 0.11727823370485968, 0.13723985756634138, 0.12618568368729632, 0.0817068174461858, 0.10843541594448447, 0.20330583715781514, 0.2524824802567135, 0.2704325206040801, 0.15363044094265332, 0.1556622328856071, 0.1151921754331745, 0.018335663987506412, 0.01676426791994623, 0.023053220014815134, 0.07746665011503717, 0.06454886273093985, 0.03240944990877326, 0.025402185086578877, 0.027887485901335607, 0.0005324944557576483, 0.05438772725917895, 9.999999999998899e-05, 9.999999999998899e-05, 0.008994276352372044, 0.014118722812366813, 0.01911487919361876, 0.13068044723906735, 0.14980417596100493, 0.1479880115769211, 0.1853384500179205, 0.19188250356402603, 0.17546314206896274, 0.14349066616750095, 0.14554469585130614, 0.14811509650646637, 0.17211490023381026, 0.14184263435780742, 0.09008906983028409, 0.1485087361815165, 0.17519503328664576, 0.15738364931750404, 9.999999999998899e-05, 0.18286229547026012, 9.999999999998899e-05, 0.02366364074394478, 0.023610503145634953, 0.023171010340789278, 0.11977838279181163, 0.1149463378327138, 0.11877466274865456, 0.03830579554430458, 0.03856425052896362, 0.03859469056901488, 0.029113929265833782, 0.02817212054849061, 0.029107641193088618, 0.2022484027958361, 0.09885437834224797, 0.10213232239776493, 0.014593606652877456, 0.2407032637404909, 0.057179338003185864, 0.19641251501674128, 0.21500489423676106, 0.207209558831016, 0.18941688233621046, 0.1989895341089063, 0.21677025457942645, 0.21907879940338348, 0.19565528253352438, 0.23036367408165348, 0.018995416001620247, 9.999999999998899e-05, 0.014121531262554887, 9.999999999998899e-05, 0.023301974301386474, 9.999999999998899e-05, 0.038624384458836314, 0.05405624479247961, 0.022127552959834262]}, "mutation_prompt": null}
{"id": "0d7c716c-0140-4a09-a2a3-797f6eba8816", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.05  # Slightly increased cognitive coefficient to enhance personal learning\n        self.c2 = 0.95  # Slightly decreased social coefficient to balance exploration and exploitation\n        self.w = 0.7  # Modified inertia weight for better exploration-exploitation balance\n        self.F_base = 0.5  # Increased to emphasize mutation's role\n        self.CR = 0.85  # Increased crossover rate for greater diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization using logistic map for improved exploration\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * (4 * np.random.rand(self.population_size, 1) * (1 - np.random.rand(self.population_size, 1)))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for more gradual inertia weight reduction\n        self.mutation_adjustment = 0.4  # Increased to boost mutation impact\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with enhanced adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined hybrid algorithm integrating adaptive learning factors, enhanced mutation strategies, and chaotic sequence exploration for accelerated convergence.", "configspace": "", "generation": 52, "fitness": 0.27259879171404156, "feedback": "The algorithm RefinedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8729964337119076, 0.8772763667379544, 0.8594016675994586, 0.876872232413448, 0.8639027954006018, 0.8619565765093234, 0.8639504538662428, 0.8688924493174325, 0.8632728777273229, 0.7445567192278533, 0.2612043626847743, 0.21103832398279054, 0.1769771506520823, 0.1961961490537799, 0.10869286826980784, 0.05828754817809845, 0.41413959176328685, 0.07923317638952998, 0.18232930096989786, 0.15952119192707725, 0.179081294772802, 0.13275450926166632, 0.17810552925134326, 0.17573455707093766, 0.14164277042549034, 0.15855560281778258, 0.1621589315306543, 0.06609652669219579, 0.1114962622398471, 0.1509831141848328, 0.11167616897641675, 0.11139845269631365, 0.12161739824953599, 0.14026798847268052, 0.12765419055130334, 0.13716142125144237, 0.9671694206894187, 0.990653370606626, 0.9728721761136796, 0.9627961384213303, 0.9554421727831818, 0.9644707478663828, 0.9861140553806499, 0.9815017956388248, 0.9773313634812727, 0.5554323452606885, 0.15410480525674553, 0.7105989751988205, 0.3823823594863739, 0.6472695035658106, 0.5198285002919956, 0.16138227575942843, 0.475951474433027, 0.6520994470561501, 0.8785687255867012, 0.22120681274060527, 0.22370031121419165, 0.15666418930952863, 0.8698781218676416, 0.2111145058329853, 0.21983872949077388, 0.23055841478187378, 0.13725524957556479, 0.15190054614300263, 0.13264698024354116, 0.1801133588872813, 0.1555087571500906, 0.1622425914498219, 0.14137566201209317, 0.1317709113444967, 0.175160558845748, 0.2432449918925308, 0.16138381875832453, 0.1163279256871731, 0.13140951583919136, 0.18676643209141863, 0.2212230041324328, 0.1540999940110347, 9.999999999998899e-05, 0.11703815463817313, 0.1644149906583019, 0.03708555883326736, 9.999999999998899e-05, 0.06036287492316006, 0.03599916536814507, 0.03114073336594325, 9.999999999998899e-05, 0.0073997210413888626, 0.08408113377263504, 0.010992529931845296, 0.14123442205713743, 0.08207006499553393, 0.09644812773833034, 0.017274590280401347, 0.0756996429160901, 0.05790736323271628, 0.11185519553042489, 0.05274926365727883, 0.03982456683586555, 0.09190574721981848, 0.03342978549774345, 0.12379428127670866, 0.0821687587896317, 0.0769821234581114, 0.07265266761910572, 0.14428369263100527, 0.12185819052618918, 0.0736137522385647, 0.18094424976624146, 0.019675707582308855, 0.3182016667810146, 0.007372313080316828, 0.12665507068839177, 0.10050029240394509, 0.21011683901742018, 0.08093291921406798, 0.08132291468215913, 0.5606695044450554, 0.5252733646740374, 0.6065775340558325, 0.5693348743420816, 0.5714296876115786, 0.54129649729219, 0.5900269006405976, 0.5538280744729913, 0.5645293942115601, 0.1111199135557348, 0.09025959957383878, 0.09133517962554505, 0.11896047010031274, 0.12168591852601363, 0.14131273262034716, 0.13291617763424313, 0.1300370016651743, 0.1162262095626806, 0.2890582062377909, 0.20533129577078313, 0.20924677994624485, 0.19422491869583502, 0.1951190315373973, 0.14884473611655435, 0.2389983329888098, 0.28063027048275446, 0.24466975755049547, 0.3201299467293556, 0.17170105070565989, 0.3837944833396728, 0.3641593242809603, 0.5840034597874608, 0.36584185244767875, 0.29258100448158797, 0.6338635069056446, 0.44538010260770633, 0.13168073949119297, 0.09800775321452582, 0.2499306836391867, 0.1917283401551917, 0.2524571850132241, 0.21932360903082793, 0.15121331083194745, 0.22868562007609594, 0.4405706469160402, 0.2408093204146755, 0.25958882596302324, 0.2701118349310967, 0.19843043918069003, 0.2131781384351935, 0.23557844438762365, 0.247561191465545, 0.23614350827333808, 0.21743311934338783, 0.19348917570206237, 0.22240435821997329, 0.18602144882273142, 0.2226622035319874, 0.21547049594251377, 0.22603252532982976, 0.22115457929410876, 0.249326665227263, 0.2076925041450397, 0.16092016790139263, 0.15367028077269984, 0.18842906601564235, 0.15309502458395985, 0.16341061523883926, 0.1686001641563789, 0.162963357275558, 0.27078124935429404, 0.16446969293291136, 0.11141521183414005, 0.3645385633717224, 0.2093840530193637, 0.2719893972683495, 0.21214171692408978, 0.5094731592897297, 0.15521902086140016, 0.4947069316020112, 0.1553407136618684, 0.1809001387826662, 0.20057394285331498, 0.19195599362965787, 0.2044578655300886, 0.18103429018448858, 0.2063853959321107, 0.24446791647332422, 0.1719879500085868, 0.18621680907529103, 0.09944950510697759, 0.1065757205835125, 0.10195537276944966, 0.10079834756208872, 0.10299701342318512, 0.11234199911388076, 0.10550906420114115, 0.10009715501235783, 0.09326931847022757]}, "mutation_prompt": null}
{"id": "eafa5df7-3417-455f-ad13-0efe75b55371", "solution": "import numpy as np\n\nclass AcceleratedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Fine-tuned cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Fine-tuned social coefficient for dynamic adaptability\n        self.w = 0.5  # Reduced inertia weight for faster convergence\n        self.F_base = 0.5  # Adjusted DE mutation parameter for better adaptation\n        self.CR = 0.9  # Increased crossover rate for higher diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly increased adaptive factor for inertia adjustment\n        self.mutation_adjustment = 0.4  # Enhanced parameter for adaptive mutation scaling\n        self.global_search_intensity = 0.1  # New parameter to adjust global search intensity\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with accelerated velocity adjustment\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Differential Evolution Mutation and Crossover with improved adaptability\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "AcceleratedHybridPSO_DE", "description": "A refined hybrid approach combining accelerated PSO dynamics with adaptive DE mutations for enhanced convergence speed.", "configspace": "", "generation": 53, "fitness": 0.26439053883289093, "feedback": "The algorithm AcceleratedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8771733989350157, 0.8575965629013252, 0.8748287433758242, 0.877617952252714, 0.8502714747108329, 0.8554636990689907, 0.8823867273694869, 0.8891581773739442, 0.793589610680929, 0.08046113889194528, 0.16135021244310332, 0.08820778187986056, 0.3758189240918529, 0.6062703190425804, 0.7369235762915947, 0.061688421550657235, 0.724800988945847, 0.1835150670764938, 0.07435447207937307, 0.11519898537619921, 0.08441841522018334, 0.12390997243946045, 0.06877187037409294, 0.06982667498927253, 0.11379986866726322, 0.10823204561130295, 0.05873385413139731, 0.03803107433037989, 0.16638169621043164, 0.15641933488807513, 0.0439009666780974, 0.0827228376247533, 0.13523398292481814, 0.12386835040225452, 0.15284358452259783, 0.0904334608514884, 0.9817772221927185, 0.9855142465155814, 0.985257314698436, 0.9828583863322854, 0.9811079465642667, 0.9565298858100777, 0.9785466682142927, 0.9844170706419649, 0.9863412013190055, 0.5685205298822289, 0.6716038267016216, 0.7426437800068224, 0.3716185489062722, 0.3497173346536546, 0.5076257214707409, 0.08777499267682776, 0.08546743345118979, 0.7150712327267656, 0.23740961669648197, 0.223470317640866, 0.31982505327964317, 0.19053324243043834, 0.1601740238847833, 0.19307744339015243, 0.1160160609829547, 0.17895463782841015, 0.8919881164324804, 0.1285192430430392, 0.1772309264213875, 0.12355030609763251, 0.12967563597394816, 0.14194947409964165, 0.131447673162721, 0.1615507747360274, 0.2902082942824018, 0.1327130833471314, 0.12682399969671365, 0.191726070940765, 0.1709408128722909, 0.1418187716910243, 0.24337944633484443, 0.08802493755047758, 0.1273276453418113, 0.17249147888040828, 0.14300656907957532, 0.006536005675609302, 0.00010000099692120124, 0.002412117710476891, 9.999999999998899e-05, 9.999999999998899e-05, 0.05820689720143224, 9.999999999998899e-05, 9.999999999998899e-05, 0.16929070368242205, 0.05601282247828021, 0.053219519407649796, 0.05326634930461682, 0.025103069688472868, 0.009886946037012234, 0.04726820035807755, 0.03738518921604883, 0.08178872203624543, 0.022998003915222, 0.12042259896067675, 9.999999999998899e-05, 0.09365335934683494, 0.07554233351447237, 0.08961351181452615, 0.07466437787424762, 0.14611056212465778, 0.10011683207843236, 0.16524297462738102, 0.0913774163100376, 0.041669916690334485, 0.09937576364281009, 0.006606754113957725, 0.005684110168166945, 0.008529250791648901, 0.08312550542277308, 0.05465896042666263, 0.1594249062858063, 0.5077978747492542, 0.5412311831313057, 0.5338795760051442, 0.5817285415356488, 0.5285862908710945, 0.5202954629806238, 0.6025125393756612, 0.4689223866669727, 0.5679303510972384, 0.060419014994953835, 0.08322337059042006, 0.05139782526456327, 0.10164487494076435, 0.1470979522418442, 0.12995674215392994, 0.0907418366481797, 0.14101224545589208, 0.10882811885432897, 0.15757120782775258, 0.1644611490346255, 0.19661689597220045, 0.23014600199017465, 0.2071704399600356, 0.23170056649516568, 0.1266636488410774, 0.17194957083371243, 0.2101528931723876, 0.4406747307705242, 0.17724814994227123, 0.5041162856013451, 0.3304657025200909, 0.4115931140381651, 0.25364670271462286, 0.4839763030081219, 0.19332099121545732, 0.1766206553904287, 0.3221812545920173, 0.24790434935437855, 0.12082972828922067, 0.29688243333650277, 0.1845094464516721, 0.25895678203487127, 0.13524963438544624, 0.48394213084974536, 0.40064212984433856, 0.21038256253889576, 0.1790188074559823, 0.2360627240476515, 0.20738880047579955, 0.25497175407855655, 0.20464427282559028, 0.22019547023493835, 0.20545487019524122, 0.20160392832395113, 0.19417276067643496, 0.8187073854026921, 0.20849593931415233, 0.19778063732623685, 0.22008489888403215, 0.2439640587743952, 0.19084711665569432, 0.1882740985164464, 0.21896094902645746, 0.18551753749900834, 0.19940705950196858, 0.16828865966287632, 0.16696857799599585, 0.18074592032685433, 0.16882118482595776, 0.8868908868282086, 0.13863614498143284, 0.15427610471718778, 0.2110193151337919, 0.19667701912370505, 0.16808666640162717, 0.21078448214187517, 0.12755376249489747, 0.16542141535201083, 0.3193247384049016, 0.6036493971276852, 0.1506019699863278, 0.18088038536220752, 0.200538890840532, 0.18955688600444887, 0.1890074440315096, 0.17482708139116399, 0.19117594265271787, 0.18582219394418187, 0.17725479677522327, 0.22701182689130728, 0.06344323304767918, 0.09144906932328012, 0.10282111123233295, 0.07813601863923525, 0.11560652082067335, 0.08443735172611433, 0.10532840022797263, 0.09026528714027393, 0.09048807958078908]}, "mutation_prompt": null}
{"id": "5bd9c6d4-5ffa-4cde-baaa-1ef6b097c615", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "66f20f6c-b50d-47d9-9fac-114b9eacb9ea", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "b91f8d71-5c90-41dd-85e9-675661fe3005", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.8  # Adjusted cognitive coefficient for balanced exploration-exploitation\n        self.c2 = 1.2  # Adjusted social coefficient for stronger convergence focus\n        self.w = 0.7  # Slightly increased inertia for initial exploration\n        self.F_base = 0.5  # Increased baseline mutation factor for robust diversity\n        self.CR = 0.9  # Increased crossover rate for effective recombination\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced initial velocity range\n        # Chaotic Initialization refined for even better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly stronger adaptation for inertia weight\n        self.mutation_adjustment = 0.4  # Enhanced mutation adjustment for dynamic conditions\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with refined velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply refined adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with improved mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_V2", "description": "A refined metaheuristic incorporating enhanced adaptive strategies, chaotic local search, and refined inertia dynamics to accelerate convergence toward optimal solutions.", "configspace": "", "generation": 56, "fitness": 0.29139702438941484, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8659001714164982, 0.8607465387272775, 0.868053247484541, 0.864070604827998, 0.848558592095681, 0.8595991247522594, 0.8620017688105424, 0.866925464528737, 0.8614048223411064, 0.13456194005976851, 0.725355328357078, 0.7404422368517627, 0.12602879525214483, 0.693837855638354, 9.999999999998899e-05, 0.6759145318396467, 0.7502981231578332, 0.7170472319252827, 0.10766270182887017, 0.12648102311091047, 0.17432995230406378, 0.11566961000929932, 0.18174453451551775, 0.07194398357512277, 0.15907750003957577, 0.1490480082928436, 0.11659299986638816, 0.050106798900422134, 0.12710692110533073, 0.11309361251485894, 0.10492645719723592, 0.10273204144568449, 0.11493532028422015, 0.08722576626204759, 0.10115014466970929, 0.07844872492415578, 0.9811709703435126, 0.9851990758791201, 0.9727530183443505, 0.9814449990533415, 0.9811239810103695, 0.9463265816506665, 0.9818385139140229, 0.9812961023467268, 0.9822821783084276, 0.6038097652897796, 0.5767046360980548, 0.6969554979080773, 0.6254158736778209, 0.3647047103658143, 0.49518746540807734, 0.08696983047824902, 0.08669005128645679, 0.628759054914029, 0.21993508636267844, 0.21621503523688623, 0.7973062615701074, 0.19073932469420118, 0.19036672310682023, 0.19314917642225993, 0.22973355068789925, 0.1402168731983744, 0.3829873237100778, 0.17058353139290794, 0.19015064756009104, 0.1942483735487528, 0.1358347484421798, 0.1253307587165422, 0.17333028144988527, 0.15225588410293245, 0.13153745068405043, 0.17526661356478523, 0.16184148588627445, 0.20234212147473063, 0.22205941132297735, 0.1575258395913508, 0.1897211017350845, 0.17241037034802997, 0.1922433323141658, 0.17942659150410456, 0.21052026288730696, 0.1317584027901112, 9.999999999998899e-05, 9.999999999998899e-05, 0.031627599988272914, 0.13566503005065367, 0.15790823640125873, 9.999999999998899e-05, 9.999999999998899e-05, 0.08429333749173729, 0.08631122279364445, 0.06344010751075779, 0.09579250437424602, 0.06841763833617731, 0.09170901463300452, 0.03304771169641407, 0.06029778908913763, 0.10388035274187624, 0.21940775656050127, 0.21198429544773412, 0.08779656285540682, 0.09648122772523215, 0.2470911293111886, 0.08879736412844164, 0.07348879580878331, 0.16951990951597184, 0.17650710200990138, 0.16822285223671785, 0.06386668796425843, 0.19326310077452535, 0.07914214274513376, 0.14151398652937874, 0.2016090153850365, 0.08560844754871866, 0.08159876984302206, 0.11891245290505104, 0.10524773743667026, 0.5107346651168774, 0.5237805504052254, 0.5657920387809042, 0.5725961009520499, 0.5540418428179026, 0.5856632999890132, 0.5848954606236044, 0.5967854498684125, 0.5524291510087038, 0.07848550488160366, 0.10589328364068384, 0.07793099632523848, 0.09392697608209022, 0.15772538956483717, 0.10614468492023788, 0.14208803061923936, 0.16016153718644177, 0.15866466300407467, 0.18523507642696369, 0.278376148329076, 0.2287176773374252, 0.20425925639623166, 0.25467133922721774, 0.15979414011462467, 0.19347682463574467, 0.21111353026105484, 0.2967594666102279, 0.24388311107575567, 0.5404447793292834, 0.3097615431176991, 0.33328852679759435, 0.3260748403281375, 0.5277008650569281, 0.5121741364247429, 0.28646133562623455, 0.45249646094431784, 0.2602023451592127, 0.23301263447354037, 0.1729839945618309, 0.25687145509169085, 0.3159151657652718, 0.24336977469685883, 0.15459396184837937, 0.2624767789459539, 0.23104947696225064, 0.22096330742196568, 0.22384540167463063, 0.2440855452958004, 0.2391880050249433, 0.23472366870609163, 0.23070542424884743, 0.20671850392953606, 0.2623784177808035, 0.18860151602417619, 0.18694621635744157, 0.19715206089391524, 0.7791515390945561, 0.18549033899752254, 0.21117672260332, 0.6069433675008394, 0.20306418662065673, 0.21041699072119013, 0.18985595789070242, 0.1862635077296283, 0.2002494446325942, 0.16885710521599884, 0.11924414899396218, 0.8945590200333348, 0.16845282928604322, 0.1529437999329868, 0.14830897581295244, 0.15392583948078864, 0.18248283828609346, 0.1919812275645959, 0.21098844695261088, 0.20324555807060174, 0.20965147320630517, 0.5029339914449297, 0.4679815386226285, 0.4588528710214542, 0.15607623428581652, 0.1961609732210271, 0.2019507574104238, 0.19812968566937084, 0.20735645106432243, 0.19516223592652027, 0.18612373607475596, 0.20542925231525944, 0.20823088442758075, 0.21076163071170773, 0.09441501801779772, 0.10566792115268187, 0.10384140402436748, 0.08916693358230954, 0.08507622692304218, 0.09596898992989933, 0.09760555965517959, 0.14045196834340945, 0.10530611563820369]}, "mutation_prompt": null}
{"id": "28c3959f-0199-4bc1-ad50-0e720b854051", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population for better exploration\n        self.c1 = 1.5  # Fine-tuned cognitive coefficient\n        self.c2 = 1.5  # Balanced social coefficient\n        self.w = 0.7  # Slightly higher inertia weight to improve global search\n        self.F_base = 0.5  # Increased differential weight\n        self.CR = 0.9  # Higher crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.45  # Enhanced parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity adjustment\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Differential Evolution Mutation and Crossover with enhanced mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.3:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c, d = np.random.choice(indices, 4, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c] + self.positions[d] - self.positions[a])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Adaptive", "description": "Enhanced with adaptive learning rates and diversified mutation strategies for accelerated convergence.", "configspace": "", "generation": 57, "fitness": 0.29550691790570416, "feedback": "The algorithm EnhancedHybridPSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8320233787982676, 0.8268964905491432, 0.8415400988473373, 0.8248262891450406, 0.8310419356055092, 0.8333173587174132, 0.8184521265644207, 0.8253553986076044, 0.828714225893779, 0.6905255992148434, 0.6634131805744605, 0.11443045589924261, 0.6684025863291081, 0.673643041382363, 0.20039282369848355, 0.6179025145413747, 0.6280446152341307, 0.6502129473166689, 0.1508968684496642, 0.09672673938498555, 0.15398693232707028, 0.1779471863446166, 0.1306474553648299, 0.15682907903265564, 0.15376356227166432, 0.15467374321620664, 0.11215542366947406, 0.10541867079747425, 0.1040081805362999, 0.126082762605771, 0.10809744022303769, 0.14804956537092007, 0.09113477104184964, 0.15026776033539313, 0.1269213295142012, 0.1403283601408375, 0.9829916230906329, 0.9874779683292745, 0.9759318727885765, 0.9832768158843773, 0.982486313149657, 0.9867477255221864, 0.9875257627107593, 0.9871961543205939, 0.9732313010738216, 0.6375002694441656, 0.571187365662207, 0.4817664035617305, 0.7013027128641032, 0.6467999044699535, 0.6961336509549879, 0.5449251411092098, 0.5334204737017416, 0.5703091976117196, 0.20517027752844652, 0.8649235260203485, 0.22226496314800948, 0.1922327947454716, 0.1922566574909117, 0.2040977846400498, 0.11657084352067959, 0.17359139976738147, 0.8902680706842946, 0.12935627774840208, 0.16189308264714486, 0.20179854635610217, 0.13185328517984618, 0.21240813404308823, 0.18271482076869894, 0.15489871914531728, 0.11983679147741311, 0.19622564557799527, 0.20579503374854635, 0.11306781549342781, 0.166666877435939, 0.18899299802161384, 0.18927417351199416, 0.12666980781865422, 0.2000455134732091, 0.12004743561029463, 0.17998484226983258, 0.05811942151218996, 9.999999999998899e-05, 0.021536667593519243, 9.999999999998899e-05, 0.0005675843346025777, 0.017774881356316108, 9.999999999998899e-05, 9.999999999998899e-05, 0.08455122548823779, 0.12320758001318277, 0.07315257478699533, 0.08384098665785511, 9.999999999998899e-05, 0.09601949815949773, 0.05017865723118775, 0.05066645575867712, 0.07305603921021431, 0.03196025668209801, 0.24002663745745256, 0.14177982501664432, 0.04676222047965717, 9.999999999998899e-05, 0.06935626014793994, 0.08150064712280802, 0.0883540031377128, 0.06373324858784779, 0.06352269450443182, 0.09700310909910859, 0.07751437552587959, 0.15606711471973522, 0.03631550669771422, 0.29525033289419556, 0.24172079446608008, 0.05072128820148614, 0.09750846015050096, 0.1386588049436821, 0.5377921320532659, 0.5424819068196464, 0.5498898268332353, 0.570241001163901, 0.5856208297602556, 0.5540351796893497, 0.590202051050699, 0.5730773132712885, 0.5782478532344866, 0.1150410843688352, 0.09194696928300838, 0.06381750148343202, 0.14261825292880892, 0.10958621052648287, 0.1337846308956281, 0.10112973089259958, 0.08975317787007075, 0.08603206576695777, 0.23447650659384578, 0.32617667788894666, 0.31455733661724405, 0.26755057845841934, 0.31574890872735983, 0.1819458098161285, 0.24038869028950516, 0.2503266799770807, 0.2486565390771578, 0.32153926965719526, 0.2114940262859739, 0.2076618573230028, 0.5365689969560107, 0.4621470146197737, 0.4477743278551719, 0.19796994631575437, 0.5070304128794967, 0.4967499633852014, 0.291326627241949, 0.08768047769062282, 0.291318303818657, 0.4584416585057498, 0.28910500566136776, 0.38713400292721867, 0.2823432734937369, 0.2534051329938303, 0.2258186104381732, 0.23525492783216773, 0.19914242715727482, 0.20054242670691824, 0.2292118709853671, 0.3306618415295266, 0.19602150781108307, 0.23009831453929752, 0.21113998163735792, 0.18714476429274518, 0.22262111287305875, 0.20643141968849654, 0.24797696440319694, 0.19670762719899348, 0.19726078646924006, 0.19592965124333073, 0.1939901779416927, 0.21960760459835782, 0.20951626023949543, 0.13055321847365053, 0.16509152239377656, 0.18792050526881676, 0.19734577239886764, 0.15878249031188918, 0.16797305356125103, 0.6075813317680665, 0.13145150695763608, 0.7961644365948879, 0.20313177344808886, 0.16955494648377967, 0.8050458889557119, 0.44905870590000685, 0.12793120574868555, 0.23232434108474342, 0.16868641846502364, 0.1045661683151704, 0.1558014718655779, 0.22938400194752306, 0.20625699523289776, 0.22263118456011277, 0.24539247579958579, 0.1881754610420654, 0.20761750816385005, 0.18011578000700557, 0.24766497247836783, 0.2406818698902784, 0.09453669503945406, 0.09153699590750097, 0.11037235002529655, 0.09843695386821893, 0.09852520800558373, 0.08466801028314241, 0.09536164290547988, 0.1034108338357943, 0.08465172650377606]}, "mutation_prompt": null}
{"id": "8e349fb0-84ec-41b5-8405-abd1760d7c56", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "01f92a11-78d4-408e-84e0-11bdedc6a5f4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "57de6a2d-1446-443b-8b19-86c2e87e3c8b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "0f86d26e-3c05-4216-a2ce-81b24bb5ad73", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_AdaptiveRestart:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.2  # Slightly higher cognitive coefficient for enhanced exploration\n        self.c2 = 0.8  # Further decreased social coefficient for more controlled diversification\n        self.w = 0.7  # Adjusted inertia weight for balanced convergence\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for increased initial diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None] * np.pi / 4)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n        self.restart_threshold = 0.1  # Random restart threshold for diversity maintenance\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity adjustment\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < self.restart_threshold:  # Random restart if diversity is too low\n                    self.positions[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.dim)\n                else:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_AdaptiveRestart", "description": "A refined hybrid PSO-DE algorithm with enhanced adaptive strategies and random restarts for improved convergence speed.", "configspace": "", "generation": 61, "fitness": 0.22995580474420513, "feedback": "The algorithm EnhancedHybridPSO_DE_AdaptiveRestart got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.4987497843719725, 0.49787943559401426, 0.48361699625339694, 0.5019858645147355, 0.4864092329184304, 0.48497633215610114, 0.4984671589652002, 0.5041386650891255, 0.4794101779725468, 0.04412419851033411, 0.21243071009603953, 0.26322514130432406, 0.28055810636185075, 0.03933007419519885, 0.32584576156016254, 0.24521173187071876, 0.23344841992909438, 0.33457436146684394, 0.11213090145783933, 0.10589217321282118, 0.09889285869957876, 0.14361343673272586, 0.16612571081562888, 0.10273429703441139, 0.12733064924057835, 0.14548967545163483, 0.12984324294588423, 0.10692233085011105, 0.10977242106889151, 0.09918940582295455, 0.1077102391922865, 0.12565936993843152, 0.13138486800387783, 0.0974108217071864, 0.1100974669725161, 0.10297464066635964, 0.9663993040945925, 0.9916340167639638, 0.9858409410578528, 0.9390961409467227, 0.9327711488188002, 0.9514207414288626, 0.9755868775723101, 0.9847252733598175, 0.9697218091114073, 0.25625460188044435, 0.3496523802481357, 0.34942793710418996, 0.3027274706838773, 0.30911115428682245, 0.2922775301826833, 0.31880591524351043, 0.32533561582623194, 0.267139376304263, 0.21651198722177756, 0.3115764708013471, 0.7265658316018593, 0.18302129156974833, 0.19523030294037202, 0.20481752326466673, 0.22567681982323406, 0.219087623905993, 0.2327106023155303, 0.14099515808317808, 0.15034975956884533, 0.1538485329931344, 0.15370813355145152, 0.16522505470794258, 0.14198229074432278, 0.1481622204759847, 0.17215116091300475, 0.14236314409734985, 0.12325287162592691, 0.15028102098026141, 0.1877909828711174, 0.14676623077075523, 0.14772555952765487, 0.12570034777751948, 0.12176646738216679, 0.27690079053536687, 0.1614841776503072, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054451234337133836, 9.999999999998899e-05, 0.05588601398630433, 0.0005331838500233221, 0.01560443011985757, 0.1139258784882703, 0.046453269327860314, 0.06270656049321444, 0.06309157113144714, 0.07380194977280075, 0.028119238786528, 0.016400832114375263, 0.06775484933235476, 0.04789767378044685, 0.007346715441941543, 0.022884969911229236, 0.052381412502979785, 0.005139665035992946, 0.025213788410172855, 0.05697507949590852, 0.035409199689979465, 0.09460338021660697, 0.02539915400951609, 0.10054606359402274, 0.1778438491713954, 0.09584282201456895, 0.08825847225156758, 0.11697465584257227, 0.0980835552056375, 0.07592140854761287, 0.08768780972266488, 0.10297768582546774, 0.4721023478175598, 0.4596422474874152, 0.45398595455829804, 0.4219847289335166, 0.4209062667875699, 0.42912627323864583, 0.44307890966946795, 0.4499106595182265, 0.42559797958468504, 0.1100883174608509, 0.14058627455673345, 0.09058619911281496, 0.12670897871287856, 0.12300129109189184, 0.12505902687323434, 0.10763317198598965, 0.10917703041707028, 0.08713149978460821, 0.1509869940127745, 0.24061383468180964, 0.18761603904711122, 0.1255550389201271, 0.18934115196105872, 0.16842952032646574, 0.193029442671387, 0.14402094030288992, 0.27315978763840754, 0.3043643017397769, 0.3114300762430233, 0.28587059479707055, 0.2935569060694263, 0.26888009465827056, 0.305900723641373, 0.2965184888388257, 0.3074711905961425, 0.31895659451579483, 0.16255343496234786, 0.15692697241843123, 0.163263717251508, 0.17712800232366843, 0.19984985859904714, 0.2663919776725516, 0.22771161317392863, 0.2247333578368017, 0.2710862626399604, 0.21971100500727347, 0.17789258105469286, 0.17558271115597657, 0.19218267398148914, 0.2100972340310544, 0.1903306267646525, 0.23712990053390082, 0.21272298902620423, 0.18890126229849113, 0.19384482079780974, 0.19549660559668125, 0.2786720020131923, 0.20084642692998356, 0.22279377987192472, 0.2145165001175391, 0.22005282086109368, 0.20774278781234545, 0.23202958127964401, 0.17596768394961526, 0.18365072902702062, 0.18580611954422122, 0.8059639542189783, 0.1666433320045828, 0.1671158085970732, 0.13425306614674914, 0.5517045965494323, 0.18434056662282639, 0.19624752587715, 0.49376758409647215, 0.16579629540871488, 0.35993275583918216, 0.2072611382484727, 0.438967976889994, 0.28869428252244145, 0.20710170224758617, 0.12410212647881158, 0.19034309576603492, 0.17791969817006215, 0.18244639044459554, 0.1808798823111396, 0.18689539367614605, 0.19501731021502278, 0.17881409956494676, 0.19455556574680455, 0.18749567955340019, 0.08426972473475003, 0.08100855967115062, 0.07610731082690547, 0.07233043086434077, 0.07971986304606982, 0.08614012506326363, 0.08146917566811485, 0.08238444445197424, 0.08538581846930426]}, "mutation_prompt": null}
{"id": "76b07708-21cb-4ced-9970-bc0e4c68226b", "solution": "import numpy as np\n\nclass AugmentedAdaptivePSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 45  # Slightly reduced for accelerated convergence\n        self.c1 = 2.2  # Further increased cognitive coefficient for robust local search\n        self.c2 = 0.9  # Slightly adjusted social coefficient for better global exploration\n        self.w = 0.5  # Reduced inertia weight for more agility\n        self.F_base = 0.5  # Increased mutation factor for more vigorous exploration\n        self.CR = 0.85  # Slightly higher crossover rate for improved diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for initial diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor for inertia weight control\n        self.mutation_adjustment = 0.4  # Enhanced adaptive mutation parameter\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "AugmentedAdaptivePSO_DE_Chaotic", "description": "Augmented Adaptive PSO-DE with enhanced chaotic strategies and thresholds for improved balance between exploration and exploitation.", "configspace": "", "generation": 62, "fitness": 0.2503411745377459, "feedback": "The algorithm AugmentedAdaptivePSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.9017280077324786, 0.910951710731379, 0.9050852471908547, 0.8998073134546627, 0.8328501176747047, 0.9042005218385533, 0.9164660034268628, 0.9045759431306487, 0.9065825693393816, 0.08949506584139655, 0.3335774126763522, 9.999999999998899e-05, 0.14603928200817795, 0.4070716569697228, 0.308737765280668, 0.09101210515249036, 0.20854445529243726, 9.999999999998899e-05, 0.1223281673554053, 0.4908435530888656, 0.11547177308592638, 0.12282044281195015, 0.12237252444942714, 0.15912034002791242, 0.1106277187011463, 0.1551377187045424, 0.11893731067578284, 0.11712432685403329, 0.1508880859827887, 0.08827273914544043, 0.09740461622219698, 0.11748085605644387, 0.05455797550458974, 0.07828556714469814, 0.06960286371128, 0.051491093846483316, 0.949971841310386, 0.9758272953697271, 0.19904705725879301, 0.919142380467043, 0.3144692764533481, 0.9722830917883422, 0.9715490123234678, 0.9811950014536507, 0.9725144591584404, 0.033537638897858546, 0.059469529020155454, 9.999999999998899e-05, 0.3316398120588526, 0.2060151169026314, 0.33756237600827976, 0.10960837223701692, 0.08856555973118208, 0.20261863110063028, 0.17148477463434098, 0.1410172427176296, 0.16564273512985783, 0.21997765160439808, 0.3828739952076754, 0.21238040138133596, 0.1780853896598723, 0.37853865418066346, 0.24253026959486823, 0.11801854913919285, 0.17323397115693295, 0.15760281956570055, 0.15201608258919264, 0.12676931283984372, 0.1897570304734345, 0.15457858371952404, 0.17853450855260522, 0.14655418112885488, 0.12858571912532912, 0.17892482974699397, 0.29685025714664803, 0.15234295418350652, 0.13038694106924265, 0.1946325268646698, 0.1421741404604263, 0.2044977109276226, 0.13068341532565952, 0.03230689957542732, 9.999999999998899e-05, 0.024966068476612757, 9.999999999998899e-05, 0.0967911029903955, 9.999999999998899e-05, 0.047471502808392185, 0.04592701680221145, 0.010498792951995184, 0.07738906393168621, 0.09031699212067235, 0.07707679542022794, 0.02724781942582688, 0.12335126509516481, 0.03826467036033865, 0.07356548906599969, 0.12421575075229319, 0.02920499627233497, 0.09821129783212634, 0.22767582526392827, 0.1960539106656869, 0.33078495664372953, 0.11919760793753054, 0.20870153343388087, 0.07968401873762254, 0.09959318884026958, 0.34611222044081447, 0.11532214906622962, 0.07086342661001233, 0.1683561608847376, 0.19223515060303198, 0.26217152142843514, 0.19980441916040004, 0.1330604492067805, 0.08380064835198897, 0.2027644445330956, 0.5957799686637748, 0.5526741641366953, 0.5728947893613199, 0.5608567195864984, 0.41593221943752456, 0.6033872324924296, 0.583748019345927, 0.6228017184559833, 0.5525846287386438, 0.07373214792135663, 0.13496026755758106, 0.0667055115934958, 0.18710914755959918, 0.0957790445780583, 0.09017045287953529, 0.07937081070857965, 0.14285107850982692, 0.11550858521696461, 0.20338531884046473, 0.17803197072042098, 0.43105409548674856, 0.16532248578515774, 0.20169142053573574, 0.21773606214265262, 0.1933482266130956, 0.2675197328700629, 0.22799603453360118, 0.3253124537684863, 0.22902572390916265, 0.26122839089434746, 0.2480769169540359, 0.41586555446228557, 0.5243331653270246, 0.35723229875005635, 0.27281471224830167, 0.7088710915595164, 0.22095741250120504, 0.24683361484081867, 0.20143889595424647, 0.17020124981256723, 0.3353343541004987, 0.3220322206117825, 0.33299958628342663, 0.25375841109369224, 0.18658502515072894, 0.2739125310920739, 0.2486623336714785, 0.23129088346155813, 0.2136891848719803, 0.20742524187514721, 0.21696898378039708, 0.22976619877177085, 0.2622249736550655, 0.20824544083492325, 0.2259054202769536, 0.18978133511455708, 0.20583976275483318, 0.22660201709044048, 0.18039671260042545, 0.22738274543413184, 0.19674060735727628, 0.1846119506369167, 0.17802937130310004, 0.1864736327690758, 0.1885925075784216, 0.18792478162634985, 0.16850514839925212, 0.20226559461535976, 0.15418444957044408, 0.1611798344723243, 0.16309646990240945, 0.15478671241628617, 0.2126738597248733, 0.21160376489280242, 0.11682977755152046, 0.6196874430900902, 0.2064220406310776, 0.1408424227311893, 0.16455274840136447, 0.43618554911219254, 0.22071802867040502, 0.2018504012449286, 0.19853809724757965, 0.20859743269513253, 0.2065114344883553, 0.2185078480587298, 0.19886758213214506, 0.1891721137529756, 0.19652295720516377, 0.20348051271226808, 0.09264815511387714, 0.14462466863523882, 0.09183340560256403, 0.09077405920921633, 0.10419579102323095, 0.08795463813392201, 0.09770020923261546, 0.16661702222843344, 0.08869287173895701]}, "mutation_prompt": null}
{"id": "b1dac630-3d71-426e-b0cc-2fe1fbef03c4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Reduced population size for faster iterations\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Balanced social coefficient to complement c1\n        self.w = 0.5  # Slightly lower inertia weight for quick convergence\n        self.F_base = 0.5  # Increased mutation factor for more diverse search\n        self.CR = 0.9  # Increased crossover rate for higher trial acceptance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for even better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.local_search_intensity = 0.1  # New parameter for local search\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with integrated local search\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.positions += self.local_search_intensity * np.random.uniform(-1, 1, self.positions.shape)  # Local search step\n            \n            # Differential Evolution Mutation and Crossover\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                F_adaptive = self.F_base if diversity > 0.1 else self.F_base + 0.1\n                mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, self.positions[i])\n\n                trial_score = func(trial)\n                function_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_V2", "description": "An enhanced PSO-DE hybrid with chaotic initialization and dynamic adaptation, tuned for faster convergence by optimizing control parameters and introducing local search intensification.", "configspace": "", "generation": 63, "fitness": 0.21571490588273104, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.45709768992627453, 0.44393759801386445, 0.4614071378383502, 0.4739981802869201, 0.4540245835223049, 0.4336882917711178, 0.44926721695777183, 0.45534112700236395, 0.47425382790009685, 0.015010808692093591, 0.046295648851435334, 0.004245713455842126, 0.02420774559285932, 0.03228430696210238, 0.02460588220095905, 0.021735390225166018, 0.046706951520456785, 0.029368181845643493, 0.11854189689822348, 0.09874149445551161, 0.09443290074911215, 0.08692489524787927, 0.0664579596311129, 0.12103784801159168, 0.10718686829944468, 0.10169613808327027, 0.13380145457571557, 0.08658961727338699, 0.10568134052501188, 0.10674446930242598, 0.08527489508758512, 0.08619289951155551, 0.09612615394964852, 0.07688574537671355, 0.09543280783677233, 0.10043086966140635, 0.9595818365710584, 0.9723011659593506, 0.9660459295808168, 0.9388194457941789, 0.9607284409249648, 0.9749367467566014, 0.9820977072928407, 0.9769983847436154, 0.9818748591944123, 0.2656488963606476, 0.28175767610961866, 0.22733829382786652, 0.28049990441604156, 0.2913353170780284, 0.29230291588341983, 0.2653195966830155, 0.27038869029583634, 0.25609795934476265, 0.22310665852453537, 0.3331091549881706, 0.5260247448319503, 0.3337300267417245, 0.2672693163877461, 0.3694243608132155, 0.2914912065934795, 0.29238554564077923, 0.320778599115632, 0.2041489782309357, 0.12492051996127707, 0.17223060071083418, 0.18091709252207344, 0.15902334219523384, 0.16073107012326204, 0.15580651510150345, 0.159109762612906, 0.1682054166939484, 0.15779370346555477, 0.1719005833577154, 0.17965395441371912, 0.17010855592263907, 0.18445033084028728, 0.16946051553139163, 0.1755600850904533, 0.17332632018197147, 0.16596423227967572, 0.01281824886146421, 9.999999999998899e-05, 0.0014901664214020949, 0.010243976780595632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026524184280023344, 0.06419830942028926, 0.04648552697663422, 0.06626142408120173, 0.05134864252532534, 0.040657608453912863, 0.031248516950176608, 0.12138727966148344, 0.035296057485081245, 0.05989136891688085, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0986094855704106, 0.10689399941141764, 0.0897065192045895, 0.07502426841063603, 0.10344497622049986, 0.10467261381589055, 0.05870948925768893, 0.07017324593458885, 0.09513100236414407, 0.4005953715787972, 0.41618752960834493, 0.4337542025990637, 0.4043461150839984, 0.4111942768239374, 0.40917014469853696, 0.4206421614552369, 0.42116805017941983, 0.40777180149801784, 0.09057983539085213, 0.11310253826204064, 0.07349530826873307, 0.0957486160507548, 0.11574524146901988, 0.09459816877723626, 0.08456317157162174, 0.08362189320494584, 0.09914736928265988, 0.14675594887151033, 0.14298381085001277, 0.15901479781448435, 0.23008401876678886, 0.17652128873189632, 0.24548384459485095, 0.15162707698382805, 0.2534752561940571, 0.21262349895437505, 0.2783514871264716, 0.28052000648597064, 0.2973333968646039, 0.28994977537346545, 0.3007147134282352, 0.2841956107396202, 0.3017539730871003, 0.25713570831807053, 0.3199294265114999, 0.24721639721697464, 0.19265547719848042, 0.21485697610609455, 0.17455289843571886, 0.17337181321567063, 0.2305813911031881, 0.21824560071320476, 0.239444411009207, 0.21614033100445518, 0.19098106598600229, 0.2035138814169437, 0.21363008897822267, 0.1935436023489866, 0.2019180169360162, 0.18612317204104178, 0.19461573501849894, 0.19288192307675944, 0.2271062828871221, 0.20360026691503186, 0.2448594756400274, 0.24190099266874165, 0.21140807458838073, 0.22605511056891325, 0.20554425272945642, 0.19643501909738437, 0.2013532959563762, 0.17447463281839537, 0.672329054989148, 0.18797954450308763, 0.18657351766480956, 0.16488069699541574, 0.6613154242365462, 0.1658105068674528, 0.16178787807542971, 0.1527278118743428, 0.1516236231024266, 0.4741404065949024, 0.21031554402334995, 0.11138215343767621, 0.5417442845953488, 0.2091541984834927, 0.21004080640532452, 0.16697792991048876, 0.10418096213173267, 0.5117632384998821, 0.17413730228262536, 0.20073710294447678, 0.2048887935957554, 0.1908698538043685, 0.18512661531013608, 0.18986013818874214, 0.16976198390679875, 0.18679521091322948, 0.18359932303816884, 0.09213580140231592, 0.07850455657218203, 0.09451709641957873, 0.08094851250272694, 0.07389043421481767, 0.07760481659919094, 0.07067039650772255, 0.07793562541302612, 0.07483449575181145]}, "mutation_prompt": null}
{"id": "8f9a2f90-4c8c-4d83-986b-9c0cfd4d0f22", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "e1d8ae91-0f9b-482e-a809-bdb7a528df69", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "2ee49fd8-e1f6-465d-8217-6d4fd71457dc", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "f15182f9-3042-4bb8-bb1d-cf3a0d600ab7", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_LevyAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Slightly reduced cognitive coefficient for better balance\n        self.c2 = 1.5  # Balanced social coefficient\n        self.w = 0.7  # Slightly increased inertia weight for improved exploration\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.95\n        self.mutation_adjustment = 0.3\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities + self.levy_flight(self.positions.shape) * 0.1\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.3:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_LevyAdaptive", "description": "Incorporate Lévy flight for enhanced exploration and adaptive momentum in PSO to improve convergence speed and balance exploration-exploitation.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {}, "mutation_prompt": null}
{"id": "d4af94db-4f42-4bcb-9a9b-6c584db22306", "solution": "import numpy as np\n\nclass ImprovedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.5  # Increased cognitive coefficient for sharper personal attraction\n        self.c2 = 0.7  # Reduced social coefficient further to prevent convergence stagnation\n        self.w = 0.5  # Decreased initial inertia weight for faster convergence\n        self.F_base = 0.5  # Increased base mutation factor for stronger exploration\n        self.CR = 0.9  # Increased crossover rate for better information exchange\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for more dynamic inertia weight control\n        self.mutation_adjustment = 0.4  # Increased mutation adjustment for enhanced adaptability\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with chaotic velocity perturbation for exploration\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            chaotic_component = np.sin(np.random.rand(self.population_size, self.dim) * 10)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions) +\n                               chaotic_component * 0.1)\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "ImprovedHybridPSO_DE_Chaotic", "description": "An improved hybrid PSO-DE algorithm with enhanced exploration via chaotic velocity perturbation and adaptive population scaling for rapid convergence.", "configspace": "", "generation": 68, "fitness": 0.22387610784484263, "feedback": "The algorithm ImprovedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.44701227692202905, 0.4598912128128494, 0.4507902756717084, 0.4563304477952863, 0.46033870419346523, 0.4406089142001849, 0.4871173146788915, 0.45111646407191697, 0.45976656712058683, 9.999999999998899e-05, 0.01022686515081006, 0.04923908695347001, 9.999999999998899e-05, 9.999999999998899e-05, 0.025790078832500174, 9.999999999998899e-05, 0.010663139165018931, 0.0011434194884041293, 0.09846687224384909, 0.14897222329855309, 0.11381358224516358, 0.06781137914613355, 0.10154193382331045, 0.10254761445362126, 0.10601768698225766, 0.1500930441025845, 0.10897560826442876, 0.08442534918966849, 0.107499897285662, 0.09007762607699299, 0.09742880236935869, 0.10336721232820545, 0.12429172151704293, 0.10351519101766549, 0.08700910488141422, 0.10394766195274263, 0.9517828907674715, 0.747123438352228, 0.8973837801280415, 0.7010361837792268, 0.5964317669555452, 0.9280857387207, 0.9631959187040248, 0.9197641733519806, 0.9250621243624918, 0.3143163962732102, 0.281282560971291, 0.2643592456618976, 0.29419805130431376, 0.30476316702001394, 0.3331464472297505, 0.2670464758454201, 0.3208685283049706, 0.2894357118107499, 0.22251683113417675, 0.8107676332570648, 0.5739393179176723, 0.2170206864448212, 0.2733689506730931, 0.2197907298541404, 0.22789568576642583, 0.21513953655906037, 0.1968241993132689, 0.24726761943778752, 0.15841305061050448, 0.18985941526913985, 0.18562969775005644, 0.1828499859316174, 0.1675416353760314, 0.16443914915996194, 0.2650164209081606, 0.20937063804294997, 0.21997893599066898, 0.1738153810295998, 0.17564496163135868, 0.15603985347078708, 0.22841602194525434, 0.21255347438529526, 0.16654254452825956, 0.15490800402258542, 0.16984953338279174, 9.999999999998899e-05, 0.029864520060117528, 0.0029651254744185174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015867315887726052, 0.035772756052334986, 9.999999999998899e-05, 0.10609528493583698, 0.07171400215994994, 0.10022732428193248, 0.08979931679690867, 0.09268793733444758, 0.06507829095742401, 0.06271396101986226, 0.13604703063769796, 0.045722684308404093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11743781182108781, 0.13525667181577428, 0.0369242262064754, 0.06516992060798876, 0.11111025682136699, 0.10099653297187017, 0.09380308936429971, 0.08052251036889357, 0.05508023385108152, 0.4320285676513016, 0.43086063966060295, 0.4128574292959002, 0.42047282656221463, 0.4212741345758556, 0.4263748858303694, 0.4593561330417886, 0.4194146989427765, 0.435920020340562, 0.09525490415076654, 0.11499407956127672, 0.09948065993133293, 0.13786476585849416, 0.12428068775210777, 0.1400075652875794, 0.10935500469582826, 0.10977911239119531, 0.11807996763982354, 0.2330472447174744, 0.1362185944543911, 0.1828814061977776, 0.16699442557894983, 0.2520874153193171, 0.22862499582378426, 0.2060857851903546, 0.24651220050348344, 0.20398837496166267, 0.28471902794836135, 0.2871687261701964, 0.27905157980354256, 0.2420852154784816, 0.22194949517867757, 0.30137906722164987, 0.1851027014804194, 0.3016700066066611, 0.21217136714113183, 0.23472516259915743, 0.22867695076351757, 0.2653020341825534, 0.1848071395355324, 0.19960392521880255, 0.2122898350989324, 0.18090832463813278, 0.21572831391125802, 0.19424904864779824, 0.25026332151319186, 0.22774666107873787, 0.2360098939456342, 0.2280660416124698, 0.21095183100033532, 0.23714175548097582, 0.1922246646115996, 0.2730280061008754, 0.25609722344927366, 0.18329057823478456, 0.18706487535808825, 0.21927624698894121, 0.23053622583354905, 0.22287761555786478, 0.20466787096871497, 0.2035643340694523, 0.21115081796727986, 0.20153630312085646, 0.1867366650467448, 0.5555354463085915, 0.18806043297328612, 0.8351751958475067, 0.19693840877404678, 0.16714035331781196, 0.6837211983450677, 0.28057143382414074, 0.7016593502565617, 0.19894241735381313, 0.16916071244949127, 0.6714086109622884, 0.21169563360838506, 0.21148287318419556, 0.3289653503920429, 0.16614375303315465, 0.1674196210312079, 0.42006343235320487, 0.18788823575276692, 0.19947469531994588, 0.19892655274728455, 0.19762010693529597, 0.1891994521070406, 0.19130848389325206, 0.1857007968111899, 0.21583595869550543, 0.17517709465898512, 0.10323903802254664, 0.09661097760275639, 0.09133490364927743, 0.11189998064376827, 0.10413098189015324, 0.08752409493333013, 0.09092696088981078, 0.08282948798812251, 0.088435313141498]}, "mutation_prompt": null}
{"id": "78459ca3-8a84-4358-8717-ea54385baf1e", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "8627c9e1-4ab3-40b3-b7e4-cbee906a67ac", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "f556e35c-5562-4ef2-8dea-8dca758fb6f2", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "3d94c106-410f-4c05-9b0a-6b671bf3be60", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.1  # Adjusted cognitive coefficient for stronger personal exploration\n        self.c2 = 0.8  # Adjusted social coefficient for reducing premature convergence\n        self.w = 0.7  # Slightly increased inertia weight for better exploration\n        self.F_base = 0.5  # Increased base differential weight\n        self.CR = 0.9  # Increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.97  # Improved adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted mutation parameter for more aggressive mutation\n        self.leader_selection_pressure = 0.3  # New parameter for leader selection pressure\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Enhanced PSO Update with adaptive velocity and elite leader selection\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            if np.random.rand() < self.leader_selection_pressure:\n                elite_position = self.personal_best_positions[np.argmin(self.personal_best_scores)]\n            else:\n                elite_position = self.global_best_position\n\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (elite_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Self-Adaptive Differential Evolution Mutation and Crossover\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted diversity threshold\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_V2", "description": "A novel optimization algorithm enhancing PSO-DE with adaptive inertia, leader selection, and self-adaptive mutation to accelerate convergence.", "configspace": "", "generation": 72, "fitness": 0.26342134079495805, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8819559261913441, 0.880755538461137, 0.8792121731708074, 0.8825091594645575, 0.8776647883353452, 0.8725984184808014, 0.8845048981875316, 0.8796866539885375, 0.8861802256769115, 0.09429114094842517, 0.09108035030372552, 0.18702029749711235, 9.999999999998899e-05, 0.3767759707860514, 0.06658554235450354, 0.12041380162078952, 0.11252135152528353, 9.999999999998899e-05, 0.08297709506437245, 0.17837494845993274, 0.46188240362393485, 0.11515671635279545, 0.13580290893625346, 0.1706750455850019, 0.18346058252321118, 0.3776590659963328, 0.15484708243537848, 0.0917352387746041, 0.0907481225604897, 0.1307988604796837, 0.10682272229429235, 0.12167253353842356, 0.09849974565648967, 0.12850825251641396, 0.06917684793874979, 0.14237270319230777, 0.9726988552111752, 0.9605173023191976, 0.956526850635116, 0.40372775679923445, 0.8649959382435816, 0.9769550178480705, 0.9791856131340514, 0.9743156548455686, 0.977495459204919, 0.12193139687464094, 0.214447263343561, 0.18798427562022524, 0.33497464899445906, 0.3633350665659083, 0.4466750115598428, 0.56545594522514, 0.2832996586097466, 0.23626738087330335, 0.22269080887458426, 0.8847764112660876, 0.3906939582507519, 0.3797764610026556, 0.27734280618386453, 0.15890019140016753, 0.1736002254280875, 0.18411058464282082, 0.3905912303334723, 0.2310646791596883, 0.15067889837884663, 0.1343034576944303, 0.14994088147245566, 0.17182205801673955, 0.22902779916543836, 0.1524824739023688, 0.16493210532291613, 0.1708727961879949, 0.20422302076132492, 0.16440371639111384, 0.12873345670992242, 0.13144426393458142, 0.1324660567353041, 0.17847998919008223, 0.05167106267466137, 0.13579447741571005, 0.16882721457916683, 0.019085033556009656, 0.057519317320033014, 0.13763915442818397, 9.999999999998899e-05, 0.01908288121014101, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07878562501652109, 0.09708756272321206, 0.12701474971642435, 0.10005526262877518, 0.15162155919833653, 0.06950251507918948, 0.03883152822575797, 0.10590799424232389, 0.10510469844806614, 0.05260037538302964, 0.09894902917197379, 0.2754804552778424, 0.1636165796425204, 0.09703934139626014, 0.14721930854008802, 0.09414726159820952, 0.1301395576864368, 0.2389328702160186, 0.2529569356794861, 0.23986890588558263, 0.13408104169601776, 0.07226191488860878, 0.05571346943627087, 0.10948468838969949, 0.1777202235836941, 0.08285754036169746, 0.08354154007164705, 0.08812957603893357, 0.5770893287273351, 0.5857391511961062, 0.5059930773894535, 0.5404324875395581, 0.5177513464958344, 0.5502674555627209, 0.5655541617139761, 0.6185724311594375, 0.572844984420433, 0.10834068370921945, 0.06398477466171093, 0.15777846596214862, 0.13354683358710717, 0.12814942670746676, 0.12367260482061881, 0.09911961045880668, 0.07944819487043364, 0.15501478805993707, 0.2809054578711919, 0.33805796008360234, 0.1884287280954765, 0.16248123405896442, 0.18102444349043922, 0.190028105479211, 0.1968425458831905, 0.2138146710239759, 0.18661626325002356, 0.2543949744308376, 0.46882641673206227, 0.25269503957611994, 0.21406771089392906, 0.27637162920467295, 0.4140725090623618, 0.27915534090523153, 0.6229958939328573, 0.4714084383399878, 0.27800763417617314, 0.2228396693812048, 0.2647632192056584, 0.20843051424527248, 0.26229382564167647, 0.2585555417594928, 0.2575913566332815, 0.2799604510130683, 0.2143578538723394, 0.21366207928260406, 0.28478188302568164, 0.20135399334841142, 0.2280263364010343, 0.2164212062234968, 0.23138098532885398, 0.22719272155282955, 0.239937388111381, 0.2534094907937682, 0.24462652667856954, 0.19597677809621716, 0.2021571874051401, 0.21895794667395085, 0.18520429362600466, 0.2040636657634085, 0.20699702234533457, 0.20454806981472484, 0.22165340718705673, 0.18699616346766956, 0.9313160647507301, 0.18713316090725107, 0.346320569977423, 0.15195429526403836, 0.15777100584848447, 0.20403687972237528, 0.16874018467061636, 0.15404628127397724, 0.20572673981181944, 0.16885470241787004, 0.15474427796597634, 0.21146154414123797, 0.2093851400974046, 0.3055978230801093, 0.3222506892107502, 0.166334350510136, 0.2706021912293636, 0.1786444565877291, 0.20394338087137853, 0.19137086123875557, 0.18695797255579094, 0.1939944929589299, 0.19755447492257194, 0.22913756080464331, 0.1994560449320929, 0.19110162535013142, 0.09628695075516791, 0.08703557642080217, 0.08679688184282786, 0.15616189764102273, 0.08463865131954662, 0.09529633276490457, 0.08660670236667245, 0.08229730199836227, 0.09387237444779584]}, "mutation_prompt": null}
{"id": "7adf8c54-a3a9-45bd-b026-aed25c8d769b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.8  # Slightly reduced cognitive coefficient\n        self.c2 = 1.2  # Slightly increased social coefficient\n        self.w = 0.7  # Slightly increased inertia weight for exploration\n        self.F_base = 0.5\n        self.CR = 0.9  # Increased crossover rate for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None] + np.pi)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity recalibration\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with elitist selection\n            diversity = np.mean(np.std(self.positions, axis=0))\n            if diversity < 0.25:  # Adjusted threshold for diversity check\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + 0.3 * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    # Implementing elitist selection\n                    if trial_score < self.personal_best_scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "An enhanced hybrid metaheuristic leveraging adaptive PSO-DE with chaotic initialization, dynamic velocity recalibration, and elitist selection to bolster convergence speed.", "configspace": "", "generation": 73, "fitness": 0.254328668345043, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.5025789072523863, 0.842641073145376, 0.835622440404765, 0.8566028580688915, 0.4410719637605638, 0.2366123809162597, 0.8276242132156292, 0.8331041478332497, 0.8578706697070827, 9.999999999998899e-05, 0.17790920377873554, 0.6202649412977485, 0.6189460664516112, 0.058340963396599554, 0.043842100503547976, 0.7098641588618888, 0.049256894195302436, 0.000634097986682125, 0.693124426660912, 0.10027478251536359, 0.10271519988804645, 0.15171566406322967, 0.09162981730155717, 0.0701381235636247, 0.1025145382515622, 0.13223814354997976, 0.11109761289503584, 0.17506732982479312, 0.1049576442267145, 0.11621027694278196, 0.09395697928514368, 0.08861279577522341, 0.1144947479876477, 0.1049259520297875, 0.10055629347113959, 0.10586028407761239, 0.980236761984794, 0.9827884954479615, 0.9819959127512485, 0.9684870825356721, 0.9774695839505083, 0.9726704291708733, 0.9860278950500808, 0.9860925920858706, 0.9815260212740103, 0.22895033366056006, 0.6256955533318808, 0.7323820562019306, 0.21651709941684594, 0.7312811692436543, 0.1521315613325387, 0.15302955669299012, 0.6562136417886049, 0.11133197514648019, 0.38097667776170274, 0.16685576901659938, 0.15967202743660092, 0.26472845478561535, 0.21290137564906686, 0.20234879772907166, 0.2279089803756834, 0.17465802015776666, 0.12402525042366774, 0.15808876817673212, 0.1550593094641075, 0.15128178568019213, 0.15637233161217956, 0.20540096691890963, 0.2887417382870565, 0.16981681837606777, 0.10802509180608633, 0.17815213776553718, 0.17458337468248042, 0.16804422676837438, 0.17127490545110702, 0.12818425345002704, 0.15757031011674316, 0.1540945206674058, 0.15934821887965522, 0.20079004931080924, 0.13970359587132464, 0.004042267765416385, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1419504590305296, 9.999999999998899e-05, 0.07476246272515441, 0.12441190495515397, 0.10421673459359682, 0.06637795626565379, 0.04236193898253515, 0.01904516270956158, 0.04498586857042974, 0.029775726805363445, 0.07547570705527817, 0.1461079344532218, 0.035468669288022614, 0.04483960356810601, 0.05103254510973676, 0.06606513781013224, 0.06958804557417175, 0.1967374264923285, 0.13218390563601368, 0.35926461592717795, 0.010858524093393496, 0.037977987659186696, 0.2436979823805746, 0.06201194157647005, 0.07851984440624638, 0.037118281842690726, 0.08069821112283848, 0.23213375652936408, 0.0781850290289442, 0.5664589267596427, 0.5719768758564979, 0.5234285864694509, 0.5312175295179876, 0.2381207903377346, 0.5707569772307703, 0.5030756506282198, 0.4246004663379367, 0.5628385123720797, 0.11219124638196476, 0.05776856406019082, 0.07437380660403381, 0.09211782623264331, 0.12379637281393863, 0.09215488322248488, 0.09755086405817637, 0.13866742222681527, 0.11347119955089424, 0.2715701763540417, 0.1863414895006159, 0.21901526640429592, 0.21870160825499985, 0.17224625906338442, 0.18798227859398897, 0.1955036717421671, 0.203462354753026, 0.25829050386701513, 0.25615558907111946, 0.31491266278881913, 0.4041827720454929, 0.5866839455972463, 0.30384245648001285, 0.2642106332680204, 0.43756813469510125, 0.6965086955321, 0.42834904039547816, 0.3120917099362195, 0.10631889316445509, 0.16008492941421681, 0.22267811525744396, 0.1230068899790202, 0.18852757040540835, 0.1846007041456701, 0.23559460085057904, 0.12446897081233943, 0.17699500378052913, 0.21575300388364727, 0.2235782573380134, 0.21215432915496113, 0.22050351010527725, 0.20925424172815266, 0.24182179999513942, 0.20514030182122878, 0.21822293124365877, 0.19208416675696194, 0.24594084416918605, 0.17952265232471531, 0.19412037968239204, 0.21471122797623265, 0.2028504596810209, 0.17766993834312328, 0.1753508623008907, 0.24444953544533332, 0.1451508940430054, 0.1856532243643415, 0.8654774357975721, 0.1684903384813804, 0.16636093093162785, 0.16870052712547534, 0.15653729482991163, 0.33440747845087304, 0.20400796126354248, 0.1080899355278927, 0.5215238799290856, 0.12198209645420688, 0.5204726485752881, 0.4003366067505185, 0.2989639268687653, 0.16887818687809342, 0.207790027793463, 0.16683814172407052, 0.1811821222391924, 0.19646433667246022, 0.1980623423182697, 0.18246933605147164, 0.2153386604363452, 0.19732500318910773, 0.194064972762515, 0.18146946722766522, 0.18282840342325501, 0.07046426259502458, 0.07401574698095625, 0.07861947755583443, 0.0851843853790526, 0.07923180864970014, 0.11035416816611865, 0.08353793190750347, 0.08626240836327159, 0.09385732132737867]}, "mutation_prompt": null}
{"id": "06d815c8-a4a3-4ccd-bf0b-77a55be03a7a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_c1 = 2.5  # Increased for faster personal exploration\n        self.initial_c2 = 0.5  # Reduced further to control social influence\n        self.w = 0.5  # Lowered inertia weight for quicker adaptation\n        self.F_base = 0.5  # Enhanced mutation strategy\n        self.CR = 0.9  # Increased crossover for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.tan(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Refined adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Improved adaptation strategy\n        self.c1 = self.initial_c1\n        self.c2 = self.initial_c2\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # Adaptive learning coefficients based on performance feedback\n            improvement_rate = np.mean(self.personal_best_scores) / (np.mean(scores) + 1e-8)\n            self.c1 = self.initial_c1 * improvement_rate\n            self.c2 = self.initial_c2 * (2 - improvement_rate)\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted diversity threshold\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "A refined hybrid PSO-DE algorithm implementing dynamic learning coefficients, a feedback mechanism to enhance convergence, and an adaptive mutation strategy.", "configspace": "", "generation": 74, "fitness": 0.22245366440807335, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8771446201349221, 0.886900478444135, 0.8493109635215791, 0.8407909688741162, 0.8678570365911151, 0.8709398388998982, 0.6970825621092973, 0.8683113245946894, 0.8765102207004054, 0.38170735907851894, 0.19947595816889097, 0.050612969831128285, 9.999999999998899e-05, 0.27083022289373215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18061238477633745, 0.21311469853583886, 0.15416412561454396, 0.11532159898915506, 0.11114257671662142, 0.11747703718337632, 0.1777648169638807, 0.1401296013945006, 0.15576993885006574, 0.03592408396088265, 0.06835305595437768, 0.09134875878227122, 0.09735516812781753, 0.08746756057870586, 0.08669600945764655, 0.1140324586690884, 0.08252187843552727, 0.0849430289394646, 0.9402287345978687, 0.9716083560971768, 0.9919162675444286, 0.14414854837922375, 0.9748407923030032, 0.1333860425567044, 0.8758812347411222, 0.9449320611025759, 0.9590064587449743, 9.999999999998899e-05, 0.04518564819078896, 0.06110021568520407, 0.3561796169539705, 0.12364628254887067, 0.3439697910017411, 0.11362283563768816, 0.06795668257910292, 0.13865997432616772, 0.1752186122992343, 0.16550581776309214, 0.13825373007079966, 0.14575861800799061, 0.21216329246770516, 0.215919855264729, 0.152590208835498, 0.2198187053989571, 0.1214798827825081, 0.10861463584730302, 0.1340677352584667, 0.2386694865157185, 0.2528798175724404, 0.24432889749875086, 0.12292548429885153, 0.14047680247705774, 0.06884769166127225, 0.22431409815831094, 0.1157259229978872, 0.18449659210748826, 0.12453158868592595, 9.999999999998899e-05, 0.1417368291985307, 0.13850165313322937, 0.14391643167448243, 0.14305824178165893, 0.11310055571056743, 0.10053594625549211, 0.04132682294717138, 9.999999999998899e-05, 0.0382361880790022, 0.08499058766567436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08607526747987171, 0.05553296963729304, 0.04317100508561966, 0.03299297952186775, 0.047789029355744916, 0.02147888942137266, 0.03876841717144375, 0.02286469937248825, 0.018518742963449353, 0.13101387015350408, 0.13188680697394373, 0.19787073193012938, 0.16234424960598026, 0.100139297180038, 0.19988673247777733, 0.2264967670624214, 0.1065390567013168, 0.25103149465964225, 0.19704630865702977, 0.01736477873890907, 0.17303094373366634, 0.05335346307400357, 0.07040028491078787, 0.1411153840265359, 0.13645602488946185, 0.1799669334331364, 0.19762002880660268, 0.18852737440471468, 0.3037795319913241, 0.23368716966318515, 0.2661506350213767, 0.22955159866820418, 0.5692277256821948, 0.4212472186636216, 0.6022678760045157, 0.5835027946027639, 0.05234235949474242, 0.10367316601313992, 0.1286448869485084, 0.11574520314523129, 0.09907838190058627, 0.1490572086220152, 0.11118393917999692, 0.10718936568589887, 0.06491688353816827, 0.11433989222430241, 0.21645251998435167, 0.1846669439969172, 0.21219594603231606, 0.19791707522712276, 0.1684864049594842, 0.2484714382198494, 0.23752176335148756, 0.1599416543437353, 0.14984077846763344, 0.17703456738063583, 0.2586141837300663, 0.5861655534364781, 0.24791527392888868, 0.2920269436635926, 0.604106668744818, 0.2336086907176229, 0.40131902464921043, 0.1609731094747927, 0.15910658186792137, 0.180131422100268, 0.24207029325642015, 0.29013959083406415, 0.3159289431165142, 0.18147558380939455, 0.16333378749906313, 0.22669235211709748, 0.22732935165361767, 0.2501878871317641, 0.18386600930976282, 0.22290156485725998, 0.22609541548727108, 0.21269081127672174, 0.2704173081628197, 0.19878385247415875, 0.17637820165978524, 0.18264657217996094, 0.17010317476273462, 0.16539606320247713, 0.2797391377804552, 0.22213701806330588, 0.23653872881432358, 0.18633924164928217, 0.1808869305820554, 0.2234956720255734, 0.1741902530803191, 0.16618451089668218, 0.17522365749296387, 0.42908389568915795, 0.15209518000468802, 0.15692016475349224, 0.17195890957787574, 0.19839088635101954, 0.15509648329394676, 0.410997015011933, 0.414863992103191, 0.2163673747660374, 0.5575020222670566, 0.19873907117796763, 0.2733853599044832, 0.15312446461051932, 0.22612179422810263, 0.16668457586546026, 0.20624645107772355, 0.1944419671200882, 0.18182759999542786, 0.19873712873978477, 0.17800807391746531, 0.17871245972508132, 0.1914814030716836, 0.1892674906716313, 0.18279916218289305, 0.10440117368351953, 0.12342112769603297, 0.08245052897143779, 0.09310006535258253, 0.1062847602329744, 0.08739041337250819, 0.0827162292866993, 0.09753010164229525, 0.08623377868856874]}, "mutation_prompt": null}
{"id": "5bd7f125-a424-4342-82d7-1f322d51b837", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.5  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 0.9  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.5  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.5  # Increased base mutation factor\n        self.CR = 0.85  # Increased crossover probability for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.95  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "Enhanced hybrid algorithm with dynamic learning rates and adaptive crossover emphasizing rapid convergence through improved exploration-exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.24203991888235526, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.9160700775750586, 0.9027675261849288, 0.9116964160947351, 0.8925444118952416, 0.9186332435531234, 0.8973255549777955, 0.9165961922481194, 0.9049567404476107, 0.9147068204542704, 9.999999999998899e-05, 0.2575503269185516, 0.3125460742612608, 9.999999999998899e-05, 0.20863705835021762, 0.6922657635923499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07196029405442439, 0.15934956597926553, 0.09485347736943273, 0.15748163223122502, 0.1126611017589152, 0.1800363793557037, 0.11002530071192884, 0.18067147687884932, 0.15905038907763336, 0.12675186828995788, 0.15123432835229267, 0.17980371526963668, 0.08833016455912379, 0.12404382932119662, 0.11324156041656641, 0.1688750503957268, 0.0860599228057507, 0.0894435216784264, 0.886956069148166, 0.9265812487393958, 0.09414239365024257, 0.1110435827390307, 0.10885158685881435, 0.9727238654331555, 0.9587191462051287, 0.9662911691970104, 0.9627140339125522, 0.3301209947285423, 0.10844874771080792, 0.06206662424311149, 0.2026821428295309, 0.3013096190381771, 0.2259089714113668, 0.11002023319861232, 0.15382551779201115, 0.2405678861032906, 0.22749130772370185, 0.2256998279086977, 0.22668231028130081, 0.2817326420500009, 0.28074040382794496, 0.21340376604389644, 0.1679261008843569, 0.6471093722901041, 0.6880824373305117, 0.2652396935965248, 0.13714939456088437, 0.12805817337668846, 0.20244893732965574, 0.1382508435549631, 0.18563971457452777, 0.15146456319949597, 0.1479888191642602, 0.1442361718268792, 0.12849872653389482, 0.129709227695186, 0.15800138244280204, 0.3024071809716843, 0.13075863739059645, 0.26999804724665055, 9.999999999998899e-05, 0.13556776925633218, 0.17101917536268352, 9.999999999998899e-05, 0.0019830462371998037, 9.999999999998899e-05, 9.999999999998899e-05, 0.032377470658888186, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0790096742889298, 0.11084280598196261, 0.09691891129800312, 0.07350841617770165, 0.10738866614256726, 0.02013011117393637, 0.05041037606436416, 0.09231092717925427, 0.09202840160116088, 0.17200210763880008, 0.15425409446655158, 0.13176666315820507, 0.10652630870684321, 0.15311222745154895, 0.17989616815149456, 0.21247943166310523, 0.1201872420686757, 0.2324501194757319, 0.14059617838745508, 0.12551246741133382, 0.05867120384132085, 0.007245841135586906, 0.10856982004151583, 0.17183654401513426, 0.09365921089383589, 0.08384429504745727, 0.09826057252172082, 0.5651400702467198, 0.5348324231109696, 0.5286800264099674, 0.36240970740371437, 0.38929223693220616, 0.510076912520155, 0.5001963884687488, 0.563453160093732, 0.5721277653767248, 0.07715749604886091, 0.14098433202480154, 0.112476588593584, 0.10954606493300811, 0.11711351170754647, 0.11523959392013416, 0.12483758964435598, 0.1367586992403974, 0.12050712034613131, 0.22751043677617933, 0.18139710952520938, 0.2539742455334216, 0.16670665894864667, 0.18226384538473084, 0.14326428207762842, 0.19852931832308496, 0.20921399887623904, 0.23689393539547288, 0.41558775605096887, 0.2013025409770517, 0.2731799611340323, 0.20929749337461523, 0.2379258016049055, 0.3156594306480561, 0.2654340513091664, 0.3416517033158132, 0.32633870024041367, 0.24365051672492688, 0.3367901908369919, 0.2695354594051701, 0.14680252588537224, 0.2358433112302304, 0.15683823059706503, 0.24985778544309412, 0.20512520046228377, 0.21505952487961255, 0.21821227520910425, 0.20466067309739433, 0.2179497874869506, 0.2119976626916691, 0.23289878587219315, 0.2551721842302168, 0.21577269925349019, 0.2654339418566787, 0.24980071190570585, 0.1876814939744036, 0.1936310248430474, 0.21161448730697263, 0.1942835234091801, 0.2266464060565162, 0.2518733078069567, 0.2067964629950635, 0.23009533585026298, 0.2077181286051496, 0.9314196710571305, 0.23116332462308042, 0.18832820671266803, 0.45058114652184733, 0.1912830097400856, 0.16790231321577087, 0.18056224978829427, 0.16248995383506348, 0.15355090675617578, 0.12507978055916968, 0.16869316435967485, 0.1528660098383764, 0.5629003289798611, 0.19676004635538136, 0.10787835370560894, 0.16521065721768158, 0.46863849535881097, 0.278565144443335, 0.2030069812768407, 0.1987157173613021, 0.18754565688940106, 0.20372999206475062, 0.19400498063807292, 0.18146552579744613, 0.21663152691719112, 0.20690174261274863, 0.19003889745858538, 0.07281486709979867, 0.09326361313187359, 0.07885684578078722, 0.11337248160585545, 0.1513562006533724, 0.08792739218752632, 0.08942519874756438, 0.11150256928982194, 0.08995938427191597]}, "mutation_prompt": null}
{"id": "3ee82cf3-e1bd-40cf-8134-bb28dde97f00", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "ac980f77-6d72-458c-8bdc-7fedf751d05d", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.1  # Increased slightly for stronger personal component\n        self.c2 = 0.9  # Slightly lower to counterbalance the increase in c1\n        self.w = 0.5  # Reduced for faster convergence\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR = 0.9  # Increased for more frequent trial updates\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Improved Chaotic Initialization for enhanced exploration\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.tan(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # More aggressive reduction\n        self.mutation_adjustment = 0.4  # Enhanced mutation for dynamic adaptation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.3:  # Adjusted threshold for better diversity control\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n                    \n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_V2", "description": "A refined metaheuristic combining adaptive PSO-DE with chaotic initialization and enhanced diversity control for improved convergence speed.", "configspace": "", "generation": 77, "fitness": 0.2602875840434834, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8897018020011314, 0.8885779056750297, 0.8840625793067978, 0.8895981141514281, 0.8935409823309675, 0.8874783567244751, 0.8938733515450299, 0.8888822154537613, 0.8965424904652515, 0.7672597828419693, 0.22962649083215925, 0.17612027484833181, 0.17249144688157902, 0.8105221335390884, 0.04583427716259425, 9.999999999998899e-05, 0.14783529516346972, 0.7205808447673142, 0.11041830436244149, 0.10952451003608166, 0.15618835098132478, 0.1395641051357288, 0.12364675725454677, 0.08992834136437722, 0.11662836934361398, 0.12856579758397457, 0.09044123228125678, 0.12225519142254104, 0.11432866892266302, 0.0952947235599142, 0.08962078384261518, 0.1315256999620419, 0.08714741147958116, 0.10173510021073395, 0.06340033926154387, 0.1088063823246157, 0.9803269121070627, 0.9773744512409512, 0.9919162675444286, 0.9762302296826463, 0.970981524549798, 0.9517977781982646, 0.9726411167421131, 0.9750118387006572, 0.9729226798115529, 0.08405015717915598, 0.10361444193565694, 0.00210107360466516, 0.2542017907003934, 0.552175010567684, 0.18625265643222955, 0.33438495075061825, 0.10930054923700427, 0.1534503783095199, 0.6373237276867957, 0.21331276247821995, 0.1226998199349173, 0.9220474219814364, 0.21506187527379517, 0.20671071643425476, 0.12607812552093856, 0.1844749154885852, 0.12570710585373268, 0.13681343885992103, 0.13370447491627258, 0.15084761317622142, 0.12831358922901914, 0.14145584813813583, 0.16936547437113314, 0.1310183591528694, 0.15124381944602516, 0.1548973257568016, 0.15252630450040872, 0.22906395849980177, 0.12729562164792618, 0.1754311440408436, 0.15206822523996055, 0.12708546535964638, 0.12948914869448946, 0.14313022719026414, 0.00456802446339466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009784009683443395, 0.031983883179913186, 9.999999999998899e-05, 0.005878500589166835, 0.08432778451096545, 0.07215817890966769, 0.0814631751136825, 0.13219142686347818, 0.010888787468676164, 0.10528144355550795, 0.04714058380406072, 0.031326948494863394, 0.036774861718282925, 0.04774294821694891, 0.10994531683763142, 0.12027209524276694, 0.06063182034880632, 0.11592829684198735, 0.08531395017115595, 0.09519912387218332, 0.25567736228075866, 0.0994410223358898, 0.21731760921081633, 0.10671833160267485, 0.058460972727016114, 0.15036736247252813, 0.04322776262098782, 0.05375549861006579, 0.10296921412399895, 0.08345161494999431, 0.16935083419126062, 0.3490221388739103, 0.5806137028264197, 0.5455548859304684, 0.5797604304331111, 0.5362304083118412, 0.4175180871389217, 0.5693543208626541, 0.4859375285508498, 0.5878196339142594, 0.5972232922027358, 0.05959461457732218, 0.1332941511122091, 0.11523150892086509, 0.07944654481840485, 0.07919646213257836, 0.16041628753397452, 0.08576143814469084, 0.1003185390354836, 0.10410734600861138, 0.15610280538446508, 0.1838142522803342, 0.14435113357102458, 0.19290484394996077, 0.15067900033465342, 0.19708519520273138, 0.365609427445984, 0.5133934323683824, 0.19086430185968128, 0.1678460019286384, 0.4136833546837655, 0.4608375571828165, 0.4450008600493328, 0.32571524116264783, 0.2660315764701692, 0.20006673007322007, 0.2622849086684711, 0.570729897419298, 0.17761748571005986, 0.2914744546999051, 0.09194156338356474, 0.23143056138590568, 0.30092518107685917, 0.17692123737597798, 0.37887242209847605, 0.22956316626269546, 0.1782547403471857, 0.21663282597598332, 0.21629262354199208, 0.20594215887991596, 0.20563124590434856, 0.26545827024230984, 0.2213831802407259, 0.19310795050844942, 0.21423182653018913, 0.20653604739194187, 0.19046541022406227, 0.20081563660054547, 0.19546991665555058, 0.19526101040890254, 0.19571328914542696, 0.2157193446222847, 0.22579371576965346, 0.19637097912667545, 0.18797650904836605, 0.18649309162307393, 0.16737374373795533, 0.2026509556543986, 0.9246052087465229, 0.17253437190930654, 0.1674470348445275, 0.1583878887973864, 0.3448551934923727, 0.1543303165313682, 0.3664753728396013, 0.19061388553008085, 0.21194585217545536, 0.3502655997812013, 0.21077249333809733, 0.46309354883181164, 0.1504966223976758, 0.35781715354149846, 0.1686872266259457, 0.21138252244175815, 0.18390900995044757, 0.1898345181391412, 0.19305705589565747, 0.17955580322426923, 0.1972510370442212, 0.20863545878505274, 0.2015989229305586, 0.20965963147814615, 0.06233141094271455, 0.08592797442341993, 0.07541285935214315, 0.0887615784975816, 0.09528552895374798, 0.07836250103212206, 0.1006974519795043, 0.11395446941694265, 0.09086278978449713]}, "mutation_prompt": null}
{"id": "8d09c52b-f497-44e1-813a-d63f58f53835", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "3eab96bd-0f87-4c38-9189-a7867bd9bd63", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced personal attraction\n        self.c2 = 1.5  # Adjusted social coefficient for balanced global attraction\n        self.w = 0.7  # Slightly increased inertia weight for enhanced exploration\n        self.F_base = 0.5  # Increased base mutation factor for stronger exploration\n        self.CR = 0.9  # Increased crossover rate for more aggressive exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "Enhanced chaotic hybrid PSO-DE with adaptive diversity control and reinforced global-local balance for accelerated convergence.", "configspace": "", "generation": 79, "fitness": 0.24143126839630644, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8028278749713863, 0.7788436914666588, 0.8300242509191338, 0.19103356889912193, 0.19179825517783866, 0.7851981023976395, 0.20946045454962303, 0.7700523214128648, 0.8347519957265707, 9.999999999998899e-05, 0.1565172911574929, 9.999999999998899e-05, 0.6917415219677585, 9.999999999998899e-05, 9.999999999998899e-05, 0.6975132092988849, 0.42002915804179164, 0.20621917507488363, 0.16977498820305625, 0.10898641621506633, 0.15387494009532476, 0.09404584925519188, 0.09899461164976142, 0.1325226531360968, 0.09165510902381813, 0.05243064973734968, 0.05550181143330135, 0.11115448102701575, 0.048963178055646095, 0.12485164426438933, 0.11151348331461164, 0.11166320152012466, 0.03677184672324296, 0.05762611021520003, 0.10823865491910001, 0.05719912287959994, 0.9858416287444934, 0.9835784444773911, 0.9817355917397129, 0.9774395426691327, 0.96776086358983, 0.9855013169669272, 0.9805356898327919, 0.9869488148282727, 0.9827451758912897, 0.6048972097072859, 0.3499109033257771, 9.999999999998899e-05, 0.1389341002476946, 0.14870019516548005, 0.14893476933681482, 0.08267567021156541, 0.0881464968674125, 0.17960011380554242, 0.18276988377880166, 0.220810411306833, 0.3717751682172844, 0.21126179507086296, 0.1882231787063171, 0.19957011002795177, 0.08141527117862057, 0.3855852882444295, 0.7480624408035714, 0.2104305204178204, 0.19267826779509245, 0.14152153447859983, 0.15352643748819572, 0.13687811385244408, 0.15008757259897976, 0.1581172173930796, 0.10537043068318108, 0.1612450988825156, 0.1875843934107394, 0.13099606575115708, 0.12634704641596672, 0.21386330887124627, 0.14561237099812407, 0.16571325520033442, 0.13132516188600352, 0.2374685417509781, 0.12739816555653072, 0.013128476282612378, 0.0058619992607608085, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053610713222166706, 9.999999999998899e-05, 9.999999999998899e-05, 0.0707676364257217, 0.06295762775388614, 0.027477468935833693, 0.0305096606372115, 0.07806010653213358, 0.04648481124468018, 0.08693367321807965, 0.07079435579602855, 9.999999999998899e-05, 0.030839167167216353, 0.03191792750565747, 0.0860172695974013, 9.999999999998899e-05, 0.07189964522200776, 9.999999999998899e-05, 0.1458616750252124, 0.0884352490378073, 0.12456600834425846, 9.999999999998899e-05, 0.13415236378936557, 0.010568420786121857, 0.04888444522865598, 0.1309767891042728, 0.0033416176661321684, 0.2288803753569304, 0.07444068494967482, 0.05554203707636174, 0.48671002778123906, 0.5479703922962238, 0.5344847711949359, 0.5441809363705992, 0.5557463124294539, 0.5412906132996138, 0.5415798950172683, 0.5852742924937571, 0.5746377916893339, 0.11971104328756388, 0.06351449858046876, 0.06057554349340388, 0.10778836817747017, 0.09418868066200026, 0.13540505604530995, 0.11096074183065796, 0.07913239865982047, 0.11697160800665929, 0.14184722911474745, 0.16623024079459214, 0.26369232803921794, 0.1465024235436082, 0.1828040434743703, 0.15643915577435363, 0.13657075738700952, 0.19643406396328855, 0.17848435115217942, 0.20630300097469012, 0.2461746028082844, 0.42045669053291335, 0.19635477264602563, 0.3299493790185628, 0.1916771798279865, 0.41765014249702115, 0.276394336464864, 0.5294386477589383, 0.16451931457546431, 0.16688104277716853, 0.16960551235354326, 0.18897511510300224, 0.23460091305356245, 0.17522384939395652, 0.3620484714944924, 0.1862164869090044, 0.15432809092855715, 0.25746999136292914, 0.17955357482113854, 0.18606137664181055, 0.20850211617394376, 0.2150781878894782, 0.2260714815537731, 0.23040228278872743, 0.22878302367216885, 0.23951725090653597, 0.23082306598077817, 0.20290704073685462, 0.2203722851736346, 0.2403366925939613, 0.20132224731306136, 0.16881402973280402, 0.18596926570507277, 0.5672100545847731, 0.20288962459043902, 0.8481138337423023, 0.8792263037378282, 0.20531091609493812, 0.8870831024935169, 0.7754806341027325, 0.19926524045845828, 0.20948725839561344, 0.11604377136913213, 0.15447355554244246, 0.20682753265131837, 0.16876002485750796, 0.13920652736819283, 0.13675752919640705, 0.1366328371651192, 0.28681358862232875, 0.13618551539675594, 0.769497661916639, 0.1541296190691479, 0.18676867807453135, 0.17967617712650463, 0.18013885683997155, 0.18565765048757188, 0.18248775700782294, 0.18740620807568176, 0.21791286953083822, 0.1884443597717944, 0.18236207307583485, 0.07786724269706269, 0.07463230150518452, 0.08278026754370349, 0.09370984601587529, 0.05131505859284191, 0.09002869642250821, 0.09810424547134078, 0.06162893615174925, 0.09521518506310878]}, "mutation_prompt": null}
{"id": "3e1a12c8-4d7f-4e86-bd25-ddf776cf312e", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_MultiSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.num_swarms = 2  # Introduce multiple swarms\n        self.c1 = 1.5  # Reduced cognitive coefficient for balanced personal and social influences\n        self.c2 = 1.5  # Increased social coefficient for diversified search\n        self.w = 0.7  # Slightly increased inertia for better exploration early on\n        self.F_base = 0.5  # Increased mutation factor for robust differential evolution\n        self.CR = 0.9  # Increased crossover rate for better mixing\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.97  # Slightly adjusted adaptive factor for inertia\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            for swarm_id in range(self.num_swarms):\n                r1 = np.random.rand(self.population_size // self.num_swarms, self.dim)\n                r2 = np.random.rand(self.population_size // self.num_swarms, self.dim)\n                swarm_slice = slice(swarm_id * (self.population_size // self.num_swarms),\n                                    (swarm_id + 1) * (self.population_size // self.num_swarms))\n                self.velocities[swarm_slice] = (self.w * self.velocities[swarm_slice] +\n                                                self.c1 * r1 * (self.personal_best_positions[swarm_slice] - self.positions[swarm_slice]) +\n                                                self.c2 * r2 * (self.global_best_position - self.positions[swarm_slice]))\n                self.positions[swarm_slice] += self.velocities[swarm_slice]\n                self.w *= self.adaptive_w_factor\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-9)))\n                mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, self.positions[i])\n                trial_score = func(trial)\n                function_evaluations += 1\n\n                if trial_score < scores[i]:\n                    self.positions[i] = trial\n                    scores[i] = trial_score\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n            # Local search around global best for refined exploitation\n            if function_evaluations < self.budget:\n                local_trial = self.global_best_position + 0.05 * np.random.randn(self.dim)\n                local_trial = np.clip(local_trial, self.lower_bound, self.upper_bound)\n                local_score = func(local_trial)\n                function_evaluations += 1\n                if local_score < self.global_best_score:\n                    self.global_best_score = local_score\n                    self.global_best_position = local_trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_MultiSwarm", "description": "Introduced multi-swarm adaptive strategy and local search integration for enhanced exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.25831644678933785, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_MultiSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8466642046932488, 0.849646011831832, 0.8345475624367323, 0.8465591586884784, 0.8463300045333021, 0.8404304321384285, 0.8268681475885054, 0.8376838556633555, 0.8553515069335054, 0.26052839375201053, 0.12375807942947648, 0.08320107044436587, 0.030821733913048988, 0.33840942462494117, 0.5261469926938732, 0.052252893387412236, 0.31208317077857173, 0.2303470138088689, 0.15071379741934254, 0.14324428371475784, 0.16443928452632206, 0.10639605623302628, 0.0716820997583254, 0.13750499474213118, 0.13583957781422562, 0.11236051895362342, 0.10191248840251088, 0.1442953055687718, 0.1158908181325774, 0.12195349477777839, 0.09827732390162569, 0.10432369765831173, 0.11091780901284565, 0.10507957783899036, 0.12589904565334764, 0.146881648914719, 0.9933410871544096, 0.9861278006394173, 0.975870482447448, 0.9573192713795424, 0.9759766216688155, 0.9680777121948405, 0.9793946880890074, 0.9829008521006306, 0.9849273892920767, 0.058323919551431236, 0.4979712980930078, 0.1806399334593416, 0.4298393543845086, 0.2821655041271727, 0.2939228673636971, 0.4373645952524027, 0.4570462642767078, 0.4176641076106945, 0.22018868008639392, 0.21583104122108976, 0.23769563454016795, 0.1891117957220284, 0.15892751677722694, 0.3588172350976905, 0.11475753082625983, 0.22370244003689876, 0.22824629495215043, 0.15439611278830345, 0.15991102040498661, 0.13999849199314107, 0.1145042207534821, 0.16823099535680064, 0.123356141940827, 0.09212302475275425, 0.17487969237554613, 0.11031231240608563, 0.13954246560680528, 0.1157402850236049, 0.28924831674282503, 0.13649439964165744, 0.1391198989810437, 0.2961998857841913, 0.08461326435045535, 0.2580822590502848, 0.23630428064550701, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002927239838335427, 0.02729408907465969, 0.06275602534684166, 0.08890977638091568, 0.020078813792606676, 0.052890259066868395, 0.0432549313503392, 0.041874935909115396, 0.03401605420586051, 0.04319892893016464, 0.04517439042810456, 0.23017754911823285, 0.0441821519761465, 0.12544901968947686, 0.10995315875858014, 9.999999999998899e-05, 0.175027639452758, 0.0657957348683742, 0.011347870516784875, 0.10203899735336563, 0.073768153771678, 0.14283449205869325, 0.035873638376456296, 0.08512091088585971, 0.13082513017630792, 0.07692090901281556, 0.0782690446980574, 0.05625506002529512, 0.538216843488657, 0.5356929456316094, 0.5138857015290572, 0.49041245893645136, 0.5703257102186312, 0.5043543251604374, 0.5804789804878056, 0.5727807443673593, 0.5342490453659279, 0.07344613343097839, 0.07237731219338639, 0.14208147760527046, 0.10068008297777886, 0.10955350560846999, 0.10408242908837251, 0.10704077544768531, 0.11660901711712668, 0.07477356675281721, 0.23518526777494475, 0.2182847945227867, 0.18213838506904734, 0.1470041625424654, 0.17062394307928375, 0.1633207123531616, 0.28415362907730257, 0.31060809457384386, 0.12798319315173867, 0.3160716602245093, 0.363576324416774, 0.5104187421913791, 0.37004752457996204, 0.37924801959870513, 0.36492908011575875, 0.4192546952621594, 0.3906275785943156, 0.4194361065143929, 0.2013226856610758, 0.1134418530293968, 0.22058205353248117, 0.19711888485136286, 0.3043039040301001, 0.18572056982975094, 0.2343319632431028, 0.27450698921625194, 0.29431859411458416, 0.18088056731086344, 0.17718279792874492, 0.19811606193050746, 0.19932099278338444, 0.1938457765885664, 0.21130472538868672, 0.2127594102767283, 0.2582532020555822, 0.21494569999229163, 0.17853623152671227, 0.20298284033891856, 0.1866298527078547, 0.21406492070054328, 0.17005514796675414, 0.6596071247140098, 0.20726141911504914, 0.17636854073816288, 0.18279407956803784, 0.81072976820376, 0.1870048199003821, 0.8911329062396067, 0.15015628401692083, 0.20420534189727846, 0.1652820909813446, 0.12315694564840196, 0.17069872079293968, 0.13881344532392725, 0.16656315785742049, 0.16832692065845, 0.6694559250588963, 0.5674952439434668, 0.12570413727700158, 0.16828579145638345, 0.16731173961102064, 0.487231125746584, 0.31695441363393395, 0.19248068257462658, 0.1822200314165784, 0.1833111386766041, 0.18475601406471753, 0.1798435681465691, 0.17783551456267765, 0.21536817163797017, 0.18194507121739523, 0.1940922127659952, 0.08683985327482024, 0.08989219448413732, 0.07983630700499811, 0.09164270751438308, 0.07691751057626173, 0.08764287682457395, 0.08290430259736437, 0.09156872029376684, 0.0886716200567167]}, "mutation_prompt": null}
{"id": "864e3c34-3f61-4b0b-8cae-30ee13b62150", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "f08a8324-f5b6-43a7-9d96-edc20c7a381b", "solution": "import numpy as np\n\nclass ImprovedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for better personal learning\n        self.c2 = 1.5  # Balanced social coefficient to enhance convergence\n        self.w = 0.7  # Increased inertia weight for better exploration in early stages\n        self.F_base = 0.5\n        self.CR = 0.9 \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Revised adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Modified parameter for adaptive mutation\n        self.local_search_factor = 0.1  # Added local search factor for refined exploration\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Introduce a Chaotic Local Search for better local exploration\n            random_scale = np.random.uniform(-self.local_search_factor, self.local_search_factor, self.positions.shape)\n            self.positions += random_scale * np.sin(np.arange(self.population_size)[:, None])\n\n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "ImprovedHybridPSO_DE_Chaotic", "description": "An improved hybrid PSO-DE algorithm utilizing chaotic local search and adaptive parameters for enhanced convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.25294900897947475, "feedback": "The algorithm ImprovedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.71249234574682, 0.6877950850861622, 0.6841498245831323, 0.6928924412429152, 0.6746974496207995, 0.7033889503114601, 0.7023566662300487, 0.6877968816121185, 0.6916141636490722, 0.028290865683766264, 0.08607011861874903, 0.07810788309874128, 0.05889461083299208, 0.058965011962131886, 0.12922453713149318, 0.18799856584959662, 0.050637535621147034, 0.09904695933473961, 0.11953141835271996, 0.13674169577690232, 0.13228792427926506, 0.07000852657776124, 0.15872598831957274, 0.15325667644567842, 0.1224278427217057, 0.09053276410345623, 0.12270206282747242, 0.12046300397056098, 0.11917001839546792, 0.09896315331366223, 0.10510837070627732, 0.1079943718115306, 0.09985386150620512, 0.12962850067924336, 0.06414172224967118, 0.11906629512998512, 0.985556695435885, 0.9853395825771561, 0.9812742867174079, 0.9745297949010197, 0.9664333566016503, 0.9853691991570386, 0.9807064179956726, 0.9863476844891436, 0.9861071365115531, 0.4817715577956352, 0.3737131837278702, 0.30815063738677606, 0.404959046820486, 0.4587664164543901, 0.4948012869230788, 0.3926772976109303, 0.38029665160788273, 0.3874173133362102, 0.16921650603812033, 0.22556411703838286, 0.835764369481501, 0.7571198030120707, 0.2071494698811981, 0.19947051265286841, 0.20528240185610402, 0.2308385717769852, 0.7232383033494183, 0.17873491783138684, 0.18295682773550803, 0.16948405375224285, 0.1307844144311806, 0.1711190325206684, 0.18901503144730658, 0.19041021131932878, 0.1780444522161846, 0.1753218826950793, 0.12499814565040235, 0.17678637370913386, 0.17902612335618107, 0.18102874692203774, 0.177100539466983, 0.1806335805905499, 0.13599805340858073, 0.2203395100872354, 0.2008493544015385, 0.006793397124196576, 0.04926865955403703, 9.999999999998899e-05, 0.011046252871073747, 9.999999999998899e-05, 0.010809478596316535, 9.999999999998899e-05, 0.00843394817569565, 0.13854521337842995, 0.05071627736707929, 0.0724043018314331, 0.03124496233073404, 0.04827614697436344, 0.05538666967973149, 0.020207396967127922, 0.057983795447495545, 0.15722471633564072, 0.07089366001358433, 0.03208093752023722, 0.10011397756196605, 0.13362968858823154, 0.082681114819253, 0.16016036205164363, 0.0857796783905802, 0.07408539584615759, 0.0964177874033143, 0.07968312154383095, 0.2234898227484936, 0.12346744221245431, 0.03632028285827926, 0.04611943644779892, 0.21974927156956403, 0.046524529310915885, 0.07923012888640846, 0.08983241139728493, 0.05996269294102419, 0.5216706328812241, 0.4787387444353115, 0.48435640215744, 0.49575400944432857, 0.48955312860874034, 0.4776502338185553, 0.5149088978493789, 0.4561336402184132, 0.484091195259171, 0.11301480184652701, 0.06335605994156412, 0.11713417187475339, 0.09492823440507803, 0.09394638796492705, 0.18122030451528115, 0.1260500698394842, 0.13848459122368406, 0.09477102810673499, 0.29310670178045795, 0.2733937871646731, 0.3192872158852642, 0.1840481204434321, 0.2869963758490103, 0.3225456634533478, 0.20443364620046056, 0.2156748572915963, 0.30353702102950697, 0.23558470890281302, 0.3469453792265593, 0.35785399646723515, 0.2151980236087604, 0.2767584506358851, 0.36818013072199296, 0.16503600973391308, 0.3810417952524623, 0.21093547168513838, 0.2044295518645175, 0.2660368734348769, 0.22793851918811392, 0.20107730327296325, 0.1905365501967371, 0.1271151494618864, 0.17903234852232874, 0.2368115509362987, 0.13355700009637783, 0.20332068271557013, 0.19738881180130619, 0.2160736881798384, 0.18887498833938166, 0.20591929464437297, 0.1892468985059249, 0.21223750529272978, 0.2037306983707604, 0.20023328289905185, 0.21037038659896357, 0.23217008586408971, 0.2499988466723737, 0.23978191309973673, 0.19693929573458935, 0.2431041289670659, 0.23745686960383705, 0.21871705411377473, 0.21105276631148895, 0.16382604308882454, 0.8690608208453691, 0.18715629530232625, 0.16872799383959913, 0.19769398870926558, 0.16677698813194985, 0.21155490499379037, 0.16776649818947353, 0.1535579587218424, 0.21028360033799853, 0.16764322153463596, 0.15408108144630916, 0.21214717291773044, 0.21003598579372607, 0.5179916548325195, 0.6249353353314525, 0.6555762348604015, 0.16628551453326568, 0.19023664435787324, 0.1920903408917578, 0.19976833028141372, 0.19227779590385896, 0.19623277421295615, 0.22182673364120298, 0.1851136178467675, 0.19215383414056963, 0.18807840823303434, 0.09553619891664222, 0.09654859923289605, 0.08638192978088177, 0.09479631346459483, 0.09373369213501737, 0.061292187137950704, 0.10944682384031545, 0.0960351916827904, 0.0764833912381151]}, "mutation_prompt": null}
{"id": "f1bbdd43-2379-4cb7-a87d-38ea0ef31f8f", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for better exploration\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration and exploitation\n        self.c2 = 1.5  # Adjusted social coefficient to enhance cooperation\n        self.w = 0.7  # Slightly increased inertia weight to maintain momentum\n        self.F_base = 0.6  # Increased mutation factor for stronger exploration\n        self.CR = 0.9  # Increased crossover rate for enhanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic initialization for enhanced diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * (np.random.rand(self.population_size, self.dim) * np.sinh(np.arange(self.population_size)[:, None]))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly reduced adaptive factor for faster inertia reduction\n        self.mutation_adjustment = 0.5  # Increased adaptive mutation factor for stronger perturbations\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with enhanced adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Slightly increased diversity threshold\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "Enhanced hybrid optimization blending PSO-DE with chaotic initialization, dynamic adjustments, and increased diversity preservation for faster convergence.", "configspace": "", "generation": 83, "fitness": 0.156756897777023, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.21.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.3709902434851815, 0.8117810016501361, 0.2161811814158915, 0.5807161880545268, 0.42326998919466674, 0.4775795516608212, 0.44690966249865915, 0.3454325303521104, 0.1407043609373133, 9.999999999998899e-05, 0.05355798000257306, 0.18735873200821507, 9.999999999998899e-05, 0.060164392238292175, 0.011878670766986343, 0.020443368117636584, 0.4699183327860663, 0.01672715664922053, 0.06704901945571562, 0.08361324817141469, 0.04308843833267051, 0.012147775997732979, 0.11264129629672293, 0.009458779831063802, 0.04534464522968484, 0.14616649969752382, 0.02312117946014347, 9.999999999998899e-05, 0.07548015921497042, 9.999999999998899e-05, 0.08506792323572121, 0.1266592266787424, 9.999999999998899e-05, 0.04070677283553559, 0.08567858203436085, 9.999999999998899e-05, 0.9924521621100115, 0.9925690415563818, 0.9902901878777737, 0.9928222870129645, 0.9912478066970429, 0.9721806582304924, 0.9929911240404122, 0.9776159190528915, 0.9899753511064905, 0.055775446008096474, 9.999999999998899e-05, 0.051626309283071214, 0.05019991855273498, 0.011412572871602578, 0.043029179593292444, 0.050628018178687895, 0.24691185232796953, 0.06318550497602649, 0.058923903380969755, 0.12686055691196396, 0.0763451939921097, 0.04418691817412834, 0.16765645527444317, 0.17483321203082158, 0.088732255086588, 0.1034178556398283, 0.11277982893921779, 0.09665081161656486, 0.13742593813709936, 0.060887281508135715, 9.999999999998899e-05, 0.049779275608645146, 0.0896556779398705, 9.999999999998899e-05, 9.999999999998899e-05, 0.23150473675868488, 9.999999999998899e-05, 0.013951667543070423, 0.09554412489855768, 0.09935794659614217, 0.12396238101649937, 9.999999999998899e-05, 0.08849797081847033, 9.999999999998899e-05, 0.13028468325879838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02498695554217434, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05285874630061682, 0.05628789902033693, 0.056752970931515434, 0.05425255154792319, 0.011790055041442926, 0.022767144411965257, 0.005534252668537354, 0.009513474739406225, 0.015222054820525743, 0.04309818797086451, 0.035421748879354564, 0.03222748022324917, 0.04769717828566156, 9.999999999998899e-05, 0.051494805511183905, 9.999999999998899e-05, 0.10853073968894023, 9.999999999998899e-05, 0.008650042229499166, 9.999999999998899e-05, 0.017547680506583174, 0.0051076114428139086, 0.0057732430140755575, 0.005865289509285332, 9.999999999998899e-05, 0.04207967064987772, 0.014447820556125812, 0.14284151752777108, 0.15647292480472175, 0.1271607404586681, 0.40884083591692233, 0.20229994568144372, 0.4338880414658225, 0.13014153039790033, 0.506064144508134, 0.1401759051313506, 0.08798375739356468, 0.09205354813332345, 0.0698263592803905, 0.024317247163389788, 0.08444865368804677, 0.08363528198049097, 0.03831824349997459, 0.1069849551590274, 0.04649778016188588, 0.14831394021125766, 0.14500352185482857, 0.13805084112871335, 0.11628843464829786, 0.24425140140146673, 0.13457079540448846, 0.11245522036538746, 0.18441257787022935, 0.16603068920091568, 0.11716597536445683, 0.24767754530614494, 0.222574979994687, 0.17522150737606512, 0.24126911882741786, 0.251254359648165, 0.17589479936157038, 0.27537616159348366, 0.16086962358893342, 0.17590460208454972, 0.20195965218202594, 0.12617479411058807, 0.16120786551480593, 0.18765033922277286, 0.06176542906369631, 0.10851204387460622, 0.09931342446398683, 0.08378043795146772, 0.1719207132952848, 0.17409290819609746, 0.1265271213851462, 0.15108205046117906, 0.2576223927950405, 0.20471503073713415, 0.1567739980249031, 0.23299313407295674, 0.18524460504272022, 0.550692870257621, 0.17976299483846814, 0.16249098069065826, 0.12024839673661625, 0.16804847142982327, 9.999999999998899e-05, 0.14114321322491963, 0.1531109866185969, 0.15338309797667882, 0.15438947912561085, 0.14964861313618272, 0.10024327134484678, 0.15595716643446045, 0.16707130222818833, 0.17152093283131942, 0.10480371953666667, 0.10198848371902891, 0.12441520936482198, 0.10851988657607237, 0.07910688148269873, 0.116334288173218, 0.18016168591012716, 0.41656611970637225, 0.404715666325172, 0.12070992198803743, 0.18654039865640337, 0.19798427331257218, 0.1942355671909689, 0.18288372766384553, 0.20282561517060127, 0.20436827963772752, 0.20078460739831305, 0.18614363497102382, 0.1795340541805468, 0.17307074703246106, 0.2071094533742588, 0.09058881232085747, 0.08177587924457452, 0.043396032363277826, 0.04388113976458119, 0.08809265943370737, 0.025645395501501467, 0.039943054777238696, 0.07670409493939079, 0.0064788988798006875]}, "mutation_prompt": null}
{"id": "43391c85-d265-428a-bc3f-9154fc93d1fc", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population for better diversity\n        self.c1 = 2.2  # Further increased cognitive coefficient\n        self.c2 = 0.8  # Reduced social coefficient to maintain balance\n        self.w = 0.5  # Lowered inertia weight for quicker convergence\n        self.F_base = 0.5  # Slightly increased for more aggressive mutation\n        self.CR = 0.9  # Higher crossover rate for more frequent mixing\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.tan(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Slightly adjusted adaptive factor\n        self.mutation_adjustment = 0.4  # Adjusted parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined hybrid PSO-DE algorithm with enhanced chaotic exploration and adaptive mutation strategies for accelerated convergence.", "configspace": "", "generation": 84, "fitness": 0.2708686049264262, "feedback": "The algorithm RefinedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8827882193377691, 0.8743559257080912, 0.8760254028425559, 0.876229062058636, 0.8773087786833991, 0.8732988411415807, 0.8794178345341871, 0.8778284271654782, 0.8797911915331866, 0.0756980375086681, 9.999999999998899e-05, 0.2830505601717693, 0.7208671222909881, 0.13481242064670673, 0.09711447796645156, 9.999999999998899e-05, 0.407599479350678, 0.7379118940266962, 0.13118324737283715, 0.18538022742971827, 0.1568595219005201, 0.1610270267346532, 0.12023151333048732, 0.11977271235635212, 0.18004360643832584, 0.48926655030622723, 0.2514434209380958, 0.06925702299687475, 0.14147026799859286, 0.052160472860764306, 0.0866422098357601, 0.09272768808988263, 0.07474913121104365, 0.10574433116428605, 0.14221114936659707, 0.11213142983634627, 0.9673717839931737, 0.967910498806082, 0.9724551018493462, 0.9622265114086345, 0.9836141123279547, 0.954605329707678, 0.9729310383116523, 0.9718182497047432, 0.9706532978465666, 0.44458580899255384, 0.3222046564727358, 0.20342864126934668, 0.31564524435176, 0.2321848168845364, 0.5415309895341268, 0.1049905110031154, 0.32833730683334583, 0.48130030230033816, 0.22367613784042928, 0.21212929946184167, 0.20299827244202484, 0.20794864308428307, 0.19119296142596887, 0.8660012957854243, 0.156439877043966, 0.23480461818492904, 0.17320698944364465, 0.18232073577550678, 0.11744889395629798, 0.19232543168968852, 0.12787831675021877, 0.1707859691274316, 0.14244377880347603, 0.16909321642884612, 0.1357396777284965, 0.15065070138802805, 0.19422422893940072, 0.14416088562890872, 0.1276136370154709, 0.18024815308358066, 0.16428370078857502, 0.1703124666974356, 0.1731256894212434, 0.18963211937563507, 0.13708143086735314, 0.014432042085350982, 0.0038230993890369103, 0.003032754630725165, 9.999999999998899e-05, 0.10283138892361021, 0.000775649291339664, 9.999999999998899e-05, 9.999999999998899e-05, 0.07170747000346833, 0.09924596391316043, 0.08883795997061406, 0.08210026017960104, 0.13290666095905235, 0.042207353761294475, 0.024274149679214263, 0.04849510690259973, 0.08805878888190055, 0.06173390359037678, 0.09737933450050462, 0.16667905214857215, 0.07793156808735746, 0.18779186428814165, 0.12534052224819137, 0.07629320116945604, 0.22037411109920269, 0.17243676264928032, 0.2715654060221553, 0.06533822596335448, 0.07307669516481496, 0.26700168443023853, 0.018597467978446747, 0.18121110185542444, 0.07793309805437054, 0.08218560644789463, 0.06686967145219969, 0.05960959404046695, 0.5762524575604997, 0.5594453703092557, 0.5960705966253017, 0.6073524478193819, 0.4573157731958559, 0.5908025725061653, 0.5625118155671478, 0.6161772455386152, 0.6091799225523735, 0.13639152721912573, 0.07965946231476095, 0.07979104421457395, 0.132206067698444, 0.1183822798050358, 0.140963799790773, 0.10926440384741232, 0.13270382606331854, 0.14807380410146675, 0.1625783880406878, 0.24118339189806282, 0.18985090497709578, 0.16372447747616115, 0.29814642928389157, 0.18146602499225384, 0.19908015274075563, 0.14373663635490685, 0.18586305679284865, 0.5427637555239133, 0.4241967401207035, 0.3590500525152217, 0.3101932183202749, 0.3666729448028835, 0.37877865687203016, 0.5674602229997486, 0.24815256528860175, 0.4647561960348203, 0.2624730209034223, 0.17841752423976176, 0.1864451330450786, 0.17052163321256464, 0.2780359673925721, 0.22773426091614324, 0.2427973321224185, 0.2962308040667815, 0.21350538170425448, 0.2006657815039502, 0.2763708052458923, 0.23023253015822165, 0.20808718112344748, 0.2399984447016651, 0.23193027601467742, 0.19409334684496848, 0.26748441145284274, 0.22540792008065114, 0.24918727320093692, 0.19820643315383646, 0.22538133120436055, 0.2221852166144732, 0.23868936276147856, 0.212466508180973, 0.21428190695347615, 0.20276570289897122, 0.19375093731800586, 0.1932497955919492, 0.18797561831481058, 0.18675233404172675, 0.1669654324026717, 0.26291260863997545, 0.13090486889156816, 0.16042114471386026, 0.7909347965735767, 0.5416838609645376, 0.34611573958495045, 0.4466353232920134, 0.13379572370781134, 0.2538447810241926, 0.2039657152011548, 0.4453804468939818, 0.1677344936620111, 0.16614529215096685, 0.16793567218685934, 0.19766042334318235, 0.20432940312375825, 0.1816472949811755, 0.18574094469980929, 0.20779640671306232, 0.17994900177290984, 0.19832335173202265, 0.1860311147078646, 0.1928188735482077, 0.07886431791508708, 0.09278856528950041, 0.09911391716404994, 0.0888540474544367, 0.12575568334727927, 0.09385001950916161, 0.09074136588485637, 0.07555132573596346, 0.0923662458955079]}, "mutation_prompt": null}
{"id": "2f1946d7-4a71-4209-ba41-229795a38946", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_AdaptiveEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population for better exploration\n        self.c1 = 1.5  # Adjusted cognitive coefficient\n        self.c2 = 1.5  # Adjusted social coefficient for balanced exploration\n        self.w = 0.5  # Further reduced inertia for faster convergence\n        self.F_base = 0.5  # Enhanced mutation factor for diversity\n        self.CR = 0.9  # Increased crossover rate for more trial vectors\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Improved Chaotic Initialization\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.cos(np.pi * np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.97  # Slightly increased dampening for inertia\n        self.mutation_adjustment = 0.3  # Adjusted adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n            \n            # Differential Evolution Mutation and Crossover\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_AdaptiveEnsemble", "description": "Enhanced convergence through adaptive ensemble strategies combining chaotic search diversification, dynamic mutation, and reinforced local search.", "configspace": "", "generation": 85, "fitness": 0.2756144100480011, "feedback": "The algorithm EnhancedHybridPSO_DE_AdaptiveEnsemble got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8567837105131063, 0.8747276582852088, 0.8710981468004406, 0.8663136595255786, 0.8604500127839394, 0.8694582629553858, 0.8606975455126827, 0.8663615766383653, 0.8756279216479156, 0.6821395550715553, 0.7226376294604915, 0.7412941373347253, 0.04463038769960781, 0.31355447586049423, 0.2733222913184118, 0.6629066186765797, 0.4316725015154276, 0.7110716675129216, 0.08664879654765811, 0.11550295991105253, 0.15645998484445522, 0.14557276517836126, 0.1604495856848107, 0.1564309639141065, 0.11803223166170229, 0.18364107980728184, 0.10372989020760726, 0.10771674316560798, 0.14219173863958767, 0.12431945664342625, 0.06224291978781349, 0.09528248967166586, 0.10815184605426986, 0.12916943826278526, 0.10555869511215876, 0.09319737687698326, 0.9766588053752618, 0.9832082707574745, 0.9817788155059037, 0.9844349544551042, 0.9736455416526039, 0.9829496571222787, 0.9939678221842878, 0.993071328989976, 0.9881675877532432, 0.3513008248904712, 0.05865039172726394, 0.6735368120593666, 0.6884063040672284, 0.6912141744446341, 0.1748428223572066, 0.5544116222721885, 0.49342426768097447, 0.6408848688916623, 0.20606223228721288, 0.24239559881022665, 0.227509779527183, 0.19143797940236218, 0.19155555892567155, 0.1933025918305219, 0.12966943265376052, 0.23579358102961678, 0.1672876981863599, 0.19113541948365254, 0.15909857363493096, 0.1859786823783215, 0.1298551945250077, 0.1723003333326667, 0.15630735436567234, 0.12154072658225601, 0.13430742335836343, 0.1645643251258858, 0.13217614784267084, 0.12121471045030863, 0.1946009236850531, 0.1282638318932895, 0.3491130417839866, 0.15980615996838043, 0.12989094308966687, 0.13391651094304402, 0.12979709677903029, 0.040340050511480374, 0.0159366368148256, 0.07653361172601558, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002663825653111962, 9.999999999998899e-05, 9.999999999998899e-05, 0.09307885466976618, 0.060538975566672204, 0.10135214368011525, 0.05429683762405768, 0.006025029800889703, 0.08293072877440932, 0.005952248463553356, 0.11573024470087201, 0.07636457661521834, 0.16773063184128512, 0.14256687419082592, 0.0983427264014648, 0.2762657256608053, 0.09155781511555905, 0.2151887375504411, 0.07535182874282254, 0.0970398583249813, 0.14029687132563629, 0.09710920183778349, 0.055152186040536844, 0.11711157876093115, 0.011359350644532973, 0.03871178071216563, 0.08805511130007904, 0.024983976766206784, 0.1617783625546072, 0.10646389123630451, 0.05454628139676365, 0.5520976487286036, 0.6567698022495101, 0.5459714880870463, 0.5829918204248423, 0.5543037072112276, 0.5646722794288405, 0.5827428238350726, 0.5760553562149122, 0.5922747503189544, 0.09422437045534249, 0.06403240835366542, 0.06414093824651623, 0.11475870362783391, 0.08006581970330606, 0.13904814593012094, 0.10176459659362935, 0.12123563328142772, 0.08206318241471522, 0.16636702791339808, 0.42773830424355497, 0.17569278356121576, 0.15410974519962506, 0.14721282028879867, 0.2677627086124945, 0.1813661237522468, 0.237601683442899, 0.15043235256479892, 0.25774845688888814, 0.25203493160025514, 0.21673630654417997, 0.2278294799165106, 0.6240268551764903, 0.40718313568265396, 0.26224905826833433, 0.25977810003020063, 0.5511662800240076, 0.1999820903571622, 0.24399377604954275, 0.23903706399925229, 0.2658346732916197, 0.28073193426678145, 0.31196719610130474, 0.3618110217044148, 0.19169000850302265, 0.2010745884078864, 0.2079961094004229, 0.2783145247184238, 0.2583903044888517, 0.2564235533568563, 0.19158378483586347, 0.23284442341890743, 0.2794872182941094, 0.2312612310811717, 0.22325593875564065, 0.19855729954557844, 0.22774274117192728, 0.20034805564769576, 0.22422469359897534, 0.18958480446970394, 0.22798649275319272, 0.20791297865585368, 0.25321993693443745, 0.18809974644123484, 0.1320606764573291, 0.21100950190857726, 0.924014037453896, 0.16485137969504782, 0.15860800485821946, 0.16774868600917403, 0.12269266153323788, 0.13084074002396973, 0.18579137892166253, 0.35250177405931304, 0.12670893771700886, 0.12710755920466676, 0.21049816963416557, 0.1268203553301166, 0.22753318996923722, 0.43313670028326723, 0.20537847156407574, 0.16649841439238078, 0.19280969915060453, 0.2124652209460962, 0.17979686353531454, 0.18705061931874778, 0.19205901294831706, 0.23148807960609408, 0.24281917446450063, 0.22709124419125615, 0.21146591504509038, 0.07885226799139056, 0.08420497519215331, 0.08683448776743663, 0.09244505120506907, 0.09474905315934412, 0.12034899240241081, 0.07825017460270645, 0.09864172693878803, 0.10609099675829514]}, "mutation_prompt": null}
{"id": "2f82216b-4d39-4dd8-8be2-5ffd5d235da3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Adjusted social coefficient for improved convergence\n        self.w = 0.7  # Slightly increased inertia weight for exploration in initial stages\n        self.F_base = 0.5\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        # Chaotic Initialization with enhanced diversity spread\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None] * np.pi/2)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Increased parameter for adaptive mutation\n        self.min_population_size = 20  # New lower limit for adaptive population size\n    \n    def _resize_population(self, scores):\n        if np.std(scores) < 0.01 and self.population_size > self.min_population_size:\n            self.population_size = max(self.min_population_size, self.population_size // 2)\n            self.positions = self.positions[:self.population_size]\n            self.velocities = self.velocities[:self.population_size]\n            self.personal_best_positions = self.personal_best_positions[:self.population_size]\n            self.personal_best_scores = self.personal_best_scores[:self.population_size]\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # Dynamic resizing based on performance\n            self._resize_population(scores)\n            \n            # PSO Update with gradient-based velocity adjustment\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            gradient = np.gradient(scores)\n            self.velocities = (self.w * self.velocities -\n                               0.01 * gradient[:, None] * (self.positions - self.global_best_position) +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.3:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_Improved", "description": "Improved convergence speed by employing adaptive population resizing, gradient-based velocity adjustment, and diversity preservation mechanisms.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,1) (25,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,1) (25,5) ')", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {}, "mutation_prompt": null}
{"id": "b3824e2d-b37c-47de-92f3-0fe17cf10e86", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "fbde741c-95b9-468a-9b45-076bc4111f85", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "bec846f4-37b9-4691-b604-e41f3aa508d0", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic_MultiSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.8  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.2  # Adjusted social coefficient for improved convergence\n        self.w = 0.7  # Adjusted inertia weight for stability\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98\n        self.mutation_adjustment = 0.3\n        self.num_swarms = 3  # Multi-swarm approach for enhanced diversity\n        self.swarm_assignments = np.random.choice(self.num_swarms, self.population_size)\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n\n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # PSO Update with multi-swarm influence\n            for swarm in range(self.num_swarms):\n                swarm_indices = np.where(self.swarm_assignments == swarm)[0]\n                swarm_best_position = self.personal_best_positions[swarm_indices].mean(axis=0)\n                r1 = np.random.rand(len(swarm_indices), self.dim)\n                r2 = np.random.rand(len(swarm_indices), self.dim)\n                self.velocities[swarm_indices] = (self.w * self.velocities[swarm_indices] +\n                                                  self.c1 * r1 * (self.personal_best_positions[swarm_indices] - self.positions[swarm_indices]) +\n                                                  self.c2 * r2 * (swarm_best_position - self.positions[swarm_indices]))\n                self.positions[swarm_indices] = self.positions[swarm_indices] + self.velocities[swarm_indices]\n\n            self.w *= self.adaptive_w_factor\n\n            # Differential Evolution Mutation and Crossover with adaptive chaotic perturbations\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * np.random.uniform(0.8, 1.2)\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic_MultiSwarm", "description": "An improved hybrid method enhancing solution diversity and convergence speed using multi-swarm strategy with adaptive chaotic perturbations.", "configspace": "", "generation": 89, "fitness": 0.16040505369136845, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic_MultiSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8502743743135505, 0.8339996339311829, 0.8377410342139685, 0.8322270440134141, 0.24425439689560235, 0.5626529051926366, 0.8070073182522536, 0.28517172395684176, 0.8243532259674436, 9.999999999998899e-05, 0.04885306596401351, 9.999999999998899e-05, 0.016679966829870274, 0.10790984451468322, 9.999999999998899e-05, 9.999999999998899e-05, 0.04399617220355012, 9.999999999998899e-05, 0.08412066129801932, 0.10869554189331809, 0.07022317468708827, 0.08108102983497101, 0.06738013158860467, 0.11599240205969485, 0.11224497167187797, 0.07278423933648681, 0.08147637592513857, 0.07503849684640485, 0.08009144991895989, 0.062392593045397904, 0.0636237665562881, 0.0897108063719414, 0.05902427497688545, 0.05234686421574841, 0.07725175617694913, 0.06846905300568362, 0.11231634467358997, 0.16369653861126376, 0.11840834790000976, 0.10733041902533624, 0.08877537627235765, 0.30099712164305825, 0.14275085082518113, 0.09886965500718636, 0.11677159613730326, 0.09255746184896851, 0.09149346660326241, 0.08647156669221734, 0.13897890850787953, 0.1289830836473338, 0.06215638871512841, 0.09111254570391414, 0.061572117492624034, 0.12019438685331374, 0.17063355601785934, 0.171369796386714, 0.17944303763579994, 0.2735295947958002, 0.2133445218791249, 0.2611838789678743, 0.15561175604734034, 0.17687414572578963, 0.1805978941928177, 0.05945981843665782, 0.06944389274286045, 0.0831310191057657, 0.21941216332322866, 0.16572986805056156, 0.022364092703996752, 0.18461266556894906, 0.05866261643775228, 0.14959603643730623, 0.14690791985814122, 0.17123768000714612, 0.09993479573055941, 0.14615654521615218, 0.1679885214002519, 0.1445885648444668, 0.18185316186773526, 0.1121538257292255, 0.14605618865088088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14582706492825637, 0.0935098361457718, 0.09943117130490242, 0.06610129564864564, 0.06397622536593606, 0.05368116045976423, 0.0987971083327368, 0.14203498232908152, 0.09045822958364858, 9.999999999998899e-05, 0.16601974289122867, 9.999999999998899e-05, 9.999999999998899e-05, 0.11814630976969698, 0.1117573685009513, 0.036560955092028835, 9.999999999998899e-05, 9.999999999998899e-05, 0.00498168263131904, 0.016708812318414146, 0.01626358995456545, 0.12096320080066325, 0.02122195240536695, 0.06743203380058715, 0.10996607302786854, 0.008227026028536644, 0.08043404429775347, 0.5388528059808493, 0.5098692604548236, 0.4976346457179299, 0.29501573704881223, 0.4228251722314279, 0.5440275783149076, 0.49015566855846104, 0.4002021881421127, 0.6098672836459456, 0.0952815224295529, 0.07049142108754547, 0.062232035757267656, 0.11168567848569655, 0.07982798392340229, 0.10799334170030739, 0.10057625269178061, 0.08843600140508334, 0.07811255338543155, 0.16384502631357245, 0.16031204767715768, 0.15198817484682547, 0.1529857555537425, 0.17629874953983193, 0.1271910243587907, 0.14868167294370638, 0.15784775648867888, 0.1517683345639369, 0.18195708111015196, 0.15714865692592195, 0.17205752469308222, 0.25186113816357714, 0.28185424931281766, 0.26106613522976874, 0.1946847574501317, 0.2274754116481893, 0.19184012919406757, 0.1248468726497356, 0.10445080258025263, 0.1754451042325611, 0.1841108234005414, 0.1848875529234072, 0.1754833497271565, 0.16380843929594846, 0.15401808272188788, 0.12677653550394608, 0.23650225681128, 0.2756548186098554, 0.2284161847857229, 0.264309537884831, 0.26251346668991427, 0.21346898227018996, 0.23707087592487464, 0.23474909486526407, 0.2328270311554117, 0.16997550651107118, 0.18004568171262414, 0.16646812726587046, 0.16111562733431362, 0.17208085382659666, 0.166725104897392, 0.16482034817483526, 0.17720646851054966, 0.1712424176497348, 0.1861912118143607, 0.18454499208693398, 0.17786181003861168, 0.14503834527190862, 0.17643272852961223, 0.14086444110194496, 0.1782744635148048, 0.1400222879128492, 0.15469919520486308, 0.2085662356456518, 0.1692382586727641, 0.16864807290458594, 0.14208114290176732, 0.10152657411802535, 0.2034237604575614, 0.18707946200192382, 0.18593483063182648, 0.1671507173845399, 0.20286335832829216, 0.19730619544946182, 0.1799217591663309, 0.18616159046634062, 0.19536033003422582, 0.20369989977888714, 0.18918938809631025, 0.1925078631484708, 0.17736648807790678, 0.06580425382971078, 0.0691301912065122, 0.084033709032729, 0.07581304171848047, 0.08122149258368827, 0.06946947511553458, 0.08383067583954884, 0.07068277548142432, 0.09579797969926729]}, "mutation_prompt": null}
{"id": "ad308655-d63f-4036-97d0-c5086bf480ff", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass EnhancedHybridPSO_DE_Levy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population for better exploration\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Equal social coefficient for social diversity\n        self.w = 0.7  # Slightly higher inertia weight for initial exploration\n        self.F_base = 0.5  # Increased base scaling factor for DE\n        self.CR = 0.9  # Higher crossover rate for better mix of traits\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # More significant adaptive mutation\n        self.local_search_chance = 0.3  # Probability to perform local search\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n\n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n\n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor\n\n            # Levy flight for enhanced exploration\n            levy_step = levy.rvs(size=(self.population_size, self.dim))\n            if np.random.rand() < self.local_search_chance:\n                self.positions += levy_step\n\n            # Differential Evolution Mutation and Crossover\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Levy", "description": "A hybrid PSO-DE algorithm with enhanced exploration through Levy flights and adaptive local search for faster convergence.", "configspace": "", "generation": 90, "fitness": 0.1973191125243431, "feedback": "The algorithm EnhancedHybridPSO_DE_Levy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.4361186514502112, 0.4185185240874666, 0.4414842242656709, 0.46946545221409475, 0.6003979126812233, 0.44250371716438985, 0.40308981115151177, 0.47775575866271724, 0.45059778020627095, 0.05182185099251657, 9.999999999998899e-05, 0.05817959243314308, 0.023526145125347453, 0.05626403394934931, 0.05363946398369057, 0.03776124129042746, 0.05647451973658535, 0.12102726083565851, 0.09200757908987744, 0.09781755761708022, 0.14093219009852187, 0.10135579884147405, 0.10578908100707118, 0.09458765966062799, 0.0964521705597321, 0.10761306907427426, 0.10660214345562613, 0.08415319682233857, 0.08349206822389676, 0.11048118623452297, 0.07587263358085161, 0.09401368228602425, 0.09448121772313256, 0.0990718105796744, 0.08918955199223833, 0.09142831661820239, 0.9834621210199611, 0.9875649799788296, 0.9833677811959843, 0.98267807842205, 0.9857776110967985, 0.9838067480958645, 0.9875718911560157, 0.9832992629937429, 0.973076828951581, 0.14024074731010772, 0.27842072953283326, 0.2830491029990999, 0.1860766435459229, 0.15069017433080922, 0.23130251038059435, 0.08556808387027881, 0.18857085493527015, 0.2744382407444709, 0.18811369982404813, 0.5027735938271951, 0.43816811043046655, 0.23960951745178116, 0.1832914709560297, 0.18679282209367898, 0.2073361592957923, 0.18603981867006514, 0.6027266701934371, 0.11969774928943266, 0.1252503138708726, 0.12203398758009132, 0.09010114192502061, 0.1078875182085951, 0.11293903791034532, 0.07530782275354109, 0.10803014305952818, 0.1290945725806839, 0.11138683059632126, 0.11135517755612323, 0.11984437094851641, 0.12374412145186542, 0.12053972936747182, 0.12024624812988516, 0.03640432548886108, 0.10063322542142983, 0.10323555634711723, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03719185504987421, 0.008561971205395258, 0.07401929824234232, 0.07711901654408704, 0.05735730014425189, 0.054608694808584546, 0.030863218611695276, 0.07885325821446132, 0.0439012423464239, 0.06979131763739965, 9.999999999998899e-05, 0.01896313069037403, 0.014128450917814783, 0.022427418146721334, 0.01006937314155043, 0.03591680149535181, 0.015424804281282234, 0.00397955944308892, 0.016592621720674883, 0.06063911490610441, 0.07669311094746989, 0.07477118228531676, 0.040192516865929284, 0.039050690260722276, 0.05224649400903214, 0.035075915921595535, 0.060479633777485886, 0.03657360336827464, 0.34645091379104365, 0.3906249580059019, 0.37754936520263593, 0.3914764399818378, 0.3953929784778508, 0.3904934504263592, 0.35187962364519143, 0.3805315486649279, 0.41554642433598254, 0.08577989801007335, 0.07359731655675916, 0.09987826110392384, 0.07028950009923463, 0.09869277801652077, 0.09323383275667929, 0.07632098974575197, 0.06899841612032409, 0.08432352225114281, 0.18453478519353184, 0.18779006304318513, 0.2258611700054276, 0.14914539641666902, 0.23389973251680063, 0.1713738381968669, 0.15968446592289853, 0.16858931528759458, 0.1920408157097896, 0.2931389343130324, 0.2782473475720322, 0.21881876516748966, 0.2545431237780642, 0.3302041143256502, 0.3238567279304362, 0.2820690187556725, 0.24910409729917726, 0.24826479341948582, 0.18378240965474446, 0.16670320570551977, 0.20676042407793893, 0.1979664282008773, 0.22048175905994538, 0.20138971516334936, 0.1534100923571079, 0.18152325790845203, 0.23254525247224866, 0.18367632294965464, 0.2085467144412515, 0.20514860300967475, 0.18655894780255988, 0.18617409132781848, 0.1759094868260127, 0.17765390204504616, 0.21289728516039497, 0.20367344647592422, 0.17937339511989536, 0.19421364288805731, 0.18866442256625215, 0.1788523494658495, 0.19733638490773842, 0.1975380740010576, 0.1805351105766917, 0.18092499408997043, 0.17635220032826715, 0.13035685000767339, 0.1629331205454213, 0.6835630558158414, 0.15651114058166005, 0.1983153801481703, 0.16242745480272536, 0.16614618571457263, 0.1623244603370575, 0.12468599344933773, 0.13654370323037934, 0.34172456332975154, 0.25614131306966814, 0.3969942917348721, 0.12470820667187221, 0.16628786430328601, 0.15338561556613017, 0.20366814083256546, 0.15458189312718895, 0.18644728230352425, 0.1924876789387273, 0.18821416182889672, 0.19127568556108643, 0.188166190459095, 0.18551066661130533, 0.20110445988131054, 0.18103098276747187, 0.1877613965725835, 0.06927902767768357, 0.07161884337944868, 0.0899906389989481, 0.07016059124507901, 0.07491939757035837, 0.07808058439583032, 0.0745579784242234, 0.07442794289855159, 0.08177234738039929]}, "mutation_prompt": null}
{"id": "b565e316-f2d7-42a5-97f2-5bcf44b56ba4", "solution": "import numpy as np\n\nclass ImprovedHybridPSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Adjusted social coefficient for balanced exploration\n        self.w = 0.7  # Slightly increased inertia for better exploration at start\n        self.F_base = 0.5\n        self.CR = 0.9  # Increased crossover rate for greater diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.95  # Enhanced adaptive factor for inertia weight\n        self.mutation_adjustment = 0.25  # Adjusted parameter for mutation based on diversity\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with dynamic neighborhood\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.3:  # Adjusted diversity threshold\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    neighbors = np.random.choice(indices, 3, replace=False)\n                    a, b, c = neighbors\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "ImprovedHybridPSO_DE_Adaptive", "description": "This improved algorithm accelerates convergence by integrating a dynamic neighborhood approach and adaptive control of DE parameters to maintain diversity and exploration.", "configspace": "", "generation": 91, "fitness": 0.23917011977361918, "feedback": "The algorithm ImprovedHybridPSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.7998420273514644, 0.8879091173792824, 0.8872540854134665, 0.3004005621846283, 0.15087312298781363, 0.8810031323742321, 0.8707499882036723, 0.8016554360054523, 0.8757237150519251, 0.6368898957519162, 9.999999999998899e-05, 0.7794669055454245, 0.2859852594800394, 0.058827630605153725, 0.43252370122070316, 0.04450979652732401, 0.5790552775018671, 0.7386564366199494, 0.14101229091674172, 0.14166785402401472, 0.15007975523617734, 0.13050307191243793, 0.08316594441973524, 0.0950894723580068, 0.15165508107079773, 0.0942132536326491, 0.07443552549559318, 0.09031448682537213, 0.13658660016925683, 0.116007052554146, 0.08956369288010124, 0.10521396662498506, 0.11656587236506877, 0.0938942632444858, 0.10802135266872304, 0.12837679029995908, 0.9848693869363375, 0.9865205909280282, 0.9852089656039649, 0.9776364640970193, 0.9778946984729153, 0.9713159051483651, 0.9907580063459236, 0.986440859106196, 0.9900393904963465, 0.6460805056577736, 0.39762376450991976, 0.27101633964817806, 0.5728500722577339, 0.3297326847317794, 0.15110975741644284, 0.6010824131433853, 0.2569531884134655, 0.2765112991326001, 0.3866945324261335, 0.1693643671231364, 0.2250764565260137, 0.2742902027891827, 0.19351857130597327, 0.20707113322489634, 0.2023188343600718, 0.1623852018885249, 0.17434538427910662, 0.17142532063960392, 0.23234487663481018, 0.1554971391311517, 0.09877856490170345, 0.16991801457668587, 0.15564244991968934, 0.13248321437880528, 9.999999999998899e-05, 0.18134343236186146, 0.1813963076979731, 0.12708377471460608, 0.14780379642127173, 0.12881367397313737, 0.17234244078860406, 0.1889766049085645, 0.12933549270189248, 0.1306124878785544, 0.20103329486619714, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045911668106844106, 9.999999999998899e-05, 9.999999999998899e-05, 0.026859181822414424, 0.05861169785991294, 0.07113636468358708, 0.022282776199628818, 0.05980812465732055, 0.05615708774241379, 0.06703611376945995, 0.06856694639970029, 0.032277547404131246, 0.04705459580705451, 0.09730822223097835, 0.0706142439565014, 9.999999999998899e-05, 0.08691963412187254, 0.07590199531671626, 0.09521960775169136, 9.999999999998899e-05, 9.999999999998899e-05, 0.10391399056666994, 0.08629802339876946, 0.020239310505117847, 0.11183411166552193, 0.12928888296988483, 0.02312883855224901, 0.08159942329542069, 0.11127490569142517, 0.05692210412477139, 0.5077739700447865, 0.5524128706379168, 0.5400256192963506, 0.49421877271811177, 0.5803941992087018, 0.3091978303013494, 0.2590004213754006, 0.5004428198684647, 0.4540951686253988, 0.04670259894892426, 0.08349277232396779, 0.08390097447845257, 0.05942115008929982, 0.07760739987747856, 0.09620653667690682, 0.09194161515150301, 0.09449950263491758, 0.08763234917033447, 0.18965308754044619, 0.1424846585397499, 0.12840850236951684, 0.19413073584273344, 0.25262502511948537, 0.22203689090258427, 0.17961656244328283, 0.1897932711178144, 0.33670030137912166, 0.29833824999284275, 0.2969935141727579, 0.22520699742874795, 0.3492404911972937, 0.1883321009424812, 0.37766613773698987, 0.386821554334694, 0.18984354392408054, 0.28608206204526865, 0.19986686391212483, 0.3457770963767365, 0.34100720429316467, 0.16313088665583164, 0.2569785244402295, 0.22096359312591285, 0.13219701190644229, 0.16017661298903607, 0.18325243629716037, 0.1999952757441159, 0.2118380171253268, 0.19548698356167082, 0.2195497184484867, 0.17786433835720306, 0.2513089488501695, 0.22649915840820134, 0.22452499075292154, 0.1802800831469552, 0.1971346165287451, 0.17144206467569145, 0.20439566033634016, 0.181827205925858, 0.17549656014334192, 0.1858007837605814, 0.16954632981005202, 0.1879598647940427, 0.19841677238750555, 0.135056311690684, 0.1675305852308202, 0.410296739646721, 0.11899330736999258, 0.16282422612305092, 0.16821690663467503, 0.12335553046411574, 0.20933690373880443, 0.16528752019423387, 0.21029885389821323, 0.16044970573416828, 0.12696442471870595, 0.4201628135001175, 0.12740138624517128, 0.1689762403758367, 0.1661935685749386, 0.1047807180342144, 0.31751966785463737, 0.20145940223309333, 0.1809562057774513, 0.17894294595852767, 0.17797076537140166, 0.18567030662066797, 0.1722559682793231, 0.19918118917452476, 0.24405309632256755, 0.1795543714631156, 0.10495217443429428, 0.060403106940595586, 0.08951607592724808, 0.08416801931254647, 0.0992820944372983, 0.05477366597925504, 0.07546479550359253, 0.08960881586066849, 0.08453192229732154]}, "mutation_prompt": null}
{"id": "2d6dafdd-bdb9-4f88-b598-fa009708a479", "solution": "import numpy as np\n\nclass RefinedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Reduced cognitive coefficient for balanced exploration-exploitation\n        self.c2 = 1.5  # Equalized social coefficient for harmony between personal and global attraction\n        self.w = 0.5  # Further lowered inertia weight for faster convergence\n        self.F_base = 0.6  # Increased mutation factor for more aggressive mutation\n        self.CR = 0.9  # Higher crossover rate for more thorough exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization using logistic map for improved diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.arange(self.population_size)[:, None] * np.pi))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.97  # Slightly adjusted adaptive factor for smoother inertia decrease\n        self.mutation_adjustment = 0.4  # Slightly increased parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold to maintain diversity longer\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "RefinedHybridPSO_DE_Chaotic", "description": "A refined hybrid PSO-DE algorithm with adaptive parameter scaling and reinforced chaotic initialization for accelerated convergence.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {}, "mutation_prompt": null}
{"id": "21ee2f2e-aff2-46df-80bd-6f10a08740b4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "9d2f3bb1-2729-41f9-b083-d0ebfddbbc35", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Reduced cognitive coefficient for balanced exploration\n        self.c2 = 1.5  # Increased social coefficient for enhanced herd effect\n        self.w_max = 0.9  # Adaptive inertia weight starts high\n        self.w_min = 0.4  # Adaptive inertia weight ends lower\n        self.F_base = 0.5  # Increased base mutation factor\n        self.CR = 0.9  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.tan(np.arange(self.population_size)[:, None])  # Chaotic mapping\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_adjustment = 0.4  # Slightly increased adaptive mutation adjustment\n\n    def __call__(self, func):\n        function_evaluations = 0\n        iteration = 0\n        \n        while function_evaluations < self.budget:\n            # Calculate adaptive inertia weight\n            self.w = self.w_max - ((self.w_max - self.w_min) * (function_evaluations / self.budget))\n            \n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.15:  # Reduced threshold for diversity check for frequent DE application\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-6)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            iteration += 1\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic combining modified PSO-DE with chaotic mapping and dynamic learning rates for accelerated convergence.", "configspace": "", "generation": 94, "fitness": 0.14098450438745272, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.20.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.10660916389184238, 0.32043092384017524, 0.4484493002018285, 0.18872168956096946, 0.14049921486816497, 0.18912891263943288, 0.4072317254406834, 0.2870405838889608, 0.528931683926095, 0.08702828085867131, 0.011309689988869831, 9.999999999998899e-05, 0.011616013709101702, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007855958470468494, 0.13025595732012862, 0.09944606152269664, 0.03369262210568902, 0.0396987887243222, 0.05507157666797757, 0.04029296516468406, 0.06201039183381796, 0.04444539858506247, 0.04362808328266399, 0.048642236164725405, 0.048738096100235495, 0.07531224186931484, 0.05809789218761219, 0.007222604487654327, 0.036755822921595405, 0.06178914548474934, 0.02369734444946736, 0.014232975517521118, 0.028005270756878753, 0.993260749827593, 0.9879791031843025, 0.9948250871496995, 0.9817796425372443, 0.9940218692222041, 0.9728027029511401, 0.9919971063161687, 0.9845969721338006, 0.9825356752200658, 0.027164862811564494, 0.036413044959392904, 9.999999999998899e-05, 0.16146628265552776, 0.09853645026986468, 0.04116930237339056, 0.04935380290999325, 0.08088674963125198, 0.09300743981522408, 0.13034602755645897, 0.15790045287422805, 0.04820207007060384, 0.29303980516217143, 0.10959882575110735, 0.0758195672855827, 0.08236394894373789, 0.08368450972417141, 0.08529537156402911, 0.1110775390426193, 9.999999999998899e-05, 9.999999999998899e-05, 0.015295562435204357, 0.04650825619930876, 0.13896359282934245, 0.060536890436118096, 0.08436851815909208, 0.04841834936759626, 0.07321638532512276, 0.009905573097143128, 0.009249793437817067, 9.999999999998899e-05, 0.08605055090496039, 0.11395820352177943, 0.05601553984985563, 0.08393438242081497, 0.03468876635365303, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005372110015007259, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031140214841940406, 9.999999999998899e-05, 0.012970657892270587, 0.06076321858145617, 0.04452046630071815, 0.0049422563613811255, 0.009216296512814526, 0.012939849045599527, 9.999999999998899e-05, 9.999999999998899e-05, 0.021720484441143162, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00027779697390828417, 0.009432049040338786, 0.04902112264629499, 0.10289659907582827, 9.999999999998899e-05, 0.006349339420381739, 0.02813575927013845, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023143503628476614, 0.04220951921106153, 0.04593277446257038, 0.15252824839594303, 0.3596036237879454, 0.33245231283391574, 0.3861713431719881, 0.24615118355563692, 0.11864040882648819, 0.25857169044650063, 0.3535895603210125, 0.36389140575875123, 0.04707656175679875, 0.038067655309259485, 0.05027132022935654, 0.0918793144182275, 0.09055448492795981, 0.08793643818535546, 0.08874614356762489, 0.06373071092903226, 0.06008161195266715, 0.11672593900488826, 0.09809746579699585, 0.08402161281034581, 0.12475613485590675, 0.1628032715678135, 0.21684907952533106, 0.11307946990898343, 0.1508888671801114, 0.14476253864629163, 0.18766303448338584, 0.18870972921244655, 0.09592353644706886, 0.17982743886350272, 0.14490751662649604, 0.1831812240485694, 0.17801420806178325, 0.1351458325741811, 0.1365230065748274, 0.17693522288289187, 0.165610805186023, 0.08525607969402971, 0.09409008876898439, 0.0858110776038411, 0.0674696503223684, 0.10145775206179752, 0.10939102895632624, 0.1691730334752598, 0.13441178254098063, 0.13945814528787936, 0.15150698860140566, 0.16424801814433343, 0.17451294914360538, 0.1629752419509789, 0.15917899438944838, 0.16876539264345936, 0.17619953341622308, 0.15800622654673935, 0.18304781592806407, 0.16787468083704393, 0.20907255960249538, 0.1783309185128199, 0.1759335155639663, 0.17110998800052257, 0.1911040497574119, 0.18516429370607268, 0.17813970620929376, 0.11187678314749794, 0.11412498532084048, 0.15258636391953984, 0.12123787014474274, 0.15726610382549644, 0.11408911887742146, 0.14703872184819577, 0.1549142486084749, 0.10809598569185441, 0.10431876776962545, 0.10827588922783038, 0.1097389520196812, 0.0940139754251943, 0.38679976980334996, 0.10734019314232413, 0.27084989059752607, 0.11906027399685226, 0.2008320271274343, 0.18135435782233422, 0.18212220536556534, 0.19773917957735032, 0.17748704846702767, 0.1560422938596212, 0.1935952028055692, 0.1794273534565557, 0.192991063253099, 0.04000656011051307, 0.06845297332084865, 0.05782678362311966, 0.039310800128325774, 0.08957989832492008, 0.06541013472487522, 0.04169555238724565, 0.08456481142051597, 0.0603826114124999]}, "mutation_prompt": null}
{"id": "889d1929-6a08-4562-b975-66a633b2197a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "4dc7ccfd-32f3-434f-b2af-be085e336a74", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for better diversity\n        self.c1 = 2.2  # Further increased cognitive coefficient\n        self.c2 = 0.8  # Reduced social coefficient for controlled exploration\n        self.w = 0.7  # Slightly higher inertia weight for initial exploration\n        self.F_base = 0.5  # Increased base mutation factor for DE\n        self.CR = 0.9  # Higher crossover rate for more aggressive trials\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for greater initial diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None] * np.pi/4)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.95  # Adjusted adaptive factor\n        self.mutation_adjustment = 0.4  # Modified parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "A hybrid optimizer enhancing PSO and DE with chaotic initialization, adaptive parameters, and self-tuning mechanisms for accelerated convergence.", "configspace": "", "generation": 96, "fitness": 0.258180816210963, "feedback": "The algorithm EnhancedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8740544653985111, 0.8515595175470869, 0.8718207055321474, 0.8154352296222048, 0.868250783862653, 0.8698051623782044, 0.8736118306769707, 0.8565947857475227, 0.8302550354536757, 0.09542033739405165, 9.999999999998899e-05, 0.14847465230289913, 0.45455662097256866, 0.057366336278318664, 9.999999999998899e-05, 0.05676960702407019, 0.13998037802720242, 0.6974195330309865, 0.1781966003542539, 0.33965289450946334, 0.1600317677162726, 0.11042854015684112, 0.17869016138634164, 0.14930771935138965, 0.15119662511018161, 0.13355003525433295, 0.1195975384015715, 0.13431066299047922, 0.1354766513209945, 0.08934124251601083, 0.07966085171432513, 0.11209421108184703, 0.11718325711856614, 0.12964839660997152, 0.1327320478580406, 0.13076460790352462, 0.8357548635500778, 0.9684251670985009, 0.9753282835295685, 0.0997505660130602, 0.866164132241904, 0.9708127193709274, 0.9700100890731317, 0.9774278861984542, 0.9697197929991251, 0.15622614838531823, 0.2568381048542212, 0.15791494730482913, 0.4713419138349051, 0.22718503973859994, 0.4566472075559055, 0.32700964578742264, 0.0828856559389991, 0.3346690475498306, 0.2151683665017864, 0.3833732081004003, 0.21087642301278597, 0.9165604308449294, 0.26688807193395114, 0.1939005508461602, 0.24347759947021985, 0.17694847971043548, 0.12560796199348356, 0.14600111534579863, 0.16195409068935462, 0.2066221567277885, 0.15377472381955937, 0.14573807443694808, 0.13202761825453402, 0.17852646649484794, 0.18678495191075484, 0.14963112013590252, 0.12714786463996808, 0.14923337562230066, 0.15530634159268852, 0.12704162587746237, 0.15691209890176794, 0.18846979017751442, 0.1679470133357963, 0.13661748693941622, 0.12647013315516575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08916104580206174, 0.05547306869532154, 0.01624203967241522, 0.06990008077950349, 9.999999999998899e-05, 0.017977717534422344, 0.11849901494535464, 0.1845105139086436, 0.07529612312095435, 0.017295326292213198, 0.10304510855631765, 0.03504888237462911, 0.07051670874127725, 0.08835354545540153, 0.05404768061583376, 0.03301267021863785, 0.16961017378583543, 0.06657389876481812, 0.21476631767733445, 0.09412703602875905, 0.11127745389078503, 0.2411102478804168, 0.13430859608533374, 0.3168059738619381, 0.1393900431226326, 0.16336774675477994, 0.17746823937772405, 0.08058850159750741, 0.2707689946944086, 0.19941331705650933, 0.12876788167056163, 0.08613227055129191, 0.08728863256373809, 0.5383505853387449, 0.591493846866225, 0.5918446523107912, 0.5887314866247226, 0.5407041827055279, 0.5922181890263499, 0.5646955178992981, 0.5535764714785116, 0.5546387636802627, 0.06262257520794667, 0.09178089731935002, 0.06707589573072292, 0.11261939942185051, 0.16104801141255398, 0.13918026187909505, 0.1385458384398064, 0.11340294669422346, 0.13902018566176189, 0.15279313870806976, 0.21043304852111733, 0.1956837342188097, 0.18265892453818655, 0.18042090518111964, 0.1588963679962362, 0.1781091428028545, 0.20766716826079812, 0.16535106948230438, 0.3319754555955975, 0.2958832413345126, 0.24760352731106716, 0.3303164409172934, 0.3658981263482418, 0.5303422326986458, 0.36293437588875554, 0.3245025111529165, 0.3035521465159946, 0.13716733918382074, 0.19763179531100084, 0.29375729898883873, 0.23864831428309896, 0.22769024328752951, 0.2640142103773636, 0.21419676100423812, 0.1998989334031367, 0.2443717186481642, 0.2083081024429725, 0.2424210347631358, 0.21274618302931436, 0.21218531497306015, 0.21404650458256158, 0.22185800151943036, 0.19908405682739816, 0.21033523936270182, 0.21761626561818082, 0.17790293655121436, 0.19990792771563382, 0.19629834384332778, 0.20864217317895384, 0.21146005838407655, 0.2223050140697952, 0.24633831363390302, 0.22203113189959844, 0.19384667894016827, 0.1850598334787371, 0.9234841164595976, 0.4740398944335902, 0.16792972507394766, 0.3412357030066566, 0.1511120930315457, 0.15826461200706776, 0.16602735693779358, 0.1482212814294046, 0.14813126430781431, 0.2114900051502212, 0.6444572718170529, 0.20979666555099885, 0.2102475016308526, 0.5222137058418934, 0.22019112382289618, 0.1614860511348748, 0.2265181118365489, 0.17667305694408442, 0.1870727200690795, 0.18494140553502136, 0.1891286537327499, 0.18123261065255214, 0.18143384176661081, 0.18268892854196983, 0.18341178188140084, 0.17404949133066694, 0.09472005609503908, 0.13031745975116138, 0.0827998533983264, 0.07391256650662603, 0.12061204577987938, 0.07784807516479664, 0.08737629596052887, 0.10117779633975277, 0.09937018799603792]}, "mutation_prompt": null}
{"id": "a4bd5541-fc5f-4995-b753-4211b2d638b4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for stronger personal attraction\n        self.c2 = 1.0  # Further decreased social coefficient to reduce premature convergence\n        self.w = 0.6  # Lower inertia weight for rapid convergence in later stages\n        self.F_base = 0.4\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic Initialization for better diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * np.sin(np.arange(self.population_size)[:, None])\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.99  # Fine-tuned adaptive factor for inertia weight\n        self.mutation_adjustment = 0.35  # Fine-tuned parameter for adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity dampening\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.2:  # Slightly higher threshold for diversity check\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_Chaotic", "description": "An enhanced metaheuristic blending adaptive PSO-DE with chaotic initialization and dynamic parameter tuning for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.861100225211921, 0.8586667480910962, 0.8717797832007301, 0.8699856748976097, 0.8726923960849043, 0.8725097197454935, 0.8675169790741334, 0.8595992106354914, 0.861833992852427, 0.6890732796731212, 0.10483498346723952, 0.6861140841710165, 0.19272779320195232, 0.11495675008382644, 0.6653795385618579, 0.42412893761123904, 0.13322361169065589, 0.07962194369623898, 0.1373251882382357, 0.15362645354876037, 0.1851435527261741, 0.1571168918904281, 0.11846302902517158, 0.1406320870097565, 0.18061333025392545, 0.15126207184299978, 0.14893079289243327, 0.08240037804004519, 0.12126059884523077, 0.1099048249184682, 0.10789636304216799, 0.12134012480088019, 0.1014482327469245, 0.10855976260685074, 0.13019463031569323, 0.11154650382209785, 0.9674871862657756, 0.9710210922354016, 0.9715652107315641, 0.8839678966543117, 0.7390005338798711, 0.9799798946475985, 0.9778388576487992, 0.9812343121794057, 0.9813571339562427, 0.7166681643542008, 0.5696268092968024, 0.05586998978462421, 0.7107048336670742, 0.36826031569040985, 0.5228538159504916, 0.7013025952313116, 0.6797283170263677, 0.6693119096295942, 0.22274258432661886, 0.36870422514620227, 0.21710382178978904, 0.2775002598216719, 0.3849620606087022, 0.19247159930683144, 0.8303935205531844, 0.24217484069298367, 0.8607432894281792, 0.16571512670884436, 0.14268411173543138, 0.1613504626508031, 0.1786079607101133, 0.16373329748992527, 0.16720846309838167, 0.16866343938907935, 0.1675715774317207, 0.1198460989636766, 0.130837860789068, 0.17037213660289474, 0.13619536359162687, 0.14884591136776126, 0.14619524609269952, 0.13148740471050402, 0.20791945270152568, 0.12902131305416842, 0.176693851214218, 0.00803786396243722, 9.999999999998899e-05, 0.08546036986559613, 0.003249010612224823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03087535078118453, 0.005561195686548448, 0.1176896468217814, 0.06342874361456963, 0.09408894892002151, 0.103346611148877, 0.06372760123763932, 0.031827596621425425, 0.028803834079061397, 0.07091282966783097, 0.0722275736202499, 0.14168715667113996, 0.17382006189940635, 0.11099016727670008, 0.08974794111534101, 0.19460732892246801, 0.08923796000015749, 0.2299201451574383, 0.2339061506208634, 0.12483009444389082, 0.29154632905259614, 0.10152998660078849, 0.12706919637442093, 0.040977590609216574, 0.13432494165809072, 0.18079733694576594, 0.08505706514267752, 0.0839038276495725, 0.057453220538342786, 0.5495327482956824, 0.5469093937242991, 0.548748317324953, 0.5804310081705107, 0.5934325977954971, 0.5611109702968811, 0.5525948083804271, 0.5601080468600967, 0.5670057386691625, 0.07417082290280341, 0.12155946124010586, 0.14460238183330676, 0.16084040145969025, 0.15943995987166504, 0.14368475615385645, 0.14288460870268505, 0.14147594839108257, 0.10458564436139217, 0.2721067334567153, 0.43329962754123896, 0.20255724038925194, 0.2573853315962965, 0.20455269151586342, 0.26367115280197273, 0.20135421851737179, 0.23235746753443198, 0.2500287150713294, 0.3743099988405253, 0.1961893884804332, 0.23717729972605384, 0.2575176251431982, 0.2882483139948694, 0.50210020172254, 0.31131215706053594, 0.5683401001190888, 0.25722215667821424, 0.2691253797937373, 0.17270407156957313, 0.23043011200212093, 0.21768828280245345, 0.31379021579424893, 0.19721407001831615, 0.20494693510778872, 0.3092954427065362, 0.2130859700760942, 0.24541076123313088, 0.2260370221878485, 0.2200865875682252, 0.19308790589390168, 0.22851172333584735, 0.23894618807428425, 0.21348462216608954, 0.22276723852738756, 0.24604919490965538, 0.1883432194368596, 0.18567168396768285, 0.24233506118681203, 0.19765943105312767, 0.2234047355355413, 0.19387251935719996, 0.2084167627332255, 0.20925889756288063, 0.2492350249252333, 0.9205390976467864, 0.92182852456698, 0.18656399512086996, 0.9146762378156643, 0.12538009686080254, 0.1674124812420823, 0.38074313828513096, 0.16897165209027387, 0.1540465568633037, 0.20309869283743742, 0.1690985278430691, 0.3620491035235336, 0.702773167702049, 0.20035754755276602, 0.209491653554144, 0.16529749010942874, 0.6593741607020498, 0.6718712420238626, 0.21940945471764917, 0.20154813004967764, 0.24093527394895375, 0.19657048583404524, 0.19254889158243738, 0.201820119548755, 0.20650022104584653, 0.18592737966803252, 0.18614987100791336, 0.09335737536255806, 0.09003037009171877, 0.10031966321048769, 0.17565065432031557, 0.08013904166654884, 0.10329161749137328, 0.08216298704635505, 0.0967557781767624, 0.10397879279700539]}, "mutation_prompt": null}
{"id": "df1d8490-41b4-407b-a658-e5e93acedec4", "solution": "import numpy as np\n\nclass ImprovedEnhancedHybridPSO_DE_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive coefficient for balanced personal attraction\n        self.c2 = 1.5  # Adjusted social coefficient for balanced global attraction\n        self.w = 0.5  # Lower inertia weight for faster convergence\n        self.F_base = 0.5  # Adjusted mutation scaling factor for enhanced mutation\n        self.CR = 0.9  # Higher crossover rate for better offspring diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Updated Chaotic Initialization using logistic map for better initial diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim) * (np.sin(np.arange(self.population_size)[:, None]) + 0.5)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adaptive inertia weight for gradual convergence control\n        self.mutation_adjustment = 0.40  # Enhanced parameter for adaptive mutation\n        self.diversity_threshold = 0.3  # Adjusted diversity threshold for mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n\n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with adaptive velocity strategy\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions = self.positions + self.velocities\n            self.w *= self.adaptive_w_factor  # Adaptive inertia weight decay\n            \n            # Differential Evolution Mutation and Crossover with adaptive mutation scaling\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < self.diversity_threshold:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / self.global_best_score))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "ImprovedEnhancedHybridPSO_DE_Chaotic", "description": "ImprovedEnhancedHybridPSO_DE_Chaotic with diversified swarm strategies and adaptive mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.27523793433653876, "feedback": "The algorithm ImprovedEnhancedHybridPSO_DE_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.884636029215112, 0.876138315727883, 0.8687847607987962, 0.876949894587916, 0.3960199927985334, 0.8820015322388425, 0.8807573422744993, 0.8775835818567835, 0.896092379519829, 0.30359731038898996, 0.5681108444903615, 0.07521352180063967, 0.2618972902845873, 0.4126333214242165, 0.10595239661159561, 9.999999999998899e-05, 0.657894617256399, 0.7593569507722717, 0.10314014550133, 0.1533262096776754, 0.1555664058385806, 0.10473347609471861, 0.058752606730660406, 0.07531253782443348, 0.10694684981107383, 0.1162759286283459, 0.1860774974109345, 0.07595074638648436, 0.08834822904840456, 0.10876523762283163, 0.06849809903501425, 0.08808913635740989, 0.11639576567771348, 0.1319315155287093, 0.11507570716844362, 0.09195240135106875, 0.9653316311767866, 0.9810462776454677, 0.9678557357261175, 0.9690140022068895, 0.9596230946492565, 0.9777756229622996, 0.9868426692539051, 0.9867041358236004, 0.9819601237720553, 0.6755142879283806, 0.24735275440302373, 0.5137657017632338, 0.526141740883956, 0.5585745202729993, 0.2726742815576805, 0.12705747020963043, 0.6922487964987596, 0.6954600664452131, 0.3897742978539358, 0.07221448798829877, 0.3934694000125373, 0.9027586427489149, 0.27878840731550203, 0.19236596514593596, 0.13004860080289182, 0.1642308964750837, 0.240054235110172, 0.13022290631530808, 0.16523945035897292, 0.18184712480384047, 0.2155403742689307, 0.15872744062118094, 0.17220156619420957, 0.28349843073519, 0.15395435421573145, 0.15705643602733632, 0.19841929451787654, 0.2060877883865765, 0.1338482511543776, 0.19232653802868616, 0.16757775453780066, 0.14367922849497028, 0.212827888067056, 0.11307218030503918, 0.19216837677098986, 0.0007650433229069442, 9.999999999998899e-05, 0.014147358898917606, 9.999999999998899e-05, 9.999999999998899e-05, 0.02058382902574518, 9.999999999998899e-05, 0.005748025394421541, 9.999999999998899e-05, 0.02890335265324462, 0.08071980640916188, 0.05874178470898661, 0.011455190386282621, 0.06888203325200015, 0.021834081224532786, 0.05580613827082492, 0.030789680837808198, 0.04625154430574019, 0.03427462910402157, 0.15189025312768967, 0.10193269900969937, 9.999999999998899e-05, 0.07609389355128493, 9.999999999998899e-05, 0.38144280903970584, 0.09862299116344997, 0.07803079293881143, 0.2242210386214989, 0.07356258407470417, 0.011622530432754186, 0.03897238988173157, 0.21531745959206028, 0.11735746089091592, 0.05689237585398699, 0.08304494019689534, 0.10772090123552369, 0.5853311955751805, 0.5443795312853486, 0.6076899190331415, 0.5581688510779024, 0.6182714265226671, 0.20909545605343105, 0.5408462440575733, 0.5731828534958096, 0.6148628175792064, 0.10503651074761988, 0.14637414846646501, 0.07493342811809978, 0.11717533459815022, 0.14553198767681863, 0.1628764195848862, 0.0664381492787679, 0.09691664781949383, 0.11033347457024101, 0.3354447129017947, 0.21450812445990897, 0.37335962815269186, 0.1623689595200294, 0.32747297089575744, 0.19531715452393938, 0.20967949447974665, 0.20790791241623063, 0.2060838134478844, 0.24806645707418196, 0.2539630672499479, 0.3386109416431382, 0.39745248264233846, 0.4975746888777537, 0.25003135530779175, 0.21612680987913746, 0.40236110515511314, 0.46267916377394147, 0.2500768778688004, 0.1727301716677273, 0.2737958301077883, 0.2557675663334903, 0.388790021351052, 0.2039227614831265, 0.13829454601993052, 0.21788146761409954, 0.3206143796748815, 0.21391010159205348, 0.18005988164765874, 0.2220346673585426, 0.18873353093206469, 0.18422808706307736, 0.19944500895838924, 0.3009869663504967, 0.22147015638488687, 0.2258646473004423, 0.22431866801705702, 0.18602645729681488, 0.22645011102090307, 0.2002598797373668, 0.19938757745811908, 0.19316203632379925, 0.19109057801059937, 0.22551306236541369, 0.2239773238280457, 0.9334901191941416, 0.1759172901219408, 0.1876894600838318, 0.16780151071217664, 0.16792290803685084, 0.1546140585762078, 0.1666349741956883, 0.15362324313238174, 0.8644107354345714, 0.39667614606624324, 0.21198302371735778, 0.15553466225646317, 0.21173712457068616, 0.900627824092027, 0.21307949055672948, 0.3393032161258346, 0.15613247037749411, 0.15584465223582433, 0.2074441290785246, 0.19179119133287081, 0.18757529807274043, 0.20021609724674094, 0.23057525442693494, 0.22024718247231778, 0.2001045347768613, 0.198852673634066, 0.2403192817891031, 0.08933524725625008, 0.08697576397234097, 0.10496785386118768, 0.09207653728639276, 0.07935499785802425, 0.09928197180448983, 0.0844289913039078, 0.08400551657119426, 0.08344335717020845]}, "mutation_prompt": null}
{"id": "385bcef6-093f-4562-874f-b41273d17df7", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_AdaptiveChaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased population for better exploration\n        self.c1 = 2.1  # Slightly increased cognitive coefficient for more personal exploration\n        self.c2 = 0.9  # Further decreased social coefficient for reduced herd behavior\n        self.w = 0.5  # Decreased inertia weight for faster convergence\n        self.F_base = 0.5  # Increased base mutation factor for stronger DE effect\n        self.CR = 0.9  # Increased crossover rate to encourage more trial solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Enhanced Chaotic Initialization for initial diversity\n        self.positions = self.lower_bound + (self.upper_bound - self.lower_bound) * (np.random.rand(self.population_size, self.dim)**2) * np.sin(np.arange(self.population_size)[:, None] + 1)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_w_factor = 0.98  # Adjusted adaptive factor for inertia weight\n        self.mutation_adjustment = 0.4  # Adjusted parameter for stronger adaptive mutation\n\n    def __call__(self, func):\n        function_evaluations = 0\n        \n        while function_evaluations < self.budget:\n            # Evaluate current population\n            scores = np.apply_along_axis(func, 1, self.positions)\n            function_evaluations += self.population_size\n            \n            # Update personal bests and global best\n            for i in range(self.population_size):\n                if scores[i] < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = scores[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                if scores[i] < self.global_best_score:\n                    self.global_best_score = scores[i]\n                    self.global_best_position = self.positions[i]\n            \n            # PSO Update with improved velocity control\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.velocities = (self.w * self.velocities +\n                               self.c1 * r1 * (self.personal_best_positions - self.positions) +\n                               self.c2 * r2 * (self.global_best_position - self.positions))\n            self.positions += self.velocities\n            self.w *= self.adaptive_w_factor  # Apply adaptive inertia weight\n            \n            # Differential Evolution Mutation and Crossover with enhanced adaptation\n            diversity = np.mean(np.std(self.positions, axis=0))\n            for i in range(self.population_size):\n                if diversity < 0.25:  # Adjusted diversity threshold for DE activation\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    F_adaptive = self.F_base + self.mutation_adjustment * (1 - (scores[i] / (self.global_best_score + 1e-8)))\n                    mutant = self.positions[a] + F_adaptive * (self.positions[b] - self.positions[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n\n                    trial = np.where(cross_points, mutant, self.positions[i])\n\n                    trial_score = func(trial)\n                    function_evaluations += 1\n\n                    if trial_score < scores[i]:\n                        self.positions[i] = trial\n                        scores[i] = trial_score\n                        if trial_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = trial_score\n                            self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Ensure positions are within bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n        return self.global_best_position", "name": "EnhancedHybridPSO_DE_AdaptiveChaotic", "description": "A novel hybrid optimization algorithm integrating chaotic maps with adaptive control of diversity and exploration-exploitation balance for enhanced convergence.", "configspace": "", "generation": 99, "fitness": 0.22574799349739005, "feedback": "The algorithm EnhancedHybridPSO_DE_AdaptiveChaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "f190dab1-19ed-40a6-b66a-cc56971d7c0a", "metadata": {"aucs": [0.8674259904915793, 0.8788840292049735, 0.8709518559559404, 0.8732495843300652, 0.8632621742222828, 0.8691542753125288, 0.872495029527751, 0.8747354319942098, 0.8642879006617277, 0.05424043052368288, 9.999999999998899e-05, 0.11196538847645243, 9.999999999998899e-05, 0.259304429868917, 9.999999999998899e-05, 9.999999999998899e-05, 0.7053825545801367, 0.22138533239289016, 0.11639422478769179, 0.16980380945199758, 0.08142762529783121, 0.09298829712827594, 0.15394243475019664, 0.10529432778061143, 0.07952945577926618, 0.13996583049826805, 0.15290979055163667, 0.11200393769521011, 0.09221690739474486, 0.08331837124375963, 0.1199828608285799, 0.08778374238789144, 0.09387352895851309, 0.03769166281335179, 0.12656685330766626, 0.08979316877159904, 0.9324693494820541, 0.9693722426696909, 0.7113166692463226, 0.24039666669351323, 0.9481197475690376, 0.1062009624340381, 0.9721635283329726, 0.9439755935205532, 0.9736002744987361, 0.05569252047383921, 0.5024444047168055, 0.14554284677458496, 0.4971156017214343, 0.32936892866468537, 0.1724899317487334, 0.5563986015450944, 0.09514425361377365, 0.22834308444567641, 0.21059626347274785, 0.20434454845188088, 0.15610021025419463, 0.15253832791812094, 0.19121143857044165, 0.07147035075386299, 0.1757557927185791, 0.15900639251079918, 0.1765244593157369, 0.12878703011602177, 0.14815541610490524, 0.18546293822486148, 0.16403701701708684, 0.15273884360029766, 0.1921470516807141, 0.1531598873234643, 0.1429047399231982, 0.1544603388208181, 9.999999999998899e-05, 0.15350806138581996, 0.17382268405757328, 0.12304880318158906, 0.15481680848439205, 0.11225544409495214, 0.16060755245601377, 0.1345944329630907, 0.24220390547619208, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02223719958319781, 0.02475674858339627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07859950847836938, 0.08630179049345954, 0.04291091048432172, 0.01511932070580968, 0.013682685666823069, 0.04320463605921521, 0.002553971860987936, 0.06163362913254311, 0.04026563391230287, 9.999999999998899e-05, 9.999999999998899e-05, 0.04588096615113568, 0.08149942561202683, 0.09615198956600579, 0.09154388400455993, 0.16219543086854482, 0.18444598772369936, 0.1034830074679467, 0.0874674779315997, 0.12096763824027712, 0.05152741049326792, 0.12321234393368341, 0.15355148215551473, 0.038448484427905494, 0.10848262411024212, 0.08689674350277987, 0.09818933540692176, 0.6259012576669897, 0.4742992991853917, 0.5716757480133934, 0.5351136426818721, 0.5226565652868476, 0.5448179409615121, 0.5703584503611743, 0.38419019511829, 0.5597301432714133, 0.0816838187028176, 0.061963980564700205, 0.17945015664524622, 0.15632586904084222, 0.06856944900700856, 0.10225469506052709, 0.0955217993778229, 0.12310011580876778, 0.09753105580219745, 0.2981607986297812, 0.20913964709137567, 0.17674718081199192, 0.3391461612240221, 0.3108645547833384, 0.19824018428243162, 0.21273715055112474, 0.22323314580103915, 0.20755982204888668, 0.14558112853099736, 0.3303916273062273, 0.1560433176889241, 0.16839483261469834, 0.24601472231069388, 0.21036296058437087, 0.4009383231084024, 0.13223959231836502, 0.2853669268295369, 0.16214004972224016, 0.2592792333388624, 0.06100473507146287, 0.1709060252054565, 0.1517908725915761, 0.2216670428452463, 0.32602920690380066, 0.1535603831641984, 0.0841761181504388, 0.22253556035164945, 0.20581482907853177, 0.20447889102621675, 0.1659551695698852, 0.22803364170413531, 0.1528234123162271, 0.19795264555929337, 0.2104667935793998, 0.18685220428938554, 0.2032720426266379, 0.18745026299979795, 0.20752809495314206, 0.22139628236837594, 0.2218162258812154, 0.19843886954674894, 0.21559928619979396, 0.22089735760418805, 0.22266092467331056, 0.9105508747216767, 0.13553682818981705, 0.6477789102611554, 0.15101977600346306, 0.1679745452099516, 0.16791343887846544, 0.12642326392969194, 0.1141724476710746, 0.16535194943565545, 0.11045040614281043, 0.11271912488475666, 0.11246636952302724, 0.21083696708263244, 0.3199732949027285, 0.18678040234763504, 0.16237346863782565, 0.24199711452574968, 0.20952340914148004, 0.18559596268051437, 0.19920056343336823, 0.1903148822904519, 0.19099985501440364, 0.20119391696953504, 0.20329427278439227, 0.189542140807194, 0.18647540754808334, 0.1860637077159506, 0.08314249233720927, 0.079906087164476, 0.08834180718399276, 0.057711592089837005, 0.12000787636324717, 0.08880627214381764, 0.058106193075927015, 0.08738446862498661, 0.09756863476935762]}, "mutation_prompt": null}
