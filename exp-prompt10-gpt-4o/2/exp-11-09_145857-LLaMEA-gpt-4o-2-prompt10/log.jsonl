{"id": "9b3cb5b7-415b-48e3-9804-b7f3914710b1", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A dual-population hybrid algorithm combining Differential Evolution and Simulated Annealing to explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.2445129188431638, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6724509386627546, 0.6995998243379044, 0.700003837396423, 0.6993613640042287, 0.7309607279926169, 0.7263458975935668, 0.7222776745889468, 0.7313795672869614, 0.6988784377716011, 0.4944418566945473, 0.5488698269332295, 0.48645961609458277, 0.5201278297045177, 0.46957661043259935, 0.5077962598499994, 0.4724859175334284, 0.4389721332664248, 0.48841383436020036, 0.1293071886114987, 0.14537052640686, 0.14803219787144029, 0.12769250828516943, 0.14785918431383305, 0.13691211705424777, 0.1153135694395705, 0.1696104712526374, 0.13048745195191436, 0.14733439015771943, 0.1397371230382951, 0.11940537969105847, 0.12804728364635798, 0.11714697886424275, 0.1613424602203104, 0.10466137095368633, 0.153957189274052, 0.11352487622481544, 0.9614260326034232, 0.9522535561570864, 0.9551105572495668, 0.9333450075625147, 0.9276875593035596, 0.9666934642928338, 0.9590923304338275, 0.917137843138132, 0.9626388799787172, 0.28780469469713776, 0.30211522650227596, 0.29005442516163027, 0.2729956204914863, 0.28771055334084183, 0.28116584895522256, 0.2935205806384933, 0.1541853253643436, 0.2897624519093672, 0.2782455055915716, 0.24440089817652688, 0.36606552679755133, 0.3975857058399763, 0.38612966061702636, 0.3815634888787599, 0.42405365220858215, 0.46895326443630536, 0.25815069961499726, 0.18352941524795174, 0.1586674198041934, 0.15007475162632744, 0.17443186443507397, 0.1579069189535356, 0.17163642651538524, 0.1447290788302067, 0.18464557570951068, 0.15457293007472905, 0.11625282323026453, 0.05058151934058819, 0.15932824423014225, 0.1678994026475379, 0.11285764235186302, 0.12505275021225193, 0.20760841090551052, 0.16971523677801326, 0.14952720281369292, 0.018765571515246826, 0.020300922002054023, 0.008736473185622873, 0.019101258527389975, 0.03969911677307625, 0.007259654704591223, 0.009540903190074501, 0.016816143428556418, 0.022371940275257796, 0.13346669866442318, 0.09767922073122992, 0.12444176404778118, 0.1213832755737212, 0.08567092550678512, 0.05860585288712683, 0.13730574852407573, 0.11733778711147624, 0.13284855860352984, 0.014580375702774262, 0.008213534155213198, 0.0031333801865459643, 0.008316822550321512, 0.0017810340694397464, 0.0038628816415666734, 0.010939315424131402, 0.0012920304954880946, 0.004094614601063085, 0.09292771909763253, 0.08886029664371986, 0.09073929036075656, 0.12596209426383376, 0.11014504188552787, 0.10231066152012702, 0.0827381845905234, 0.11349442589670433, 0.10406209929166665, 0.46080580523167247, 0.46739774827609604, 0.4740034557849462, 0.4413767499469917, 0.47432267193713473, 0.2774623368379293, 0.4718236014534952, 0.46729264984783536, 0.4662650875194593, 0.08358571778482604, 0.0875391846747069, 0.09058100702315153, 0.10157109206155002, 0.08046666595008956, 0.07592505820470319, 0.0860094490544161, 0.08076305580534404, 0.08844222701598814, 0.13257335118468494, 0.12474367243979212, 0.17903592087377274, 0.18846218465504028, 0.14143733515803092, 0.18519662843923412, 0.15648355183192286, 0.15109606509442586, 0.12410130043465994, 0.2690602986092633, 0.25054650161899494, 0.24559337553820937, 0.2619439044011509, 0.27978585711545845, 0.27054000449888194, 0.2867306951020462, 0.3345638943622512, 0.29604672913350305, 0.17801010931225514, 0.21100533246084519, 0.18483466517438119, 0.17621229808988081, 0.16431357134884816, 0.1774043502324537, 0.19881294661436055, 0.2082510792311716, 0.18795065905014108, 0.19411502150738125, 0.1702547929085858, 0.23011267158152648, 0.19494863867404055, 0.2007949136621865, 0.19482196248282124, 0.18886885436886436, 0.18873398758287752, 0.1819588561400758, 0.18032088791538992, 0.1917379739658177, 0.1810811774984945, 0.1950885226986987, 0.19504878292281447, 0.1912906949118668, 0.20906551894337133, 0.20268720256819195, 0.21153428872925628, 0.1587829334099521, 0.16900635735169312, 0.39805337617351044, 0.21856397059865462, 0.3314293210921019, 0.17924400443845478, 0.367337512164557, 0.15703908180873227, 0.17850478877148634, 0.3235412313917828, 0.23306292254572636, 0.18747309637064713, 0.24943720751673837, 0.2474494292087276, 0.1996906751172386, 0.18365495223888884, 0.3395529878054827, 0.19186724848129377, 0.19183620390930456, 0.19676295970958668, 0.1813743457874557, 0.1669083079592829, 0.18692307403056996, 0.18630771239070343, 0.19569249674931122, 0.18520790790304387, 0.18395901076399934, 0.07478124618301574, 0.06713952311363247, 0.07567990048916107, 0.06870927409781458, 0.07120466439147188, 0.07448870417603559, 0.08553928316758463, 0.07364070357242125, 0.07031344672523099]}, "mutation_prompt": null}
{"id": "1997f790-39ed-4f75-9990-56a8fc8451e6", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A dual-population hybrid algorithm combining Differential Evolution and Simulated Annealing to explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9b3cb5b7-415b-48e3-9804-b7f3914710b1", "metadata": {"aucs": [0.6724509386627546, 0.6995998243379044, 0.700003837396423, 0.6993613640042287, 0.7309607279926169, 0.7263458975935668, 0.7222776745889468, 0.7313795672869614, 0.6988784377716011, 0.4944418566945473, 0.5488698269332295, 0.48645961609458277, 0.5201278297045177, 0.46957661043259935, 0.5077962598499994, 0.4724859175334284, 0.4389721332664248, 0.48841383436020036, 0.1293071886114987, 0.14537052640686, 0.14803219787144029, 0.12769250828516943, 0.14785918431383305, 0.13691211705424777, 0.1153135694395705, 0.1696104712526374, 0.13048745195191436, 0.14733439015771943, 0.1397371230382951, 0.11940537969105847, 0.12804728364635798, 0.11714697886424275, 0.1613424602203104, 0.10466137095368633, 0.153957189274052, 0.11352487622481544, 0.9614260326034232, 0.9522535561570864, 0.9551105572495668, 0.9333450075625147, 0.9276875593035596, 0.9666934642928338, 0.9590923304338275, 0.917137843138132, 0.9626388799787172, 0.28780469469713776, 0.30211522650227596, 0.29005442516163027, 0.2729956204914863, 0.28771055334084183, 0.28116584895522256, 0.2935205806384933, 0.1541853253643436, 0.2897624519093672, 0.2782455055915716, 0.24440089817652688, 0.36606552679755133, 0.3975857058399763, 0.38612966061702636, 0.3815634888787599, 0.42405365220858215, 0.46895326443630536, 0.25815069961499726, 0.18352941524795174, 0.1586674198041934, 0.15007475162632744, 0.17443186443507397, 0.1579069189535356, 0.17163642651538524, 0.1447290788302067, 0.18464557570951068, 0.15457293007472905, 0.11625282323026453, 0.05058151934058819, 0.15932824423014225, 0.1678994026475379, 0.11285764235186302, 0.12505275021225193, 0.20760841090551052, 0.16971523677801326, 0.14952720281369292, 0.018765571515246826, 0.020300922002054023, 0.008736473185622873, 0.019101258527389975, 0.03969911677307625, 0.007259654704591223, 0.009540903190074501, 0.016816143428556418, 0.022371940275257796, 0.13346669866442318, 0.09767922073122992, 0.12444176404778118, 0.1213832755737212, 0.08567092550678512, 0.05860585288712683, 0.13730574852407573, 0.11733778711147624, 0.13284855860352984, 0.014580375702774262, 0.008213534155213198, 0.0031333801865459643, 0.008316822550321512, 0.0017810340694397464, 0.0038628816415666734, 0.010939315424131402, 0.0012920304954880946, 0.004094614601063085, 0.09292771909763253, 0.08886029664371986, 0.09073929036075656, 0.12596209426383376, 0.11014504188552787, 0.10231066152012702, 0.0827381845905234, 0.11349442589670433, 0.10406209929166665, 0.46080580523167247, 0.46739774827609604, 0.4740034557849462, 0.4413767499469917, 0.47432267193713473, 0.2774623368379293, 0.4718236014534952, 0.46729264984783536, 0.4662650875194593, 0.08358571778482604, 0.0875391846747069, 0.09058100702315153, 0.10157109206155002, 0.08046666595008956, 0.07592505820470319, 0.0860094490544161, 0.08076305580534404, 0.08844222701598814, 0.13257335118468494, 0.12474367243979212, 0.17903592087377274, 0.18846218465504028, 0.14143733515803092, 0.18519662843923412, 0.15648355183192286, 0.15109606509442586, 0.12410130043465994, 0.2690602986092633, 0.25054650161899494, 0.24559337553820937, 0.2619439044011509, 0.27978585711545845, 0.27054000449888194, 0.2867306951020462, 0.3345638943622512, 0.29604672913350305, 0.17801010931225514, 0.21100533246084519, 0.18483466517438119, 0.17621229808988081, 0.16431357134884816, 0.1774043502324537, 0.19881294661436055, 0.2082510792311716, 0.18795065905014108, 0.19411502150738125, 0.1702547929085858, 0.23011267158152648, 0.19494863867404055, 0.2007949136621865, 0.19482196248282124, 0.18886885436886436, 0.18873398758287752, 0.1819588561400758, 0.18032088791538992, 0.1917379739658177, 0.1810811774984945, 0.1950885226986987, 0.19504878292281447, 0.1912906949118668, 0.20906551894337133, 0.20268720256819195, 0.21153428872925628, 0.1587829334099521, 0.16900635735169312, 0.39805337617351044, 0.21856397059865462, 0.3314293210921019, 0.17924400443845478, 0.367337512164557, 0.15703908180873227, 0.17850478877148634, 0.3235412313917828, 0.23306292254572636, 0.18747309637064713, 0.24943720751673837, 0.2474494292087276, 0.1996906751172386, 0.18365495223888884, 0.3395529878054827, 0.19186724848129377, 0.19183620390930456, 0.19676295970958668, 0.1813743457874557, 0.1669083079592829, 0.18692307403056996, 0.18630771239070343, 0.19569249674931122, 0.18520790790304387, 0.18395901076399934, 0.07478124618301574, 0.06713952311363247, 0.07567990048916107, 0.06870927409781458, 0.07120466439147188, 0.07448870417603559, 0.08553928316758463, 0.07364070357242125, 0.07031344672523099]}, "mutation_prompt": null}
{"id": "2b3072dc-99db-4fd2-886f-6c24b9e28c48", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A dual-population hybrid algorithm combining Differential Evolution and Simulated Annealing to explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9b3cb5b7-415b-48e3-9804-b7f3914710b1", "metadata": {"aucs": [0.6724509386627546, 0.6995998243379044, 0.700003837396423, 0.6993613640042287, 0.7309607279926169, 0.7263458975935668, 0.7222776745889468, 0.7313795672869614, 0.6988784377716011, 0.4944418566945473, 0.5488698269332295, 0.48645961609458277, 0.5201278297045177, 0.46957661043259935, 0.5077962598499994, 0.4724859175334284, 0.4389721332664248, 0.48841383436020036, 0.1293071886114987, 0.14537052640686, 0.14803219787144029, 0.12769250828516943, 0.14785918431383305, 0.13691211705424777, 0.1153135694395705, 0.1696104712526374, 0.13048745195191436, 0.14733439015771943, 0.1397371230382951, 0.11940537969105847, 0.12804728364635798, 0.11714697886424275, 0.1613424602203104, 0.10466137095368633, 0.153957189274052, 0.11352487622481544, 0.9614260326034232, 0.9522535561570864, 0.9551105572495668, 0.9333450075625147, 0.9276875593035596, 0.9666934642928338, 0.9590923304338275, 0.917137843138132, 0.9626388799787172, 0.28780469469713776, 0.30211522650227596, 0.29005442516163027, 0.2729956204914863, 0.28771055334084183, 0.28116584895522256, 0.2935205806384933, 0.1541853253643436, 0.2897624519093672, 0.2782455055915716, 0.24440089817652688, 0.36606552679755133, 0.3975857058399763, 0.38612966061702636, 0.3815634888787599, 0.42405365220858215, 0.46895326443630536, 0.25815069961499726, 0.18352941524795174, 0.1586674198041934, 0.15007475162632744, 0.17443186443507397, 0.1579069189535356, 0.17163642651538524, 0.1447290788302067, 0.18464557570951068, 0.15457293007472905, 0.11625282323026453, 0.05058151934058819, 0.15932824423014225, 0.1678994026475379, 0.11285764235186302, 0.12505275021225193, 0.20760841090551052, 0.16971523677801326, 0.14952720281369292, 0.018765571515246826, 0.020300922002054023, 0.008736473185622873, 0.019101258527389975, 0.03969911677307625, 0.007259654704591223, 0.009540903190074501, 0.016816143428556418, 0.022371940275257796, 0.13346669866442318, 0.09767922073122992, 0.12444176404778118, 0.1213832755737212, 0.08567092550678512, 0.05860585288712683, 0.13730574852407573, 0.11733778711147624, 0.13284855860352984, 0.014580375702774262, 0.008213534155213198, 0.0031333801865459643, 0.008316822550321512, 0.0017810340694397464, 0.0038628816415666734, 0.010939315424131402, 0.0012920304954880946, 0.004094614601063085, 0.09292771909763253, 0.08886029664371986, 0.09073929036075656, 0.12596209426383376, 0.11014504188552787, 0.10231066152012702, 0.0827381845905234, 0.11349442589670433, 0.10406209929166665, 0.46080580523167247, 0.46739774827609604, 0.4740034557849462, 0.4413767499469917, 0.47432267193713473, 0.2774623368379293, 0.4718236014534952, 0.46729264984783536, 0.4662650875194593, 0.08358571778482604, 0.0875391846747069, 0.09058100702315153, 0.10157109206155002, 0.08046666595008956, 0.07592505820470319, 0.0860094490544161, 0.08076305580534404, 0.08844222701598814, 0.13257335118468494, 0.12474367243979212, 0.17903592087377274, 0.18846218465504028, 0.14143733515803092, 0.18519662843923412, 0.15648355183192286, 0.15109606509442586, 0.12410130043465994, 0.2690602986092633, 0.25054650161899494, 0.24559337553820937, 0.2619439044011509, 0.27978585711545845, 0.27054000449888194, 0.2867306951020462, 0.3345638943622512, 0.29604672913350305, 0.17801010931225514, 0.21100533246084519, 0.18483466517438119, 0.17621229808988081, 0.16431357134884816, 0.1774043502324537, 0.19881294661436055, 0.2082510792311716, 0.18795065905014108, 0.19411502150738125, 0.1702547929085858, 0.23011267158152648, 0.19494863867404055, 0.2007949136621865, 0.19482196248282124, 0.18886885436886436, 0.18873398758287752, 0.1819588561400758, 0.18032088791538992, 0.1917379739658177, 0.1810811774984945, 0.1950885226986987, 0.19504878292281447, 0.1912906949118668, 0.20906551894337133, 0.20268720256819195, 0.21153428872925628, 0.1587829334099521, 0.16900635735169312, 0.39805337617351044, 0.21856397059865462, 0.3314293210921019, 0.17924400443845478, 0.367337512164557, 0.15703908180873227, 0.17850478877148634, 0.3235412313917828, 0.23306292254572636, 0.18747309637064713, 0.24943720751673837, 0.2474494292087276, 0.1996906751172386, 0.18365495223888884, 0.3395529878054827, 0.19186724848129377, 0.19183620390930456, 0.19676295970958668, 0.1813743457874557, 0.1669083079592829, 0.18692307403056996, 0.18630771239070343, 0.19569249674931122, 0.18520790790304387, 0.18395901076399934, 0.07478124618301574, 0.06713952311363247, 0.07567990048916107, 0.06870927409781458, 0.07120466439147188, 0.07448870417603559, 0.08553928316758463, 0.07364070357242125, 0.07031344672523099]}, "mutation_prompt": null}
{"id": "a3f96b53-99bb-4780-94e9-571e53181a4e", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.initial_F = 0.8  # Initial Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.97  # Slightly faster cooling\n        self.adaptive_factor = 0.05\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        diversity = np.std(population, axis=0).mean()\n        F = self.initial_F * (1 + self.adaptive_factor * diversity)  # Adaptive F\n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced the dual-population strategy by increasing exploration capabilities and adaptive control of the differential weight and temperature, adjusting them based on population diversity.", "configspace": "", "generation": 3, "fitness": 0.23988567882916528, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "9b3cb5b7-415b-48e3-9804-b7f3914710b1", "metadata": {"aucs": [0.6875466834333738, 0.7059082263568015, 0.7006579412954846, 0.6928201600705572, 0.7064224090242146, 0.7060555976307594, 0.6940686204471945, 0.671924448142297, 0.6821545579885482, 0.5357643878174906, 0.4687107354325942, 0.4059617315040659, 0.4779225642668591, 0.43943433307586754, 0.46855959230753985, 0.5072999022148872, 0.47354278339428757, 0.5297254462887029, 0.11331805865292477, 0.15644474019670818, 0.11842752823977298, 0.18807778954298549, 0.11980226444024267, 0.1371871306900606, 0.11988861582515331, 0.12090084451883143, 0.15515452219520154, 0.12520304209532607, 0.10807181304266322, 0.11288079590705657, 0.1420999125798902, 0.12228299294852263, 0.10614584792625481, 0.1167940983609198, 0.13363269517981602, 0.12280010103486405, 0.9755865776053712, 0.9503464154305217, 0.9650330421264035, 0.9615433147852369, 0.9613860542209223, 0.9399606887684784, 0.9607173190839422, 0.954840303417525, 0.9633876591873345, 0.2771524733499299, 0.2745174675705232, 0.26307290178275056, 0.3227938089460751, 0.2629660222946423, 0.32107835319609235, 0.15087157359875292, 0.27059181750336825, 0.3193901758243989, 0.2584942781285501, 0.2246663765651482, 0.35198444542029017, 0.2433529439695219, 0.2866179250428994, 0.3103555228910828, 0.3174991908756558, 0.27324943421828907, 0.36136596306134927, 0.15227512771871243, 0.15162073664127163, 0.13378927058149015, 0.17115693216225158, 0.18310276527113167, 0.15830050238098703, 0.17042931432582153, 0.1775356358753425, 0.16303093565345095, 0.16135050733024403, 0.20281945366738008, 0.14252733275598517, 0.1537693372319633, 0.16838744698090757, 0.15908171598515708, 0.14199195206782844, 0.15571380810446112, 0.10563932330236725, 0.005432539406007186, 0.012258901689416235, 0.0013264983130651942, 0.015491990850219683, 0.026215347957355695, 0.006416207064231294, 0.0017738445505796063, 0.014172904203379244, 0.0006660754707263905, 0.14662472345480604, 0.0682156212920465, 0.11244723569468984, 0.06977377260937101, 0.06537256993015561, 0.07431380350722516, 0.15346134267217382, 0.12471937093233387, 0.14184597566823398, 0.014775635563796796, 9.999999999998899e-05, 9.999999999998899e-05, 0.005157128573435643, 9.999999999998899e-05, 9.999999999998899e-05, 0.003996044108216301, 0.010367072966914415, 0.015084714317393777, 0.12313562965084968, 0.08270424244020891, 0.10327901133477901, 0.11215626394959222, 0.12745122818549914, 0.11114638154043766, 0.09898434222506858, 0.10619898003780814, 0.1295153005350851, 0.4607405932337917, 0.4219701526162968, 0.4579036382325612, 0.49414660864608073, 0.4392724155384171, 0.456580399071118, 0.44281918561136846, 0.45164073889336465, 0.43827562982009827, 0.08959508003939953, 0.08120255054567282, 0.08640666215564308, 0.11035719081589146, 0.08581226385599017, 0.09209704763938842, 0.10457504954012531, 0.08395253335862285, 0.08235744038886583, 0.1545876675122776, 0.15229377975435132, 0.21271635565220626, 0.13414231036210944, 0.13794039311936956, 0.14086181330045056, 0.1508766164527593, 0.15387592226266333, 0.1365305197615576, 0.2630559514893074, 0.2736364401615008, 0.27362928131285824, 0.2677807295966014, 0.2586287693571594, 0.24027568477676808, 0.28088064621894404, 0.2864334341451049, 0.26257821776600676, 0.1917479066483565, 0.202763693536806, 0.1933945561466872, 0.18995566423805343, 0.16020357283873743, 0.15318248409290358, 0.25015962263601155, 0.2306588128012922, 0.18823010585394373, 0.18003226525314353, 0.187048401242087, 0.17877048946607177, 0.1913695376642921, 0.20410699888532058, 0.20539807304638646, 0.1866867710686878, 0.168233115810956, 0.18622958789067812, 0.18132797035865666, 0.1893658818007511, 0.18826879449345502, 0.2107801303654092, 0.189974919498323, 0.19087763815909298, 0.19059761322907198, 0.19236680888824453, 0.19851223106242188, 0.22961523899770697, 0.16589450146802376, 0.18710485139215882, 0.1789454547992274, 0.16271573827741648, 0.182775823565147, 0.1628481142018725, 0.1761162477392758, 0.2747625256421464, 0.32354183212412213, 0.15621229224260025, 0.2703744230833721, 0.17654024115192146, 0.19928623930319767, 0.28466743535583905, 0.205234713984071, 0.16260085187730688, 0.5379629255958479, 0.18777830088489122, 0.1844940068887494, 0.19897706423251915, 0.177701707473514, 0.18685963424569596, 0.20509727531647315, 0.19149261732224254, 0.17808882176002494, 0.17333387211636797, 0.0776362391316936, 0.0774311519055616, 0.08160330113640957, 0.07029721928303201, 0.07550217683003102, 0.07716197132561686, 0.11645612595533639, 0.07656735019040661, 0.06713721865371858]}, "mutation_prompt": null}
{"id": "9d63085c-820b-4885-9d91-40788139bad2", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 4, "fitness": 0.2562372093215908, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "9b3cb5b7-415b-48e3-9804-b7f3914710b1", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "3ca6eeea-5b26-4c1e-b58d-1f2b5c6d8a4b", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "0391ba19-5ebe-410b-8930-7c548c9794e4", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "1feb4c1c-4cd4-4d7a-90fa-11d9cd1ff561", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "5ed78cac-fe0e-412a-87eb-0dac581635f0", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.initial_temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.98  # Adjusted cooling rate for faster convergence\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            mutation_scale = self.F * (1 + diversity_factor)  # Adapt mutation scale\n            x_t = population[a] + mutation_scale * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        temperature = self.initial_temperature\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced Dual-Population Optimizer with Adaptive Mutation Scaling and Dynamic Cooling to Accelerate Convergence.", "configspace": "", "generation": 8, "fitness": 0.20605120466504714, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.726663815288572, 0.7070413259080637, 0.7174718273525713, 0.7124189878026643, 0.6981643801133054, 0.7279140897330594, 0.6997399689909852, 0.7046340848546402, 0.7164558694289951, 0.0061561420239854, 0.0006168394097496588, 0.024815359439321227, 9.999999999998899e-05, 0.03222159818361814, 0.036964023027641124, 0.004780809934537555, 0.008947960350693895, 0.03238040459525615, 0.12629959462223905, 0.14718879915398775, 0.17731326002740988, 0.15132457825469758, 0.1244047695910272, 0.14098361391042058, 0.13580094943248167, 0.11081019319993868, 0.11035596778310497, 0.13109675548791033, 0.10339470242644966, 0.11928416016430365, 0.10389812396653453, 0.11577778425521779, 0.1254882677798912, 0.11344065570818385, 0.12626264914310448, 0.10171083888432386, 0.9701473268281126, 0.9712573496482982, 0.9503128663665893, 0.9514570322390384, 0.9512449644185161, 0.9668985358826447, 0.9423506349149416, 0.9463308608481374, 0.9823886282635527, 0.26762377726841446, 0.12649941784928176, 0.20871620501246468, 0.2260718140472252, 0.16404446654829485, 0.27647155527973555, 0.09323443958165356, 0.28183445954288, 0.10334318436635548, 0.41345587290126173, 0.22505548758589777, 0.32393281017459197, 0.3983511309890587, 0.2880710862730145, 0.5199846279044085, 0.42460651191074805, 0.2911523224959284, 0.23681340349877134, 0.10949919358088622, 0.1000304495191836, 0.0950494934169075, 0.07066239705088462, 0.06840508836560089, 0.07146107191757167, 0.0950025057077486, 0.11567044691491979, 0.09265426647408859, 0.0625279391224649, 0.05010302821006973, 0.0583558443738007, 0.11886420055539126, 0.08940644357083694, 0.08898101799345037, 0.13090569327861012, 0.10039613613334786, 0.09648672288582216, 0.013871056730968445, 0.019690035584391086, 0.011911491016343145, 0.00781960705798479, 0.01409272807314177, 9.999999999998899e-05, 0.026414628986543565, 9.999999999998899e-05, 0.016156738520927916, 0.10362166119820215, 0.0740149940767405, 0.06359630690796692, 0.024832234787477536, 0.056585919756939385, 0.03787926858545121, 0.04603007519513591, 0.15157769932497178, 0.0583703298672561, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08574311846983296, 0.10322722911793192, 0.09067138820512888, 0.04426820949239885, 0.030915129781149187, 0.050076762395607655, 9.999999999998899e-05, 9.999999999998899e-05, 0.035887865353087745, 0.4574647377067578, 0.4377825044868998, 0.43060367552302137, 0.44210408596104533, 0.47076641621436865, 0.4601680485649037, 0.4637078409834332, 0.45328866588837113, 0.4576032193660682, 0.09787284127951656, 0.07712500263929811, 0.08047729302287532, 0.08124270325141603, 0.07163089117942623, 0.0825797153149429, 0.058706150262526124, 0.04609622159453863, 0.06801221432079185, 0.1454329078430927, 0.13376106841461932, 0.12933049408957342, 0.14056419795148212, 0.12389002303701324, 0.13480786832203007, 0.15201015904508808, 0.14674512996739886, 0.14132190085615115, 0.25918137228819027, 0.2781097376303976, 0.26013167401332427, 0.24183181683517685, 0.23280317607736012, 0.2509045795809518, 0.28289765397385136, 0.3250506997753455, 0.29137523790971853, 0.11427893606341344, 0.11481684050622731, 0.10886360841704534, 0.173113081946752, 0.15263697179351787, 0.15076200409931462, 0.21369118260760656, 0.21060078498166324, 0.20641209227604118, 0.17890066183464204, 0.17583033182277663, 0.21121720130761978, 0.20152820573427543, 0.17253509444205262, 0.1730944800759706, 0.20328702019167189, 0.18843872711155796, 0.19492210383575714, 0.16811409443357883, 0.1877448240819538, 0.1706985167726187, 0.1765646851720729, 0.20126393068272452, 0.1765218256345239, 0.17615169624536686, 0.1733807774066719, 0.1727947332572367, 0.1684180209068059, 0.1667101404109591, 0.17620526239380885, 0.1803854406565497, 0.2771956971136216, 0.17391298597597016, 0.1766961750967696, 0.28523882081410534, 0.18244430976347836, 0.1576652127889252, 0.20271413698603924, 0.2707946896151895, 0.3163874202296828, 0.2847741888317904, 0.18610714552565455, 0.20692411856971948, 0.3305154723243663, 0.20618555708759068, 0.1821361870549264, 0.19706108936420286, 0.18391278961328394, 0.1831381308214609, 0.17217326080898687, 0.19581386493673736, 0.2057586863808184, 0.18211896832575813, 0.19546865288262516, 0.06765516679235084, 0.06737494103466402, 0.06908031218906363, 0.06876159616690236, 0.07406616669865251, 0.06594887939925942, 0.056339472270553026, 0.06109866926256147, 0.06734190022486475]}, "mutation_prompt": null}
{"id": "d377f8d9-5f1d-4af4-b4f6-d1be9d100fbc", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "c58055fd-fb4a-4d6c-bc12-a4be3b696003", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "ecc5a89a-b0cd-47a4-b3b8-96e1b866f889", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "0e68d720-5020-4d55-8e4c-56635aca9002", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "572af66a-ebe4-43ef-a3d7-033a6f80a887", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "6e574ac9-f6eb-4b4a-9839-43815e0b6090", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "70e916cc-ca10-4340-94ca-745f237d7eda", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "6c6e4f9d-108f-4ee0-bb3c-873a02f5c4dd", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "cb16c908-ec4a-446f-95cb-c26bda9fa2dd", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "8097548a-82b0-41d3-9970-745c98f4479f", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "A refined dual-population optimizer with enhanced exploration using dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.6791804358414191, 0.6895298840813746, 0.685457927698373, 0.7386019355606082, 0.7436595869123825, 0.7257351167578046, 0.7257161705689883, 0.7128367274889638, 0.7107882738180004, 0.5519641684904562, 0.502106911408946, 0.49688286996754283, 0.4512976440717352, 0.47280523557322507, 0.4992669521538422, 0.5038198562480259, 0.5166864216170806, 0.5259931357846125, 0.16283655211847436, 0.13497403303871758, 0.19366296244833048, 0.2099085309434574, 0.1301689094986821, 0.13674007481685135, 0.1433331016041126, 0.13732943897820582, 0.11167107544370158, 0.10363476033005425, 0.11537711094828718, 0.1289730701549905, 0.1186096514489664, 0.1443209218004482, 0.11153511913558922, 0.10363806151096056, 0.19461098979223612, 0.1301279049256644, 0.9498432344605542, 0.9743760334792799, 0.9217360958100401, 0.9284132892811181, 0.9395477663217168, 0.9666934642928338, 0.95468019516151, 0.9480190151288329, 0.969306957242532, 0.2847883670061463, 0.14833491022711243, 0.3242970427409224, 0.29681831320690666, 0.3088344295860028, 0.3144525233563171, 0.1862452823935813, 0.2770456389355337, 0.2962293297983052, 0.2574535029677266, 0.4163064376158965, 0.4373823044801679, 0.38093549060509013, 0.3453743767423483, 0.3369146826542895, 0.4073425083330098, 0.5030481090093929, 0.5701978570412249, 0.16267695781481994, 0.17087284025257632, 0.1424466193136542, 0.1244809227545125, 0.16171859862438376, 0.17115916905823036, 0.17294937616009953, 0.1808836762485151, 0.1841352220325232, 0.1295380633091825, 0.10589076248403761, 0.19664624129536645, 0.14324907009516152, 0.2404760253385526, 0.1483046317807557, 0.15838706101794908, 0.15774861659897255, 0.14175931734405045, 0.05831806371918624, 0.08136437242467709, 9.999999999998899e-05, 0.023427064763217653, 0.06061840051167311, 0.09035148219530453, 0.02890785355437142, 0.02781239051802209, 0.010586953609937, 0.19832170704715024, 0.2167473915889746, 0.16668001261571985, 0.11957681348958593, 0.08321092331967361, 0.12530807676576283, 0.20198128563710038, 0.22356110591194045, 0.25107612394064904, 0.05904160089331345, 0.014973847340639224, 0.013488281950075898, 0.013292901050737105, 0.01384600097493549, 0.013378815990404469, 0.08941487732559328, 0.049611278478929544, 0.040648366810419945, 0.12380767038703744, 0.08481392163233636, 0.13071474081001866, 0.1414202132697555, 0.1333975499039769, 0.09844929023809923, 0.09742957582636869, 0.11944127536504656, 0.10762458919097573, 0.4554052490740008, 0.4502816921739554, 0.4600594556881439, 0.4666153676823963, 0.4392986828408473, 0.4402336194133173, 0.4465236510991941, 0.43675321561409053, 0.45801450578835345, 0.07648846570465506, 0.09457235306298006, 0.0823134721799117, 0.08897659281865311, 0.07942951227115047, 0.07830499474749886, 0.10737958921925672, 0.09460716617320086, 0.08781612926968552, 0.1475113419928975, 0.1339458612699489, 0.1807713074993209, 0.18846218465504028, 0.12680299965856934, 0.1686835531095947, 0.14882196785847612, 0.16148243000534734, 0.13793339001342064, 0.25219008695620126, 0.2556714119656084, 0.27279538448036, 0.26272109628692164, 0.30591917492366183, 0.27219449030108656, 0.29069604983991804, 0.32052356380158054, 0.2869159180549016, 0.15735651356596259, 0.17900754278137787, 0.2014486293504486, 0.17469890338189875, 0.19709602056015596, 0.18439964166837552, 0.1808859047761031, 0.22067618710564152, 0.18319812522596746, 0.1843916913773994, 0.17617350901280082, 0.23034120237439748, 0.19300266490897933, 0.2002244045580932, 0.21382596630668516, 0.18250268054910423, 0.18912668909473518, 0.17377752646301092, 0.20556434458875417, 0.18403900101691884, 0.18415242845129698, 0.18706703103831168, 0.19422807208772208, 0.20452706710025592, 0.1868952766662324, 0.19782740935609822, 0.19623683835753625, 0.17304227906508352, 0.16818571985572983, 0.1874612655365565, 0.18129247726315867, 0.6576784019712301, 0.6942165958963296, 0.14098525354899627, 0.3585305645768718, 0.2815062167145179, 0.1590287255432573, 0.23306292254572636, 0.17997612568344934, 0.18417163103915912, 0.19871694959943864, 0.20033117231507935, 0.20459207775146349, 0.2974531920967338, 0.2983865642657726, 0.18553923690959395, 0.2021025354174859, 0.18101233915459403, 0.19504368230489222, 0.18290839780782275, 0.18155448230460614, 0.17565066114831607, 0.17657605586905234, 0.18471864078828804, 0.06928058901990719, 0.07110596583251338, 0.08604542756719147, 0.07960737495830195, 0.07201651190226543, 0.07539279845625735, 0.0793517327467207, 0.07143365502227084, 0.06502512033209873]}, "mutation_prompt": null}
{"id": "20c98dec-37e4-4117-a28e-77439a16faae", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale adjustment based on individual success rates.", "configspace": "", "generation": 19, "fitness": 0.261732538322394, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "9d63085c-820b-4885-9d91-40788139bad2", "metadata": {"aucs": [0.7028771065953692, 0.6899950942742932, 0.6997938063946645, 0.7102177792857662, 0.7094763291282796, 0.7437274540120717, 0.7123979732030135, 0.7166959394688843, 0.6830978891232453, 0.464017627589135, 0.5151588108668763, 0.4908692342046289, 0.5294487296641229, 0.48451520685611527, 0.446647564060225, 0.5145614759865653, 0.4930857715644916, 0.49687679166789134, 0.11800889724492114, 0.1645296768998703, 0.10470754224888024, 0.13272297631588448, 0.17634182427585254, 0.14899577944685916, 0.17616276225372918, 0.10853581339348917, 0.1494379752174465, 0.130398607112728, 0.11931625425592507, 0.1056465915549184, 0.10633491064336376, 0.10579704066211326, 0.11637211186082241, 0.10518900808291232, 0.1078580673211521, 0.13315761488731426, 0.9498432344605542, 0.9369351584690553, 0.9442250915832563, 0.9689768200065486, 0.9413886274117735, 0.9596868208589906, 0.9477398059157249, 0.9620761414746546, 0.969301807246949, 0.324879067675937, 0.2841334144236414, 0.32258432090240563, 0.35777477546946235, 0.3349153926606888, 0.3343011276569632, 0.3697568354930594, 0.34345836223379944, 0.3471590669494451, 0.812866994947523, 0.24728807972974665, 0.25633109931413645, 0.5237187791254256, 0.4589160661378887, 0.4800686762756784, 0.5172182956695894, 0.3455772027731311, 0.3934571605319833, 0.18678724354701826, 0.21125798251791006, 0.21718256750512888, 0.14760670693944644, 0.18881232481736954, 0.1715648814173919, 0.17090516191608063, 0.20380017706243847, 0.17142543771658114, 0.19058635088876086, 0.15753401468877914, 0.19106283716016204, 0.2160006413962301, 0.1908364061747868, 0.1670241684419883, 0.19342612588369545, 0.15750210148096233, 0.1377085211362783, 0.06524741311894955, 0.12210926500820984, 0.07635642165824863, 0.056182315316629095, 0.1011810304504408, 0.12608286146197312, 0.005567876495716884, 0.00043904982236886436, 0.04101612982022507, 0.20175551962565597, 0.1523630875445322, 0.2120585630383499, 0.1309483838405251, 0.10859863420137994, 0.11808531693377977, 0.29630642659865014, 0.21896154462702722, 0.2064639628380167, 0.02589140885698349, 0.010191625004765559, 0.03309249409727344, 0.04220277947727025, 0.015630689932046526, 0.03848079895756418, 0.04331070485748678, 0.05264411825913051, 0.036106619150957364, 0.119253271900985, 0.1316583320954785, 0.13887310866417013, 0.11165130484137553, 0.12307981693431447, 0.132660185880204, 0.10005094785539914, 0.11314189680077902, 0.1267381493355073, 0.4784833715066821, 0.46920938853944183, 0.46170727058128325, 0.4669854413008566, 0.46268337839978235, 0.45273818586487835, 0.46365805683669703, 0.4705795235536221, 0.4478410807916342, 0.0920103049541493, 0.11057518189830695, 0.07649726127363154, 0.07983349423597574, 0.10083236652315464, 0.08673380870980618, 0.09241785959748705, 0.08826585512366492, 0.09150150407293478, 0.13213012907543198, 0.13652850630110025, 0.15062517301693168, 0.1436461066967104, 0.1748048243667325, 0.1345547172066941, 0.14498729396163257, 0.14064732728396467, 0.22054125783025202, 0.2504254464062946, 0.27503607993041734, 0.2470695640184848, 0.2585986434374158, 0.29533840653937604, 0.24451782665770916, 0.3100518430381456, 0.3202794878368752, 0.30872188672718526, 0.1981442331232165, 0.1696639292387605, 0.20157910847004978, 0.1821370438449863, 0.17755212052197766, 0.1821116273523521, 0.1765196300527817, 0.241872567993203, 0.19754193322338598, 0.16539354587472388, 0.17382293971638285, 0.17646527128023204, 0.1789748603179825, 0.1734571292296785, 0.18978732035350598, 0.19712665718543443, 0.1747396509999226, 0.1840030645588554, 0.20225049164968334, 0.1836685139424319, 0.19112042972259535, 0.1850778594465271, 0.20585105342254995, 0.17961225342076037, 0.18885186142017096, 0.19890874383358548, 0.21110547827677673, 0.15351899868754548, 0.17226726372347545, 0.14840034598684848, 0.17296473907976995, 0.1742016144404268, 0.6178550980177964, 0.15185124218107704, 0.17006719365016454, 0.20769721347803116, 0.44514594789145234, 0.5073771166887994, 0.33639275444539984, 0.1987134288189546, 0.33529852042641495, 0.1509148573906266, 0.19496586210415656, 0.20339384592077758, 0.2631179336413274, 0.18616619769091347, 0.18582227760699999, 0.19950168484634645, 0.18741895807482745, 0.17236525369693978, 0.20385094699742856, 0.18656217696667377, 0.18386457592850003, 0.1895241424607621, 0.06110145226757524, 0.06378257845433599, 0.06323502859643992, 0.0680007021912925, 0.07310564591549196, 0.07744074398960399, 0.06995575436663715, 0.06711168029491399, 0.06991935913531055]}, "mutation_prompt": null}
{"id": "d3f0d0e6-4776-4d92-b918-b6a1add0cd24", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def adjust_population_size(self, scores):\n        diversity = np.std(scores) / np.mean(scores)\n        if diversity < 0.1:\n            self.population_size = min(self.population_size + 2, self.initial_population_size * 2)\n        else:\n            self.population_size = self.initial_population_size\n\n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.initial_population_size\n        \n        while evals < self.budget:\n            self.adjust_population_size(scores)\n            if population.shape[0] != self.population_size:\n                population = np.resize(population, (self.population_size, self.dim))\n                scores = np.resize(scores, self.population_size)\n            \n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced Adaptive DualPopulationOptimizer with dynamic population size adjustment to improve convergence speed.", "configspace": "", "generation": 20, "fitness": 0.22548211074963673, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.5159044177991984, 0.4860612076114127, 0.5106336049556716, 0.5187232291839847, 0.5006299718726325, 0.5265643574931563, 0.5240396974419028, 0.5049962127303098, 0.48164738389674, 0.2691967228939043, 0.34010505869800134, 0.2990101109180403, 0.30847966732437326, 0.29732900970391196, 0.3056256424235875, 0.34718452180981607, 0.29562809013066016, 0.303194303679415, 0.09236496505117953, 0.11250827332155389, 0.10027980337033127, 0.1553888622304448, 0.11130811993121026, 0.11761931266481374, 0.123790148757148, 0.10279753310262219, 0.12032095102363749, 0.09569264137164735, 0.08421660146115151, 0.08859566592172563, 0.10887694290019723, 0.11785038685549354, 0.11060128073617015, 0.11921394452554634, 0.09793120898547858, 0.10067298857851414, 0.9436161718918252, 0.933667885858689, 0.9419647072415958, 0.9229651071647756, 0.9520906460751433, 0.9452523520836825, 0.9427585748097488, 0.9627027190678961, 0.969301807246949, 0.3024324965144265, 0.29412378154981156, 0.29310223431016114, 0.2979141780027392, 0.3082496352326858, 0.27983557465233055, 0.33438917056721185, 0.3030695904340204, 0.34092717193582, 0.261752901509434, 0.2286270626053747, 0.22473457476226943, 0.26687504838013776, 0.25903771067633097, 0.2605493941196597, 0.3864915261975911, 0.29789989064517586, 0.42764101785552744, 0.20940212163571503, 0.20627987783534196, 0.21309391771859787, 0.15284844246302964, 0.18244614390286418, 0.20158315631507107, 0.16346864755788193, 0.19167250925788581, 0.15540298080630688, 0.2132021741152238, 0.1404114504549696, 0.18057005075115884, 0.1793393091819342, 0.18632190157009743, 0.15262713843776, 0.1834602028179112, 0.1652909097997699, 0.13803407043931715, 0.07353264877577326, 0.11595810920977945, 0.07635642165824863, 0.05815485359191952, 0.10144715209924382, 0.10498857775980719, 0.0011978090510952333, 9.999999999998899e-05, 0.05783030104632203, 0.19711707678184598, 0.15430534944420526, 0.22026018871389474, 0.14251598462807946, 0.12824592519950506, 0.11808531693377977, 0.310568821185772, 0.21600021916219314, 0.2235174346020995, 0.023149955458617533, 0.01383171949860973, 0.031300671623528564, 0.028873739660673303, 0.0044152992078144715, 0.030880126787987683, 0.04331070485748678, 0.052815506289777714, 0.03613750911778846, 0.11246422581539917, 0.12820794563280924, 0.12098736628743789, 0.09895783664897773, 0.10589683250468152, 0.09094627913699938, 0.08766923401797189, 0.09803051353187364, 0.09467061734480231, 0.41533151175214866, 0.4069399686481, 0.40854491599472953, 0.399067713746864, 0.3986960101684113, 0.4143227322377765, 0.3993524149390164, 0.4112688193514148, 0.4030359919102988, 0.06877192060761661, 0.08862447560618092, 0.07252246944580043, 0.08874421746439654, 0.07703641974572006, 0.10326816592647425, 0.08335090545090129, 0.10006393704018957, 0.09231168063381678, 0.1346161522777889, 0.12795414223913582, 0.14249024508360597, 0.13796474102024092, 0.17450103848418907, 0.28624707459375964, 0.2758705786713965, 0.23505661146220613, 0.13244644692290009, 0.21586079167756977, 0.2068597262775307, 0.19156286894329688, 0.2135124138121065, 0.2140310326937308, 0.20963702730495504, 0.21355751621965635, 0.23524942198933596, 0.22025499396109083, 0.1936709636090269, 0.16784298470423564, 0.16423611959113693, 0.15045175431796265, 0.15405335460277625, 0.17528652414474932, 0.15512656818960535, 0.17383272335474687, 0.15612801278444188, 0.18085431100959382, 0.18222564914238215, 0.18194384659935836, 0.20563789138398336, 0.16888717528038144, 0.1823736028781907, 0.17089651920520033, 0.20157208004793548, 0.1814414513170648, 0.1803441655815362, 0.18665971832380457, 0.19158550098444704, 0.19091169225159577, 0.1878414610112069, 0.19535550216411335, 0.1853368306267934, 0.17964580089410498, 0.2078638035118694, 0.1512103523657321, 0.16983446630508603, 0.14854587295337973, 0.1729621797769556, 0.1741803961053745, 0.5041329461711691, 0.17063127363535602, 0.17343538084852295, 0.15589470585424747, 0.14963929272075238, 0.21749118367045828, 0.1765073199619197, 0.20062518877934765, 0.17220094854696744, 0.23562323148623132, 0.2749525018208684, 0.1867698447472681, 0.23377196901316, 0.18586256037137616, 0.1870347829507245, 0.19950168484634645, 0.18741895807482745, 0.17236525369693978, 0.20385094699742856, 0.17648588912881946, 0.18133467699549888, 0.1735444290487037, 0.0664148659617334, 0.07138500709236628, 0.067133879291011, 0.06672551025600226, 0.06931062079746575, 0.07429885496180144, 0.06995575436663715, 0.06711168029491399, 0.06991935913531055]}, "mutation_prompt": null}
{"id": "bd7276cd-a6ee-45bc-805d-cc260be3b2f2", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale adjustment based on individual success rates.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.7028771065953692, 0.6899950942742932, 0.6997938063946645, 0.7102177792857662, 0.7094763291282796, 0.7437274540120717, 0.7123979732030135, 0.7166959394688843, 0.6830978891232453, 0.464017627589135, 0.5151588108668763, 0.4908692342046289, 0.5294487296641229, 0.48451520685611527, 0.446647564060225, 0.5145614759865653, 0.4930857715644916, 0.49687679166789134, 0.11800889724492114, 0.1645296768998703, 0.10470754224888024, 0.13272297631588448, 0.17634182427585254, 0.14899577944685916, 0.17616276225372918, 0.10853581339348917, 0.1494379752174465, 0.130398607112728, 0.11931625425592507, 0.1056465915549184, 0.10633491064336376, 0.10579704066211326, 0.11637211186082241, 0.10518900808291232, 0.1078580673211521, 0.13315761488731426, 0.9498432344605542, 0.9369351584690553, 0.9442250915832563, 0.9689768200065486, 0.9413886274117735, 0.9596868208589906, 0.9477398059157249, 0.9620761414746546, 0.969301807246949, 0.324879067675937, 0.2841334144236414, 0.32258432090240563, 0.35777477546946235, 0.3349153926606888, 0.3343011276569632, 0.3697568354930594, 0.34345836223379944, 0.3471590669494451, 0.812866994947523, 0.24728807972974665, 0.25633109931413645, 0.5237187791254256, 0.4589160661378887, 0.4800686762756784, 0.5172182956695894, 0.3455772027731311, 0.3934571605319833, 0.18678724354701826, 0.21125798251791006, 0.21718256750512888, 0.14760670693944644, 0.18881232481736954, 0.1715648814173919, 0.17090516191608063, 0.20380017706243847, 0.17142543771658114, 0.19058635088876086, 0.15753401468877914, 0.19106283716016204, 0.2160006413962301, 0.1908364061747868, 0.1670241684419883, 0.19342612588369545, 0.15750210148096233, 0.1377085211362783, 0.06524741311894955, 0.12210926500820984, 0.07635642165824863, 0.056182315316629095, 0.1011810304504408, 0.12608286146197312, 0.005567876495716884, 0.00043904982236886436, 0.04101612982022507, 0.20175551962565597, 0.1523630875445322, 0.2120585630383499, 0.1309483838405251, 0.10859863420137994, 0.11808531693377977, 0.29630642659865014, 0.21896154462702722, 0.2064639628380167, 0.02589140885698349, 0.010191625004765559, 0.03309249409727344, 0.04220277947727025, 0.015630689932046526, 0.03848079895756418, 0.04331070485748678, 0.05264411825913051, 0.036106619150957364, 0.119253271900985, 0.1316583320954785, 0.13887310866417013, 0.11165130484137553, 0.12307981693431447, 0.132660185880204, 0.10005094785539914, 0.11314189680077902, 0.1267381493355073, 0.4784833715066821, 0.46920938853944183, 0.46170727058128325, 0.4669854413008566, 0.46268337839978235, 0.45273818586487835, 0.46365805683669703, 0.4705795235536221, 0.4478410807916342, 0.0920103049541493, 0.11057518189830695, 0.07649726127363154, 0.07983349423597574, 0.10083236652315464, 0.08673380870980618, 0.09241785959748705, 0.08826585512366492, 0.09150150407293478, 0.13213012907543198, 0.13652850630110025, 0.15062517301693168, 0.1436461066967104, 0.1748048243667325, 0.1345547172066941, 0.14498729396163257, 0.14064732728396467, 0.22054125783025202, 0.2504254464062946, 0.27503607993041734, 0.2470695640184848, 0.2585986434374158, 0.29533840653937604, 0.24451782665770916, 0.3100518430381456, 0.3202794878368752, 0.30872188672718526, 0.1981442331232165, 0.1696639292387605, 0.20157910847004978, 0.1821370438449863, 0.17755212052197766, 0.1821116273523521, 0.1765196300527817, 0.241872567993203, 0.19754193322338598, 0.16539354587472388, 0.17382293971638285, 0.17646527128023204, 0.1789748603179825, 0.1734571292296785, 0.18978732035350598, 0.19712665718543443, 0.1747396509999226, 0.1840030645588554, 0.20225049164968334, 0.1836685139424319, 0.19112042972259535, 0.1850778594465271, 0.20585105342254995, 0.17961225342076037, 0.18885186142017096, 0.19890874383358548, 0.21110547827677673, 0.15351899868754548, 0.17226726372347545, 0.14840034598684848, 0.17296473907976995, 0.1742016144404268, 0.6178550980177964, 0.15185124218107704, 0.17006719365016454, 0.20769721347803116, 0.44514594789145234, 0.5073771166887994, 0.33639275444539984, 0.1987134288189546, 0.33529852042641495, 0.1509148573906266, 0.19496586210415656, 0.20339384592077758, 0.2631179336413274, 0.18616619769091347, 0.18582227760699999, 0.19950168484634645, 0.18741895807482745, 0.17236525369693978, 0.20385094699742856, 0.18656217696667377, 0.18386457592850003, 0.1895241424607621, 0.06110145226757524, 0.06378257845433599, 0.06323502859643992, 0.0680007021912925, 0.07310564591549196, 0.07744074398960399, 0.06995575436663715, 0.06711168029491399, 0.06991935913531055]}, "mutation_prompt": null}
{"id": "c57afff8-fd2c-4965-8b50-db5b5dca9a4d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n\n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / (mean_score + 1e-8)\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n\n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005, 0.1)\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n\n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n\n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with strategic initialization and adaptive mutation tailored for rapid convergence.", "configspace": "", "generation": 22, "fitness": 0.2613300871515898, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.7203780919442939, 0.7306810707343583, 0.6989399081753067, 0.7341728188346165, 0.705323684759419, 0.7447171830553478, 0.6921200238054321, 0.7211946469989927, 0.7412744244324095, 0.5098792158668559, 0.5060315940237581, 0.5083527528246007, 0.5359644815194338, 0.5074214412532843, 0.4957870984214281, 0.48524748218894487, 0.5058260845660714, 0.541852116948391, 0.11646330737854549, 0.15646770165203439, 0.12726772395159291, 0.1732666219308001, 0.12583339842652264, 0.12172904392984274, 0.17982597617030283, 0.11384546880769886, 0.14503218886268276, 0.15016489787231424, 0.10511299663399643, 0.13150746724478724, 0.11135808400337932, 0.12739958708985555, 0.10232760807478591, 0.12234248759546718, 0.11596930744040523, 0.12806036569800594, 0.9498432344605542, 0.9742445132111187, 0.9217360958100401, 0.9283257228888726, 0.9181242623374782, 0.9383927291740108, 0.9546527081074501, 0.9513400188901948, 0.969332287558485, 0.3237847984671237, 0.3358814199466905, 0.31508523123606136, 0.3457256932409779, 0.3560157928434289, 0.3372990902853785, 0.341450368427317, 0.3358609577862227, 0.31241905842215667, 0.4067462869973629, 0.41417605894501097, 0.2835731154264428, 0.26597641208924017, 0.36280348722397193, 0.295854713098306, 0.37980011431078187, 0.3811660882096094, 0.5007748044082583, 0.2452662640903689, 0.16613649334482394, 0.1888468314385695, 0.14088903791686958, 0.18095170769307567, 0.14067899879312262, 0.1802861173133926, 0.16853167036847794, 0.2030234491346451, 0.11227322249789773, 0.126246684299267, 0.10899802170359929, 0.16763509765759665, 0.16904120170491244, 0.19292944272162038, 0.1920078314819007, 0.12903639132743905, 0.18507217808874799, 0.06214419877451127, 0.0843546311583766, 0.03803217273205084, 0.11059160713702476, 0.15833840832997792, 0.0005429369866364331, 0.0007238939583650295, 0.06748061041676956, 0.005096632343653207, 0.1827545681604139, 0.1828876039243703, 0.25323042688756914, 0.11209224097531534, 0.11320059281827144, 0.1009472877850871, 0.2101792087483677, 0.20469412873731208, 0.22982887012973663, 0.006724570821212694, 0.025653225868598417, 0.019996337181883095, 0.03310611101466998, 0.03359468886746875, 0.04849807658812699, 0.03397505591338701, 0.051532229513222005, 0.06507237766207419, 0.11198138785229728, 0.1188639034901664, 0.1331250091225593, 0.1320828007058482, 0.12976815982827172, 0.12610213434691342, 0.11830816577501724, 0.12288912470238011, 0.11040013213439326, 0.44765916721777266, 0.44840826347604157, 0.47587656980038207, 0.4563940547441506, 0.45143003898974365, 0.4518228225149583, 0.44102999891243744, 0.47363890962789856, 0.43161239836479326, 0.09041936504171988, 0.0951453908821499, 0.08354731728309761, 0.1250583781312241, 0.14322391512282362, 0.0863102700187739, 0.08099921373874475, 0.11879656928071602, 0.07940576290414048, 0.26259416057113627, 0.17353181823981179, 0.18130644021076714, 0.18809787627031416, 0.1516898804692942, 0.16572664033133555, 0.14869937870157468, 0.28840675862901666, 0.1558411769935506, 0.25503765821503943, 0.2731589543851739, 0.2516142246362304, 0.26770235081255767, 0.26355251922752065, 0.291206061955976, 0.2780115457276525, 0.2713032522156985, 0.3272275167148939, 0.19174191625185866, 0.1943864710596842, 0.18438450081974123, 0.1891799245123581, 0.19855862339832042, 0.2286052681648877, 0.19986688922314588, 0.1970404331185669, 0.20319947877460276, 0.16226825758879804, 0.18108117338196628, 0.16853968194586832, 0.16511751303399647, 0.16642484264232904, 0.1630180497982896, 0.19425775895405206, 0.17117784377386613, 0.18511959965878844, 0.18602735314774332, 0.20124614563089271, 0.19701165150765432, 0.2004422473120121, 0.18139526470431944, 0.19291486077648745, 0.2102212499562195, 0.20072738005964597, 0.20419148328224845, 0.44621573009003057, 0.15500259930839844, 0.3107424988347317, 0.6149589698823259, 0.6871114409285204, 0.3306845000163793, 0.13055767496226822, 0.1546556922771113, 0.16288237240615144, 0.2094647920531193, 0.19252641019718708, 0.18960746232615588, 0.16922798678710294, 0.2851460232903087, 0.196873437935841, 0.20170414842032092, 0.39660975187566627, 0.2044467978757657, 0.20228868824715862, 0.19835033128241097, 0.20766575544187038, 0.18210290130127083, 0.1782710776794909, 0.18551169179003268, 0.1713498549726431, 0.18748468905763793, 0.18566856914351126, 0.07243438715452577, 0.07241499871729395, 0.07631722520453221, 0.07529226697477187, 0.06932623300377982, 0.07150417766528117, 0.07571279812373954, 0.06196845840449028, 0.06541637838697023]}, "mutation_prompt": null}
{"id": "af473b29-cd6f-4731-9bbe-e2635092d64b", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale adjustment based on individual success rates.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.7028771065953692, 0.6899950942742932, 0.6997938063946645, 0.7102177792857662, 0.7094763291282796, 0.7437274540120717, 0.7123979732030135, 0.7166959394688843, 0.6830978891232453, 0.464017627589135, 0.5151588108668763, 0.4908692342046289, 0.5294487296641229, 0.48451520685611527, 0.446647564060225, 0.5145614759865653, 0.4930857715644916, 0.49687679166789134, 0.11800889724492114, 0.1645296768998703, 0.10470754224888024, 0.13272297631588448, 0.17634182427585254, 0.14899577944685916, 0.17616276225372918, 0.10853581339348917, 0.1494379752174465, 0.130398607112728, 0.11931625425592507, 0.1056465915549184, 0.10633491064336376, 0.10579704066211326, 0.11637211186082241, 0.10518900808291232, 0.1078580673211521, 0.13315761488731426, 0.9498432344605542, 0.9369351584690553, 0.9442250915832563, 0.9689768200065486, 0.9413886274117735, 0.9596868208589906, 0.9477398059157249, 0.9620761414746546, 0.969301807246949, 0.324879067675937, 0.2841334144236414, 0.32258432090240563, 0.35777477546946235, 0.3349153926606888, 0.3343011276569632, 0.3697568354930594, 0.34345836223379944, 0.3471590669494451, 0.812866994947523, 0.24728807972974665, 0.25633109931413645, 0.5237187791254256, 0.4589160661378887, 0.4800686762756784, 0.5172182956695894, 0.3455772027731311, 0.3934571605319833, 0.18678724354701826, 0.21125798251791006, 0.21718256750512888, 0.14760670693944644, 0.18881232481736954, 0.1715648814173919, 0.17090516191608063, 0.20380017706243847, 0.17142543771658114, 0.19058635088876086, 0.15753401468877914, 0.19106283716016204, 0.2160006413962301, 0.1908364061747868, 0.1670241684419883, 0.19342612588369545, 0.15750210148096233, 0.1377085211362783, 0.06524741311894955, 0.12210926500820984, 0.07635642165824863, 0.056182315316629095, 0.1011810304504408, 0.12608286146197312, 0.005567876495716884, 0.00043904982236886436, 0.04101612982022507, 0.20175551962565597, 0.1523630875445322, 0.2120585630383499, 0.1309483838405251, 0.10859863420137994, 0.11808531693377977, 0.29630642659865014, 0.21896154462702722, 0.2064639628380167, 0.02589140885698349, 0.010191625004765559, 0.03309249409727344, 0.04220277947727025, 0.015630689932046526, 0.03848079895756418, 0.04331070485748678, 0.05264411825913051, 0.036106619150957364, 0.119253271900985, 0.1316583320954785, 0.13887310866417013, 0.11165130484137553, 0.12307981693431447, 0.132660185880204, 0.10005094785539914, 0.11314189680077902, 0.1267381493355073, 0.4784833715066821, 0.46920938853944183, 0.46170727058128325, 0.4669854413008566, 0.46268337839978235, 0.45273818586487835, 0.46365805683669703, 0.4705795235536221, 0.4478410807916342, 0.0920103049541493, 0.11057518189830695, 0.07649726127363154, 0.07983349423597574, 0.10083236652315464, 0.08673380870980618, 0.09241785959748705, 0.08826585512366492, 0.09150150407293478, 0.13213012907543198, 0.13652850630110025, 0.15062517301693168, 0.1436461066967104, 0.1748048243667325, 0.1345547172066941, 0.14498729396163257, 0.14064732728396467, 0.22054125783025202, 0.2504254464062946, 0.27503607993041734, 0.2470695640184848, 0.2585986434374158, 0.29533840653937604, 0.24451782665770916, 0.3100518430381456, 0.3202794878368752, 0.30872188672718526, 0.1981442331232165, 0.1696639292387605, 0.20157910847004978, 0.1821370438449863, 0.17755212052197766, 0.1821116273523521, 0.1765196300527817, 0.241872567993203, 0.19754193322338598, 0.16539354587472388, 0.17382293971638285, 0.17646527128023204, 0.1789748603179825, 0.1734571292296785, 0.18978732035350598, 0.19712665718543443, 0.1747396509999226, 0.1840030645588554, 0.20225049164968334, 0.1836685139424319, 0.19112042972259535, 0.1850778594465271, 0.20585105342254995, 0.17961225342076037, 0.18885186142017096, 0.19890874383358548, 0.21110547827677673, 0.15351899868754548, 0.17226726372347545, 0.14840034598684848, 0.17296473907976995, 0.1742016144404268, 0.6178550980177964, 0.15185124218107704, 0.17006719365016454, 0.20769721347803116, 0.44514594789145234, 0.5073771166887994, 0.33639275444539984, 0.1987134288189546, 0.33529852042641495, 0.1509148573906266, 0.19496586210415656, 0.20339384592077758, 0.2631179336413274, 0.18616619769091347, 0.18582227760699999, 0.19950168484634645, 0.18741895807482745, 0.17236525369693978, 0.20385094699742856, 0.18656217696667377, 0.18386457592850003, 0.1895241424607621, 0.06110145226757524, 0.06378257845433599, 0.06323502859643992, 0.0680007021912925, 0.07310564591549196, 0.07744074398960399, 0.06995575436663715, 0.06711168029491399, 0.06991935913531055]}, "mutation_prompt": null}
{"id": "fba42fae-968f-4fa5-b8a0-82b7815956af", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        adaptive_F = self.F * (1 + 0.2 * diversity_factor)  # Enhance mutation based on diversity\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + adaptive_F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced convergence speed by integrating adaptive crossover rate and mutation scale with diversity-based adjustments.", "configspace": "", "generation": 24, "fitness": 0.2559337818664212, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.6772009538048909, 0.6753456658458097, 0.708003658622307, 0.7215873479317751, 0.7062080844803671, 0.7342887502688893, 0.7259583798118048, 0.7067878302326871, 0.710064543904839, 0.3658409127540505, 0.3786631841342162, 0.43129384771608537, 0.0547483144691987, 0.12382896591315384, 0.4242004714003206, 0.5197173549016953, 0.045729629524369875, 0.4323759204307389, 0.1336967223582587, 0.2670364292653309, 0.12100230249590349, 0.1614869155911438, 0.10487638735557869, 0.1378703513282371, 0.15276049569215444, 0.17661277507212747, 0.13522433328060235, 0.12632001782121638, 0.13006947837309546, 0.11808757887723298, 0.13718820470835202, 0.10234823952461214, 0.09735907377286224, 0.10805055246125117, 0.11280735510537665, 0.12265627744887608, 0.9787121174446867, 0.9323618409807608, 0.9275158370374794, 0.9689891594735178, 0.9271795093793346, 0.9598231280368777, 0.9439108751743056, 0.9585862349893066, 0.9693595948029546, 0.29017568757458034, 0.32432071082153857, 0.30930591267902774, 0.3147754308996473, 0.3237965130771667, 0.31858576684444073, 0.331893866680777, 0.3402597074664152, 0.345992532766484, 0.4018634825263564, 0.25562445533438094, 0.2544116491484547, 0.5803080776933962, 0.3810825256881205, 0.30652492502195905, 0.35875563304931735, 0.32909460212753117, 0.5060175973587253, 0.19507043594425844, 0.18435166351075627, 0.17703991196138502, 0.1583341380544413, 0.17681840235316726, 0.19422164253833063, 0.18651082830704113, 0.16818657714476848, 0.17327416195850642, 0.21165555605210762, 0.14987514488272957, 0.16895277440812573, 0.17007016094786154, 0.14187624926797526, 0.17953660358024282, 0.19069878114494754, 0.16735717923559512, 0.14989367883418547, 0.05155728869197851, 0.04237895526419322, 0.08411102377600654, 0.07680057116427308, 0.08602218930925465, 0.06820583704785199, 0.024749424041545343, 0.011941207905215356, 0.024461027179966677, 0.1780549148158429, 0.14664010938915417, 0.1916801045979707, 0.11440442690865837, 0.09321526346022879, 0.0826167038160529, 0.22935277843336144, 0.23835976300130046, 0.17853742503747305, 0.0017871169616578975, 9.999999999998899e-05, 0.01444396051490493, 0.009615245051286192, 0.020541119697919163, 0.0030525899589142202, 0.05682887749276855, 0.03874745140875946, 0.05798378418657779, 0.14452314874027017, 0.10534305401955757, 0.13752513930904586, 0.091118463624697, 0.11690355621964466, 0.09122130984335675, 0.11784748969411762, 0.09158806120841623, 0.08782627870775994, 0.4276202424456955, 0.4467882795217737, 0.48751477150017475, 0.46580974267498976, 0.4449548986952041, 0.46561905130302705, 0.45366677352379936, 0.4610225702959503, 0.4899548722332635, 0.07715088041505247, 0.07860700612425775, 0.09012198235321811, 0.08261678317876409, 0.07544849502635131, 0.1087302539135353, 0.05977908565480938, 0.057323902589656583, 0.07467174165116597, 0.1850112781037374, 0.13999861375710243, 0.1350225130863808, 0.14106347633828686, 0.12327207684887143, 0.12660410116761434, 0.26409895494875124, 0.28325645840869307, 0.24636709795879808, 0.24356431395112377, 0.2854032071139141, 0.25756702738746995, 0.2794701430518184, 0.2677015076326522, 0.25870351522005197, 0.29592013437995646, 0.31172733227534244, 0.29928696014840483, 0.12001906365288129, 0.15167586300507607, 0.13894983296990326, 0.17722960892652695, 0.16579722440994593, 0.17731760622167858, 0.20056385742627014, 0.19855276205560823, 0.20974284790619335, 0.17661180119223552, 0.17937187577415592, 0.1738887833293713, 0.1601388361799747, 0.1692364308869806, 0.15348570999741185, 0.17833715747583756, 0.1712048396390803, 0.1917031043618137, 0.1759303651167684, 0.1873425702979724, 0.1825109322751749, 0.1995134660759571, 0.19751466617214009, 0.1961346218326102, 0.19276633341478888, 0.30412976149101856, 0.1926081704113326, 0.5711226790379391, 0.17125129861110855, 0.43078372280395105, 0.7089122635780618, 0.6126438581383921, 0.32465795443869616, 0.18819783280189772, 0.33808191781494956, 0.22638223367711174, 0.4219050783303938, 0.16306091632776443, 0.4151083375660821, 0.3172512621439645, 0.1594162680142006, 0.14277345204023417, 0.5043451521142142, 0.4552258090293463, 0.2517896567662852, 0.1779310010617835, 0.18592605879343804, 0.1915966435305424, 0.18252693663901054, 0.17851704621846998, 0.20007307657353324, 0.180819267556663, 0.18593009573023833, 0.18187803688693327, 0.06667434314042531, 0.05831311409818063, 0.07702209260151671, 0.06847823108313222, 0.0688493039108995, 0.06913857236418952, 0.06815774303646982, 0.07173291748468658, 0.07117034046054616]}, "mutation_prompt": null}
{"id": "cfc8ba80-36c1-49e7-923c-e36cde5a484d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale adjustment based on individual success rates.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.7028771065953692, 0.6899950942742932, 0.6997938063946645, 0.7102177792857662, 0.7094763291282796, 0.7437274540120717, 0.7123979732030135, 0.7166959394688843, 0.6830978891232453, 0.464017627589135, 0.5151588108668763, 0.4908692342046289, 0.5294487296641229, 0.48451520685611527, 0.446647564060225, 0.5145614759865653, 0.4930857715644916, 0.49687679166789134, 0.11800889724492114, 0.1645296768998703, 0.10470754224888024, 0.13272297631588448, 0.17634182427585254, 0.14899577944685916, 0.17616276225372918, 0.10853581339348917, 0.1494379752174465, 0.130398607112728, 0.11931625425592507, 0.1056465915549184, 0.10633491064336376, 0.10579704066211326, 0.11637211186082241, 0.10518900808291232, 0.1078580673211521, 0.13315761488731426, 0.9498432344605542, 0.9369351584690553, 0.9442250915832563, 0.9689768200065486, 0.9413886274117735, 0.9596868208589906, 0.9477398059157249, 0.9620761414746546, 0.969301807246949, 0.324879067675937, 0.2841334144236414, 0.32258432090240563, 0.35777477546946235, 0.3349153926606888, 0.3343011276569632, 0.3697568354930594, 0.34345836223379944, 0.3471590669494451, 0.812866994947523, 0.24728807972974665, 0.25633109931413645, 0.5237187791254256, 0.4589160661378887, 0.4800686762756784, 0.5172182956695894, 0.3455772027731311, 0.3934571605319833, 0.18678724354701826, 0.21125798251791006, 0.21718256750512888, 0.14760670693944644, 0.18881232481736954, 0.1715648814173919, 0.17090516191608063, 0.20380017706243847, 0.17142543771658114, 0.19058635088876086, 0.15753401468877914, 0.19106283716016204, 0.2160006413962301, 0.1908364061747868, 0.1670241684419883, 0.19342612588369545, 0.15750210148096233, 0.1377085211362783, 0.06524741311894955, 0.12210926500820984, 0.07635642165824863, 0.056182315316629095, 0.1011810304504408, 0.12608286146197312, 0.005567876495716884, 0.00043904982236886436, 0.04101612982022507, 0.20175551962565597, 0.1523630875445322, 0.2120585630383499, 0.1309483838405251, 0.10859863420137994, 0.11808531693377977, 0.29630642659865014, 0.21896154462702722, 0.2064639628380167, 0.02589140885698349, 0.010191625004765559, 0.03309249409727344, 0.04220277947727025, 0.015630689932046526, 0.03848079895756418, 0.04331070485748678, 0.05264411825913051, 0.036106619150957364, 0.119253271900985, 0.1316583320954785, 0.13887310866417013, 0.11165130484137553, 0.12307981693431447, 0.132660185880204, 0.10005094785539914, 0.11314189680077902, 0.1267381493355073, 0.4784833715066821, 0.46920938853944183, 0.46170727058128325, 0.4669854413008566, 0.46268337839978235, 0.45273818586487835, 0.46365805683669703, 0.4705795235536221, 0.4478410807916342, 0.0920103049541493, 0.11057518189830695, 0.07649726127363154, 0.07983349423597574, 0.10083236652315464, 0.08673380870980618, 0.09241785959748705, 0.08826585512366492, 0.09150150407293478, 0.13213012907543198, 0.13652850630110025, 0.15062517301693168, 0.1436461066967104, 0.1748048243667325, 0.1345547172066941, 0.14498729396163257, 0.14064732728396467, 0.22054125783025202, 0.2504254464062946, 0.27503607993041734, 0.2470695640184848, 0.2585986434374158, 0.29533840653937604, 0.24451782665770916, 0.3100518430381456, 0.3202794878368752, 0.30872188672718526, 0.1981442331232165, 0.1696639292387605, 0.20157910847004978, 0.1821370438449863, 0.17755212052197766, 0.1821116273523521, 0.1765196300527817, 0.241872567993203, 0.19754193322338598, 0.16539354587472388, 0.17382293971638285, 0.17646527128023204, 0.1789748603179825, 0.1734571292296785, 0.18978732035350598, 0.19712665718543443, 0.1747396509999226, 0.1840030645588554, 0.20225049164968334, 0.1836685139424319, 0.19112042972259535, 0.1850778594465271, 0.20585105342254995, 0.17961225342076037, 0.18885186142017096, 0.19890874383358548, 0.21110547827677673, 0.15351899868754548, 0.17226726372347545, 0.14840034598684848, 0.17296473907976995, 0.1742016144404268, 0.6178550980177964, 0.15185124218107704, 0.17006719365016454, 0.20769721347803116, 0.44514594789145234, 0.5073771166887994, 0.33639275444539984, 0.1987134288189546, 0.33529852042641495, 0.1509148573906266, 0.19496586210415656, 0.20339384592077758, 0.2631179336413274, 0.18616619769091347, 0.18582227760699999, 0.19950168484634645, 0.18741895807482745, 0.17236525369693978, 0.20385094699742856, 0.18656217696667377, 0.18386457592850003, 0.1895241424607621, 0.06110145226757524, 0.06378257845433599, 0.06323502859643992, 0.0680007021912925, 0.07310564591549196, 0.07744074398960399, 0.06995575436663715, 0.06711168029491399, 0.06991935913531055]}, "mutation_prompt": null}
{"id": "981f3e1d-9316-4a85-9c11-b69350fa3c36", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale adjustment based on individual success rates.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.7028771065953692, 0.6899950942742932, 0.6997938063946645, 0.7102177792857662, 0.7094763291282796, 0.7437274540120717, 0.7123979732030135, 0.7166959394688843, 0.6830978891232453, 0.464017627589135, 0.5151588108668763, 0.4908692342046289, 0.5294487296641229, 0.48451520685611527, 0.446647564060225, 0.5145614759865653, 0.4930857715644916, 0.49687679166789134, 0.11800889724492114, 0.1645296768998703, 0.10470754224888024, 0.13272297631588448, 0.17634182427585254, 0.14899577944685916, 0.17616276225372918, 0.10853581339348917, 0.1494379752174465, 0.130398607112728, 0.11931625425592507, 0.1056465915549184, 0.10633491064336376, 0.10579704066211326, 0.11637211186082241, 0.10518900808291232, 0.1078580673211521, 0.13315761488731426, 0.9498432344605542, 0.9369351584690553, 0.9442250915832563, 0.9689768200065486, 0.9413886274117735, 0.9596868208589906, 0.9477398059157249, 0.9620761414746546, 0.969301807246949, 0.324879067675937, 0.2841334144236414, 0.32258432090240563, 0.35777477546946235, 0.3349153926606888, 0.3343011276569632, 0.3697568354930594, 0.34345836223379944, 0.3471590669494451, 0.812866994947523, 0.24728807972974665, 0.25633109931413645, 0.5237187791254256, 0.4589160661378887, 0.4800686762756784, 0.5172182956695894, 0.3455772027731311, 0.3934571605319833, 0.18678724354701826, 0.21125798251791006, 0.21718256750512888, 0.14760670693944644, 0.18881232481736954, 0.1715648814173919, 0.17090516191608063, 0.20380017706243847, 0.17142543771658114, 0.19058635088876086, 0.15753401468877914, 0.19106283716016204, 0.2160006413962301, 0.1908364061747868, 0.1670241684419883, 0.19342612588369545, 0.15750210148096233, 0.1377085211362783, 0.06524741311894955, 0.12210926500820984, 0.07635642165824863, 0.056182315316629095, 0.1011810304504408, 0.12608286146197312, 0.005567876495716884, 0.00043904982236886436, 0.04101612982022507, 0.20175551962565597, 0.1523630875445322, 0.2120585630383499, 0.1309483838405251, 0.10859863420137994, 0.11808531693377977, 0.29630642659865014, 0.21896154462702722, 0.2064639628380167, 0.02589140885698349, 0.010191625004765559, 0.03309249409727344, 0.04220277947727025, 0.015630689932046526, 0.03848079895756418, 0.04331070485748678, 0.05264411825913051, 0.036106619150957364, 0.119253271900985, 0.1316583320954785, 0.13887310866417013, 0.11165130484137553, 0.12307981693431447, 0.132660185880204, 0.10005094785539914, 0.11314189680077902, 0.1267381493355073, 0.4784833715066821, 0.46920938853944183, 0.46170727058128325, 0.4669854413008566, 0.46268337839978235, 0.45273818586487835, 0.46365805683669703, 0.4705795235536221, 0.4478410807916342, 0.0920103049541493, 0.11057518189830695, 0.07649726127363154, 0.07983349423597574, 0.10083236652315464, 0.08673380870980618, 0.09241785959748705, 0.08826585512366492, 0.09150150407293478, 0.13213012907543198, 0.13652850630110025, 0.15062517301693168, 0.1436461066967104, 0.1748048243667325, 0.1345547172066941, 0.14498729396163257, 0.14064732728396467, 0.22054125783025202, 0.2504254464062946, 0.27503607993041734, 0.2470695640184848, 0.2585986434374158, 0.29533840653937604, 0.24451782665770916, 0.3100518430381456, 0.3202794878368752, 0.30872188672718526, 0.1981442331232165, 0.1696639292387605, 0.20157910847004978, 0.1821370438449863, 0.17755212052197766, 0.1821116273523521, 0.1765196300527817, 0.241872567993203, 0.19754193322338598, 0.16539354587472388, 0.17382293971638285, 0.17646527128023204, 0.1789748603179825, 0.1734571292296785, 0.18978732035350598, 0.19712665718543443, 0.1747396509999226, 0.1840030645588554, 0.20225049164968334, 0.1836685139424319, 0.19112042972259535, 0.1850778594465271, 0.20585105342254995, 0.17961225342076037, 0.18885186142017096, 0.19890874383358548, 0.21110547827677673, 0.15351899868754548, 0.17226726372347545, 0.14840034598684848, 0.17296473907976995, 0.1742016144404268, 0.6178550980177964, 0.15185124218107704, 0.17006719365016454, 0.20769721347803116, 0.44514594789145234, 0.5073771166887994, 0.33639275444539984, 0.1987134288189546, 0.33529852042641495, 0.1509148573906266, 0.19496586210415656, 0.20339384592077758, 0.2631179336413274, 0.18616619769091347, 0.18582227760699999, 0.19950168484634645, 0.18741895807482745, 0.17236525369693978, 0.20385094699742856, 0.18656217696667377, 0.18386457592850003, 0.1895241424607621, 0.06110145226757524, 0.06378257845433599, 0.06323502859643992, 0.0680007021912925, 0.07310564591549196, 0.07744074398960399, 0.06995575436663715, 0.06711168029491399, 0.06991935913531055]}, "mutation_prompt": null}
{"id": "63fc804c-5292-4fba-a7a0-744033fa07be", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n        self.elitism_rate = 0.1\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Optimized DualPopulationOptimizer with controlled elitism and dynamic population resizing for enhanced convergence speed.", "configspace": "", "generation": 27, "fitness": 0.2928719826791646, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "20c98dec-37e4-4117-a28e-77439a16faae", "metadata": {"aucs": [0.7345853422556136, 0.7355043040498297, 0.7424384349482527, 0.7563367485494141, 0.7622768173532216, 0.7805353477654016, 0.7786763196161215, 0.7480428839303286, 0.7746060280758922, 0.28876268290665497, 0.11071488934313367, 0.1404237046672946, 0.33049162906536744, 0.08443086950982293, 0.30702034868292727, 0.3905015540134207, 0.38479551930032385, 0.41193412015715636, 0.11958125308719103, 0.11301096990138393, 0.5216955859466283, 0.11943842255224957, 0.12681497779068795, 0.13293924924919298, 0.4621284646178483, 0.1424471346245757, 0.13317479623743989, 0.15568611204488025, 0.13849248859545438, 0.12699888256770642, 0.09950742565479109, 0.0712105759715127, 0.08668158558719019, 0.08658542370517264, 0.09019064572435587, 0.10428178149570344, 0.9830088772468145, 0.8303803017615587, 0.7957379740999604, 0.9678715222276507, 0.9475653646136885, 0.9705464826607678, 0.9543355553046587, 0.9460139903714385, 0.9238043081592731, 0.3818694631180658, 0.30820321852721366, 0.3177859445328236, 0.2860687105809916, 0.42338224877333264, 0.30784067147573224, 0.2987709903410032, 0.3154932054483369, 0.3050282175986436, 0.6116840604705829, 0.6987702297124654, 0.6784158914255192, 0.6735095871051957, 0.8030428394033132, 0.7563223151890587, 0.29169968869830987, 0.29870442769192895, 0.3316062867466495, 0.09968897967185608, 0.18738791518219267, 0.17253772549617608, 0.17067664789924042, 0.16429515020524954, 0.23600207454372935, 0.16311936368482527, 0.18999872251272643, 0.18376944132446438, 0.19097442129726827, 0.11351904168449234, 0.12854975953251346, 0.18435535486470023, 0.27478893013529526, 0.17564432660083606, 0.21832873487169124, 0.10172062798234072, 0.15697818788375684, 0.3810618991766611, 0.2095129314538875, 0.06778225170556962, 0.035061701723856586, 0.2750526575533472, 0.4037503619951315, 0.12235850841763818, 0.3129545598474247, 0.21527555018677524, 0.4725815085588553, 0.4191007380435847, 0.11183296177716218, 0.09320568140355501, 0.14230879016489706, 0.3855747036365502, 0.26133612202857337, 0.06621636945735265, 0.3468003562003984, 0.13575986777365268, 0.0378564274437273, 0.16214222659942423, 0.17769218610684878, 0.0797230563612007, 0.10102229172249322, 0.10139940879057197, 0.09569759853318516, 0.23316899891908305, 0.2368556193716176, 0.20923961760866927, 0.27120825428729556, 0.10122493577935365, 0.2768051337817987, 0.2521084001855183, 0.12426468316751982, 0.08820776977499611, 0.12286116332472996, 0.463769919915738, 0.46280134592554145, 0.5365441933167188, 0.5137914957182115, 0.5017419455104266, 0.481697102366625, 0.5353878890698595, 0.5035191454114905, 0.4878038150648707, 0.07683760997193767, 0.10085988196635132, 0.11369452101613275, 0.06697547485947675, 0.09990448432968702, 0.10437214265757189, 0.09443683679310999, 0.10667776341036428, 0.0978912442275639, 0.13999990867867051, 0.14178651041733104, 0.20566014900879104, 0.2811665081840219, 0.2791158021702249, 0.1926313686288691, 0.1845905689156928, 0.2222782903986159, 0.1393740383566896, 0.2876621316172474, 0.22222307510771766, 0.2815966539609671, 0.3609855609193774, 0.3580306252263087, 0.31348052660772874, 0.37158363799560123, 0.3551018894631639, 0.37641502223086976, 0.18205282496859165, 0.24540455721449916, 0.20806591252379214, 0.2822990542040119, 0.20632070626748766, 0.20117026826425555, 0.24564504778777851, 0.3210075156782649, 0.27491027423055037, 0.1950498242298534, 0.17578249225144604, 0.17993707202107634, 0.202661470209751, 0.1743950748124835, 0.20344177387227524, 0.1827734328627334, 0.21031471784414757, 0.18015323296313124, 0.16876311036109148, 0.19904901706690892, 0.16821667449827782, 0.18523807127244507, 0.18361860490286763, 0.17636875535489238, 0.19306501008721066, 0.1942149708804468, 0.17429217142121145, 0.7461369646317721, 0.15111850773423974, 0.15190520601323731, 0.1843383877203313, 0.18421661778692144, 0.1741999680134655, 0.6237848584851309, 0.6658997727638567, 0.6599867605093848, 0.2123335106684675, 0.162463156930295, 0.16208781476088574, 0.20135352149728325, 0.46253044150509715, 0.5433727784707914, 0.3478193016259523, 0.5181609481425342, 0.4574944203042397, 0.19645914038021084, 0.183868946117415, 0.21370062160154435, 0.19886656848555817, 0.16659664180033484, 0.1659132171319163, 0.18184388712412125, 0.20184329208566953, 0.17119226028044343, 0.06996962445494359, 0.07021722845561451, 0.07692672516989152, 0.07252234159477122, 0.06760469708836003, 0.06651621885688142, 0.07434158824933534, 0.07849500515863017, 0.0759202085635916]}, "mutation_prompt": null}
{"id": "406fa785-902d-4273-a299-900c67cbf26d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n        self.elitism_rate = 0.1\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Optimized DualPopulationOptimizer with controlled elitism and dynamic population resizing for enhanced convergence speed.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63fc804c-5292-4fba-a7a0-744033fa07be", "metadata": {"aucs": [0.7345853422556136, 0.7355043040498297, 0.7424384349482527, 0.7563367485494141, 0.7622768173532216, 0.7805353477654016, 0.7786763196161215, 0.7480428839303286, 0.7746060280758922, 0.28876268290665497, 0.11071488934313367, 0.1404237046672946, 0.33049162906536744, 0.08443086950982293, 0.30702034868292727, 0.3905015540134207, 0.38479551930032385, 0.41193412015715636, 0.11958125308719103, 0.11301096990138393, 0.5216955859466283, 0.11943842255224957, 0.12681497779068795, 0.13293924924919298, 0.4621284646178483, 0.1424471346245757, 0.13317479623743989, 0.15568611204488025, 0.13849248859545438, 0.12699888256770642, 0.09950742565479109, 0.0712105759715127, 0.08668158558719019, 0.08658542370517264, 0.09019064572435587, 0.10428178149570344, 0.9830088772468145, 0.8303803017615587, 0.7957379740999604, 0.9678715222276507, 0.9475653646136885, 0.9705464826607678, 0.9543355553046587, 0.9460139903714385, 0.9238043081592731, 0.3818694631180658, 0.30820321852721366, 0.3177859445328236, 0.2860687105809916, 0.42338224877333264, 0.30784067147573224, 0.2987709903410032, 0.3154932054483369, 0.3050282175986436, 0.6116840604705829, 0.6987702297124654, 0.6784158914255192, 0.6735095871051957, 0.8030428394033132, 0.7563223151890587, 0.29169968869830987, 0.29870442769192895, 0.3316062867466495, 0.09968897967185608, 0.18738791518219267, 0.17253772549617608, 0.17067664789924042, 0.16429515020524954, 0.23600207454372935, 0.16311936368482527, 0.18999872251272643, 0.18376944132446438, 0.19097442129726827, 0.11351904168449234, 0.12854975953251346, 0.18435535486470023, 0.27478893013529526, 0.17564432660083606, 0.21832873487169124, 0.10172062798234072, 0.15697818788375684, 0.3810618991766611, 0.2095129314538875, 0.06778225170556962, 0.035061701723856586, 0.2750526575533472, 0.4037503619951315, 0.12235850841763818, 0.3129545598474247, 0.21527555018677524, 0.4725815085588553, 0.4191007380435847, 0.11183296177716218, 0.09320568140355501, 0.14230879016489706, 0.3855747036365502, 0.26133612202857337, 0.06621636945735265, 0.3468003562003984, 0.13575986777365268, 0.0378564274437273, 0.16214222659942423, 0.17769218610684878, 0.0797230563612007, 0.10102229172249322, 0.10139940879057197, 0.09569759853318516, 0.23316899891908305, 0.2368556193716176, 0.20923961760866927, 0.27120825428729556, 0.10122493577935365, 0.2768051337817987, 0.2521084001855183, 0.12426468316751982, 0.08820776977499611, 0.12286116332472996, 0.463769919915738, 0.46280134592554145, 0.5365441933167188, 0.5137914957182115, 0.5017419455104266, 0.481697102366625, 0.5353878890698595, 0.5035191454114905, 0.4878038150648707, 0.07683760997193767, 0.10085988196635132, 0.11369452101613275, 0.06697547485947675, 0.09990448432968702, 0.10437214265757189, 0.09443683679310999, 0.10667776341036428, 0.0978912442275639, 0.13999990867867051, 0.14178651041733104, 0.20566014900879104, 0.2811665081840219, 0.2791158021702249, 0.1926313686288691, 0.1845905689156928, 0.2222782903986159, 0.1393740383566896, 0.2876621316172474, 0.22222307510771766, 0.2815966539609671, 0.3609855609193774, 0.3580306252263087, 0.31348052660772874, 0.37158363799560123, 0.3551018894631639, 0.37641502223086976, 0.18205282496859165, 0.24540455721449916, 0.20806591252379214, 0.2822990542040119, 0.20632070626748766, 0.20117026826425555, 0.24564504778777851, 0.3210075156782649, 0.27491027423055037, 0.1950498242298534, 0.17578249225144604, 0.17993707202107634, 0.202661470209751, 0.1743950748124835, 0.20344177387227524, 0.1827734328627334, 0.21031471784414757, 0.18015323296313124, 0.16876311036109148, 0.19904901706690892, 0.16821667449827782, 0.18523807127244507, 0.18361860490286763, 0.17636875535489238, 0.19306501008721066, 0.1942149708804468, 0.17429217142121145, 0.7461369646317721, 0.15111850773423974, 0.15190520601323731, 0.1843383877203313, 0.18421661778692144, 0.1741999680134655, 0.6237848584851309, 0.6658997727638567, 0.6599867605093848, 0.2123335106684675, 0.162463156930295, 0.16208781476088574, 0.20135352149728325, 0.46253044150509715, 0.5433727784707914, 0.3478193016259523, 0.5181609481425342, 0.4574944203042397, 0.19645914038021084, 0.183868946117415, 0.21370062160154435, 0.19886656848555817, 0.16659664180033484, 0.1659132171319163, 0.18184388712412125, 0.20184329208566953, 0.17119226028044343, 0.06996962445494359, 0.07021722845561451, 0.07692672516989152, 0.07252234159477122, 0.06760469708836003, 0.06651621885688142, 0.07434158824933534, 0.07849500515863017, 0.0759202085635916]}, "mutation_prompt": null}
{"id": "18c268f8-0c9e-40fc-b310-e3e0ec7b4c25", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8  # Differential weight\n        self.temperature = 1000  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5  # Scale for mutation size\n        self.elitism_rate = 0.1\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)  # Increase scale if successful\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01, 0.1)  # Decrease scale if not\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Optimized DualPopulationOptimizer with controlled elitism and dynamic population resizing for enhanced convergence speed.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63fc804c-5292-4fba-a7a0-744033fa07be", "metadata": {"aucs": [0.7345853422556136, 0.7355043040498297, 0.7424384349482527, 0.7563367485494141, 0.7622768173532216, 0.7805353477654016, 0.7786763196161215, 0.7480428839303286, 0.7746060280758922, 0.28876268290665497, 0.11071488934313367, 0.1404237046672946, 0.33049162906536744, 0.08443086950982293, 0.30702034868292727, 0.3905015540134207, 0.38479551930032385, 0.41193412015715636, 0.11958125308719103, 0.11301096990138393, 0.5216955859466283, 0.11943842255224957, 0.12681497779068795, 0.13293924924919298, 0.4621284646178483, 0.1424471346245757, 0.13317479623743989, 0.15568611204488025, 0.13849248859545438, 0.12699888256770642, 0.09950742565479109, 0.0712105759715127, 0.08668158558719019, 0.08658542370517264, 0.09019064572435587, 0.10428178149570344, 0.9830088772468145, 0.8303803017615587, 0.7957379740999604, 0.9678715222276507, 0.9475653646136885, 0.9705464826607678, 0.9543355553046587, 0.9460139903714385, 0.9238043081592731, 0.3818694631180658, 0.30820321852721366, 0.3177859445328236, 0.2860687105809916, 0.42338224877333264, 0.30784067147573224, 0.2987709903410032, 0.3154932054483369, 0.3050282175986436, 0.6116840604705829, 0.6987702297124654, 0.6784158914255192, 0.6735095871051957, 0.8030428394033132, 0.7563223151890587, 0.29169968869830987, 0.29870442769192895, 0.3316062867466495, 0.09968897967185608, 0.18738791518219267, 0.17253772549617608, 0.17067664789924042, 0.16429515020524954, 0.23600207454372935, 0.16311936368482527, 0.18999872251272643, 0.18376944132446438, 0.19097442129726827, 0.11351904168449234, 0.12854975953251346, 0.18435535486470023, 0.27478893013529526, 0.17564432660083606, 0.21832873487169124, 0.10172062798234072, 0.15697818788375684, 0.3810618991766611, 0.2095129314538875, 0.06778225170556962, 0.035061701723856586, 0.2750526575533472, 0.4037503619951315, 0.12235850841763818, 0.3129545598474247, 0.21527555018677524, 0.4725815085588553, 0.4191007380435847, 0.11183296177716218, 0.09320568140355501, 0.14230879016489706, 0.3855747036365502, 0.26133612202857337, 0.06621636945735265, 0.3468003562003984, 0.13575986777365268, 0.0378564274437273, 0.16214222659942423, 0.17769218610684878, 0.0797230563612007, 0.10102229172249322, 0.10139940879057197, 0.09569759853318516, 0.23316899891908305, 0.2368556193716176, 0.20923961760866927, 0.27120825428729556, 0.10122493577935365, 0.2768051337817987, 0.2521084001855183, 0.12426468316751982, 0.08820776977499611, 0.12286116332472996, 0.463769919915738, 0.46280134592554145, 0.5365441933167188, 0.5137914957182115, 0.5017419455104266, 0.481697102366625, 0.5353878890698595, 0.5035191454114905, 0.4878038150648707, 0.07683760997193767, 0.10085988196635132, 0.11369452101613275, 0.06697547485947675, 0.09990448432968702, 0.10437214265757189, 0.09443683679310999, 0.10667776341036428, 0.0978912442275639, 0.13999990867867051, 0.14178651041733104, 0.20566014900879104, 0.2811665081840219, 0.2791158021702249, 0.1926313686288691, 0.1845905689156928, 0.2222782903986159, 0.1393740383566896, 0.2876621316172474, 0.22222307510771766, 0.2815966539609671, 0.3609855609193774, 0.3580306252263087, 0.31348052660772874, 0.37158363799560123, 0.3551018894631639, 0.37641502223086976, 0.18205282496859165, 0.24540455721449916, 0.20806591252379214, 0.2822990542040119, 0.20632070626748766, 0.20117026826425555, 0.24564504778777851, 0.3210075156782649, 0.27491027423055037, 0.1950498242298534, 0.17578249225144604, 0.17993707202107634, 0.202661470209751, 0.1743950748124835, 0.20344177387227524, 0.1827734328627334, 0.21031471784414757, 0.18015323296313124, 0.16876311036109148, 0.19904901706690892, 0.16821667449827782, 0.18523807127244507, 0.18361860490286763, 0.17636875535489238, 0.19306501008721066, 0.1942149708804468, 0.17429217142121145, 0.7461369646317721, 0.15111850773423974, 0.15190520601323731, 0.1843383877203313, 0.18421661778692144, 0.1741999680134655, 0.6237848584851309, 0.6658997727638567, 0.6599867605093848, 0.2123335106684675, 0.162463156930295, 0.16208781476088574, 0.20135352149728325, 0.46253044150509715, 0.5433727784707914, 0.3478193016259523, 0.5181609481425342, 0.4574944203042397, 0.19645914038021084, 0.183868946117415, 0.21370062160154435, 0.19886656848555817, 0.16659664180033484, 0.1659132171319163, 0.18184388712412125, 0.20184329208566953, 0.17119226028044343, 0.06996962445494359, 0.07021722845561451, 0.07692672516989152, 0.07252234159477122, 0.06760469708836003, 0.06651621885688142, 0.07434158824933534, 0.07849500515863017, 0.0759202085635916]}, "mutation_prompt": null}
{"id": "887d5db2-863e-4d84-a2ec-3a609035af72", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 30, "fitness": 0.30039672998200484, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "63fc804c-5292-4fba-a7a0-744033fa07be", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "c4b2a317-a66f-4c96-8751-ee0fe459997a", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "0acd77b9-3977-4bb1-9c74-5232e3b29997", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "e05e5368-cf16-430e-a9f6-145a759f6e16", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "dcb03c07-3751-412a-98b7-99f79638247a", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "1e960c28-0433-4dea-adcd-13298d65bf46", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "1950db59-3c70-4b84-ad8d-a2823b8fcb9d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "ef41db2f-8c50-4105-9ec1-5a9bf2602dbf", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "ca00bd17-22b6-480e-b1c9-c2a17b25b518", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "1b67f9a4-d56a-487f-a311-d2124d2e14b3", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "e0d105d3-2395-4ed5-b7ab-af2b2332957a", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "28da9ac0-dd41-49ee-9056-e3104d69e669", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "4f2e5f5c-cbd1-41ae-a80b-cdc4c0214de8", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "202f4279-969f-4db7-848d-d9a362b99fde", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "b562930c-c840-4587-8436-3470d906f9a2", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "8fed367d-9da3-447e-86c6-0f56f81e20b9", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "8a73f2a4-3401-4bf5-b9ed-953650d957d3", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  \n        self.target_diversity = 0.1  # New parameter for diversity control\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.2 * diversity_factor)  # Reduced influence\n\n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n\n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c]) * (1 + diversity_factor)  # Enhanced mutation\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n\n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 3:  # Earlier adaption\n            self.population_size = max(10, int(self.initial_population_size * (1 - (evals / self.budget))))\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with a refined mutation strategy and adaptive population resizing for faster convergence.", "configspace": "", "generation": 46, "fitness": 0.23434038264749224, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7331817851637131, 0.7234550738766364, 0.7399079260812746, 0.7609292893228268, 0.7579061374774796, 0.7567028329639899, 0.7993281447230156, 0.7756204343940993, 0.7669470358799984, 0.06767207819443843, 0.03991778291130865, 0.0, 0.07751285395887608, 0.0, 0.0, 0.0, 0.0, 0.07179476242463967, 0.16380945856581963, 0.15638982949015245, 0.1865307540176978, 0.1439420381152784, 0.08810010760403253, 0.14342992314712688, 0.11960868934907465, 0.12271135406135691, 0.14454846942173827, 0.1363706077001018, 0.15205386501498086, 0.4179008151605452, 0.07562342507802644, 0.07595258693971374, 0.10085989100972215, 0.009622654810422349, 0.11971251489367174, 0.08656082028812961, 0.9635419278602938, 0.961450641869116, 0.9708915749898559, 0.9649898741999839, 0.9708819217002371, 0.9699130103563938, 0.9645196178185959, 0.9598727501526934, 0.9519125322295723, 0.2974483530714632, 0.29416972655491125, 0.3041231130635915, 0.29304185473367905, 0.3059140731683906, 0.31214355285043716, 0.31141974260703886, 0.3010675731599365, 0.2718382469945997, 0.6124283697766755, 0.2692564887533412, 0.19527049888275516, 0.1799664901139345, 0.22034572325689927, 0.25693482328260686, 0.2219618235421864, 0.2055273151767284, 0.3548784326499528, 0.14354796933159109, 0.17110230371835555, 0.16112928990840447, 0.11876966918070853, 0.16924912824732197, 0.16362639446877347, 0.16135660228618287, 0.1245414635667359, 0.18133577524801536, 0.18371067543084496, 0.08175637595542362, 0.11767836562183798, 0.15695832211194716, 0.14572276679317853, 0.19594030960707365, 0.12643559850971964, 0.14233461611711662, 0.18188928120551473, 0.0, 0.0, 0.0, 0.006278050345739361, 0.0, 0.0, 0.01231286726923242, 0.0, 0.014110698012315348, 0.07486433218534072, 0.03418218868535927, 0.10219992501434749, 0.06639833166229114, 0.006745152204742366, 0.006348951707067285, 0.08622865297817495, 0.042817642444231696, 0.03733320078346347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.11446757787577222, 0.07689334995081609, 0.05692154090953705, 0.1105747914752161, 0.10189033060259212, 0.11491952707412945, 0.13127615795380476, 0.10107548199603411, 0.1025124842337356, 0.40420254250648147, 0.3986287649875154, 0.48683489946876457, 0.569194643608794, 0.5416529247893558, 0.3915877653788671, 0.5348450593319148, 0.5638556433008688, 0.5031441642308893, 0.0906152994429531, 0.08807822079530692, 0.1467968601070181, 0.05791451805056258, 0.09434835221404414, 0.09103531363989026, 0.0359729700435546, 0.07518124841982132, 0.06067619346402375, 0.18186180364797166, 0.2574671391606804, 0.2820474915520029, 0.17840314684176906, 0.28955842764755224, 0.2728063624976932, 0.24000589106485215, 0.21906652132738058, 0.21865129599151623, 0.3629808657331559, 0.19194703115192546, 0.2074801001132579, 0.35304682186607406, 0.2403125816743864, 0.26483724510725426, 0.4032669468370246, 0.41373467238877837, 0.42714136608235453, 0.07737604598712078, 0.07958207993074062, 0.09493281865839998, 0.1865880045545234, 0.13573847882241297, 0.20111951649995996, 0.2983240765746126, 0.2551626249568615, 0.2208743950298988, 0.18004814351203036, 0.19261886924626004, 0.202842926408622, 0.17761814627528727, 0.17524363893616646, 0.17194341107617817, 0.19255286798078974, 0.16546741631002937, 0.19295272046941336, 0.16649904206241717, 0.17453921105329284, 0.17730039315842094, 0.18996125473226844, 0.1745478910284144, 0.2142224211689443, 0.1684408413954097, 0.1771474907467009, 0.16864594103911879, 0.16265756129457365, 0.1821281394071147, 0.1512236636643982, 0.169668621818861, 0.1207035396655749, 0.19632588487191083, 0.42179707051549564, 0.7172226096303914, 0.5884422090288313, 0.4865853168002007, 0.20098280882545005, 0.12385141847882986, 0.19878295928299072, 0.4565339692190904, 0.5864375862827225, 0.19806522440929775, 0.5563186082067255, 0.3062711287034916, 0.17739554785661182, 0.19123117374404974, 0.18851607091487588, 0.18348890786432037, 0.18461458101767703, 0.17972994267711806, 0.19101637771630608, 0.19089860725251317, 0.18028350941019144, 0.0692398427611759, 0.07403540666316022, 0.08217734771729379, 0.0672736841762196, 0.08473322797180283, 0.07238169949885631, 0.06094502358167664, 0.062077360336091125, 0.07426412098342972]}, "mutation_prompt": null}
{"id": "c66517a8-c478-4e10-b168-6b1a135248db", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "81248387-bf35-481b-926d-bc1ba2df87fe", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "bb465fd1-3dae-45ad-b99f-968f99ea4449", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "e5808a7f-1c3a-4dd6-8eaa-33189bb3fe8a", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "18033cc8-8afc-476f-bf41-2ae12567fb1c", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n            self.elitism_rate = min(self.elitism_rate + 0.05, 0.2)  # Adaptive elitism\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "DualPopulationOptimizer with adaptive elitism and contextual mutation scaling for enhanced convergence.", "configspace": "", "generation": 51, "fitness": 0.2979968995841268, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7430585836000068, 0.750897876448263, 0.7551132666278635, 0.766121811972621, 0.7493820492392953, 0.7981962329293821, 0.7512654642302143, 0.758252834322247, 0.7504542319110838, 0.09814277193712406, 0.2734147783309385, 0.4743734232319231, 0.2327288262319438, 0.029252736574467364, 0.42080127746962637, 0.39345489455754246, 0.29992601378322836, 0.3132970882752786, 0.1873817899834005, 0.15365427798006281, 0.13475004278949887, 0.11545810113692989, 0.11897091159787199, 0.12906407139272813, 0.14630309028948263, 0.12397444098388621, 0.15760951941237566, 0.15340947675444694, 0.15890432521212228, 0.2092165229846179, 0.07542574355556186, 0.10465686785816308, 0.11854817842974386, 0.06306542953180483, 0.10739191180682106, 0.08018741728122991, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29935072065808455, 0.2998783602941547, 0.29736509342392525, 0.28983612276896165, 0.3094375432531786, 0.347481454946413, 0.303648697282754, 0.3210672195230523, 0.4149686361779954, 0.6201894527908047, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.18751813089789637, 0.7625100929386319, 0.22638249324041737, 0.7902849131432246, 0.12536381320035705, 0.22168342630959004, 0.17813399353097137, 0.17223149766045898, 0.20422023776586085, 0.1674178103389088, 0.1981118135485238, 0.1281977055695528, 0.1592397075966746, 0.12771977237942134, 0.10339805647572464, 0.12415911516635914, 0.17517169602104055, 0.16340980125019555, 0.13767097899394176, 0.1876094920524255, 0.18177487894116762, 0.15581854399474127, 0.2763753779130155, 0.22051323851257199, 0.2841636765624702, 0.0205815324734111, 0.18939302736349828, 0.359266952084343, 0.030342835702031667, 0.3241552821750394, 0.2285748775793256, 0.4866086537518518, 0.36379534683032966, 0.5195465651511982, 0.3386947506420017, 0.436037727637982, 0.45347628058578837, 0.5227052069772427, 0.5370456849251117, 0.46966742916183957, 0.0, 0.14120308738553744, 0.18702454416284442, 0.2168856103938679, 0.20713149522106822, 0.12707428504680485, 0.13530638192914934, 0.1178511535092781, 0.0947120291108915, 0.15612731853073314, 0.08226690400459613, 0.21447708706862, 0.2845579662322284, 0.27749326505291916, 0.2832618688547356, 0.1293258987554574, 0.08335784965720705, 0.10439148035925916, 0.46472845295539533, 0.4714889276791143, 0.504612742426429, 0.49917837251900254, 0.4852240402395841, 0.4792128153969626, 0.5771334180884625, 0.5144507028549308, 0.5251505059343144, 0.10431492915586082, 0.08346185124844907, 0.0902660774311167, 0.06587761511606427, 0.07586740029039996, 0.08250857853080473, 0.0825719612454523, 0.1381271238441597, 0.15485430067297967, 0.26295541840371905, 0.16575244461528704, 0.19023293642666272, 0.17882675250087632, 0.1665706369765938, 0.18145262368338122, 0.17421274580838986, 0.2579341791909542, 0.172411787855966, 0.34075161680508814, 0.2954749148472756, 0.28330232577273196, 0.2981092184221785, 0.3312498182441589, 0.3196436826049355, 0.39433973766947494, 0.39463613231774153, 0.30799747928026666, 0.20128931446434195, 0.3024491205595853, 0.2132297473483693, 0.22906420691232465, 0.22026366174994083, 0.24535915987848256, 0.23712863605043644, 0.22675165084023696, 0.280020797816554, 0.1936950066765265, 0.17747428653919128, 0.15750381711956074, 0.19270596576465815, 0.19266785088409732, 0.16077706967243943, 0.19610924477143576, 0.17952359616594182, 0.17477743113335453, 0.2271718911080849, 0.1774127670730622, 0.18980426392985683, 0.21935930025580996, 0.1991571414157467, 0.19836196568960873, 0.1840796330893213, 0.1741469257761954, 0.1657836599164526, 0.15892740047259013, 0.14856321557046193, 0.18061472807333812, 0.42367790121012305, 0.15903976264724973, 0.17301532362562844, 0.15440766381637472, 0.6739220111092064, 0.5887204233003118, 0.29558553350642003, 0.20442539958799355, 0.26956601383122036, 0.5230607335566843, 0.48234605539407316, 0.5278819699230033, 0.4158034433857811, 0.49485795299310364, 0.3061247560956072, 0.18033167089720625, 0.18209924498755214, 0.17518051249293076, 0.17424510201860155, 0.19767505719537448, 0.18194632022572432, 0.17846789717919886, 0.18622433425544183, 0.1819129333622448, 0.06648514638268266, 0.071357630180368, 0.07381549729252368, 0.07247631223383266, 0.072038941697118, 0.06523265557618929, 0.07895257025046687, 0.06699083197135425, 0.07217102846368284]}, "mutation_prompt": null}
{"id": "099ac2d8-40ea-48d3-a0d3-c1869f5df004", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "7c789e58-e1a6-4512-b8f5-b207bbd8ac4b", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "858ef450-e31d-4822-99c7-64d1a38d73d6", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "57eda402-9c5b-4a7e-a6ab-582ef434f0d5", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "03a8b6d0-9e8e-424a-81bd-c992f62e2414", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "5c49f276-63c0-43af-8146-82253f2efacb", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "6b977c13-9670-4a84-9f65-8d263c3283e6", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "a8ee5d8f-4bf6-46eb-90ca-ca77b138bb11", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5  # New parameter controlling selection pressure\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:num_elites]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation and dynamic selection pressure for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7431124541208286, 0.7489901041463878, 0.7543658159500142, 0.7660970607655837, 0.7464650754836604, 0.7981962329293821, 0.7513237620037481, 0.7586843202417731, 0.7504569149622653, 0.09387368773519378, 0.2908778963244365, 0.4176502204305893, 0.23272882819757423, 0.030732417792354694, 0.4260457330146664, 0.37837045574711115, 0.29992601374713834, 0.31333887731912824, 0.1530413160116233, 0.1555844383262467, 0.14870143749939868, 0.12442932911133853, 0.11897130858598903, 0.12925398231963503, 0.14423678526627848, 0.12397444098389165, 0.15758715050154404, 0.15327006884933458, 0.15890440217976243, 0.3970225016939015, 0.07542574355557896, 0.10465686785814288, 0.11900730916010438, 0.06306542953178274, 0.10359018184905544, 0.08018741728122636, 0.9829120071814903, 0.8690228364030896, 0.8155232964696371, 0.9680673217148571, 0.9708080044753306, 0.9705464826607678, 0.9543355553046587, 0.9458944325769039, 0.9473383920271921, 0.29023596540353136, 0.3015475646900089, 0.3050295128783135, 0.28905141129158696, 0.29992570254340656, 0.34558454084495804, 0.30358406193804255, 0.32094245776687436, 0.4174939817759913, 0.6424737370742679, 0.6591689233269843, 0.6563416590335471, 0.7829263389542938, 0.7745984815307236, 0.19334240148400905, 0.7625100929386319, 0.22638249324042026, 0.7902849131432246, 0.1253638137555787, 0.21853072217315817, 0.1801910659092597, 0.16493027706988217, 0.2041791068406047, 0.16665092634142642, 0.1981118135484865, 0.12843731774976241, 0.15093329066932915, 0.1277197723794199, 0.10422514753885592, 0.12408476659541123, 0.17286074735711032, 0.16192254352252278, 0.12733747228367864, 0.18801549230191772, 0.17904497839804678, 0.1574321326291367, 0.34679862168992515, 0.2018067343961205, 0.2817234694132905, 0.02189031011800746, 0.18939308609150507, 0.3594269240590955, 0.030342835871932428, 0.3896050776276323, 0.22857487762937156, 0.48683987994225897, 0.3637952899178837, 0.4497403559924411, 0.3386947505842779, 0.4360949030279554, 0.4534739097160081, 0.5453078903724755, 0.5265510735660262, 0.4816057017624943, 0.0, 0.13744978890064508, 0.18703410415076838, 0.20938587207136883, 0.2147548991820173, 0.13275824618044585, 0.1353098949862711, 0.11785115350551967, 0.09493693715396334, 0.15612738884387822, 0.0815095877469153, 0.2144885145699188, 0.29152513271819147, 0.26970725986890864, 0.2845446202419887, 0.12467681852784429, 0.08638505974892796, 0.10666197506937791, 0.46002223765077066, 0.4398317986192182, 0.5193085980856564, 0.5209291492107405, 0.5167163090888274, 0.47661401643158674, 0.5519636092125315, 0.5194485930677875, 0.5596048841517833, 0.10468743170661832, 0.09174868912300649, 0.0911476591516075, 0.06587761511607682, 0.07911563662935128, 0.08250781989923128, 0.07950065953026209, 0.14116257152128875, 0.15433028051360886, 0.26295541840372205, 0.16180801521469568, 0.19023293642666372, 0.17500275616249106, 0.16813627757563132, 0.1811532554737625, 0.1751288211921086, 0.25529174192560045, 0.16971496381242246, 0.3435237078526565, 0.2784945999866698, 0.3041325312322636, 0.36616608361508474, 0.3537383472156651, 0.3591415356594254, 0.37699151523488483, 0.4135312368945716, 0.37394370904866936, 0.19471101551716774, 0.30239359440805724, 0.21403502397562602, 0.23887205688920776, 0.22288105832976857, 0.27250463439664296, 0.261789239195908, 0.22341691818845766, 0.29792256265719264, 0.2002393819240076, 0.1962653618890765, 0.16438383202791507, 0.19270596576466292, 0.18453818367906627, 0.16572075755637528, 0.1961092447714291, 0.1918700744652444, 0.17046585352662458, 0.22717188802264132, 0.1827023884166209, 0.1896232916856151, 0.21935930025580874, 0.1991537469142497, 0.19848886755258588, 0.18407963308972441, 0.174213753715309, 0.16569381391297866, 0.1589274001889427, 0.1485632141159554, 0.18061469886268056, 0.42663973908717, 0.15903976264724862, 0.17301533195560637, 0.15440765755757857, 0.6743772069783568, 0.5751197498629994, 0.3701769719884387, 0.20442540751768679, 0.3103654531634972, 0.47293741133804956, 0.47610214467237433, 0.5585618199109967, 0.3519236536797593, 0.47239735137888206, 0.30624032780874766, 0.1803316708972107, 0.17664029729275443, 0.1756968657854412, 0.17511915545095547, 0.1976750571953706, 0.1819463202257251, 0.18040924975303585, 0.17923249302762634, 0.18272659964711546, 0.06902553654734733, 0.07151667629302849, 0.06673317754876174, 0.07228622145279384, 0.07203894169711855, 0.06523265557619229, 0.07895257025048508, 0.0644445194698735, 0.07217102846367429]}, "mutation_prompt": null}
{"id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 60, "fitness": 0.3076865066132189, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "887d5db2-863e-4d84-a2ec-3a609035af72", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "45a9aff7-8227-4d4d-a587-d9d61eb09584", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "31d5f6df-cac3-416f-b809-614c053cf4a2", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)  # Adjusted crossover rate factor\n\n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.015, 1.0)  # Adjusted mutation scale increment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.003 * self.selection_pressure, 0.1)  # Adjusted mutation scale decrement\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Tweaked enhanced DualPopulationOptimizer with fine-tuned mutation scale adjustment and adaptive crossover rate for improved convergence speed.", "configspace": "", "generation": 62, "fitness": 0.29144679720984706, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7633779968320934, 0.7704805448304717, 0.7639138796652407, 0.7294525462967766, 0.7596530686460785, 0.7749527288071153, 0.764751102744421, 0.7611153389445602, 0.7703630149177998, 0.20596127355218863, 0.3059299793636896, 0.0, 0.3533951089890396, 0.39020981718514114, 0.36521385795078454, 0.5779135045349748, 0.25368798136685156, 0.4165797327686651, 0.4514982119451866, 0.1589786034184263, 0.16531935308022838, 0.1330886373983643, 0.11455411182544561, 0.17754530679169256, 0.1269991419848968, 0.08958420640004783, 0.13143538296690271, 0.1501614639393476, 0.15287084564809394, 0.44157833223593634, 0.08865447970267559, 0.10221271509070706, 0.11248098841217835, 0.07512823093439125, 0.10025423740393957, 0.09949050959768024, 0.9574246185954884, 0.8495409532321048, 0.8536846337411385, 0.9539431276361163, 0.9644031896806862, 0.9705455179745314, 0.9543355553046587, 0.9395439471176172, 0.9473176525856848, 0.25670516054693926, 0.20874745720328525, 0.24317997100929167, 0.3147139585257953, 0.32454024814590676, 0.3075504268403634, 0.3200845893071026, 0.3227231145856808, 0.2122624504277313, 0.6063589697512208, 0.7439055316155897, 0.5766982386207818, 0.7314657785367703, 0.739663368569777, 0.3352861269314945, 0.3608322623618523, 0.2939411802102221, 0.3603299937293486, 0.2382103488102899, 0.38671490733716984, 0.18269895495612887, 0.12738859750928455, 0.13343989633164588, 0.13758857583978168, 0.17224033015170426, 0.1889382579183041, 0.14879163182668675, 0.11482295398190667, 0.14062468767201897, 0.13384520430778435, 0.3632530302829312, 0.4364873491654513, 0.1338736716671437, 0.12254515726673121, 0.24043137349509547, 0.1298200309737787, 0.0818981741107, 0.0, 0.23979626170223223, 0.33224683360465135, 0.4382383301163798, 0.19967638185790704, 0.23333294075771382, 0.15916411645336104, 0.3358508705518185, 0.4237472410719181, 0.4950599713561902, 0.43148801229517153, 0.27268699714074063, 0.05823813659539645, 0.5242970494738952, 0.10021688272901486, 0.34653893639043276, 0.2808869568115553, 0.0701555776493833, 0.06850982206991463, 0.14786588342106954, 0.1390568841078249, 0.1801358316931928, 0.2552324177847486, 0.09891265039269004, 0.0, 0.040223888738695646, 0.2666094456753674, 0.2507545243925221, 0.10903617269532973, 0.2042155440088671, 0.25376225098843774, 0.257461825881513, 0.11256269433195631, 0.06179112615922644, 0.12412030479586045, 0.4587584707826935, 0.4726623220678564, 0.5211523454663556, 0.5393835039261888, 0.4754490225158646, 0.4663788546001071, 0.582512696284774, 0.5565482654776045, 0.5741025076976799, 0.09102988705129722, 0.09252203369375278, 0.0827933625830467, 0.09530094153637125, 0.07926274070599715, 0.07931190530586008, 0.11648545453615555, 0.08600807545741629, 0.08163041308878605, 0.1234702464634565, 0.16802783112419906, 0.14479678661505224, 0.15433143049237152, 0.12466971120657422, 0.282582513749953, 0.1898335204744349, 0.2747145754557907, 0.2085956771376638, 0.34410184005579525, 0.2630957544761674, 0.23892529345633706, 0.3565255393882488, 0.3681403421077256, 0.34481724821852056, 0.3940704232740191, 0.35901212095605883, 0.4084728285782766, 0.18262063108357574, 0.19476165695700542, 0.23463374272456727, 0.2808094634651688, 0.2302412745868535, 0.2637441887964658, 0.22605378048926228, 0.2238814266487007, 0.2657562870902831, 0.19215572966488337, 0.1823912754153778, 0.16985585949772286, 0.19094660576391131, 0.19725391607306486, 0.17488632524575864, 0.17568557903495963, 0.18031789569879797, 0.1761947120254972, 0.19905703099090588, 0.20085350987840345, 0.17772386631126325, 0.18430306694955167, 0.22173471119842758, 0.2023194637049105, 0.20816063689221553, 0.175126784604822, 0.226411362366993, 0.19206220526434237, 0.5837819396851612, 0.18488509819878707, 0.1754832393415412, 0.17034996730018448, 0.7665942555417721, 0.5441395874155766, 0.16126647976470887, 0.16874530345425742, 0.16136947153116876, 0.1653853909209001, 0.18139039029322668, 0.19926439917324523, 0.18341573278521417, 0.6263409249483483, 0.31640945614643123, 0.543555747500706, 0.19137134744783535, 0.17873747797207729, 0.17856705097809067, 0.1878191509898528, 0.1719804924939119, 0.1886585188858677, 0.1674843276695599, 0.18856275365027342, 0.21066749625423087, 0.17476590509664314, 0.07543720299548318, 0.06246747548705556, 0.08241377106519465, 0.08188698224316138, 0.07144906611528024, 0.07268519890189418, 0.07271959748986268, 0.07643728515469739, 0.08260008174388389]}, "mutation_prompt": null}
{"id": "035f35a8-c888-456d-bc08-203d176fb743", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "2f057ec5-3bba-4bfa-a34a-78c414aaeb05", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.75  # Adjusted crossover rate\n        self.F = 0.85  # Adjusted differential weight\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_scale = 0.6  # Adjusted mutation scale\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.2 * diversity_factor)  # Adjusted impact of diversity\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.007, 1.0)  # Adjusted mutation increment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted decrement\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhancements in mutation strategy and thermal cooling for improved diversity and convergence.", "configspace": "", "generation": 64, "fitness": 0.3035059651350375, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7415395202218782, 0.7581962682217234, 0.7767760711157952, 0.7752332052642766, 0.7545706363199137, 0.7486588796626965, 0.7410935674748677, 0.7431971778174529, 0.7487702577278407, 0.4510406613506761, 0.029617723307900468, 0.34931813649334986, 0.32580675480879073, 0.043959998993925775, 0.2819328631466105, 0.3540147510389242, 0.38075245718430584, 0.2965369506928829, 0.484873143442187, 0.16636606154656297, 0.41916362178997035, 0.12606787887411242, 0.4056348009577886, 0.12789172777823954, 0.14569158143638616, 0.3976041927121473, 0.4113288851005745, 0.3476452479004086, 0.12899941350197497, 0.12441221737317543, 0.12991270858868864, 0.1297601133859363, 0.12912480041351537, 0.08702039810054174, 0.12735205046971532, 0.09421071694714467, 0.9463082168817606, 0.9221203136912711, 0.960125951970772, 0.9508998045819993, 0.9644862154193344, 0.9728272998068761, 0.9433252454676125, 0.9353101169840874, 0.9695634712797365, 0.31793359626413187, 0.31371205064178376, 0.3416489086678003, 0.3535637520371736, 0.33126876609938893, 0.3189804455763452, 0.3318052115752723, 0.36537021237868417, 0.3621261876960147, 0.5851299944048913, 0.2158364105978734, 0.6028484199849444, 0.758792578420001, 0.35829067851793084, 0.7425313145655205, 0.7493877626759526, 0.27027282157871235, 0.23189423707894508, 0.15926288629673147, 0.41866963504830057, 0.1666015508114459, 0.17186532258827425, 0.18953545857461318, 0.1557344589069024, 0.16006514980655207, 0.22942442155161047, 0.2087467727202137, 0.1714928115697919, 0.11810653388257564, 0.22286036276153554, 0.22849551950278424, 0.18227044945286885, 0.16134032167169465, 0.1680429468309259, 0.14216084928394468, 0.20798250150900477, 0.0, 0.258799040378349, 0.18331495217313287, 0.2623366088521899, 0.2041801516170526, 0.24691120099214425, 0.30140530813100286, 0.2565656827401326, 0.07255163271426701, 0.439965360636314, 0.31510698174182616, 0.27860766326421593, 0.32811642667586316, 0.3603809980881999, 0.3593502361726091, 0.4344519310812398, 0.4653978494405371, 0.5105307088985194, 0.0, 0.07106096320053767, 0.12701160271989953, 0.05833805524378621, 0.0, 0.22396791408711514, 0.08189123365718931, 0.04708256377015807, 0.12717638792754227, 0.09060411286435588, 0.13237638082508651, 0.26932670063735875, 0.2691548234446488, 0.23911836258999497, 0.22727415947030227, 0.11041746932611929, 0.12225915663389009, 0.13274930317623146, 0.48889398323240796, 0.46856560442018413, 0.5170676055571479, 0.5446592066340392, 0.5095330260370826, 0.4987835698605969, 0.5280245776908894, 0.5166710919616628, 0.5181566948110835, 0.09909705130800461, 0.09629455639221818, 0.08890709349112336, 0.09880720717569602, 0.11465580382225493, 0.08849957750542303, 0.1224580202579757, 0.0942597902670319, 0.09269089904334027, 0.27837880840900364, 0.13636058382087046, 0.13556040662776325, 0.2862087152131618, 0.17353742076405632, 0.1460834020775481, 0.13402100527262972, 0.13635964008438073, 0.1421755568948454, 0.29610846562604165, 0.2656810788416025, 0.2827438300148246, 0.3280212123284435, 0.3534684780049384, 0.34072942653492777, 0.3982913129559845, 0.3681356202808922, 0.394098249261134, 0.19341208793583164, 0.14535007430006608, 0.21428290985868093, 0.25263243117243606, 0.13434564875204635, 0.22716316632067102, 0.24710756420649793, 0.29527398814579187, 0.27096840610486084, 0.17154591853482704, 0.17061199949775652, 0.1740997222642494, 0.16496500045924745, 0.1917590960277541, 0.17262266605617282, 0.20860822695004877, 0.17564274666598945, 0.16799956749330924, 0.18483985144349824, 0.1779154854079994, 0.1760094455726181, 0.2010578292074392, 0.18829236451694187, 0.17907343350614702, 0.17246241645655758, 0.17193136083621718, 0.22503417304224405, 0.17629905528368106, 0.16456327185110353, 0.15198967672740582, 0.5031899352863882, 0.19710518662028442, 0.16443853680667486, 0.6608026668300417, 0.5076368755661134, 0.5294892348834015, 0.5478315381547072, 0.5289625942358152, 0.5558447368774443, 0.525809418894553, 0.1923563418972739, 0.5021988231443952, 0.42283298527178637, 0.523730930119088, 0.5860160105568624, 0.20110415440520912, 0.1743428331737621, 0.1895837568953902, 0.175529702250807, 0.20714493296783343, 0.17750000154907752, 0.18177118962944772, 0.16556326873078064, 0.19006915218464793, 0.06746825063127815, 0.0712753599718926, 0.08176653292192715, 0.0681646738865751, 0.07741627228463654, 0.06533349007317013, 0.06971617916765749, 0.06900945750224241, 0.0755599867683483]}, "mutation_prompt": null}
{"id": "30b3569a-19b3-4dc1-bf12-6b04bcd872c8", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "be13810e-8943-41ee-b559-c733895bbd73", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # slightly faster cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.15  # increased elitism rate\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.015, 1.0)  # faster adaptation\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced population diversity and adaptive mutation scaling for improved convergence efficiency.", "configspace": "", "generation": 66, "fitness": 0.291386134195352, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7882032621241536, 0.7650988738519368, 0.749628971163969, 0.7947120577606752, 0.7786394848230319, 0.7742774424448009, 0.7751468712127938, 0.7771403024866986, 0.7670706823146674, 0.17003057458797266, 0.2685882694547851, 0.10968329404827803, 0.058600570597177826, 0.28001974049626777, 0.11145447430050137, 0.47567034414815457, 0.4365389733508094, 0.0, 0.16572124600187688, 0.5389487674535879, 0.4953173380412629, 0.13986431884501982, 0.14060807930690566, 0.12333111080437142, 0.15828537888679184, 0.14800286059767964, 0.139814690284069, 0.44265210182553094, 0.1617121272565546, 0.1511450111526732, 0.0922702983065119, 0.08542824487948053, 0.13741104522576575, 0.07207848528775196, 0.0797877462823775, 0.13008055655358164, 0.9678573115749345, 0.9803395842987426, 0.9445902823546959, 0.9616820492809861, 0.9800748860419486, 0.9740907423734446, 0.9618300079862735, 0.9461027018342556, 0.954877393564915, 0.3049495176579955, 0.33549707756927016, 0.2843441641895851, 0.29352955392042146, 0.3509786745738799, 0.2976216732344227, 0.2743040486164571, 0.30602278046150866, 0.28675342409500215, 0.6723363340095031, 0.21787514301064737, 0.6743432436667541, 0.8323754547739406, 0.301776028752648, 0.7984329332115965, 0.21635641501724157, 0.22992511828467233, 0.8256245769827386, 0.2041385303146288, 0.17628558410405148, 0.21080240453183485, 0.3829298639746118, 0.14333052278196157, 0.1516001964127428, 0.1758960473981298, 0.17235217420276783, 0.18505535855231525, 0.15376804513023812, 0.10489442666731918, 0.2447701300612407, 0.12796734608841942, 0.1584039837284661, 0.29734254292496465, 0.1730901059242662, 0.13320481372195137, 0.19049321763990834, 0.23264912964628226, 0.21670255361450153, 0.0999863933546794, 0.03987972009469265, 0.1425794524007914, 0.047504911883574086, 0.14734402448640527, 0.05179605167393764, 0.37694961975006736, 0.19491546151032713, 0.5700477765272931, 0.2919686725656109, 0.5943372879637359, 0.3036357664962328, 0.28173256670033, 0.5667405417796492, 0.43797863119464675, 0.5873258064159415, 0.22041136762769964, 0.07782011448985138, 0.09053451219632047, 0.11669337752109843, 0.10856698790223673, 0.11179380461115995, 0.11317107595440323, 0.1417760128638631, 0.060927625580121325, 0.12299304507807973, 0.0809064136764901, 0.1499248605386605, 0.1050845323520252, 0.15078486897028254, 0.23273763936162906, 0.23649435638698846, 0.11785212637467923, 0.12896120209971718, 0.46259330319193337, 0.4675941076108513, 0.4750329215149619, 0.518841812538752, 0.5085980050939014, 0.5005410350334363, 0.533831758711053, 0.5752574937148083, 0.5548034648769875, 0.09026103897434656, 0.10169577293442689, 0.09100992452906254, 0.13552070199136046, 0.11350822414026918, 0.07723288705224818, 0.09774559348821732, 0.11274504848929301, 0.05063672791549345, 0.12546565735234838, 0.29028729542024634, 0.2932296466297476, 0.2541104603910057, 0.29013832064441425, 0.19431124855174953, 0.1371132713389468, 0.1249298707167269, 0.12703011424075705, 0.27563837405736513, 0.24777318401370363, 0.3142236368752631, 0.3256417063801701, 0.38364528724640423, 0.37748627375170796, 0.3790076162838335, 0.38778587193750413, 0.3813373444796274, 0.2190296730016139, 0.2881927056848682, 0.20951260979379716, 0.27132897758550334, 0.15399175098651485, 0.21929250063245487, 0.2585286887182736, 0.2785147886996834, 0.2950554785038122, 0.18284335635759408, 0.19219384836613396, 0.1609816814606151, 0.18871413162445216, 0.1777945836347422, 0.17444736843230402, 0.16075890013791982, 0.1833494005552111, 0.1639836364481, 0.18173816148908295, 0.18893359861518966, 0.17763204624151896, 0.19016105020738383, 0.1922243208020631, 0.1826084454574204, 0.17680646801057698, 0.17886492846022106, 0.17692628613862138, 0.18329048998877429, 0.16567489422834114, 0.1674854177995534, 0.15116257885200923, 0.5471177729217668, 0.20927824099178804, 0.510869188532936, 0.632006965642098, 0.17649873050505283, 0.5173040251202847, 0.20504508363630825, 0.15968752101659833, 0.19253943150256325, 0.5717587423582966, 0.19958559479755056, 0.4797129170961272, 0.19723910922762866, 0.19983168871565993, 0.17025891032472684, 0.17198527424280763, 0.18569551707135523, 0.1755519612690356, 0.21256282865056397, 0.18342387949396777, 0.17866633739431415, 0.17894971933741677, 0.1872816594590938, 0.06579288717787934, 0.07860450977859623, 0.07149539349575429, 0.06906831535498059, 0.08010103652692391, 0.07449398531651108, 0.06981405622376335, 0.060771584002669576, 0.062496046682960715]}, "mutation_prompt": null}
{"id": "9dbbb821-190d-474f-bd02-36a27bad67c7", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "7b33098e-999e-4b9d-b06e-2faebfdc2286", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "047c48ea-490f-4ced-985b-5ecd3c8b6865", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "9dfcc5a7-0b12-4b0a-9e15-9734d480771f", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "8a869641-86a5-4445-8dea-c6c28df2b26f", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "6c22eac9-98e0-4c1e-84a5-9bde67e2ec2d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "f5216279-40c4-4ef9-9e5c-9292b54daf7d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.75  # Slightly increased for better exploration\n        self.F = 0.85  # Slightly increased for stronger mutation\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted for slower cooling, allowing more exploration\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.12  # Increased elitism rate for better exploitation\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.2 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.015, 1.0)  # Increased mutation scale increment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.007 * self.selection_pressure, 0.1)  # Adjusted decrease factor\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Optimized exploration-exploitation balance with adaptive mutation scale and enhanced elitism to improve convergence speed.", "configspace": "", "generation": 73, "fitness": 0.289050845311491, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7331424615674178, 0.7303087963368498, 0.749906776474691, 0.7563160700663224, 0.7718334804323055, 0.7570030427869001, 0.7590871160023265, 0.7702265373100896, 0.7197881839196493, 0.31281259193518884, 0.28916097866419554, 0.407349536953278, 0.33028211374756644, 0.3731352783612878, 0.4015211296078153, 0.2653871371473584, 0.015910859413436063, 0.2534435636604483, 0.1382686834247997, 0.11513726252032597, 0.14277957544183095, 0.14797061766341157, 0.11947259353059214, 0.4846246879520957, 0.13102200430341782, 0.13231740119447566, 0.15610879166778613, 0.43083789444751963, 0.14028650017886446, 0.1559817753096342, 0.0811198310562884, 0.10111614646968614, 0.14560045084963635, 0.10887293911249307, 0.1264010930961087, 0.09446402522305575, 0.9133889920174252, 0.9221203131447018, 0.9601272342228859, 0.9388223149144519, 0.9636538758722564, 0.9728272998068761, 0.9439015875036839, 0.935299358436708, 0.9695634712797365, 0.33159775514770784, 0.3047982884428089, 0.28156913741106093, 0.3159991408007462, 0.4347734224812011, 0.32629363210422435, 0.32429859333276345, 0.3020681874741368, 0.3267844563980571, 0.659752017581444, 0.6838645029343923, 0.6490967485503757, 0.6151214408613461, 0.7474228880079499, 0.20720091135254026, 0.34499862440302553, 0.7032597152382307, 0.31713375718451264, 0.13692095728344666, 0.17517265769322854, 0.2104698722432985, 0.14812406161826308, 0.2045313432994148, 0.22641494017326158, 0.2040462190435941, 0.23111771172629958, 0.14888027208802923, 0.24182706912265217, 0.16524343790349427, 0.15921941025198372, 0.14559382799958365, 0.24585927864395185, 0.17963093059313218, 0.17843298119415574, 0.1536324508635023, 0.17864864857379958, 0.3359287448104733, 0.09110557493839355, 0.13391859497852332, 0.06794680972907152, 0.0004693177201632315, 0.08898082014953401, 0.13295931633453761, 0.3364674416223261, 0.10014591211939461, 0.10847749645749227, 0.14520499125334374, 0.10164510375277513, 0.5947706715879517, 0.5075552043387831, 0.15348530240100733, 0.5054438952724101, 0.44962246699491903, 0.4316214222020205, 0.1360839271840456, 0.18848563874910274, 0.05569599962056637, 0.1155070945044483, 0.08258044646940033, 0.15718688382481338, 0.09828107941629838, 0.13050322216409038, 0.0642785261531259, 0.2292510690165881, 0.2296847791848552, 0.30338886766572515, 0.23110014881146657, 0.16898705895697963, 0.17024752200290327, 0.1269505410740709, 0.1272968641437181, 0.14633809502075712, 0.5241078436421382, 0.4826284056031266, 0.5180516897559992, 0.5226643411847096, 0.5124444804570578, 0.4919651256626725, 0.5432610344198591, 0.510271700808031, 0.5416825240695732, 0.09059686006541612, 0.09042824921402048, 0.08884998289284851, 0.11515753091113312, 0.07627975224216754, 0.11485259591570351, 0.08940731474595964, 0.11595148467616423, 0.08659630537522045, 0.16071236399012445, 0.13891517136368026, 0.15546553601248292, 0.12403573855022754, 0.13943483629233, 0.2819040953416969, 0.2957704160170951, 0.18027100264186813, 0.22591305161763398, 0.29049498965391807, 0.2303749867636209, 0.24866633826275342, 0.3411485992413197, 0.3467336068065284, 0.32135409415054983, 0.37611297178662606, 0.375337471186185, 0.4525225579000358, 0.19312669666140359, 0.22455002024462234, 0.15428506035303513, 0.20294420415751468, 0.20428947424897403, 0.2695750310415679, 0.2600191830520723, 0.2459907520564375, 0.2781604818681094, 0.1856601951220579, 0.19827339930382126, 0.17465196494535484, 0.1992683908832853, 0.15347209224700253, 0.18385543121820236, 0.1671327645134676, 0.16859507635725568, 0.18053166043757696, 0.16663330391973197, 0.17840666620253864, 0.1964911392042532, 0.19298391624014544, 0.177460564202521, 0.21173200112583546, 0.1765495344246707, 0.20341794633850308, 0.19213198921371555, 0.16499909519874878, 0.7450718884107339, 0.15313153183201356, 0.17951777062683782, 0.196787050743783, 0.12518758439091948, 0.5941896993597156, 0.168488568825231, 0.1659420044408615, 0.16440147830288587, 0.5682575989239826, 0.206231317057178, 0.5474914811542151, 0.1808883108937681, 0.1661693973905125, 0.4091278406372255, 0.456735868594089, 0.19183694355857384, 0.21111257302258868, 0.21999371586169114, 0.19295867731418026, 0.1768342538341069, 0.20266400359982906, 0.1749974507085581, 0.18761554140965486, 0.1940089559849455, 0.20210520542035726, 0.06781339363880512, 0.06886249817066947, 0.07197447014760583, 0.0632051326246772, 0.07565869861910124, 0.05698388524743059, 0.07556076581348803, 0.07149860119387486, 0.07002682984950315]}, "mutation_prompt": null}
{"id": "bbd0b3c7-8ff2-4f8a-a629-368e7d817144", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "57f6daae-3711-464f-b344-bac1f16b8d00", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score + 1e-9  # Avoid division by zero\n        dynamic_crossover_rate = self.crossover_rate + (0.3 * diversity_factor)  # Slightly increased influence\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.015, 1.0)  # Faster adaptation\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.0075 * self.selection_pressure, 0.1)  # Faster adaptation\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Improved DualPopulationOptimizer with enhanced adaptive mutation control and dynamic crossover strategies for faster convergence.", "configspace": "", "generation": 75, "fitness": 0.30146374952450355, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7407872345229843, 0.7561995536989985, 0.7523536106388182, 0.7591088890947955, 0.7623894889606286, 0.769868789873887, 0.7818836286636995, 0.7591925624660367, 0.7898462246632079, 0.07049894918256905, 0.5431831995529108, 0.28417685737368725, 0.2668014321004236, 0.30645267767508544, 0.4836411737469293, 0.30590606897341344, 0.3994543379207137, 0.3373680666687833, 0.15112377266021282, 0.4795922255589711, 0.4457938710723207, 0.14463015134481083, 0.13616672871038682, 0.1265402599164177, 0.1545838470965626, 0.10270853776650779, 0.1719239640483785, 0.1331520219303034, 0.15408757631912973, 0.14138553424684763, 0.07387428991800138, 0.09324387496269138, 0.11759132887350221, 0.0420304543809461, 0.12058272884103827, 0.10170171491189828, 0.9830088772468145, 0.8499157561877198, 0.869734700411936, 0.9612958106451388, 0.9473445975446844, 0.9705455179745314, 0.9543355553046587, 0.959420131405006, 0.9203875530979886, 0.3126332554791825, 0.2932956596881142, 0.2875415933888825, 0.37131772805875596, 0.29818774865523423, 0.3827284146833132, 0.3147041852042781, 0.3452182993239108, 0.3198588798466817, 0.7026868992348277, 0.7261867077062173, 0.6737578346364762, 0.7969961097850689, 0.1873031349216977, 0.23896605321312203, 0.3043052449717877, 0.3526230938732773, 0.35609465319942446, 0.21453422616011208, 0.17749931377803574, 0.23532327284821108, 0.14746172370702082, 0.17783519761027933, 0.19740014659655802, 0.1544553725129867, 0.1966998120813298, 0.2369471798737549, 0.12727978011497254, 0.23524202980700804, 0.071721667906814, 0.18024351168636366, 0.25854455212783345, 0.1412829565599628, 0.17323844981956515, 0.18773766035078732, 0.18504479426540765, 0.31599974649218043, 0.10167930761374722, 0.39989508419900144, 0.3319178767899138, 0.4740213995374386, 0.05790718101595849, 0.4808401741926658, 0.3236494611820594, 0.3386404322236475, 0.40140996654898375, 0.49156035703192524, 0.47826592165882253, 0.4030291720644631, 0.2149244765966678, 0.530885480963738, 0.5470756398962393, 0.5050528946595585, 0.5521410505841731, 0.06841291809375194, 0.056675731151935915, 0.065336051315526, 0.1688017636622997, 0.09308870225597965, 0.21724906003459432, 0.0315192812963212, 0.19825884479382516, 0.1386542881289664, 0.22989636429010707, 0.14983612209725783, 0.25719751294000603, 0.2031467014947782, 0.22894715636283258, 0.2732606669122324, 0.1258863784034151, 0.08604199885443431, 0.09230800261218663, 0.49047939420742537, 0.46043437128724085, 0.5633828759713863, 0.5120371932590386, 0.5186281693794106, 0.48079179650815196, 0.4904842518160112, 0.5596676498098028, 0.5463472949366475, 0.0956532939942637, 0.08530350495265815, 0.10268993679270366, 0.06945738043261607, 0.08580973897494437, 0.07831590633861685, 0.10133250420078443, 0.11904117578768059, 0.10616830902200602, 0.1924410446296575, 0.18431831853207348, 0.14452114368434144, 0.151059671199679, 0.27858963410847937, 0.2561906735274162, 0.20677404879008043, 0.15608761250597314, 0.16934512696892412, 0.29836884216683957, 0.23980423862471412, 0.29728956773920445, 0.35560752863477874, 0.31861197868119606, 0.3296953216136661, 0.3946451281437401, 0.3547503213714105, 0.3366853631094564, 0.19671367805074613, 0.2835824216201841, 0.23560457481666652, 0.269922351258449, 0.25046874397653374, 0.27069995122799095, 0.2523967303045971, 0.2675842462135173, 0.22462632505729585, 0.16052493010913427, 0.1791600979886121, 0.18422975453395873, 0.17609503033138751, 0.17499246609144103, 0.21398618390923807, 0.19357287794869438, 0.16407781776184094, 0.19488801652964116, 0.20442827617030201, 0.1920455703412034, 0.1824594746926842, 0.18641385231275798, 0.17926783928523093, 0.18779413347129748, 0.19361080391247998, 0.19486751156754667, 0.19869464690672467, 0.1646455436818991, 0.47857990143546625, 0.7199501296619434, 0.1866258265163444, 0.1632729150486948, 0.16229161783122548, 0.7334606104118768, 0.7175386139358262, 0.17788790463904736, 0.16270224515295684, 0.19611732907761226, 0.15812482611525158, 0.17111395190417866, 0.36183533686904434, 0.4259325531184457, 0.17973602250061227, 0.3935265481021294, 0.19805064502668257, 0.17585847750459582, 0.19166078906158723, 0.17480814664255973, 0.18753004314717936, 0.17586573489414037, 0.17424814072319728, 0.1799174086027897, 0.1845123427254306, 0.1875948904929301, 0.06833643011675739, 0.06907023340811447, 0.07020597615144653, 0.0708347580183234, 0.06617554431018458, 0.06261407707144828, 0.07748422282763856, 0.06626747971136537, 0.06614962297679561]}, "mutation_prompt": null}
{"id": "1fb68d53-0ee7-423d-9d66-db04ed7415fe", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "4a77d76c-34af-4282-a6e4-6506151486ff", "solution": "import numpy as np\n\nclass OptimizedDualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n\n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size * (1.0 + diversity_factor))\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.01 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "OptimizedDualPopulationOptimizer", "description": "Optimized DualPopulationOptimizer by integrating adaptive mutation scale and dynamic diversity-based elitism for enhanced convergence speed.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {}, "mutation_prompt": null}
{"id": "d4ee1232-9612-406a-a831-db05daa21cc7", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for faster convergence\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.012, 1.0)  # Slightly increased adaptation rate\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2) + 1  # Small increase for exploration\n    \n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced population dynamics and adaptive mutation improve convergence speed by optimizing diversity management and exploration.", "configspace": "", "generation": 78, "fitness": 0.3056264825649645, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7723359635673529, 0.7621121862036733, 0.7543484208001661, 0.7801845697709748, 0.7578391169468714, 0.7615097569938798, 0.7801413620872839, 0.777477450231671, 0.7611924190647567, 0.4458374103668383, 0.25462849822418976, 0.4320305887899887, 0.40139379451279134, 0.18489325731913797, 0.05654972261105906, 0.07217103044931594, 0.35013305404480866, 0.4316062880984167, 0.4734025695035414, 0.3271731449733808, 0.49380411042781436, 0.11655789608051981, 0.164089678227906, 0.1290843398228606, 0.1626998417338218, 0.10446592607586314, 0.13944186986550322, 0.43604210779223007, 0.4196515513155046, 0.11995013702436297, 0.08883743903849295, 0.11944058675830671, 0.1251273025887718, 0.06540451519436463, 0.10762065057159631, 0.09695203941001895, 0.9546554585388671, 0.9397113885353503, 0.951361021783415, 0.961100415941048, 0.9675320365608384, 0.9705464826607678, 0.9634662424209138, 0.9427297641412629, 0.9472561407298942, 0.2854084651099046, 0.33991362502358236, 0.3989823789061949, 0.3681781838948476, 0.4108246761372054, 0.39831939022699436, 0.3316980257463825, 0.3262738038541184, 0.30810636598002106, 0.5490948287782624, 0.34087334920419843, 0.3051684956209869, 0.7602171836015278, 0.3590015287371451, 0.7600543233949604, 0.8023664376914255, 0.6769807914952497, 0.3510071195388058, 0.2829719805254258, 0.19521449626666876, 0.15171079656395325, 0.17431348882888942, 0.20413558639720997, 0.13518806548113715, 0.16183050219636075, 0.21273294081772953, 0.21585765648646338, 0.1684684499126593, 0.13464617394409506, 0.16325771322520755, 0.22412864212552663, 0.2168448623463708, 0.13120622666010184, 0.15728670660979827, 0.14251636661828526, 0.1334180015515094, 0.2453588449113272, 0.08361960631451715, 0.49522466728757786, 0.3804646892650563, 0.06791876260655949, 0.3431590949152694, 0.1669490752774947, 0.1903549110374907, 0.2761855319865314, 0.26438100634008477, 0.49388391943389587, 0.6812011251255319, 0.45214170032466805, 0.34556214539704133, 0.4411672469734411, 0.32035207519064013, 0.5743035730561047, 0.2333875790646186, 0.18000581005721472, 0.053376437827205914, 0.10613917249944882, 0.10344613732501551, 0.0, 0.0, 0.22433756421919393, 0.14496449430121483, 0.1405017359494175, 0.10775157189497664, 0.12103016812232203, 0.21862537490727907, 0.24119378042670336, 0.2857306296515181, 0.3177277977444789, 0.09525931533924448, 0.11358791734885654, 0.12348912848255955, 0.48285487643548997, 0.483402230365222, 0.49911758107779247, 0.4971453414396003, 0.5139379919627204, 0.4679750057575818, 0.5393261133561814, 0.5687145003901105, 0.6009454015839166, 0.08707110557324627, 0.11771405939827195, 0.08339065272065349, 0.0783119643432294, 0.32591483553366685, 0.1043163244824793, 0.12071069082379249, 0.13409206161814857, 0.10064586469420533, 0.2126464293884014, 0.13888992442299952, 0.17006781760072753, 0.17470407392911225, 0.181799191186093, 0.1325339993357022, 0.3154754838751145, 0.21659036370118478, 0.17578093425495445, 0.3005438132239806, 0.25423139464493616, 0.28384399423039786, 0.31212864992000744, 0.3035773001692038, 0.380858877156278, 0.3992363666661598, 0.37916499706068696, 0.4209095816561824, 0.1833581168849585, 0.2019234997074032, 0.24580442558266724, 0.3097525511999244, 0.2691225899492816, 0.2883132783523884, 0.2194594638073245, 0.24368385919193114, 0.24583275509048153, 0.18815189524990306, 0.20412699031613457, 0.17080203739234745, 0.19300748183200056, 0.19125458676555696, 0.1974747641352671, 0.18237545347740824, 0.20831088007091036, 0.17725640618691418, 0.1681955978050873, 0.19041377838708562, 0.1814076962751182, 0.2058876342251752, 0.19189502946706338, 0.20248136575047748, 0.18879721463088006, 0.17189704939889694, 0.19874783385459915, 0.7109955397287124, 0.16656110701394244, 0.18463566065736425, 0.16820261537444914, 0.16694067422046788, 0.174207548867793, 0.1410450097178415, 0.7528533058590027, 0.5589309588682472, 0.5693732908946926, 0.1619696633046518, 0.4600389253346372, 0.14790229135251343, 0.5212605023841321, 0.3268998186288312, 0.1822743238476654, 0.1614419787641146, 0.24642551417074, 0.17289249076852653, 0.17871261287314633, 0.19376981295048135, 0.1850903037307996, 0.18044678662633318, 0.1918574647310315, 0.1964242453713475, 0.18101352340464316, 0.19067988960207982, 0.07471461319323591, 0.07861523692989159, 0.07721689265971221, 0.07211463122950512, 0.06511689075538363, 0.0628898535523793, 0.0738246536329229, 0.05556321407448106, 0.06864459208691365]}, "mutation_prompt": null}
{"id": "ced47d90-bbf7-4c5c-a6c4-d867e47e9238", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "1417916d-0a46-41e8-939c-23ac169d2478", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.99\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.01, 1.0)\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.005 * self.selection_pressure, 0.1)\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with dynamic diversity control and adaptive elitism for accelerated convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7650314185522253, 0.7392474615616685, 0.7640555325461587, 0.7573646058056375, 0.7420524929426843, 0.7573781715680019, 0.7823232813062699, 0.765896752701678, 0.770527245238398, 0.3749504185404189, 0.35934655622620904, 0.3895175621442408, 0.38956445631278025, 0.24060720598170426, 0.41329485537509214, 0.46660143710997204, 0.36626093171821505, 0.441870513314768, 0.4698922755427801, 0.418723905152355, 0.1504899605214468, 0.10557828366192734, 0.12288483251392446, 0.14845738951565612, 0.11944713866842738, 0.11853459244123299, 0.13846538810058917, 0.39039548692267156, 0.13080840358856827, 0.1493506501434, 0.06611462125094336, 0.09839559740463155, 0.12927788516253436, 0.09807012912049817, 0.10680223889907825, 0.12269349494947146, 0.974169984305751, 0.9109062128979039, 0.951215162929309, 0.9612965621186202, 0.9473458763834367, 0.9705455179745314, 0.9634662424209138, 0.9228125680467572, 0.9577638541503228, 0.2947902248549722, 0.33378297995012274, 0.34419158433150887, 0.2939613159986808, 0.3983280993170478, 0.36592382098771103, 0.29760018578209646, 0.31522965164078054, 0.28724652045262067, 0.3248576904922905, 0.6768884673749416, 0.31688317891994067, 0.7408743179209307, 0.7008366232452917, 0.8106242655890387, 0.858333563279612, 0.6439915597628507, 0.6139085634733963, 0.1453477847123955, 0.11153425101888736, 0.18294555660159628, 0.1772797248803044, 0.17105853950381478, 0.24311992900866275, 0.15733988598473736, 0.2064597133013233, 0.16980229840634997, 0.17423287231016515, 0.11462048191585217, 0.12022741041570184, 0.23623238157148507, 0.19338118165825824, 0.17205184047554067, 0.4271722860279056, 0.22852344545936198, 0.15075506000127148, 0.0, 0.0858480756647092, 0.0673748209413072, 0.07996772606274993, 0.4771522993956785, 0.4531893296836984, 0.05245449856126527, 0.10538902001450601, 0.3107010815515332, 0.1198874650146865, 0.590558016044482, 0.15337540253538662, 0.3855779974100798, 0.5334237951936377, 0.39602301302287823, 0.4622098681500658, 0.30001587522654904, 0.45786304666564004, 0.0, 0.0475153392728318, 0.08025576985812732, 0.0, 0.15689140915183197, 0.22715199112190243, 0.17685835932537664, 0.2475275315643798, 0.17449215372897875, 0.24219198533444508, 0.15488403243529503, 0.2945311607387324, 0.2891793590755125, 0.11856119293416378, 0.11816230631679359, 0.1219509613919465, 0.08566735914704893, 0.11999768436307279, 0.4733143229279059, 0.44577298543556454, 0.49156892323044377, 0.5263404825070057, 0.48101307875244415, 0.46729437768901994, 0.5452605102923025, 0.5137911251282345, 0.5713071553134537, 0.0851164427896276, 0.08666779066286512, 0.09323837761366427, 0.06617735616650533, 0.13259673969387098, 0.09591479034355, 0.10943717811420939, 0.09126120668001136, 0.1098385335314519, 0.16237462493340915, 0.1680714087884393, 0.1881513011564716, 0.17040663944409828, 0.16291029887481467, 0.22650685167621631, 0.33570179241188725, 0.21174678598048535, 0.16673803144046373, 0.2847608236721547, 0.3045928313042374, 0.2584737694465564, 0.33317461475500476, 0.33391093605705624, 0.3304284941362945, 0.3705564995498235, 0.33018435816525094, 0.38191195263562094, 0.164428160544695, 0.21766251538684955, 0.21455477887266083, 0.26737021563858354, 0.2311743122713491, 0.35601897861325593, 0.21563375593294176, 0.3002748975895706, 0.2770517505005642, 0.1868617442002114, 0.17571724271873845, 0.2029073670790803, 0.19014799091893575, 0.1761514019902366, 0.17403944062436916, 0.19211112928603014, 0.1791641005709309, 0.17253768982881934, 0.17086191374099746, 0.18379858077739242, 0.1951181104771912, 0.1952390889638812, 0.17118698408481414, 0.1714494646419945, 0.1773118259422789, 0.18742666762008864, 0.19185768550196158, 0.7045947966901575, 0.15930136813207862, 0.15051868340400798, 0.8163060999318706, 0.17982324245743553, 0.3201214569028852, 0.16706949865062581, 0.5177427238522383, 0.4402683859127009, 0.1649162241614246, 0.1645646150904917, 0.4603068057507995, 0.33108812016065325, 0.5601191932548466, 0.5728054651533521, 0.47187258232171625, 0.5057908683523773, 0.2046902125150224, 0.18056705299050024, 0.19144375991606888, 0.18913315752039794, 0.1928514259124683, 0.1807166923206387, 0.17929015383351166, 0.18236179307839107, 0.18276833347887256, 0.1849313536122098, 0.07913628696964292, 0.06609351945961295, 0.07153963332278546, 0.07716093059089402, 0.05894477969869916, 0.06449062029757302, 0.0691772329592375, 0.08109529177655095, 0.07514954514315464]}, "mutation_prompt": null}
{"id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.3100528246491722, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "3b9beb2c-0cbd-4d52-bceb-34c59b538702", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "0215d4aa-ca32-44b2-80aa-559b7d6662e3", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "bc7e600b-416c-44e3-9c84-6b2ef7467fff", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "82f6bb6e-9f91-4189-b032-0f2a21e5b49c", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.72  # Slightly adjusted for better exploration-exploitation balance\n        self.F = 0.85  # Increased for more aggressive search step\n        self.temperature = 980  # Slightly lower initial temperature for faster convergence\n        self.cooling_rate = 0.975  # Balanced cooling rate for better convergence control\n        self.mutation_scale = 0.52  # Adjusted mutation scale for improved diversity\n        self.elitism_rate = 0.12  # Increased elitism to preserve top solutions\n        self.selection_pressure = 1.45  # Fine-tuned selection pressure for diversity\n\n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.22 * diversity_factor)  # Adjusted impact of diversity\n\n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n\n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.018, 1.0)  # Fine-tuning mutation increment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.0038 * self.selection_pressure, 0.1)  # Fine-tuning scale reduction\n\n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n\n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n\n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n\n        return best_individual", "name": "DualPopulationOptimizer", "description": "DualPopulationOptimizer with fine-tuned parameters for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.29973904112318683, "feedback": "The algorithm DualPopulationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.6962193805240138, 0.7287533011743874, 0.7238474785234472, 0.7681106516952813, 0.7450976841550008, 0.7299727802727949, 0.7426402053410124, 0.7588012271940626, 0.7356670952736516, 0.20297723680610436, 0.3848600789655988, 0.3153417589071763, 0.2018451031556885, 0.3594248327829519, 0.3922492942935283, 0.1563922534258616, 0.4428867364646727, 0.3259771572669441, 0.48204823029983235, 0.43971542521583906, 0.4252515187465168, 0.1592423178109713, 0.1480798368662778, 0.15561754254625015, 0.13921983567451424, 0.3914403939971236, 0.4430795549871346, 0.3837373666977153, 0.155660503168096, 0.15345396027798763, 0.12846729310184857, 0.11833421655491039, 0.14837255754205814, 0.0934153231025795, 0.11748287490961207, 0.12896353152233064, 0.9489245671357533, 0.9739644218465884, 0.9554659567454469, 0.9501052204473719, 0.9834962620680292, 0.9551886923559993, 0.9564180188794036, 0.929685966295967, 0.948513022498953, 0.24756221297504188, 0.30701559352197905, 0.3223950287078453, 0.23306994577592566, 0.47125051551772434, 0.2692502063036041, 0.33502807276089497, 0.23142476924066402, 0.3536988527155298, 0.5526047040134621, 0.3123223811293525, 0.57437374700176, 0.7298215551482978, 0.2086512237809115, 0.7833293004812881, 0.7547867006033374, 0.8179184092854904, 0.7801637784782192, 0.16137979069620656, 0.13162772411906354, 0.188201711203958, 0.2259562598074767, 0.135270024174177, 0.1776940568203561, 0.09404897108831078, 0.3791616859906043, 0.11615580304056927, 0.25184843939428014, 0.1278318825553959, 0.2036820554012183, 0.1808569332307849, 0.15422059823159784, 0.16862430491893576, 0.15202154491055841, 0.14126926096900172, 0.14154855600948535, 0.420665658531328, 0.025320692152008273, 0.07330730343279046, 0.17781140976477894, 0.21370263987378535, 0.31760303113057353, 0.23614056059269162, 0.12596477221720348, 0.2768389941141822, 0.3049361335412588, 0.49686131444765913, 0.3057571205617241, 0.45303676725492514, 0.42981494971745526, 0.368069199533099, 0.4317505734007826, 0.29522773201820984, 0.339847475202376, 0.05724499304683561, 0.17455616578655386, 0.0, 0.06176361067004821, 0.15749652763341437, 0.10062705964910035, 0.11232394897116083, 0.0651753692601249, 0.0023647103280952653, 0.26397934999888883, 0.19606258937250653, 0.2239916780467751, 0.24492041171340484, 0.2002712420585574, 0.20318654820692383, 0.0903354642955303, 0.11039367489198249, 0.12753135936933724, 0.44756385917454933, 0.45793495502344517, 0.49647569670256364, 0.5094237045657999, 0.4968684347560055, 0.47627707287422427, 0.5605102664666379, 0.5386929873151378, 0.4984884746144479, 0.09133096013509079, 0.11977751965063455, 0.11883441119166804, 0.1371077307713764, 0.12198541865507195, 0.0893696408332979, 0.12974036772472808, 0.13458225321447903, 0.1689014863480548, 0.1904688678827825, 0.17233589798809223, 0.19841352137329904, 0.18005748932023324, 0.17722648462656476, 0.17416300751463043, 0.1718677683083797, 0.2019566903370691, 0.18472278005019127, 0.29638991041500196, 0.2830074351781653, 0.2699990487764732, 0.3240116442807913, 0.3765330100786237, 0.3506979645168875, 0.3850302144609775, 0.3495975888018277, 0.3953365776613563, 0.18323308566761753, 0.22229939630865558, 0.24454460986250193, 0.2608810447947022, 0.24762355605084918, 0.25275974622620156, 0.27632076560174024, 0.2565486640909811, 0.2444583402945475, 0.17823990873223405, 0.18604859990418832, 0.16407712189733936, 0.19264426542476132, 0.18571034918775653, 0.21676102466155212, 0.21154702499927702, 0.19841106355734817, 0.1826204949837874, 0.1877523412422074, 0.19099291824861286, 0.17556874099769026, 0.19187833679496868, 0.19152838899410507, 0.19102027626802265, 0.18212252257287087, 0.20541024829110377, 0.22758010459214284, 0.16827072280308897, 0.15901653592297282, 0.19632111780234218, 0.2136261262515673, 0.15062241476768434, 0.17417201355347767, 0.1748886399130335, 0.1845099499604178, 0.1776913015664059, 0.6784045891218271, 0.35214756778646217, 0.20714413751314875, 0.21537204424288414, 0.1867149775189807, 0.1946622265397593, 0.584188880489807, 0.5287824983704413, 0.552174102936142, 0.20311328581331, 0.18719199285414068, 0.17529850079838194, 0.19234265097110392, 0.18923315382726347, 0.17535388907020244, 0.20061892848606644, 0.17670190003197517, 0.17542545890077932, 0.07418589154528965, 0.06651792899851239, 0.0825076413499457, 0.10609065161778053, 0.06406028999201663, 0.10729315748330082, 0.06860331743614045, 0.07437270278065533, 0.0763913134480555]}, "mutation_prompt": null}
{"id": "8bda9f7e-3da7-4bef-84b6-91427fffbae6", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "9742dd52-ebcc-40a5-969f-a41e41546feb", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "9d446e2e-1a22-4052-babb-0bce61b25c19", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "f56fde9b-9095-4379-9f6c-c43e15e99638", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "dc894f58-b519-4e3d-9e6a-fd667967223b", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "f51ef05f-4b4d-44f0-8af3-63456ef49de5", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "5fc90b71-4067-4a53-a8b5-603fe719431d", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "9ce77df9-646d-4052-a667-7db8c7999086", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "1d39d28e-f285-4a1c-afda-2a4108b0ba5c", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "9cbc339f-b1eb-481e-84f6-a33e7064c83a", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "e17718c1-c54f-4f05-ac5b-a8918cd15528", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "9eb8eeb9-e5d3-4b91-a63c-92e813302820", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "d2fe10aa-6414-47a2-99bf-f030729296cc", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "e236149c-cc1e-49e7-a704-0aaed84556b7", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
{"id": "170b332f-a0f8-4b74-8766-d1a61c2dbc91", "solution": "import numpy as np\n\nclass DualPopulationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.7\n        self.F = 0.8\n        self.temperature = 1000\n        self.cooling_rate = 0.98  # Adjusted cooling rate for more gradual cooling\n        self.mutation_scale = 0.5\n        self.elitism_rate = 0.1\n        self.selection_pressure = 1.5\n    \n    def differential_evolution(self, population, scores):\n        new_population = np.copy(population)\n        mean_score = np.mean(scores)\n        diversity_factor = np.std(scores) / mean_score\n        dynamic_crossover_rate = self.crossover_rate + (0.25 * diversity_factor)\n        \n        num_elites = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(scores)[:max(1, num_elites)]\n        elites = population[elite_indices]\n        \n        for i in range(num_elites, self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            x_t = population[a] + self.F * (population[b] - population[c])\n            x_t = np.clip(x_t, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            new_individual = np.where(crossover, x_t, population[i])\n            new_score = self.func(new_individual)\n            if new_score < scores[i]:\n                new_population[i] = new_individual\n                scores[i] = new_score\n                self.mutation_scale = min(self.mutation_scale + 0.02, 1.0)  # Slightly increased mutation adjustment\n            else:\n                self.mutation_scale = max(self.mutation_scale - 0.004 * self.selection_pressure, 0.1)  # Adjusted scale reduction\n        \n        new_population[:num_elites] = elites\n        return new_population, scores\n\n    def simulated_annealing(self, best_individual, best_score):\n        current_individual = np.copy(best_individual)\n        current_score = best_score\n        for _ in range(self.population_size):\n            candidate = current_individual + np.random.normal(0, self.mutation_scale, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = self.func(candidate)\n            acceptance_prob = np.exp((current_score - candidate_score) / self.temperature)\n            if candidate_score < current_score or np.random.rand() < acceptance_prob:\n                current_individual = candidate\n                current_score = candidate_score\n            self.temperature *= self.cooling_rate\n        return current_individual, current_score\n    \n    def resize_population(self, evals):\n        if evals > self.budget / 2:\n            self.population_size = max(10, self.initial_population_size // 2)\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([self.func(ind) for ind in population])\n        best_idx = np.argmin(scores)\n        best_individual = population[best_idx]\n        best_score = scores[best_idx]\n        evals = self.population_size\n        \n        while evals < self.budget:\n            self.resize_population(evals)\n            population, scores = self.differential_evolution(population, scores)\n            evals += self.population_size\n            if evals < self.budget:\n                best_individual, best_score = self.simulated_annealing(best_individual, best_score)\n                evals += self.population_size\n        \n        return best_individual", "name": "DualPopulationOptimizer", "description": "Enhanced DualPopulationOptimizer with adaptive mutation scale and dynamic cooling for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8e5fd47-85ae-4bd4-957d-46509431ab6e", "metadata": {"aucs": [0.7393511676563775, 0.7402508577279164, 0.7757010805782434, 0.7521717626410613, 0.7554747682599963, 0.7702704660915096, 0.7640700442341658, 0.7399228532269023, 0.7564025011291688, 0.36645626373324103, 0.5105898352557967, 0.07155137409164414, 0.3809892967196391, 0.502681754476118, 0.425225370075493, 0.4010750219086682, 0.3238688969524103, 0.38289741768763563, 0.48702980288087705, 0.47983663704343493, 0.158072864194302, 0.11808419986250251, 0.1354018399264989, 0.1570416353005839, 0.13974523635729907, 0.13151638972775526, 0.11152056560298829, 0.1592003108012786, 0.13971218462120616, 0.14904329432440122, 0.08585997786563626, 0.09723757089297413, 0.1258687555746263, 0.08805176445711882, 0.10341011546924705, 0.0868908064681646, 0.9546542590609216, 0.9482508856463937, 0.9326852704741618, 0.9616674883890187, 0.951540572593935, 0.9705455179745314, 0.9634662424209138, 0.9427620438899806, 0.9485255367429346, 0.3538817935439369, 0.18007323882273507, 0.34052987723771844, 0.2645457826678945, 0.255977369729973, 0.32126859915863304, 0.29324318429676643, 0.30193057948725255, 0.372709032701539, 0.6303422613772115, 0.7384743170494681, 0.2629183485205101, 0.7172812511137016, 0.20806521004484402, 0.7816711875754669, 0.7245297427723831, 0.7785231139377826, 0.8067222601604698, 0.16342647398117371, 0.1334884680572237, 0.1692865872427397, 0.29198978578536083, 0.1430633979377246, 0.15824748748018957, 0.2086592250624899, 0.38379033187545497, 0.1276052832482577, 0.1030008129338792, 0.1485793583066174, 0.12518299126058396, 0.30171968471470023, 0.1562960914075382, 0.30094440878884454, 0.12397182494748415, 0.22850973488514914, 0.1329703029867103, 0.14885769173683416, 0.07576611348026652, 0.42039752748850456, 0.21410854005978686, 0.4382383301163798, 0.02579504124305787, 0.06342771628986521, 0.30699038003214585, 0.3616442140815398, 0.5524885152402335, 0.4330632090481972, 0.07337377583021099, 0.559869355477506, 0.3551559021857137, 0.3810634049241911, 0.3889877031785416, 0.5327367018863478, 0.5231391602781255, 0.08824917824492551, 0.2154848904219968, 0.04893112844406422, 0.08589451448904406, 0.14313533644299514, 0.28134698940301794, 0.0, 0.11788928984030211, 0.14275105456794135, 0.18189033595458848, 0.25703626312866656, 0.19626505165652386, 0.29174367224400255, 0.1329723653137247, 0.0748495496873326, 0.12250748054411509, 0.10861450030325526, 0.09658252144640755, 0.4791384832138288, 0.4644957682098506, 0.49636294654818225, 0.4842027053994018, 0.5245706111685758, 0.5049791748934961, 0.5563873121109167, 0.4952467603193058, 0.5641011452561955, 0.09047841378496146, 0.10585087227949785, 0.09840990865094756, 0.0739531277829335, 0.10518692625852966, 0.09282301752552191, 0.07746136337213705, 0.0923129363517613, 0.12265043447398405, 0.2837086242482113, 0.14052811781828645, 0.29912114254148825, 0.1267371168247955, 0.15514084249907412, 0.2631187366844062, 0.19195539483636315, 0.1845481339675462, 0.17465836160960457, 0.30870378518868924, 0.2752196989472744, 0.2608088441388938, 0.40461447241349147, 0.3597004176765931, 0.3763581728771054, 0.39200786969588275, 0.36276284169475614, 0.35602476465183897, 0.2459310619713565, 0.2774203379989669, 0.22958281833914507, 0.28187438876569526, 0.2195197446853413, 0.25004036679315644, 0.24045409343449953, 0.2567988632796617, 0.25686826858800116, 0.1802421507013916, 0.20698934792181667, 0.17448982497410181, 0.18353516496276756, 0.18709125711866303, 0.1774473006254973, 0.18367764571607603, 0.21081641206333135, 0.18386096107549776, 0.19073507195206407, 0.21434124967763912, 0.20075178917971193, 0.2418413424603546, 0.20653233101118296, 0.19628307079382357, 0.17293483870228554, 0.18132239794077165, 0.18051012632157049, 0.16910667557353665, 0.7583514631411509, 0.1766417404270063, 0.18219121806896355, 0.7459377088946841, 0.16341512660923052, 0.1785231155758833, 0.576495283799999, 0.6535816113605917, 0.16364155142143422, 0.17241720212368494, 0.5792148242237058, 0.2064936547098022, 0.48265971839231514, 0.5990606234257096, 0.1978663201146562, 0.44125338626248956, 0.28501389660965193, 0.1748459594708378, 0.1778175202130864, 0.18477285504376773, 0.18328166207899899, 0.17498207186064685, 0.17491743218625233, 0.18119592777687954, 0.1689992346710154, 0.19123251432256105, 0.0698686045009792, 0.08640738296397721, 0.0808693549215368, 0.07359221889870515, 0.08985692054237227, 0.06418678924910359, 0.07575982358559619, 0.07663274234318884, 0.07286520906806404]}, "mutation_prompt": null}
