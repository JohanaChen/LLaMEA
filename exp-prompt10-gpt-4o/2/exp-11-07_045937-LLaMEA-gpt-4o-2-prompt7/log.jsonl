{"id": "4072c1ee-9880-46f0-901a-9765980aa67e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 58, in __call__\n  File \"<string>\", line 28, in differential_evolution\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 58, in __call__\n  File \"<string>\", line 28, in differential_evolution\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "774fbe99-0ede-4007-a116-541638f84640", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "2abf410e-db91-4868-9b60-e09808ea7b85", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "16e46006-53df-4068-9d63-ad01c8de39a3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "58e0c414-774d-4a9f-92e0-7dc0077e3587", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "57318d19-91fa-4b3e-aad5-a131ae38b79f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "a6d8f7b8-61a4-474f-bad6-b08222a2e686", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "1f336cfa-0642-4f3d-a953-3f07b1a5fd81", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "c5c67bc1-6628-4591-9c3d-0408ee322c64", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "cb1ca107-ef8e-497a-ac3b-96f606f1d421", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.array([mutant[j] if np.random.rand() < self.CR else population[i, j] for j in range(self.dim)])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {}, "mutation_prompt": null}
{"id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 10, "fitness": 0.12026572288559069, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "4072c1ee-9880-46f0-901a-9765980aa67e", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "f6fccd50-2b6e-461a-81e2-040412a04402", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "f6a068a0-3655-4cae-a3e4-7e3a734590af", "solution": "import numpy as np\n\nclass OptimizedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)  # Vectorized random generation\n        for i in range(self.pop_size):\n            self.velocities[i] += self.c1 * r1[i] * (personal_best[i] - population[i]) + self.c2 * r2[i] * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "OptimizedHybridDEPSO", "description": "Optimize HybridDEPSO by reducing random number generation calls for vectorized operations.", "configspace": "", "generation": 12, "fitness": 0.12013606048140961, "feedback": "The algorithm OptimizedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.14083073204600005, 0.17764848767480346, 0.20374685613374877, 0.19419814325964713, 0.1863853710593646, 0.16841060543153485, 0.1711397457084335, 0.16784674884854978, 0.17710562358910464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04778712900045867, 0.07158168125815845, 0.04206511981227301, 0.03972809749794892, 0.05009440338504023, 0.050318384614942424, 0.035003335541322844, 0.040526460386826724, 0.03781876283699881, 0.02080167003376976, 0.04384244681896965, 0.02988762519882382, 0.02861445571967669, 0.026839829431301365, 0.03831457932694715, 0.037345182051658266, 0.019011703051105888, 0.03742762495067542, 0.9700710904064986, 0.9734425787998517, 0.9715454586033123, 0.9623605119389078, 0.9716976653774707, 0.9643309351448512, 0.977800824184904, 0.9837711297793291, 0.9772402764922267, 0.03492180515339205, 0.05828899959065459, 0.06215747032395247, 0.07603450150451885, 0.09033884623194444, 0.05539155084765568, 0.0593220256720669, 0.12045458712919244, 0.08700863404989745, 0.1192056988604554, 0.11957497512459814, 0.09365360064525574, 0.09890875883131389, 0.10253600250908934, 0.11483883874878975, 0.09735107406152987, 0.11208267133289651, 0.10970129125346118, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012569753375157866, 9.999999999998899e-05, 9.999999999998899e-05, 0.01970845073660299, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016439763937145302, 0.009848826404225686, 0.011534111829899163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019059511687239294, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014578367623721333, 0.01708426245118988, 0.023384301185522594, 9.999999999998899e-05, 0.010593129631452536, 0.0425399706961318, 0.028264415390799713, 0.013968795527312228, 0.008935093446768572, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020299030207863833, 9.999999999998899e-05, 0.00028452713659932183, 0.2206457575301336, 0.17612377403735935, 0.15686663322629268, 0.19618177046499063, 0.17661419481390161, 0.19724394589968985, 0.19202484892338967, 0.17041103511460987, 0.20850786891523143, 0.05625801669600883, 0.04745092514377369, 0.054572234493624805, 0.0559795275375764, 0.03815135320222962, 0.0489411672202541, 0.05127480797198258, 0.04172273913811808, 0.03813044252795539, 0.1426981346798991, 0.13482530705506202, 0.13819186168749165, 0.12603938918910096, 0.17244706432588353, 0.14275956168764425, 0.13477997970414324, 0.17591126676350266, 0.15362885135205528, 0.17039879498693444, 0.1557148781954909, 0.14903780591910964, 0.1565016896849598, 0.15905984018546715, 0.1500964179083739, 0.1573613737502283, 0.1603274145934387, 0.17298140409462537, 0.10183085311909124, 0.0933050362530532, 0.10266373311578703, 0.11465899341620756, 0.09508508589219256, 0.10317328533097803, 0.10866121183267619, 0.10696025424189337, 0.10568424818100774, 0.13804752024109535, 0.13530771850189416, 0.1571133534102428, 0.1767033834723969, 0.13402926200034326, 0.14892427988850754, 0.1346051783448886, 0.15513210585859816, 0.15126684083411657, 0.0583882296629199, 0.14681263560174196, 0.14622723818433825, 0.14217675111870398, 0.15598655755797408, 0.11251408876942892, 0.14927548248305633, 0.010045213115852158, 0.14881931690990535, 0.14044234229835617, 0.20322545472494913, 0.14736030570868552, 0.14658629707755733, 0.17472156357700497, 0.1539710515447814, 0.15779354446802607, 0.15244669263823185, 0.13778188000879732, 0.1545961532412501, 0.14485524069197764, 0.1369639109002444, 0.10720428639622837, 0.10799018843831676, 0.174139169563316, 0.18433390300030017, 0.18180532956218787, 0.1711480175424165, 0.17583295993886094, 0.180099876709932, 0.18654196301298787, 0.17750341971320305, 0.1830984493025638, 0.18973090402204484, 0.1806875412237352, 0.18180018494286976, 0.18530397534766807, 0.0402189594052248, 0.06334104228350645, 0.04451952583444396, 0.044141769899684324, 0.04408121976951174, 0.04318478666841552, 0.03749076679874963, 0.047071592596473644, 0.044413996480220375]}, "mutation_prompt": null}
{"id": "4289c183-e094-4343-b1ae-a67167e8e5d9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "ce438fe5-d216-44fe-83b6-5995886cdbda", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "4b0e5c83-53af-4bc3-89f2-6369e9ebf511", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "4f5709aa-df2a-4878-b3c5-4a9e9a2e048a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "55670472-aa4d-4300-8d7b-b4c81d3bea63", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "91d2da3f-f0ed-4a07-adc2-ce619498eec6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "178e9535-8886-495b-8a20-c8a9ae0fddee", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "c34dc1cd-a6fc-4324-a938-e9c290b82fac", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "bd48fcf6-edea-4a2c-b421-2ac1010b7c79", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "b79d44a0-a3e6-4967-8360-710d3a8e4c73", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "d67960b6-b0c9-497b-bb9f-91b721e65551", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] += self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < func(global_best):\n                    global_best = population[i]\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by optimizing function call efficiency and simplifying array operations for improved performance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.17147497833814507, 0.15653839448664986, 0.15895429941765793, 0.16716551115762945, 0.1659751090489806, 0.1880500645798524, 0.1796868649808988, 0.16434134666276, 0.19901105523403917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044695824783933635, 0.04071711888452867, 0.038331897356301825, 0.04550591891634481, 0.03694280230577929, 0.03635432095590441, 0.0375766026256219, 0.05823324327669832, 0.059252420356628366, 0.01596561794068696, 0.025046705509746414, 0.015288259380142888, 0.018537687297739303, 0.03239983359854737, 0.02631078710619661, 0.022202620302096188, 0.0371658866902439, 0.023027403554764847, 0.970723718066218, 0.9764614954306433, 0.9737889607683973, 0.9746262916084423, 0.9735423764195941, 0.9758020884804329, 0.9836684398734946, 0.9708237223074243, 0.9786430510501661, 0.050932444709048785, 0.06625503353308071, 0.07831007967053161, 0.036138308164834765, 0.09130488366391876, 0.026932412508806736, 0.06908161777368027, 0.11571730193296792, 0.07282218582874012, 0.11878091024690496, 0.057524654343131254, 0.12171407333247863, 0.13550982850180404, 0.13368941853312866, 0.14193610889401498, 0.11796022815555685, 0.13529678241861642, 0.12321311590070105, 9.999999999998899e-05, 0.0007399549501052594, 9.999999999998899e-05, 9.999999999998899e-05, 0.0054925998988455405, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927293070198353, 9.999999999998899e-05, 0.016806240787263227, 0.015228467107012644, 0.014172191540778867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016654548492349153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013937319045840724, 0.04783498869103009, 0.02432189168544352, 0.03135631585753895, 0.033614126389613586, 0.04738784902029802, 0.018937379605411975, 0.007676789495568825, 0.024325443013963777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040530683462568495, 0.0007683408039808048, 0.003095952743249808, 0.1560748265444325, 0.17617837742063713, 0.20490014178019977, 0.1963264881629201, 0.2032742148046932, 0.2357295711402152, 0.17558676424048714, 0.1840069241040233, 0.2089820271302627, 0.05068575516383267, 0.05682702934613704, 0.05875196726984211, 0.046188156113983525, 0.04114657726592741, 0.04509861044914232, 0.056490474768571386, 0.03855913526925048, 0.036125440130813646, 0.14566348795237682, 0.15255958913052114, 0.1349550944851624, 0.1375563760898827, 0.1518585838561639, 0.1453097384945904, 0.14012016224485435, 0.13797188516886238, 0.12347863750818255, 0.14210481250719387, 0.17444298698027105, 0.1697909870093618, 0.18835014630634184, 0.14085585785838883, 0.14852573388838042, 0.16740102402587886, 0.1499181317951701, 0.1691285241357151, 0.09997432076689583, 0.1062444784722888, 0.10396161980734919, 0.09626920049224463, 0.10875177546904069, 0.0952621136484848, 0.10937696898321048, 0.09830526381329796, 0.11006286609404181, 0.1341902265489836, 0.14613931051334605, 0.13123422235096316, 0.1437039742206513, 0.14237987609264458, 0.15192279324818225, 0.17698931880134938, 0.15377813963631182, 0.1475269022390827, 0.1496678556981691, 0.14447410188831256, 0.14377913804405396, 0.1487011439072221, 0.14080933041484245, 0.06272538456970411, 0.15425895038897675, 0.0975830932967976, 0.08531386816343345, 0.1277995915751975, 0.16730635916265912, 0.13343606381057138, 0.17242688527951067, 0.11339169099493374, 0.16832775487026486, 0.1297729161404504, 0.16824952933686743, 0.12020100748640106, 0.14443434884582151, 0.13120576851194765, 0.1416601398589319, 0.11227493663933052, 0.14722870675769284, 0.1082913617640614, 0.18871061992788352, 0.16998092196310155, 0.17705018437859565, 0.1857205970870487, 0.19267515286307746, 0.1833783663147246, 0.188193395403207, 0.1796741834143566, 0.18630788832153444, 0.1852784037123184, 0.1895874226191856, 0.19030721701631836, 0.04272978025347818, 0.051044589601114576, 0.04468761050297687, 0.04209499755714552, 0.06288979662725191, 0.04194090400107886, 0.06111851983490468, 0.03167482073423511, 0.04235036459683361]}, "mutation_prompt": null}
{"id": "9098b066-2f08-4e75-8901-07758baf67d2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i] = trial\n                fitness[i] = trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i] = population[i]\n                personal_best_fitness[i] = current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best = population[i]\n                    global_best_fitness = current_fitness\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by refining velocity calculation and reducing redundant function calls for better efficiency.", "configspace": "", "generation": 24, "fitness": 0.13464189867995024, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "6fc42b30-8449-4cc1-90b6-7e513755c530", "metadata": {"aucs": [0.18841273765222555, 0.22337860974611345, 0.20542072244052345, 0.2393147159330452, 0.249679677511648, 0.21829977264560807, 0.19989654875468943, 0.21146199911235863, 0.21054319341889582, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06736395034180354, 0.05353985696698127, 0.05333529581254426, 0.054790126119866556, 0.05113849771793033, 0.05033889707778416, 0.05190194940523163, 0.05251711512109847, 0.05250240004178708, 0.0414972741527776, 0.040552107711848695, 0.040028386619154865, 0.038052664201433606, 0.054078978589387594, 0.03438851233677631, 0.034219334324177564, 0.0325955495462269, 0.03523402952854959, 0.9818577901594471, 0.9703623579638323, 0.9798879424871035, 0.9786627237988746, 0.9791150780770904, 0.9793724169548125, 0.9813698259920729, 0.9801400858776372, 0.9797270957092598, 0.08657376117592375, 0.1131452676618121, 0.11764415635501335, 0.0999061948192792, 0.0865084325618578, 0.11420754954595536, 0.08647287564990602, 0.10442620282823167, 0.07926495285061974, 0.13645880586168935, 0.12948528842065776, 0.1363991036002713, 0.1273015685977016, 0.1673839211146032, 0.1455006507399621, 0.14566181395311928, 0.15051094871813897, 0.12475954497793296, 9.999999999998899e-05, 0.010496050357954867, 0.0584378448673597, 0.013212242237230165, 0.0038486597829945346, 0.03955787921635512, 0.0003149378797774327, 0.0350212170696057, 0.01825243957363676, 0.03992674275435382, 0.03824162835565781, 0.04190893013753705, 0.02309976978958861, 0.044604780889275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00716259372188921, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037894682405807956, 0.05249177032175378, 0.03342537498750697, 0.03630704827792308, 0.04262004445343248, 0.03203340057159765, 0.026291682593872934, 0.024581389004477594, 0.0385286635927965, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00514837095341536, 0.00022700409643039432, 0.005530634429686154, 0.0007739017202924581, 0.012326678743531772, 0.025586424251927253, 0.026925431338201244, 0.0276071527172993, 0.2901411859080487, 0.24628327251745008, 0.21237522707347722, 0.22231397473329229, 0.24213927218725062, 0.22873049459283057, 0.2456129643169349, 0.20450861610040816, 0.2251346014636817, 0.054746389418446006, 0.06568620493032717, 0.06053012037174521, 0.08970816456964281, 0.049207514933876206, 0.07716575595317188, 0.06514110523869332, 0.04918570797529642, 0.05330688966348285, 0.15338096906680754, 0.1581979938470035, 0.1459312483151518, 0.13879239769066476, 0.13586189384859393, 0.14300191107104032, 0.130661057835738, 0.14679220043241625, 0.1676948299111093, 0.18147807397359217, 0.16436264115716626, 0.1662258742053866, 0.1863189634870468, 0.16055812665504854, 0.16924101008506554, 0.18723916642203975, 0.18427850622842135, 0.18679085127926942, 0.12466016189235485, 0.1386611228993887, 0.10425162515365849, 0.11544343485632658, 0.1238081596848295, 0.13489813836446551, 0.11514478038849285, 0.12253253313107271, 0.14352832954524186, 0.14991793855833346, 0.14882294955882314, 0.16268138009610644, 0.16039301594420563, 0.14433470262026749, 0.1585570939079336, 0.15899596679775896, 0.16140190743317473, 0.1669571331172487, 0.15704721048276515, 0.14745829960440637, 0.15054972097367703, 0.15635486376779517, 0.15318919780555584, 0.1503426667146054, 0.15431495004153273, 0.15716161249553806, 0.1490762321218999, 0.1499776254914803, 0.14446453285457828, 0.17993804843272243, 0.1707963864947778, 0.16547872941046393, 0.16241334141869157, 0.15410829476440446, 0.16313191288628992, 0.17833576070035306, 0.15412409882224454, 0.15050834114338918, 0.15581279554774607, 0.12546848087676155, 0.10640114166101644, 0.14754916148424402, 0.19876075710340457, 0.1957227347002808, 0.16548926910160977, 0.1826594883925834, 0.1791859795529095, 0.17806055639624974, 0.1794046563927586, 0.1849685672207052, 0.19347422807873493, 0.18136959314463363, 0.18143987247222093, 0.1874111602284474, 0.05287482748780781, 0.054317180014348376, 0.05722966306728272, 0.06342046533790813, 0.06795380106617943, 0.06016806421557774, 0.05508107639267834, 0.055035913711241835, 0.04872867300900996]}, "mutation_prompt": null}
{"id": "31006a50-b68b-4c25-9627-1c92eb3b7cea", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = a + self.F * (b - c)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial = np.clip(trial, self.bound_min, self.bound_max)  # Mutation outside loop\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            population[i] = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(population[i])\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = population[i], current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = population[i], current_fitness\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Streamlined velocity update and mutation operation to enhance convergence efficiency.", "configspace": "", "generation": 25, "fitness": 0.13474431488774605, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "9098b066-2f08-4e75-8901-07758baf67d2", "metadata": {"aucs": [0.22092372334110055, 0.232671986757793, 0.18040136494043124, 0.25748607693820136, 0.2734682321624675, 0.24177225583168216, 0.23076198127320013, 0.2200766322857276, 0.21285366374854053, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047927330788987255, 0.05139631462246108, 0.0506217232654983, 0.06293455282787308, 0.058380587022522024, 0.05505569916104869, 0.06112978850666784, 0.05052149292920871, 0.052391781332568055, 0.039427597041094664, 0.029115108597629336, 0.03657226111193379, 0.03730882729519602, 0.03087948955702491, 0.035195205841841215, 0.04626027973121449, 0.03133807119276877, 0.04303998773494799, 0.9712488390957668, 0.9785823505513799, 0.9788806897015095, 0.9883098879651431, 0.9801007869083663, 0.9780265069724327, 0.9793465690011878, 0.9708768359340806, 0.9798147854980562, 0.11375855599785478, 0.0903849942428886, 0.0750822240775657, 0.07792806163218302, 0.07512971648131883, 0.11007974379118646, 0.09458204280355165, 0.11382231452710134, 0.0929801375951893, 0.13812903813866573, 0.11528962780008933, 0.15157078109067512, 0.13363758271466286, 0.14852638459420509, 0.15336633009838152, 0.13092684433524504, 0.14276357325319733, 0.14509714465946877, 0.05231910611168822, 0.009944151344268515, 9.999999999998899e-05, 0.028372999942672728, 0.05331151127857103, 0.012828957767436977, 0.0033053663195546923, 0.005597112432872198, 0.03464422006526169, 0.020380672280342904, 0.010701544501433236, 0.025396602817630454, 0.021395376787322284, 0.03787897979739807, 0.02164211471991384, 0.003705249116860432, 0.011269900061537164, 0.01025331652131567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017430399679132957, 0.0354688428635076, 0.01906088160884123, 0.007219532789427663, 0.025249956157245235, 0.007294027753696586, 0.037282902783531635, 0.045058517392805864, 0.023733407025471, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00658093910247004, 0.0010981652352441973, 0.01457219173782398, 0.007278877838268638, 0.0017010189868497116, 9.999999999998899e-05, 0.013767402616612023, 0.01590741404252216, 0.03258528162674734, 0.1960738041534067, 0.20375003931048097, 0.23080479056393566, 0.2513423969338905, 0.24188909827197824, 0.23519746661729224, 0.24009689790990318, 0.2071712764450202, 0.19007822082431125, 0.07112163423764617, 0.06790150700049002, 0.0683386123652514, 0.0648880977201517, 0.06019043725495721, 0.05250272347033569, 0.05351907402448197, 0.04827355003109701, 0.05324957284879461, 0.1621438858145231, 0.1309864044542206, 0.15172925146018734, 0.18775848295518893, 0.14102433994993058, 0.13846634527603197, 0.13858766565272596, 0.22334532508953653, 0.14337500996658326, 0.16776529256459394, 0.1605398376014926, 0.17869445381406657, 0.16332722279600442, 0.17331698533510154, 0.159965135984394, 0.22351631238843006, 0.18335273586470324, 0.18899937068148864, 0.12218918545149537, 0.1318586825562501, 0.12987361756736993, 0.11795620783230099, 0.13419365822374751, 0.12956180763425273, 0.12816639949588393, 0.13741488082518394, 0.14545143392297666, 0.14744199618045772, 0.2392003979109496, 0.13623065087476316, 0.1683389082495178, 0.15583109387501082, 0.17596374967018213, 0.1390380163235917, 0.18754958951776346, 0.16440355575531573, 0.15250005806832378, 0.14955065498330733, 0.1423305833748716, 0.15257849745005148, 0.15836751007116368, 0.17333174054882128, 0.16192972498184577, 0.1452546685723859, 0.1707877702900723, 0.1457146985447213, 0.1596933639253002, 0.16028301979214976, 0.16876106946341574, 0.12985206822822581, 0.13600587085015503, 0.1682763741276725, 0.16561070908179476, 0.16351626538533237, 0.16422005947837137, 0.14885647286471226, 0.16395985741587715, 0.14119097007537862, 0.12414314272011873, 0.13794028281998838, 0.13728070299185424, 0.19145177101517397, 0.1820426066756351, 0.1916131247696724, 0.22142195899739658, 0.18907506479317226, 0.18246804847623366, 0.17447720248828824, 0.19434436198190264, 0.17212697226147133, 0.1875511137389353, 0.1919900996127346, 0.04848601514503992, 0.060067437445776695, 0.06025926543459359, 0.043665033101283, 0.04583926566115604, 0.047659318119798066, 0.057808656825860116, 0.05269918267765605, 0.06855098451855646]}, "mutation_prompt": null}
{"id": "58e16fae-688e-496f-bc2f-9fbc0efd508e", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)  # Combined mutation and clip\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refinement of mutation and velocity calculation for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.16667710126274812, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "31006a50-b68b-4c25-9627-1c92eb3b7cea", "metadata": {"aucs": [0.29648833449631395, 0.32238796277523407, 0.28945181019503186, 0.31924513188441084, 0.36065845001940156, 0.35399423456631174, 0.34733561651739797, 0.35490996607633474, 0.336910245127525, 0.03742296337474238, 0.03625905282528641, 0.03700333901073316, 0.021178589924884417, 9.999999999998899e-05, 0.03806932942879071, 0.03837228558275385, 0.019927565589028418, 0.0020545207561177836, 0.09368613488239574, 0.1326914716072113, 0.07302020295307177, 0.1160438187040741, 0.1090681994409779, 0.06227177560529851, 0.07552649085451135, 0.0757285635716265, 0.08835802651730917, 0.06928789897098209, 0.06692803996529506, 0.06317252561257869, 0.0674292212554658, 0.07552455542844405, 0.0720461738858107, 0.07109161971069056, 0.07672602733110179, 0.0632870674923417, 0.9816060025357446, 0.9721851878635085, 0.9784193089624104, 0.9800284600152257, 0.9808332367173507, 0.9787826340018613, 0.9824055579074898, 0.9709730924839818, 0.9726291854117994, 0.18548181161304966, 0.05642948819233584, 0.1812838184909631, 0.18842982699119926, 0.1313851570940664, 0.1841051480284588, 0.16134513385696225, 0.08663249971212883, 0.16830569952409147, 0.14144932635318397, 0.22043560290310538, 0.17962692783772904, 0.15750899854517575, 0.15333409127913744, 0.20688877024830965, 0.16988494112424213, 0.1471054931574709, 0.19797481863650968, 0.061181598562383255, 0.09442780569365128, 0.11151958046906052, 0.0879052658412991, 0.12464963194570977, 0.0953900508216573, 0.10543236981322357, 0.1227875154339968, 0.08507041050033437, 0.0838451906601545, 0.10266624514954548, 0.1144510250655465, 0.062301905676816705, 0.08123392088786208, 0.09608336161537123, 0.0904234584418131, 0.10450353505714338, 0.09602668266239123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00044234599319092904, 9.999999999998899e-05, 0.002511252747175563, 9.999999999998899e-05, 9.999999999998899e-05, 0.03691786195392144, 0.024614169037150302, 0.02032316673101564, 0.007655644622375224, 0.05852231637382266, 0.01014077491601817, 0.04208197455748486, 0.010273721022339144, 0.04369977246510737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013197329543612746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047245812515573915, 0.018133476202637944, 0.0030864015327588534, 0.0864480482678257, 0.002466975701249652, 0.0024837891024799275, 0.05565585090561742, 0.04027283929743719, 0.05036113065017456, 0.32038043595913, 0.3130886252917293, 0.31438453638556996, 0.371273826400371, 0.3309803687369184, 0.3352568922783662, 0.32031555334841466, 0.3446864902902286, 0.3306813596634811, 0.08308482534515182, 0.07345344831423717, 0.06118443632809867, 0.07465610487721985, 0.07419338259217312, 0.07580872849283637, 0.06866523595087692, 0.09673257121507028, 0.07344055374691505, 0.15135799658511673, 0.1619507977437723, 0.13933980553908387, 0.1470672883770816, 0.18664360488840326, 0.14317710781053172, 0.15876763334332644, 0.15825443030954045, 0.16850295016993055, 0.2045670546881999, 0.22309224696775076, 0.18643284888276235, 0.17517180751484507, 0.19709019824666008, 0.2315897924933158, 0.22144164712590486, 0.2203056270093703, 0.23118934255502788, 0.15720166722898798, 0.1674799722306538, 0.15037919384242215, 0.16003795563685108, 0.16645763800291702, 0.1520167438596438, 0.1750781875049655, 0.18162473991644235, 0.17947297984379706, 0.17854750213770954, 0.19004317208446386, 0.17275774174141245, 0.19006943308672075, 0.18079675277351126, 0.19471277239888607, 0.1753016294648745, 0.18295602919655307, 0.16661725961518714, 0.16982320320731958, 0.17353559797978435, 0.16423674413154532, 0.186799913798959, 0.17549709933480295, 0.16220133831870331, 0.1690497916637581, 0.1678869697201011, 0.16636585466121667, 0.47498141986447306, 0.14053374049000067, 0.15486286760355905, 0.16488585428991265, 0.17413097092722907, 0.19697103671311933, 0.14450665686672015, 0.13503834598788123, 0.15692120874807225, 0.16692946075521853, 0.20192055481474325, 0.14262115422868193, 0.24140609982228045, 0.16640820353008767, 0.249326912513548, 0.15970987597709552, 0.27618488001198216, 0.1507644971957206, 0.19333169864571687, 0.1835114318496348, 0.1820756650949492, 0.18400758334658196, 0.17368011841108033, 0.18254801496453943, 0.17944232648897074, 0.1933272104061402, 0.1785090125490495, 0.06602612621017778, 0.06810646608895621, 0.06720530017909787, 0.07082291351898762, 0.05770408673913208, 0.08671015438816998, 0.05568389560843412, 0.06168535936906627, 0.07314027735326567]}, "mutation_prompt": null}
{"id": "2aac2c3d-fe17-4c1c-ad55-44cd63b4397c", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)  # Combined mutation and clip\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refinement of mutation and velocity calculation for improved convergence.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58e16fae-688e-496f-bc2f-9fbc0efd508e", "metadata": {"aucs": [0.29648833449631395, 0.32238796277523407, 0.28945181019503186, 0.31924513188441084, 0.36065845001940156, 0.35399423456631174, 0.34733561651739797, 0.35490996607633474, 0.336910245127525, 0.03742296337474238, 0.03625905282528641, 0.03700333901073316, 0.021178589924884417, 9.999999999998899e-05, 0.03806932942879071, 0.03837228558275385, 0.019927565589028418, 0.0020545207561177836, 0.09368613488239574, 0.1326914716072113, 0.07302020295307177, 0.1160438187040741, 0.1090681994409779, 0.06227177560529851, 0.07552649085451135, 0.0757285635716265, 0.08835802651730917, 0.06928789897098209, 0.06692803996529506, 0.06317252561257869, 0.0674292212554658, 0.07552455542844405, 0.0720461738858107, 0.07109161971069056, 0.07672602733110179, 0.0632870674923417, 0.9816060025357446, 0.9721851878635085, 0.9784193089624104, 0.9800284600152257, 0.9808332367173507, 0.9787826340018613, 0.9824055579074898, 0.9709730924839818, 0.9726291854117994, 0.18548181161304966, 0.05642948819233584, 0.1812838184909631, 0.18842982699119926, 0.1313851570940664, 0.1841051480284588, 0.16134513385696225, 0.08663249971212883, 0.16830569952409147, 0.14144932635318397, 0.22043560290310538, 0.17962692783772904, 0.15750899854517575, 0.15333409127913744, 0.20688877024830965, 0.16988494112424213, 0.1471054931574709, 0.19797481863650968, 0.061181598562383255, 0.09442780569365128, 0.11151958046906052, 0.0879052658412991, 0.12464963194570977, 0.0953900508216573, 0.10543236981322357, 0.1227875154339968, 0.08507041050033437, 0.0838451906601545, 0.10266624514954548, 0.1144510250655465, 0.062301905676816705, 0.08123392088786208, 0.09608336161537123, 0.0904234584418131, 0.10450353505714338, 0.09602668266239123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00044234599319092904, 9.999999999998899e-05, 0.002511252747175563, 9.999999999998899e-05, 9.999999999998899e-05, 0.03691786195392144, 0.024614169037150302, 0.02032316673101564, 0.007655644622375224, 0.05852231637382266, 0.01014077491601817, 0.04208197455748486, 0.010273721022339144, 0.04369977246510737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013197329543612746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047245812515573915, 0.018133476202637944, 0.0030864015327588534, 0.0864480482678257, 0.002466975701249652, 0.0024837891024799275, 0.05565585090561742, 0.04027283929743719, 0.05036113065017456, 0.32038043595913, 0.3130886252917293, 0.31438453638556996, 0.371273826400371, 0.3309803687369184, 0.3352568922783662, 0.32031555334841466, 0.3446864902902286, 0.3306813596634811, 0.08308482534515182, 0.07345344831423717, 0.06118443632809867, 0.07465610487721985, 0.07419338259217312, 0.07580872849283637, 0.06866523595087692, 0.09673257121507028, 0.07344055374691505, 0.15135799658511673, 0.1619507977437723, 0.13933980553908387, 0.1470672883770816, 0.18664360488840326, 0.14317710781053172, 0.15876763334332644, 0.15825443030954045, 0.16850295016993055, 0.2045670546881999, 0.22309224696775076, 0.18643284888276235, 0.17517180751484507, 0.19709019824666008, 0.2315897924933158, 0.22144164712590486, 0.2203056270093703, 0.23118934255502788, 0.15720166722898798, 0.1674799722306538, 0.15037919384242215, 0.16003795563685108, 0.16645763800291702, 0.1520167438596438, 0.1750781875049655, 0.18162473991644235, 0.17947297984379706, 0.17854750213770954, 0.19004317208446386, 0.17275774174141245, 0.19006943308672075, 0.18079675277351126, 0.19471277239888607, 0.1753016294648745, 0.18295602919655307, 0.16661725961518714, 0.16982320320731958, 0.17353559797978435, 0.16423674413154532, 0.186799913798959, 0.17549709933480295, 0.16220133831870331, 0.1690497916637581, 0.1678869697201011, 0.16636585466121667, 0.47498141986447306, 0.14053374049000067, 0.15486286760355905, 0.16488585428991265, 0.17413097092722907, 0.19697103671311933, 0.14450665686672015, 0.13503834598788123, 0.15692120874807225, 0.16692946075521853, 0.20192055481474325, 0.14262115422868193, 0.24140609982228045, 0.16640820353008767, 0.249326912513548, 0.15970987597709552, 0.27618488001198216, 0.1507644971957206, 0.19333169864571687, 0.1835114318496348, 0.1820756650949492, 0.18400758334658196, 0.17368011841108033, 0.18254801496453943, 0.17944232648897074, 0.1933272104061402, 0.1785090125490495, 0.06602612621017778, 0.06810646608895621, 0.06720530017909787, 0.07082291351898762, 0.05770408673913208, 0.08671015438816998, 0.05568389560843412, 0.06168535936906627, 0.07314027735326567]}, "mutation_prompt": null}
{"id": "0ebdcbf3-2b2e-4bbb-93f7-79926f154cd9", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)  # Combined mutation and clip\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refinement of mutation and velocity calculation for improved convergence.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58e16fae-688e-496f-bc2f-9fbc0efd508e", "metadata": {"aucs": [0.29648833449631395, 0.32238796277523407, 0.28945181019503186, 0.31924513188441084, 0.36065845001940156, 0.35399423456631174, 0.34733561651739797, 0.35490996607633474, 0.336910245127525, 0.03742296337474238, 0.03625905282528641, 0.03700333901073316, 0.021178589924884417, 9.999999999998899e-05, 0.03806932942879071, 0.03837228558275385, 0.019927565589028418, 0.0020545207561177836, 0.09368613488239574, 0.1326914716072113, 0.07302020295307177, 0.1160438187040741, 0.1090681994409779, 0.06227177560529851, 0.07552649085451135, 0.0757285635716265, 0.08835802651730917, 0.06928789897098209, 0.06692803996529506, 0.06317252561257869, 0.0674292212554658, 0.07552455542844405, 0.0720461738858107, 0.07109161971069056, 0.07672602733110179, 0.0632870674923417, 0.9816060025357446, 0.9721851878635085, 0.9784193089624104, 0.9800284600152257, 0.9808332367173507, 0.9787826340018613, 0.9824055579074898, 0.9709730924839818, 0.9726291854117994, 0.18548181161304966, 0.05642948819233584, 0.1812838184909631, 0.18842982699119926, 0.1313851570940664, 0.1841051480284588, 0.16134513385696225, 0.08663249971212883, 0.16830569952409147, 0.14144932635318397, 0.22043560290310538, 0.17962692783772904, 0.15750899854517575, 0.15333409127913744, 0.20688877024830965, 0.16988494112424213, 0.1471054931574709, 0.19797481863650968, 0.061181598562383255, 0.09442780569365128, 0.11151958046906052, 0.0879052658412991, 0.12464963194570977, 0.0953900508216573, 0.10543236981322357, 0.1227875154339968, 0.08507041050033437, 0.0838451906601545, 0.10266624514954548, 0.1144510250655465, 0.062301905676816705, 0.08123392088786208, 0.09608336161537123, 0.0904234584418131, 0.10450353505714338, 0.09602668266239123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00044234599319092904, 9.999999999998899e-05, 0.002511252747175563, 9.999999999998899e-05, 9.999999999998899e-05, 0.03691786195392144, 0.024614169037150302, 0.02032316673101564, 0.007655644622375224, 0.05852231637382266, 0.01014077491601817, 0.04208197455748486, 0.010273721022339144, 0.04369977246510737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013197329543612746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047245812515573915, 0.018133476202637944, 0.0030864015327588534, 0.0864480482678257, 0.002466975701249652, 0.0024837891024799275, 0.05565585090561742, 0.04027283929743719, 0.05036113065017456, 0.32038043595913, 0.3130886252917293, 0.31438453638556996, 0.371273826400371, 0.3309803687369184, 0.3352568922783662, 0.32031555334841466, 0.3446864902902286, 0.3306813596634811, 0.08308482534515182, 0.07345344831423717, 0.06118443632809867, 0.07465610487721985, 0.07419338259217312, 0.07580872849283637, 0.06866523595087692, 0.09673257121507028, 0.07344055374691505, 0.15135799658511673, 0.1619507977437723, 0.13933980553908387, 0.1470672883770816, 0.18664360488840326, 0.14317710781053172, 0.15876763334332644, 0.15825443030954045, 0.16850295016993055, 0.2045670546881999, 0.22309224696775076, 0.18643284888276235, 0.17517180751484507, 0.19709019824666008, 0.2315897924933158, 0.22144164712590486, 0.2203056270093703, 0.23118934255502788, 0.15720166722898798, 0.1674799722306538, 0.15037919384242215, 0.16003795563685108, 0.16645763800291702, 0.1520167438596438, 0.1750781875049655, 0.18162473991644235, 0.17947297984379706, 0.17854750213770954, 0.19004317208446386, 0.17275774174141245, 0.19006943308672075, 0.18079675277351126, 0.19471277239888607, 0.1753016294648745, 0.18295602919655307, 0.16661725961518714, 0.16982320320731958, 0.17353559797978435, 0.16423674413154532, 0.186799913798959, 0.17549709933480295, 0.16220133831870331, 0.1690497916637581, 0.1678869697201011, 0.16636585466121667, 0.47498141986447306, 0.14053374049000067, 0.15486286760355905, 0.16488585428991265, 0.17413097092722907, 0.19697103671311933, 0.14450665686672015, 0.13503834598788123, 0.15692120874807225, 0.16692946075521853, 0.20192055481474325, 0.14262115422868193, 0.24140609982228045, 0.16640820353008767, 0.249326912513548, 0.15970987597709552, 0.27618488001198216, 0.1507644971957206, 0.19333169864571687, 0.1835114318496348, 0.1820756650949492, 0.18400758334658196, 0.17368011841108033, 0.18254801496453943, 0.17944232648897074, 0.1933272104061402, 0.1785090125490495, 0.06602612621017778, 0.06810646608895621, 0.06720530017909787, 0.07082291351898762, 0.05770408673913208, 0.08671015438816998, 0.05568389560843412, 0.06168535936906627, 0.07314027735326567]}, "mutation_prompt": null}
{"id": "6220f6e7-9014-4bc4-967c-bbebe473c294", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)  # Combined mutation and clip\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refinement of mutation and velocity calculation for improved convergence.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58e16fae-688e-496f-bc2f-9fbc0efd508e", "metadata": {"aucs": [0.29648833449631395, 0.32238796277523407, 0.28945181019503186, 0.31924513188441084, 0.36065845001940156, 0.35399423456631174, 0.34733561651739797, 0.35490996607633474, 0.336910245127525, 0.03742296337474238, 0.03625905282528641, 0.03700333901073316, 0.021178589924884417, 9.999999999998899e-05, 0.03806932942879071, 0.03837228558275385, 0.019927565589028418, 0.0020545207561177836, 0.09368613488239574, 0.1326914716072113, 0.07302020295307177, 0.1160438187040741, 0.1090681994409779, 0.06227177560529851, 0.07552649085451135, 0.0757285635716265, 0.08835802651730917, 0.06928789897098209, 0.06692803996529506, 0.06317252561257869, 0.0674292212554658, 0.07552455542844405, 0.0720461738858107, 0.07109161971069056, 0.07672602733110179, 0.0632870674923417, 0.9816060025357446, 0.9721851878635085, 0.9784193089624104, 0.9800284600152257, 0.9808332367173507, 0.9787826340018613, 0.9824055579074898, 0.9709730924839818, 0.9726291854117994, 0.18548181161304966, 0.05642948819233584, 0.1812838184909631, 0.18842982699119926, 0.1313851570940664, 0.1841051480284588, 0.16134513385696225, 0.08663249971212883, 0.16830569952409147, 0.14144932635318397, 0.22043560290310538, 0.17962692783772904, 0.15750899854517575, 0.15333409127913744, 0.20688877024830965, 0.16988494112424213, 0.1471054931574709, 0.19797481863650968, 0.061181598562383255, 0.09442780569365128, 0.11151958046906052, 0.0879052658412991, 0.12464963194570977, 0.0953900508216573, 0.10543236981322357, 0.1227875154339968, 0.08507041050033437, 0.0838451906601545, 0.10266624514954548, 0.1144510250655465, 0.062301905676816705, 0.08123392088786208, 0.09608336161537123, 0.0904234584418131, 0.10450353505714338, 0.09602668266239123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00044234599319092904, 9.999999999998899e-05, 0.002511252747175563, 9.999999999998899e-05, 9.999999999998899e-05, 0.03691786195392144, 0.024614169037150302, 0.02032316673101564, 0.007655644622375224, 0.05852231637382266, 0.01014077491601817, 0.04208197455748486, 0.010273721022339144, 0.04369977246510737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013197329543612746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047245812515573915, 0.018133476202637944, 0.0030864015327588534, 0.0864480482678257, 0.002466975701249652, 0.0024837891024799275, 0.05565585090561742, 0.04027283929743719, 0.05036113065017456, 0.32038043595913, 0.3130886252917293, 0.31438453638556996, 0.371273826400371, 0.3309803687369184, 0.3352568922783662, 0.32031555334841466, 0.3446864902902286, 0.3306813596634811, 0.08308482534515182, 0.07345344831423717, 0.06118443632809867, 0.07465610487721985, 0.07419338259217312, 0.07580872849283637, 0.06866523595087692, 0.09673257121507028, 0.07344055374691505, 0.15135799658511673, 0.1619507977437723, 0.13933980553908387, 0.1470672883770816, 0.18664360488840326, 0.14317710781053172, 0.15876763334332644, 0.15825443030954045, 0.16850295016993055, 0.2045670546881999, 0.22309224696775076, 0.18643284888276235, 0.17517180751484507, 0.19709019824666008, 0.2315897924933158, 0.22144164712590486, 0.2203056270093703, 0.23118934255502788, 0.15720166722898798, 0.1674799722306538, 0.15037919384242215, 0.16003795563685108, 0.16645763800291702, 0.1520167438596438, 0.1750781875049655, 0.18162473991644235, 0.17947297984379706, 0.17854750213770954, 0.19004317208446386, 0.17275774174141245, 0.19006943308672075, 0.18079675277351126, 0.19471277239888607, 0.1753016294648745, 0.18295602919655307, 0.16661725961518714, 0.16982320320731958, 0.17353559797978435, 0.16423674413154532, 0.186799913798959, 0.17549709933480295, 0.16220133831870331, 0.1690497916637581, 0.1678869697201011, 0.16636585466121667, 0.47498141986447306, 0.14053374049000067, 0.15486286760355905, 0.16488585428991265, 0.17413097092722907, 0.19697103671311933, 0.14450665686672015, 0.13503834598788123, 0.15692120874807225, 0.16692946075521853, 0.20192055481474325, 0.14262115422868193, 0.24140609982228045, 0.16640820353008767, 0.249326912513548, 0.15970987597709552, 0.27618488001198216, 0.1507644971957206, 0.19333169864571687, 0.1835114318496348, 0.1820756650949492, 0.18400758334658196, 0.17368011841108033, 0.18254801496453943, 0.17944232648897074, 0.1933272104061402, 0.1785090125490495, 0.06602612621017778, 0.06810646608895621, 0.06720530017909787, 0.07082291351898762, 0.05770408673913208, 0.08671015438816998, 0.05568389560843412, 0.06168535936906627, 0.07314027735326567]}, "mutation_prompt": null}
{"id": "0667b282-b782-41da-88df-c5a9950569a9", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)  # Combined mutation and clip\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refinement of mutation and velocity calculation for improved convergence.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58e16fae-688e-496f-bc2f-9fbc0efd508e", "metadata": {"aucs": [0.29648833449631395, 0.32238796277523407, 0.28945181019503186, 0.31924513188441084, 0.36065845001940156, 0.35399423456631174, 0.34733561651739797, 0.35490996607633474, 0.336910245127525, 0.03742296337474238, 0.03625905282528641, 0.03700333901073316, 0.021178589924884417, 9.999999999998899e-05, 0.03806932942879071, 0.03837228558275385, 0.019927565589028418, 0.0020545207561177836, 0.09368613488239574, 0.1326914716072113, 0.07302020295307177, 0.1160438187040741, 0.1090681994409779, 0.06227177560529851, 0.07552649085451135, 0.0757285635716265, 0.08835802651730917, 0.06928789897098209, 0.06692803996529506, 0.06317252561257869, 0.0674292212554658, 0.07552455542844405, 0.0720461738858107, 0.07109161971069056, 0.07672602733110179, 0.0632870674923417, 0.9816060025357446, 0.9721851878635085, 0.9784193089624104, 0.9800284600152257, 0.9808332367173507, 0.9787826340018613, 0.9824055579074898, 0.9709730924839818, 0.9726291854117994, 0.18548181161304966, 0.05642948819233584, 0.1812838184909631, 0.18842982699119926, 0.1313851570940664, 0.1841051480284588, 0.16134513385696225, 0.08663249971212883, 0.16830569952409147, 0.14144932635318397, 0.22043560290310538, 0.17962692783772904, 0.15750899854517575, 0.15333409127913744, 0.20688877024830965, 0.16988494112424213, 0.1471054931574709, 0.19797481863650968, 0.061181598562383255, 0.09442780569365128, 0.11151958046906052, 0.0879052658412991, 0.12464963194570977, 0.0953900508216573, 0.10543236981322357, 0.1227875154339968, 0.08507041050033437, 0.0838451906601545, 0.10266624514954548, 0.1144510250655465, 0.062301905676816705, 0.08123392088786208, 0.09608336161537123, 0.0904234584418131, 0.10450353505714338, 0.09602668266239123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00044234599319092904, 9.999999999998899e-05, 0.002511252747175563, 9.999999999998899e-05, 9.999999999998899e-05, 0.03691786195392144, 0.024614169037150302, 0.02032316673101564, 0.007655644622375224, 0.05852231637382266, 0.01014077491601817, 0.04208197455748486, 0.010273721022339144, 0.04369977246510737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013197329543612746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047245812515573915, 0.018133476202637944, 0.0030864015327588534, 0.0864480482678257, 0.002466975701249652, 0.0024837891024799275, 0.05565585090561742, 0.04027283929743719, 0.05036113065017456, 0.32038043595913, 0.3130886252917293, 0.31438453638556996, 0.371273826400371, 0.3309803687369184, 0.3352568922783662, 0.32031555334841466, 0.3446864902902286, 0.3306813596634811, 0.08308482534515182, 0.07345344831423717, 0.06118443632809867, 0.07465610487721985, 0.07419338259217312, 0.07580872849283637, 0.06866523595087692, 0.09673257121507028, 0.07344055374691505, 0.15135799658511673, 0.1619507977437723, 0.13933980553908387, 0.1470672883770816, 0.18664360488840326, 0.14317710781053172, 0.15876763334332644, 0.15825443030954045, 0.16850295016993055, 0.2045670546881999, 0.22309224696775076, 0.18643284888276235, 0.17517180751484507, 0.19709019824666008, 0.2315897924933158, 0.22144164712590486, 0.2203056270093703, 0.23118934255502788, 0.15720166722898798, 0.1674799722306538, 0.15037919384242215, 0.16003795563685108, 0.16645763800291702, 0.1520167438596438, 0.1750781875049655, 0.18162473991644235, 0.17947297984379706, 0.17854750213770954, 0.19004317208446386, 0.17275774174141245, 0.19006943308672075, 0.18079675277351126, 0.19471277239888607, 0.1753016294648745, 0.18295602919655307, 0.16661725961518714, 0.16982320320731958, 0.17353559797978435, 0.16423674413154532, 0.186799913798959, 0.17549709933480295, 0.16220133831870331, 0.1690497916637581, 0.1678869697201011, 0.16636585466121667, 0.47498141986447306, 0.14053374049000067, 0.15486286760355905, 0.16488585428991265, 0.17413097092722907, 0.19697103671311933, 0.14450665686672015, 0.13503834598788123, 0.15692120874807225, 0.16692946075521853, 0.20192055481474325, 0.14262115422868193, 0.24140609982228045, 0.16640820353008767, 0.249326912513548, 0.15970987597709552, 0.27618488001198216, 0.1507644971957206, 0.19333169864571687, 0.1835114318496348, 0.1820756650949492, 0.18400758334658196, 0.17368011841108033, 0.18254801496453943, 0.17944232648897074, 0.1933272104061402, 0.1785090125490495, 0.06602612621017778, 0.06810646608895621, 0.06720530017909787, 0.07082291351898762, 0.05770408673913208, 0.08671015438816998, 0.05568389560843412, 0.06168535936906627, 0.07314027735326567]}, "mutation_prompt": null}
{"id": "fd273fad-7118-4147-94f2-10d788347715", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adjusted mutation factor\n        self.CR = 0.9\n        self.c1 = 1.8  # Slightly adjusted PSO parameter\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Slight refinement in velocity update and mutation factor for efficiency improvement.", "configspace": "", "generation": 31, "fitness": 0.17436135292442265, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.20.", "error": "", "parent_id": "58e16fae-688e-496f-bc2f-9fbc0efd508e", "metadata": {"aucs": [0.40532656510404563, 0.38761784918602626, 0.33178341360690333, 0.3949700487769243, 0.3724521743614331, 0.38377109951331767, 0.3782898181579477, 0.3820064479116547, 0.4192277305678216, 0.03482409073651893, 0.09184332617878099, 0.06906429822881965, 0.019841548139654552, 9.999999999998899e-05, 0.017770996558067575, 9.999999999998899e-05, 0.02869038701138471, 9.999999999998899e-05, 0.09196292486510738, 0.08497411821122203, 0.11969044831869491, 0.09305883142498805, 0.07049648926901952, 0.10447396910145013, 0.08079387076638955, 0.09501170674967019, 0.10094907344703519, 0.09081574785150281, 0.08424647806561536, 0.07996291598557803, 0.07887943116928087, 0.06834042089997217, 0.06307710444675141, 0.06278638923799373, 0.0701820551850898, 0.08178785562396074, 0.9797197126538176, 0.9892525248403976, 0.9807069008797062, 0.9732761850584443, 0.9824238047703144, 0.9808147153923228, 0.9773429065103192, 0.9898406911035045, 0.981857082998909, 0.15800138712250555, 0.1741432490648398, 0.16551661170191712, 0.20360422843022774, 0.1378795464718332, 0.12434531835947804, 0.1723461987745375, 0.17278453353139545, 0.08731377068128021, 0.1564086253654361, 0.16316455798741047, 0.21081483534923973, 0.2231435809785457, 0.18722236601151776, 0.2184029960917937, 0.15642339265975047, 0.19539601414699914, 0.1855500660985031, 0.10362772658140473, 0.13113453466782032, 0.1247387181908951, 0.10533467242220995, 0.06776091346522173, 0.07599051378510069, 0.10791249324632446, 0.09884550318109175, 0.09247603450278019, 0.08431121494802096, 0.09207271149055218, 0.061974166964727684, 0.10777594309808902, 0.11771943952470498, 0.11621781553929089, 0.09564093915851224, 0.11747170744109936, 0.10687842294157923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00402818065388133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03651807458251011, 0.027121281784675322, 0.04241977092078364, 0.06200871771634753, 0.011172411734067245, 0.02816645207422319, 9.999999999998899e-05, 0.03190149209614668, 0.04526289628287172, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018789456278347494, 0.0006633202597573495, 0.02186291354336245, 0.0002519159285184758, 9.999999999998899e-05, 9.999999999998899e-05, 0.06279155552905324, 0.056068580492122044, 0.005110148411572313, 0.04526283952584331, 0.06636525013425121, 0.0022112102298574854, 0.03953807897556272, 0.07611368579030708, 0.04278272470240685, 0.3256106896929264, 0.338446310968354, 0.32863690297024484, 0.3528541158537276, 0.31863066997824585, 0.3517590684491554, 0.3583054074375953, 0.31347419990718095, 0.33364351361467814, 0.07078512926098224, 0.061849311175727006, 0.06424515104616235, 0.076725211822263, 0.08894387431526629, 0.09574592823738459, 0.07696252455672781, 0.06696988638944201, 0.0737092426346142, 0.18397114833567185, 0.14199743449250002, 0.14696606690135394, 0.1404638386022391, 0.19224245457979072, 0.12496420180041534, 0.15214740381386405, 0.22230824472245148, 0.17925970043610107, 0.22160776808268945, 0.21125917075131406, 0.2283450282303231, 0.22158864926445154, 0.20754628370145578, 0.21018358766295064, 0.15050069076959538, 0.25416218051189554, 0.2568861537243683, 0.1457972542665541, 0.12816741607298865, 0.15530864080102091, 0.15922634682174708, 0.16067640348664136, 0.1284286197192298, 0.20280708137411552, 0.16917123232419418, 0.1814048612856538, 0.1841072783311043, 0.19535916490091731, 0.19132289314247486, 0.16757776041854466, 0.16344089334477996, 0.177024880482631, 0.19404639213593078, 0.19041622036540962, 0.17954484131564474, 0.1770489513410779, 0.18431472352207234, 0.18267787901177657, 0.17489501719546519, 0.1672571782258152, 0.17292446102293502, 0.1686426975394797, 0.17747077307672776, 0.1689219049170948, 0.37399090528238843, 0.2504099909545553, 0.16538943654982485, 0.5123908420219513, 0.17139939306813956, 0.16704855671660257, 0.17252928471306006, 0.33288903147746574, 0.18097717673335634, 0.1620481259430926, 0.11833705860166843, 0.19710137678680795, 0.1703208169345808, 0.10763987480115988, 0.20883939486839864, 0.2576041555094022, 0.14820317212788592, 0.15196234157514754, 0.18583856388467868, 0.20511551211668377, 0.1699230568270661, 0.18569183856293447, 0.22004255215015533, 0.19755008723336764, 0.18476328341025938, 0.17063467164255985, 0.17920595707496212, 0.07152922812676965, 0.07480898725332241, 0.07211934768428452, 0.0650219533471389, 0.08009760091486096, 0.07405756213418302, 0.06902128009615804, 0.06502256847862975, 0.06509898909670575]}, "mutation_prompt": null}
{"id": "f75eb9c4-11a7-46e4-a509-59639cb81216", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adjusted mutation factor\n        self.CR = 0.9\n        self.c1 = 1.8  # Slightly adjusted PSO parameter\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n\n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def differential_evolution(self, population, fitness, func):\n        idxs = np.random.choice(self.pop_size, (self.pop_size, 3), replace=True)\n        a, b, c = population[idxs[:, 0]], population[idxs[:, 1]], population[idxs[:, 2]]\n        mutants = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n        trials = np.where(np.random.rand(self.pop_size, self.dim) < self.CR, mutants, population)\n        trial_fitness = np.apply_along_axis(func, 1, trials)\n        better_indices = trial_fitness < fitness\n        population[better_indices], fitness[better_indices] = trials[better_indices], trial_fitness[better_indices]\n        return population, fitness\n\n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.velocities = 0.7 * self.velocities + self.c1 * r1 * (personal_best - population) + self.c2 * r2 * (global_best - population)\n        updated_positions = np.clip(population + self.velocities, self.bound_min, self.bound_max)\n        current_fitnesses = np.apply_along_axis(func, 1, updated_positions)\n        improved = current_fitnesses < personal_best_fitness\n        personal_best[improved], personal_best_fitness[improved] = updated_positions[improved], current_fitnesses[improved]\n        if np.min(current_fitnesses) < global_best_fitness:\n            global_best = updated_positions[np.argmin(current_fitnesses)]\n        return updated_positions, personal_best, personal_best_fitness, global_best\n\n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n\n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n\n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Streamlined vector operations and improved handling of random indices for performance gain.", "configspace": "", "generation": 32, "fitness": 0.16658256820498774, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "fd273fad-7118-4147-94f2-10d788347715", "metadata": {"aucs": [0.32538429812799086, 0.3289862603524599, 0.37814166185208786, 0.37961587268924546, 0.3346828900708033, 0.3320091796202469, 0.3659259696603637, 0.28294627400106975, 0.3755534685474611, 0.012938047368511452, 0.0032558407751681617, 0.03754142724789311, 9.999999999998899e-05, 9.999999999998899e-05, 0.014276270962599313, 0.022383999760787643, 0.0389050665977988, 0.0018296869751482925, 0.09540499126684832, 0.08904054903816083, 0.07433961574738446, 0.05449338492556921, 0.08269085980056623, 0.07535274025661087, 0.07336421768267032, 0.0542081820801974, 0.08113166710550546, 0.07600112654838409, 0.07942020067674171, 0.07559389684634354, 0.06710400281125217, 0.07378557454751222, 0.06826175816978863, 0.07313732692099673, 0.0861337618978687, 0.08078457844301534, 0.9810649147391033, 0.9706628851528971, 0.9540777387603534, 0.9720624306029323, 0.9625524129046086, 0.9479693943666532, 0.9663726781286792, 0.9599123934611914, 0.962432048740237, 0.1682872754973601, 0.17450563850781076, 0.15657769971206692, 0.12540305993943435, 0.14701899674534125, 0.1674394264411796, 0.08119611805891014, 0.08085212882205273, 0.10814296316862981, 0.1948234757240388, 0.21173250409002364, 0.19875551811321923, 0.17554128961951387, 0.19432407820621367, 0.15401471984768522, 0.20345135066069064, 0.19813414285435982, 0.1751040104900098, 0.10426747227263422, 0.09812368359999213, 0.07922127276357893, 0.09119477597363657, 0.07504263018130786, 0.07643206549485926, 0.08767464696167915, 0.07150951838788355, 0.09088482168054923, 0.04309967841885609, 0.023608227818254113, 0.04080336487005776, 0.08963821953361839, 0.09300629301080021, 0.09948918878847601, 0.10978068594422963, 0.0862311223572726, 0.09010942918971432, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045058978772613, 0.0449865569205089, 0.03936576256454505, 0.06527177434320586, 0.03960755531217075, 0.011456415141568366, 0.03604378953353904, 0.003257432720062181, 0.03541526733605538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001581740408078569, 9.999999999998899e-05, 0.0020565178605899126, 0.002724684549989087, 9.999999999998899e-05, 9.999999999998899e-05, 0.00726606064756341, 0.05315857173134131, 0.04909426114046034, 0.05433708080010269, 0.05043314743517946, 0.028002367817595908, 0.05747698908064447, 0.037156479570317646, 0.06004410754820455, 0.30420401331771596, 0.36917065134489724, 0.33653315561186814, 0.3447890488978407, 0.33990444745120973, 0.30330828490285144, 0.2834081869269147, 0.2945132600898832, 0.2989272910637526, 0.07744682259726465, 0.0636577152190202, 0.0651429828265756, 0.07206479232443197, 0.0841629960204816, 0.08801653737932758, 0.0884757043272113, 0.0916875802601902, 0.09266570786379835, 0.13160912561081894, 0.14339359295599774, 0.18114539975840227, 0.133963523335074, 0.1413610155751378, 0.16481616396827647, 0.16042277175789854, 0.15860616039605302, 0.1449909799647019, 0.21165090237708317, 0.24889445678586675, 0.20024830983377095, 0.20460609521624962, 0.21438835002527168, 0.24421589511830266, 0.22761587236378777, 0.220577228826902, 0.23354231411357385, 0.10900699325212426, 0.12353388909387863, 0.14908422839552182, 0.15248681253259988, 0.1562893213389418, 0.146257240565271, 0.19373932538257166, 0.18175201214806225, 0.1916647598883887, 0.20042185604287177, 0.18831074381852164, 0.17454798941396477, 0.22384358493103795, 0.16645207877212287, 0.17345535685737556, 0.1921811349054755, 0.19591097231054178, 0.16891661039202321, 0.16452362289932732, 0.16734329741302867, 0.17051644321884174, 0.16736141259830983, 0.16658203729041576, 0.17216501574563425, 0.1940383197934129, 0.17350855425978062, 0.1714879556533322, 0.16531617389286168, 0.29741760936787376, 0.1643346508721215, 0.1743912914715927, 0.16174156605151624, 0.3121355013013034, 0.16263548051871624, 0.27992370474353934, 0.15475715563670378, 0.16074752894502253, 0.17309498518718758, 0.32018307038857474, 0.19182129823175453, 0.19766042142964457, 0.1853034394077595, 0.25408843341538334, 0.14683077607481354, 0.19708896568219514, 0.18272837241801387, 0.18748899343206127, 0.19701653266611663, 0.18345851411790293, 0.1992223892675028, 0.1910003044481402, 0.17622046610825837, 0.17456160619467698, 0.19161513086675297, 0.05520122910459413, 0.06403528037755202, 0.06866784340745358, 0.07370742153822152, 0.07804877335955229, 0.06364563538128787, 0.08957137495609457, 0.0796702146951831, 0.06434511078565863]}, "mutation_prompt": null}
{"id": "8b643b1f-3b7b-4da8-8eb2-f11aff2bd614", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.65  # Slightly increased mutation factor\n        self.CR = 0.85  # Slightly decreased crossover rate\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Minor enhancements in mutation scaling and crossover to improve exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.17128392130857747, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "fd273fad-7118-4147-94f2-10d788347715", "metadata": {"aucs": [0.35832439190108245, 0.3714264546688453, 0.39099170947617023, 0.3766734127067334, 0.30782650988003557, 0.18375140214771268, 0.35353704828235955, 0.3693898467422154, 0.3628301945361423, 0.03965404442530107, 9.999999999998899e-05, 0.05049420689122086, 0.08756773557565334, 0.028252422671212973, 9.999999999998899e-05, 0.029645523107100447, 0.002393423587274457, 0.030811116919886028, 0.08570127053481269, 0.08850543596739624, 0.09250009728803466, 0.08097105394418436, 0.09654195267984833, 0.09585578837184272, 0.09125262293854097, 0.08337770505285247, 0.07307746152556738, 0.08296651221464524, 0.07183398304148703, 0.07161821912058475, 0.0730573661681948, 0.08638450937135944, 0.07546974650278715, 0.05328404419142696, 0.07412833333912205, 0.0682778442596289, 0.977626071440015, 0.9805115266313204, 0.9781270470693124, 0.9801269486986133, 0.980462253134419, 0.9789421526138911, 0.9804184849266996, 0.9812645470779966, 0.9791741043365559, 0.06280278965552333, 0.18023895845843652, 0.19049090705011495, 0.1829353762756264, 0.188284433064268, 0.1374809462304969, 0.07759311218934128, 0.08696574480392716, 0.13927358527834788, 0.15492538900305175, 0.2220318527495827, 0.16586012408622042, 0.18217148253647752, 0.236854650188962, 0.23115076735021522, 0.12120437652422167, 0.2072942341286622, 0.11969988435900358, 0.09948641939863756, 0.04668268308880619, 0.11845010624257613, 0.1355088300727979, 0.1014120119802625, 0.11337988493221363, 0.11150365366605897, 0.1093415129091192, 0.10622893067176242, 0.04742221413021941, 0.10938446730053675, 0.11223813993778708, 0.10049946745063354, 0.11165359897944693, 0.10059554391141023, 0.1330109697987657, 0.054444762537990576, 0.10659995679928247, 9.999999999998899e-05, 9.999999999998899e-05, 0.005928632827249425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000409337977751445, 9.999999999998899e-05, 9.999999999998899e-05, 0.04030305779184307, 0.041063346362082975, 0.025359631653825043, 0.031087347827233325, 9.999999999998899e-05, 0.007154502628479498, 0.007709018759896047, 0.010876804200699697, 0.04997318512903259, 0.0005954530075592546, 0.0028334173659168016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014113565628733893, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004005788240799557, 0.05742148165696859, 0.030274448012260313, 0.032833067543245886, 0.021937622008308955, 0.005553631867702968, 0.07314865380782232, 0.06398502972243458, 0.039254083154457886, 0.04731067007473411, 0.341868692117975, 0.3299301721303507, 0.35670463045213885, 0.33192023877841814, 0.3258814386533605, 0.33608065220358463, 0.31362636072817973, 0.31724912432259966, 0.34270197720209716, 0.08030782583749074, 0.06005846419633143, 0.07990671125653026, 0.0855238277612611, 0.07116190878915807, 0.07395712657934306, 0.08254235785980713, 0.06789041141968377, 0.08988269697001727, 0.2008178389785099, 0.14178459761194062, 0.16803008507911144, 0.16224955413555275, 0.18294658432227218, 0.13751091789781567, 0.12739791077030682, 0.21748832071281876, 0.16275218458018004, 0.2658059561283339, 0.2269352299026175, 0.25237474666766546, 0.23458245059211114, 0.1989988393824369, 0.22595276669740427, 0.18810100226323434, 0.2291448247844583, 0.2580390733376744, 0.1724775837182062, 0.18653418290849, 0.16933669817715014, 0.15229594039448202, 0.1651900266071643, 0.185600597973947, 0.15542806082608207, 0.1953197882891694, 0.1448347681890616, 0.18293203033690308, 0.18001616538599408, 0.16905795148407965, 0.1674791241169995, 0.19800045984144388, 0.1734172190568446, 0.16266468194801476, 0.17692188388385655, 0.1947511832783424, 0.18633241302101922, 0.1799792626304677, 0.17944759536154653, 0.1811454373570084, 0.21168575993240746, 0.17553108889384017, 0.1779664897765908, 0.174986461742054, 0.1801710958308662, 0.1635611553813735, 0.16849692351537127, 0.18168961764186675, 0.19156575695394473, 0.1627300946291378, 0.11265334802819582, 0.15069754400406, 0.1404866076965795, 0.4809363768259537, 0.16542815387710508, 0.33372374938079186, 0.17986415541026168, 0.28121143057108355, 0.23879474316328675, 0.19146679504028719, 0.18138411737125582, 0.18743593618217913, 0.2745847901483347, 0.17530777286276367, 0.18643550624921312, 0.1964240296284675, 0.17781651186410397, 0.16990709994383357, 0.17650603568650947, 0.18030486172569404, 0.19185842812191445, 0.19088281603398516, 0.06960996678285647, 0.07386717900234929, 0.08359535375472882, 0.07290539811045127, 0.0630453476959505, 0.06356704523583212, 0.058992096049094056, 0.061256272758204666, 0.062269880793578536]}, "mutation_prompt": null}
{"id": "03f2f629-02e0-4533-b8bd-4463b82e0b76", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adjusted mutation factor\n        self.CR = 0.9\n        self.c1 = 1.8  # Slightly adjusted PSO parameter\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Slight refinement in velocity update and mutation factor for efficiency improvement.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fd273fad-7118-4147-94f2-10d788347715", "metadata": {"aucs": [0.40532656510404563, 0.38761784918602626, 0.33178341360690333, 0.3949700487769243, 0.3724521743614331, 0.38377109951331767, 0.3782898181579477, 0.3820064479116547, 0.4192277305678216, 0.03482409073651893, 0.09184332617878099, 0.06906429822881965, 0.019841548139654552, 9.999999999998899e-05, 0.017770996558067575, 9.999999999998899e-05, 0.02869038701138471, 9.999999999998899e-05, 0.09196292486510738, 0.08497411821122203, 0.11969044831869491, 0.09305883142498805, 0.07049648926901952, 0.10447396910145013, 0.08079387076638955, 0.09501170674967019, 0.10094907344703519, 0.09081574785150281, 0.08424647806561536, 0.07996291598557803, 0.07887943116928087, 0.06834042089997217, 0.06307710444675141, 0.06278638923799373, 0.0701820551850898, 0.08178785562396074, 0.9797197126538176, 0.9892525248403976, 0.9807069008797062, 0.9732761850584443, 0.9824238047703144, 0.9808147153923228, 0.9773429065103192, 0.9898406911035045, 0.981857082998909, 0.15800138712250555, 0.1741432490648398, 0.16551661170191712, 0.20360422843022774, 0.1378795464718332, 0.12434531835947804, 0.1723461987745375, 0.17278453353139545, 0.08731377068128021, 0.1564086253654361, 0.16316455798741047, 0.21081483534923973, 0.2231435809785457, 0.18722236601151776, 0.2184029960917937, 0.15642339265975047, 0.19539601414699914, 0.1855500660985031, 0.10362772658140473, 0.13113453466782032, 0.1247387181908951, 0.10533467242220995, 0.06776091346522173, 0.07599051378510069, 0.10791249324632446, 0.09884550318109175, 0.09247603450278019, 0.08431121494802096, 0.09207271149055218, 0.061974166964727684, 0.10777594309808902, 0.11771943952470498, 0.11621781553929089, 0.09564093915851224, 0.11747170744109936, 0.10687842294157923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00402818065388133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03651807458251011, 0.027121281784675322, 0.04241977092078364, 0.06200871771634753, 0.011172411734067245, 0.02816645207422319, 9.999999999998899e-05, 0.03190149209614668, 0.04526289628287172, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018789456278347494, 0.0006633202597573495, 0.02186291354336245, 0.0002519159285184758, 9.999999999998899e-05, 9.999999999998899e-05, 0.06279155552905324, 0.056068580492122044, 0.005110148411572313, 0.04526283952584331, 0.06636525013425121, 0.0022112102298574854, 0.03953807897556272, 0.07611368579030708, 0.04278272470240685, 0.3256106896929264, 0.338446310968354, 0.32863690297024484, 0.3528541158537276, 0.31863066997824585, 0.3517590684491554, 0.3583054074375953, 0.31347419990718095, 0.33364351361467814, 0.07078512926098224, 0.061849311175727006, 0.06424515104616235, 0.076725211822263, 0.08894387431526629, 0.09574592823738459, 0.07696252455672781, 0.06696988638944201, 0.0737092426346142, 0.18397114833567185, 0.14199743449250002, 0.14696606690135394, 0.1404638386022391, 0.19224245457979072, 0.12496420180041534, 0.15214740381386405, 0.22230824472245148, 0.17925970043610107, 0.22160776808268945, 0.21125917075131406, 0.2283450282303231, 0.22158864926445154, 0.20754628370145578, 0.21018358766295064, 0.15050069076959538, 0.25416218051189554, 0.2568861537243683, 0.1457972542665541, 0.12816741607298865, 0.15530864080102091, 0.15922634682174708, 0.16067640348664136, 0.1284286197192298, 0.20280708137411552, 0.16917123232419418, 0.1814048612856538, 0.1841072783311043, 0.19535916490091731, 0.19132289314247486, 0.16757776041854466, 0.16344089334477996, 0.177024880482631, 0.19404639213593078, 0.19041622036540962, 0.17954484131564474, 0.1770489513410779, 0.18431472352207234, 0.18267787901177657, 0.17489501719546519, 0.1672571782258152, 0.17292446102293502, 0.1686426975394797, 0.17747077307672776, 0.1689219049170948, 0.37399090528238843, 0.2504099909545553, 0.16538943654982485, 0.5123908420219513, 0.17139939306813956, 0.16704855671660257, 0.17252928471306006, 0.33288903147746574, 0.18097717673335634, 0.1620481259430926, 0.11833705860166843, 0.19710137678680795, 0.1703208169345808, 0.10763987480115988, 0.20883939486839864, 0.2576041555094022, 0.14820317212788592, 0.15196234157514754, 0.18583856388467868, 0.20511551211668377, 0.1699230568270661, 0.18569183856293447, 0.22004255215015533, 0.19755008723336764, 0.18476328341025938, 0.17063467164255985, 0.17920595707496212, 0.07152922812676965, 0.07480898725332241, 0.07211934768428452, 0.0650219533471389, 0.08009760091486096, 0.07405756213418302, 0.06902128009615804, 0.06502256847862975, 0.06509898909670575]}, "mutation_prompt": null}
{"id": "b7027630-8e52-4bfa-8d63-0c459a740f7a", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adjusted mutation factor\n        self.CR = 0.9\n        self.c1 = 1.8  # Slightly adjusted PSO parameter\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            population, fitness = self.differential_evolution(population, fitness, func)\n            population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                population, fitness, personal_best, personal_best_fitness, global_best, func\n            )\n            num_evaluations += 2 * self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Slight refinement in velocity update and mutation factor for efficiency improvement.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fd273fad-7118-4147-94f2-10d788347715", "metadata": {"aucs": [0.40532656510404563, 0.38761784918602626, 0.33178341360690333, 0.3949700487769243, 0.3724521743614331, 0.38377109951331767, 0.3782898181579477, 0.3820064479116547, 0.4192277305678216, 0.03482409073651893, 0.09184332617878099, 0.06906429822881965, 0.019841548139654552, 9.999999999998899e-05, 0.017770996558067575, 9.999999999998899e-05, 0.02869038701138471, 9.999999999998899e-05, 0.09196292486510738, 0.08497411821122203, 0.11969044831869491, 0.09305883142498805, 0.07049648926901952, 0.10447396910145013, 0.08079387076638955, 0.09501170674967019, 0.10094907344703519, 0.09081574785150281, 0.08424647806561536, 0.07996291598557803, 0.07887943116928087, 0.06834042089997217, 0.06307710444675141, 0.06278638923799373, 0.0701820551850898, 0.08178785562396074, 0.9797197126538176, 0.9892525248403976, 0.9807069008797062, 0.9732761850584443, 0.9824238047703144, 0.9808147153923228, 0.9773429065103192, 0.9898406911035045, 0.981857082998909, 0.15800138712250555, 0.1741432490648398, 0.16551661170191712, 0.20360422843022774, 0.1378795464718332, 0.12434531835947804, 0.1723461987745375, 0.17278453353139545, 0.08731377068128021, 0.1564086253654361, 0.16316455798741047, 0.21081483534923973, 0.2231435809785457, 0.18722236601151776, 0.2184029960917937, 0.15642339265975047, 0.19539601414699914, 0.1855500660985031, 0.10362772658140473, 0.13113453466782032, 0.1247387181908951, 0.10533467242220995, 0.06776091346522173, 0.07599051378510069, 0.10791249324632446, 0.09884550318109175, 0.09247603450278019, 0.08431121494802096, 0.09207271149055218, 0.061974166964727684, 0.10777594309808902, 0.11771943952470498, 0.11621781553929089, 0.09564093915851224, 0.11747170744109936, 0.10687842294157923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00402818065388133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03651807458251011, 0.027121281784675322, 0.04241977092078364, 0.06200871771634753, 0.011172411734067245, 0.02816645207422319, 9.999999999998899e-05, 0.03190149209614668, 0.04526289628287172, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018789456278347494, 0.0006633202597573495, 0.02186291354336245, 0.0002519159285184758, 9.999999999998899e-05, 9.999999999998899e-05, 0.06279155552905324, 0.056068580492122044, 0.005110148411572313, 0.04526283952584331, 0.06636525013425121, 0.0022112102298574854, 0.03953807897556272, 0.07611368579030708, 0.04278272470240685, 0.3256106896929264, 0.338446310968354, 0.32863690297024484, 0.3528541158537276, 0.31863066997824585, 0.3517590684491554, 0.3583054074375953, 0.31347419990718095, 0.33364351361467814, 0.07078512926098224, 0.061849311175727006, 0.06424515104616235, 0.076725211822263, 0.08894387431526629, 0.09574592823738459, 0.07696252455672781, 0.06696988638944201, 0.0737092426346142, 0.18397114833567185, 0.14199743449250002, 0.14696606690135394, 0.1404638386022391, 0.19224245457979072, 0.12496420180041534, 0.15214740381386405, 0.22230824472245148, 0.17925970043610107, 0.22160776808268945, 0.21125917075131406, 0.2283450282303231, 0.22158864926445154, 0.20754628370145578, 0.21018358766295064, 0.15050069076959538, 0.25416218051189554, 0.2568861537243683, 0.1457972542665541, 0.12816741607298865, 0.15530864080102091, 0.15922634682174708, 0.16067640348664136, 0.1284286197192298, 0.20280708137411552, 0.16917123232419418, 0.1814048612856538, 0.1841072783311043, 0.19535916490091731, 0.19132289314247486, 0.16757776041854466, 0.16344089334477996, 0.177024880482631, 0.19404639213593078, 0.19041622036540962, 0.17954484131564474, 0.1770489513410779, 0.18431472352207234, 0.18267787901177657, 0.17489501719546519, 0.1672571782258152, 0.17292446102293502, 0.1686426975394797, 0.17747077307672776, 0.1689219049170948, 0.37399090528238843, 0.2504099909545553, 0.16538943654982485, 0.5123908420219513, 0.17139939306813956, 0.16704855671660257, 0.17252928471306006, 0.33288903147746574, 0.18097717673335634, 0.1620481259430926, 0.11833705860166843, 0.19710137678680795, 0.1703208169345808, 0.10763987480115988, 0.20883939486839864, 0.2576041555094022, 0.14820317212788592, 0.15196234157514754, 0.18583856388467868, 0.20511551211668377, 0.1699230568270661, 0.18569183856293447, 0.22004255215015533, 0.19755008723336764, 0.18476328341025938, 0.17063467164255985, 0.17920595707496212, 0.07152922812676965, 0.07480898725332241, 0.07211934768428452, 0.0650219533471389, 0.08009760091486096, 0.07405756213418302, 0.06902128009615804, 0.06502256847862975, 0.06509898909670575]}, "mutation_prompt": null}
{"id": "855d73a6-f9d7-4568-9a9e-9bd49f03f978", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.55  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Enhanced balancing between DE and PSO phases for improved convergence.", "configspace": "", "generation": 36, "fitness": 0.1774542113975986, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "fd273fad-7118-4147-94f2-10d788347715", "metadata": {"aucs": [0.35025869496865847, 0.378819633927739, 0.38429010889649773, 0.3644765607657309, 0.3623828666228879, 0.3900092752605978, 0.4209968087344811, 0.38661625389585585, 0.3954639511309769, 0.039057093851797564, 9.999999999998899e-05, 0.019810970761783175, 9.999999999998899e-05, 0.023454517605671743, 0.02289410139008108, 0.004454560576156785, 0.03319427007209763, 0.02692731257618619, 0.09278807235998776, 0.0788444580805272, 0.0938107618544296, 0.10570484601273022, 0.09811721430529474, 0.09114587702865651, 0.10893272123157971, 0.10831551966743913, 0.07530277759207549, 0.0808334205071658, 0.09424203270680986, 0.07636461721715326, 0.08027286182505655, 0.10290341034818562, 0.07354324857979577, 0.06967145753531334, 0.09672428303749125, 0.07657854923356411, 0.9848413741915965, 0.9930790569209461, 0.9827292357920856, 0.9859485226853991, 0.9867038424810366, 0.9864322128761506, 0.9843013152847901, 0.9816222947223866, 0.9840482763690271, 0.1888468742616486, 0.1663678280386064, 0.16501169704882745, 0.14263731999869755, 0.1452593968174659, 0.15659799697417953, 0.19070351101597993, 0.1538206491250823, 0.1858076640969183, 0.15941119788866176, 0.18469617506401026, 0.1711556715909186, 0.2458166086281356, 0.21028700186700267, 0.181923842832173, 0.13512917178610373, 0.12602957522660485, 0.16745593849705198, 0.09989242705077561, 0.11349801342035803, 0.12174322165353846, 0.0865396728698673, 0.10352765102406247, 0.059559048842086626, 0.13722675839470955, 0.10433917563419659, 0.09202962810195858, 0.10914785240887015, 0.10567552702640493, 0.12242609994675857, 0.11742697494387289, 0.09478609867961563, 0.10320381299293568, 0.0964848592570674, 0.11028744224034781, 0.1038881430258316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04572905509851477, 0.053951123688617764, 0.030794346870795408, 9.999999999998899e-05, 0.008597330349798926, 0.04236338400669759, 0.07916354951750748, 0.03553564491117045, 0.03545468178462852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002007261337788613, 9.999999999998899e-05, 0.00070549691725319, 9.999999999998899e-05, 0.059182508003971845, 0.023053472321824975, 0.039024713361543006, 0.07378974328777133, 0.029769489965394524, 0.0020066090342257814, 0.050777040082014, 0.04239663448279296, 0.03967239057537009, 0.33021201690061297, 0.31119549205166086, 0.32427163543884785, 0.35595060010170565, 0.33896006313202287, 0.34896920746164195, 0.36038378661336623, 0.31963437204475775, 0.31973973599691263, 0.07172937683086367, 0.09367638138468615, 0.0776450857616574, 0.08263379836696294, 0.10166241032551404, 0.08557183611579944, 0.07270702836109244, 0.09019346875216538, 0.06411420483813512, 0.15718914618449176, 0.1399932158709427, 0.1866888235121864, 0.1894334441269523, 0.1852340604903544, 0.2516862661776438, 0.13648707857378994, 0.1600944042557083, 0.22833065866724245, 0.225613448192704, 0.24114411338337705, 0.2589965723352471, 0.2356737507060448, 0.2237141767602614, 0.21929438643606258, 0.26342629004897533, 0.22120140497718743, 0.23212061871130651, 0.18651420897572157, 0.14926609561502935, 0.18197374926353027, 0.1321360532691528, 0.17197525793411683, 0.1733346529690789, 0.1831155938779454, 0.126090533574853, 0.1311051637364843, 0.16982094678360338, 0.1881988578748921, 0.17452542229857704, 0.15870560593798488, 0.14043261825641695, 0.20412224818266622, 0.17387575404334543, 0.1881082640238313, 0.17276192603108098, 0.1867078967894218, 0.18919398068795412, 0.176362215567754, 0.17573992463591093, 0.17519400185351552, 0.19471082762552983, 0.1704403710396062, 0.18942297309466183, 0.20357210395264458, 0.25672085053692584, 0.16295718141166327, 0.4905927833741799, 0.16775873606763125, 0.5020968905391006, 0.20761185725925224, 0.16522964866341316, 0.16730795212823246, 0.16409376973936818, 0.17211579857698578, 0.2784870817587959, 0.1709434721046349, 0.19289336012375724, 0.1505131516593512, 0.11082042812451587, 0.40325177224937847, 0.1587603249379692, 0.20014236725480528, 0.17809320887517643, 0.18092173099371645, 0.1848474958421108, 0.18068895015830655, 0.1952237848545183, 0.1929242390845477, 0.16802193644826025, 0.18870842209111693, 0.18199809883610873, 0.07542017717207727, 0.06930741620972336, 0.0671000151386314, 0.0745736435605513, 0.0738843718768527, 0.07037461096515285, 0.08049514950218217, 0.06321943086513548, 0.07760569976008991]}, "mutation_prompt": null}
{"id": "1a6dc88f-53bb-4f23-afe3-532ace0ac83a", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.55  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Enhanced balancing between DE and PSO phases for improved convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "855d73a6-f9d7-4568-9a9e-9bd49f03f978", "metadata": {"aucs": [0.35025869496865847, 0.378819633927739, 0.38429010889649773, 0.3644765607657309, 0.3623828666228879, 0.3900092752605978, 0.4209968087344811, 0.38661625389585585, 0.3954639511309769, 0.039057093851797564, 9.999999999998899e-05, 0.019810970761783175, 9.999999999998899e-05, 0.023454517605671743, 0.02289410139008108, 0.004454560576156785, 0.03319427007209763, 0.02692731257618619, 0.09278807235998776, 0.0788444580805272, 0.0938107618544296, 0.10570484601273022, 0.09811721430529474, 0.09114587702865651, 0.10893272123157971, 0.10831551966743913, 0.07530277759207549, 0.0808334205071658, 0.09424203270680986, 0.07636461721715326, 0.08027286182505655, 0.10290341034818562, 0.07354324857979577, 0.06967145753531334, 0.09672428303749125, 0.07657854923356411, 0.9848413741915965, 0.9930790569209461, 0.9827292357920856, 0.9859485226853991, 0.9867038424810366, 0.9864322128761506, 0.9843013152847901, 0.9816222947223866, 0.9840482763690271, 0.1888468742616486, 0.1663678280386064, 0.16501169704882745, 0.14263731999869755, 0.1452593968174659, 0.15659799697417953, 0.19070351101597993, 0.1538206491250823, 0.1858076640969183, 0.15941119788866176, 0.18469617506401026, 0.1711556715909186, 0.2458166086281356, 0.21028700186700267, 0.181923842832173, 0.13512917178610373, 0.12602957522660485, 0.16745593849705198, 0.09989242705077561, 0.11349801342035803, 0.12174322165353846, 0.0865396728698673, 0.10352765102406247, 0.059559048842086626, 0.13722675839470955, 0.10433917563419659, 0.09202962810195858, 0.10914785240887015, 0.10567552702640493, 0.12242609994675857, 0.11742697494387289, 0.09478609867961563, 0.10320381299293568, 0.0964848592570674, 0.11028744224034781, 0.1038881430258316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04572905509851477, 0.053951123688617764, 0.030794346870795408, 9.999999999998899e-05, 0.008597330349798926, 0.04236338400669759, 0.07916354951750748, 0.03553564491117045, 0.03545468178462852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002007261337788613, 9.999999999998899e-05, 0.00070549691725319, 9.999999999998899e-05, 0.059182508003971845, 0.023053472321824975, 0.039024713361543006, 0.07378974328777133, 0.029769489965394524, 0.0020066090342257814, 0.050777040082014, 0.04239663448279296, 0.03967239057537009, 0.33021201690061297, 0.31119549205166086, 0.32427163543884785, 0.35595060010170565, 0.33896006313202287, 0.34896920746164195, 0.36038378661336623, 0.31963437204475775, 0.31973973599691263, 0.07172937683086367, 0.09367638138468615, 0.0776450857616574, 0.08263379836696294, 0.10166241032551404, 0.08557183611579944, 0.07270702836109244, 0.09019346875216538, 0.06411420483813512, 0.15718914618449176, 0.1399932158709427, 0.1866888235121864, 0.1894334441269523, 0.1852340604903544, 0.2516862661776438, 0.13648707857378994, 0.1600944042557083, 0.22833065866724245, 0.225613448192704, 0.24114411338337705, 0.2589965723352471, 0.2356737507060448, 0.2237141767602614, 0.21929438643606258, 0.26342629004897533, 0.22120140497718743, 0.23212061871130651, 0.18651420897572157, 0.14926609561502935, 0.18197374926353027, 0.1321360532691528, 0.17197525793411683, 0.1733346529690789, 0.1831155938779454, 0.126090533574853, 0.1311051637364843, 0.16982094678360338, 0.1881988578748921, 0.17452542229857704, 0.15870560593798488, 0.14043261825641695, 0.20412224818266622, 0.17387575404334543, 0.1881082640238313, 0.17276192603108098, 0.1867078967894218, 0.18919398068795412, 0.176362215567754, 0.17573992463591093, 0.17519400185351552, 0.19471082762552983, 0.1704403710396062, 0.18942297309466183, 0.20357210395264458, 0.25672085053692584, 0.16295718141166327, 0.4905927833741799, 0.16775873606763125, 0.5020968905391006, 0.20761185725925224, 0.16522964866341316, 0.16730795212823246, 0.16409376973936818, 0.17211579857698578, 0.2784870817587959, 0.1709434721046349, 0.19289336012375724, 0.1505131516593512, 0.11082042812451587, 0.40325177224937847, 0.1587603249379692, 0.20014236725480528, 0.17809320887517643, 0.18092173099371645, 0.1848474958421108, 0.18068895015830655, 0.1952237848545183, 0.1929242390845477, 0.16802193644826025, 0.18870842209111693, 0.18199809883610873, 0.07542017717207727, 0.06930741620972336, 0.0671000151386314, 0.0745736435605513, 0.0738843718768527, 0.07037461096515285, 0.08049514950218217, 0.06321943086513548, 0.07760569976008991]}, "mutation_prompt": null}
{"id": "f1aab9d7-86fb-43d6-95ac-aaa25c15ee68", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.55  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Enhanced balancing between DE and PSO phases for improved convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "855d73a6-f9d7-4568-9a9e-9bd49f03f978", "metadata": {"aucs": [0.35025869496865847, 0.378819633927739, 0.38429010889649773, 0.3644765607657309, 0.3623828666228879, 0.3900092752605978, 0.4209968087344811, 0.38661625389585585, 0.3954639511309769, 0.039057093851797564, 9.999999999998899e-05, 0.019810970761783175, 9.999999999998899e-05, 0.023454517605671743, 0.02289410139008108, 0.004454560576156785, 0.03319427007209763, 0.02692731257618619, 0.09278807235998776, 0.0788444580805272, 0.0938107618544296, 0.10570484601273022, 0.09811721430529474, 0.09114587702865651, 0.10893272123157971, 0.10831551966743913, 0.07530277759207549, 0.0808334205071658, 0.09424203270680986, 0.07636461721715326, 0.08027286182505655, 0.10290341034818562, 0.07354324857979577, 0.06967145753531334, 0.09672428303749125, 0.07657854923356411, 0.9848413741915965, 0.9930790569209461, 0.9827292357920856, 0.9859485226853991, 0.9867038424810366, 0.9864322128761506, 0.9843013152847901, 0.9816222947223866, 0.9840482763690271, 0.1888468742616486, 0.1663678280386064, 0.16501169704882745, 0.14263731999869755, 0.1452593968174659, 0.15659799697417953, 0.19070351101597993, 0.1538206491250823, 0.1858076640969183, 0.15941119788866176, 0.18469617506401026, 0.1711556715909186, 0.2458166086281356, 0.21028700186700267, 0.181923842832173, 0.13512917178610373, 0.12602957522660485, 0.16745593849705198, 0.09989242705077561, 0.11349801342035803, 0.12174322165353846, 0.0865396728698673, 0.10352765102406247, 0.059559048842086626, 0.13722675839470955, 0.10433917563419659, 0.09202962810195858, 0.10914785240887015, 0.10567552702640493, 0.12242609994675857, 0.11742697494387289, 0.09478609867961563, 0.10320381299293568, 0.0964848592570674, 0.11028744224034781, 0.1038881430258316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04572905509851477, 0.053951123688617764, 0.030794346870795408, 9.999999999998899e-05, 0.008597330349798926, 0.04236338400669759, 0.07916354951750748, 0.03553564491117045, 0.03545468178462852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002007261337788613, 9.999999999998899e-05, 0.00070549691725319, 9.999999999998899e-05, 0.059182508003971845, 0.023053472321824975, 0.039024713361543006, 0.07378974328777133, 0.029769489965394524, 0.0020066090342257814, 0.050777040082014, 0.04239663448279296, 0.03967239057537009, 0.33021201690061297, 0.31119549205166086, 0.32427163543884785, 0.35595060010170565, 0.33896006313202287, 0.34896920746164195, 0.36038378661336623, 0.31963437204475775, 0.31973973599691263, 0.07172937683086367, 0.09367638138468615, 0.0776450857616574, 0.08263379836696294, 0.10166241032551404, 0.08557183611579944, 0.07270702836109244, 0.09019346875216538, 0.06411420483813512, 0.15718914618449176, 0.1399932158709427, 0.1866888235121864, 0.1894334441269523, 0.1852340604903544, 0.2516862661776438, 0.13648707857378994, 0.1600944042557083, 0.22833065866724245, 0.225613448192704, 0.24114411338337705, 0.2589965723352471, 0.2356737507060448, 0.2237141767602614, 0.21929438643606258, 0.26342629004897533, 0.22120140497718743, 0.23212061871130651, 0.18651420897572157, 0.14926609561502935, 0.18197374926353027, 0.1321360532691528, 0.17197525793411683, 0.1733346529690789, 0.1831155938779454, 0.126090533574853, 0.1311051637364843, 0.16982094678360338, 0.1881988578748921, 0.17452542229857704, 0.15870560593798488, 0.14043261825641695, 0.20412224818266622, 0.17387575404334543, 0.1881082640238313, 0.17276192603108098, 0.1867078967894218, 0.18919398068795412, 0.176362215567754, 0.17573992463591093, 0.17519400185351552, 0.19471082762552983, 0.1704403710396062, 0.18942297309466183, 0.20357210395264458, 0.25672085053692584, 0.16295718141166327, 0.4905927833741799, 0.16775873606763125, 0.5020968905391006, 0.20761185725925224, 0.16522964866341316, 0.16730795212823246, 0.16409376973936818, 0.17211579857698578, 0.2784870817587959, 0.1709434721046349, 0.19289336012375724, 0.1505131516593512, 0.11082042812451587, 0.40325177224937847, 0.1587603249379692, 0.20014236725480528, 0.17809320887517643, 0.18092173099371645, 0.1848474958421108, 0.18068895015830655, 0.1952237848545183, 0.1929242390845477, 0.16802193644826025, 0.18870842209111693, 0.18199809883610873, 0.07542017717207727, 0.06930741620972336, 0.0671000151386314, 0.0745736435605513, 0.0738843718768527, 0.07037461096515285, 0.08049514950218217, 0.06321943086513548, 0.07760569976008991]}, "mutation_prompt": null}
{"id": "cbf5d492-7a10-41e1-9e7d-84329c16a732", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.55  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocities[i] = 0.7 * self.velocities[i] + self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Enhanced balancing between DE and PSO phases for improved convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "855d73a6-f9d7-4568-9a9e-9bd49f03f978", "metadata": {"aucs": [0.35025869496865847, 0.378819633927739, 0.38429010889649773, 0.3644765607657309, 0.3623828666228879, 0.3900092752605978, 0.4209968087344811, 0.38661625389585585, 0.3954639511309769, 0.039057093851797564, 9.999999999998899e-05, 0.019810970761783175, 9.999999999998899e-05, 0.023454517605671743, 0.02289410139008108, 0.004454560576156785, 0.03319427007209763, 0.02692731257618619, 0.09278807235998776, 0.0788444580805272, 0.0938107618544296, 0.10570484601273022, 0.09811721430529474, 0.09114587702865651, 0.10893272123157971, 0.10831551966743913, 0.07530277759207549, 0.0808334205071658, 0.09424203270680986, 0.07636461721715326, 0.08027286182505655, 0.10290341034818562, 0.07354324857979577, 0.06967145753531334, 0.09672428303749125, 0.07657854923356411, 0.9848413741915965, 0.9930790569209461, 0.9827292357920856, 0.9859485226853991, 0.9867038424810366, 0.9864322128761506, 0.9843013152847901, 0.9816222947223866, 0.9840482763690271, 0.1888468742616486, 0.1663678280386064, 0.16501169704882745, 0.14263731999869755, 0.1452593968174659, 0.15659799697417953, 0.19070351101597993, 0.1538206491250823, 0.1858076640969183, 0.15941119788866176, 0.18469617506401026, 0.1711556715909186, 0.2458166086281356, 0.21028700186700267, 0.181923842832173, 0.13512917178610373, 0.12602957522660485, 0.16745593849705198, 0.09989242705077561, 0.11349801342035803, 0.12174322165353846, 0.0865396728698673, 0.10352765102406247, 0.059559048842086626, 0.13722675839470955, 0.10433917563419659, 0.09202962810195858, 0.10914785240887015, 0.10567552702640493, 0.12242609994675857, 0.11742697494387289, 0.09478609867961563, 0.10320381299293568, 0.0964848592570674, 0.11028744224034781, 0.1038881430258316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04572905509851477, 0.053951123688617764, 0.030794346870795408, 9.999999999998899e-05, 0.008597330349798926, 0.04236338400669759, 0.07916354951750748, 0.03553564491117045, 0.03545468178462852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002007261337788613, 9.999999999998899e-05, 0.00070549691725319, 9.999999999998899e-05, 0.059182508003971845, 0.023053472321824975, 0.039024713361543006, 0.07378974328777133, 0.029769489965394524, 0.0020066090342257814, 0.050777040082014, 0.04239663448279296, 0.03967239057537009, 0.33021201690061297, 0.31119549205166086, 0.32427163543884785, 0.35595060010170565, 0.33896006313202287, 0.34896920746164195, 0.36038378661336623, 0.31963437204475775, 0.31973973599691263, 0.07172937683086367, 0.09367638138468615, 0.0776450857616574, 0.08263379836696294, 0.10166241032551404, 0.08557183611579944, 0.07270702836109244, 0.09019346875216538, 0.06411420483813512, 0.15718914618449176, 0.1399932158709427, 0.1866888235121864, 0.1894334441269523, 0.1852340604903544, 0.2516862661776438, 0.13648707857378994, 0.1600944042557083, 0.22833065866724245, 0.225613448192704, 0.24114411338337705, 0.2589965723352471, 0.2356737507060448, 0.2237141767602614, 0.21929438643606258, 0.26342629004897533, 0.22120140497718743, 0.23212061871130651, 0.18651420897572157, 0.14926609561502935, 0.18197374926353027, 0.1321360532691528, 0.17197525793411683, 0.1733346529690789, 0.1831155938779454, 0.126090533574853, 0.1311051637364843, 0.16982094678360338, 0.1881988578748921, 0.17452542229857704, 0.15870560593798488, 0.14043261825641695, 0.20412224818266622, 0.17387575404334543, 0.1881082640238313, 0.17276192603108098, 0.1867078967894218, 0.18919398068795412, 0.176362215567754, 0.17573992463591093, 0.17519400185351552, 0.19471082762552983, 0.1704403710396062, 0.18942297309466183, 0.20357210395264458, 0.25672085053692584, 0.16295718141166327, 0.4905927833741799, 0.16775873606763125, 0.5020968905391006, 0.20761185725925224, 0.16522964866341316, 0.16730795212823246, 0.16409376973936818, 0.17211579857698578, 0.2784870817587959, 0.1709434721046349, 0.19289336012375724, 0.1505131516593512, 0.11082042812451587, 0.40325177224937847, 0.1587603249379692, 0.20014236725480528, 0.17809320887517643, 0.18092173099371645, 0.1848474958421108, 0.18068895015830655, 0.1952237848545183, 0.1929242390845477, 0.16802193644826025, 0.18870842209111693, 0.18199809883610873, 0.07542017717207727, 0.06930741620972336, 0.0671000151386314, 0.0745736435605513, 0.0738843718768527, 0.07037461096515285, 0.08049514950218217, 0.06321943086513548, 0.07760569976008991]}, "mutation_prompt": null}
{"id": "ec8a1a91-a8fb-493d-b41e-4a28fb9a903f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSOOptimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly optimized mutation factor\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            vel_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + vel_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSOOptimized", "description": "Enhanced hybrid DE-PSO with optimized mutation factor and streamlined velocity calculation.", "configspace": "", "generation": 40, "fitness": 0.177286792405591, "feedback": "The algorithm EnhancedHybridDEPSOOptimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "855d73a6-f9d7-4568-9a9e-9bd49f03f978", "metadata": {"aucs": [0.38987549748985884, 0.40980701971149547, 0.37114891807245765, 0.385193242895867, 0.45524218389645144, 0.40380192231897616, 0.43945122971639416, 0.40420105163746534, 0.3990242105296157, 0.03637856555548391, 0.046225159401106386, 0.043600579078631574, 0.0235610373933548, 0.02652968932852584, 0.0230789599262764, 0.027548513760917603, 0.025099595354610038, 0.01663408742614525, 0.0984086395645376, 0.06634930089188984, 0.08693050418600412, 0.1091271860313644, 0.08136843116867454, 0.06778563817274519, 0.11713803658256605, 0.08260440963802973, 0.07758879561338583, 0.07536010407074756, 0.08261401187726791, 0.0908165748609121, 0.07592093079682105, 0.06285087906353726, 0.08150329506058462, 0.06374455450339811, 0.07443078587428076, 0.08343412676707995, 0.9847244220705068, 0.9928212425918265, 0.9851062725158365, 0.9853815926252922, 0.987400248884238, 0.9828408907266969, 0.9830758866837518, 0.9921400328612602, 0.9915620279383085, 0.1455078627775478, 0.1887712640886281, 0.15111877139103747, 0.1349594934764745, 0.1393751311057988, 0.16585450319654904, 0.1905042437933887, 0.1574758402260068, 0.0860917640992569, 0.2099141665941825, 0.21311910628455166, 0.17128312613507846, 0.15762178914777614, 0.1912812963527697, 0.17990389793778483, 0.20849587835377958, 0.19372074709536524, 0.2176261360238806, 0.11398616207734735, 0.1132883634847025, 0.11559966874032146, 0.09289840200466037, 0.10109727270954771, 0.11987955711721188, 0.1262365613929971, 0.10435625697872819, 0.1174758243149987, 0.11969748744764308, 0.04377696175942003, 0.10949749281396925, 0.06757718538744462, 0.14493305948373914, 0.08487975740490639, 0.10839493658884602, 0.1286672240076534, 0.10707159278534983, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006838660444964395, 9.999999999998899e-05, 0.03583396828955865, 0.02447890974844591, 0.09245035307155103, 0.04605903755971863, 0.09187580108090299, 0.06090944079384175, 0.02950135207851523, 0.0022852451471350177, 0.042722741366871375, 0.004769341981949227, 9.999999999998899e-05, 0.0008946397290195973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011128171109009433, 9.999999999998899e-05, 0.0018376061136586852, 0.05282447798617673, 0.024970705259784842, 0.05035366227228566, 0.0746879929636789, 0.025617608505258294, 0.04290226662718144, 0.057354398092512526, 0.05403526720142049, 0.06712837580917874, 0.3403979063903323, 0.31004421799586324, 0.3370897960505268, 0.3134518980006257, 0.36039769915767483, 0.3438291997617776, 0.34911314901540014, 0.334269408330619, 0.32377722487976857, 0.08146806790593142, 0.05929607809185222, 0.08175248435610827, 0.08287743251229696, 0.07849158461080674, 0.07533561211418927, 0.09182685553309078, 0.07996570851257656, 0.07516004605901139, 0.15072398137274268, 0.165037300406621, 0.16310615577405774, 0.17564248440831398, 0.16970403198641792, 0.13837912524474305, 0.1897139141208115, 0.13900830925956797, 0.1579504748137771, 0.21884228588034949, 0.25983870385735863, 0.21073641199495263, 0.23866421180978992, 0.23051063702011543, 0.18802577748540494, 0.18088484333529675, 0.2321006055668433, 0.2214472608726421, 0.19689786470577986, 0.18747234026378068, 0.17359689785478183, 0.13198906053163795, 0.1657125484647033, 0.18304781560767347, 0.20883749800076978, 0.1902422866761897, 0.18767441017770126, 0.1990289048654994, 0.19113082339429077, 0.1836692864073456, 0.2110423131363598, 0.17302950837546127, 0.20027302369066002, 0.18451039302667194, 0.198048577811339, 0.1670227080011919, 0.18099574979403377, 0.17596085737975953, 0.1711855249722929, 0.1807480313307699, 0.17215955252119053, 0.1801630352547331, 0.17570053116815365, 0.1775447453696345, 0.1694747430614052, 0.1449477352682086, 0.47128637988316624, 0.1672986046856566, 0.4393140958783295, 0.18788645001399362, 0.17057508563143475, 0.16497520674096067, 0.11520222658990986, 0.17470875359453075, 0.11671885375755753, 0.1825851990523294, 0.13918488927652217, 0.22227796903105823, 0.2002386164732045, 0.1246648221247848, 0.15156058551510654, 0.15267129794029555, 0.3455752405832958, 0.19597632451788682, 0.19072881396351227, 0.18781346096772733, 0.1807993998884363, 0.1862918636572023, 0.18093337655478559, 0.1850848555192205, 0.19516328114869208, 0.19149493381234084, 0.0642914731332267, 0.06844842664047956, 0.06443448502737215, 0.06390614734251066, 0.06978185600343734, 0.0843570545538469, 0.10207390863472299, 0.07224360549652686, 0.07547455524456415]}, "mutation_prompt": null}
{"id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 41, "fitness": 0.18030081724648403, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "855d73a6-f9d7-4568-9a9e-9bd49f03f978", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "8f28b177-2b9d-41cd-90d5-0083634b0af6", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.65  # Slightly increased mutation factor for enhanced diversity\n        self.CR = 0.85  # Reduced crossover rate to increase exploration\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Applies targeted mutation factor and crossover rate adjustments to improve convergence speed.", "configspace": "", "generation": 42, "fitness": 0.17592924585382533, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.39718530259167717, 0.35272813331239317, 0.37675179319605834, 0.39628134076432553, 0.398981031068922, 0.41690997101036165, 0.21214192523685804, 0.3817840007608241, 0.3579442274403857, 0.021406550578465744, 0.02121933371698792, 9.999999999998899e-05, 0.04138792209911535, 0.0543113793776574, 0.02173853272239923, 0.0550858781475565, 0.039876915168405525, 0.012978549197126044, 0.10119477534457877, 0.0875280650389837, 0.06041841732522735, 0.09303447635448447, 0.061558719679767226, 0.09792527960216812, 0.10298181831019992, 0.09187776611979914, 0.09594553243253501, 0.07967349449786976, 0.08963693398018346, 0.07652293718031722, 0.08242967373857213, 0.0642464479749042, 0.0707339732999992, 0.0766039108044888, 0.09337421001863955, 0.07518037362937635, 0.9844630341004739, 0.9867514213538378, 0.9818807960326343, 0.9846890590821776, 0.9835153953636779, 0.9837112416745469, 0.9881252229164572, 0.9931857903488865, 0.986549618568887, 0.2068272124663143, 0.2730438279837739, 0.1602936906757737, 0.14069963955433795, 0.1335591380957425, 0.13282638796538426, 0.16229448049550743, 0.17296106792119226, 0.19769535109561043, 0.20683969760086962, 0.2011186945998592, 0.21279462347053402, 0.18831325848535685, 0.1570199261615215, 0.19561177860232448, 0.22175675402435868, 0.11603497889158154, 0.20815468838083673, 0.09435670150810183, 0.12013629212863075, 0.08610761252380994, 0.11633671652805389, 0.09001344990484106, 0.060615227167517105, 0.1269059408292973, 0.09748600202635971, 0.06669892360776541, 0.03752808638243699, 0.12192482193245757, 0.08757926885542455, 0.102255623647309, 0.09079942698012633, 0.09996882666634388, 0.11468302224464699, 0.08371712424929578, 0.12552067855176996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02882465028173975, 0.03363937437372044, 0.0289585553703402, 0.07030879796116296, 0.00881394872023844, 0.015250113083612127, 0.07924860100907938, 0.025349064349690753, 0.05287400992532454, 9.999999999998899e-05, 0.0011558377763652983, 9.999999999998899e-05, 9.999999999998899e-05, 0.002201395789896754, 0.007481648893209014, 9.999999999998899e-05, 0.01071694104155163, 0.00017499627880901425, 0.005867633181611764, 0.01004160836195711, 0.005289046982883905, 0.024650350111653507, 0.034282672011476834, 0.027205537413468983, 0.04224804000347848, 0.05327289078002595, 0.03862170486384897, 0.3708650540331855, 0.33662072739730375, 0.32347830233914854, 0.34062275320040025, 0.30302828097578327, 0.3363878255218451, 0.3460468185054393, 0.3210926823101681, 0.34360759009989494, 0.09447325095045433, 0.08898989979558813, 0.08889206248100545, 0.07964956068276496, 0.09046146938255129, 0.0861013059389063, 0.05938617100812682, 0.06291557440413176, 0.08018284038834977, 0.16951320514294244, 0.14622089711605624, 0.13095252077524167, 0.17298028760083306, 0.1903832195358527, 0.18551551879313044, 0.14047492187287391, 0.17418326189558797, 0.14888919412649593, 0.21018020269718818, 0.25658034650462014, 0.2578400744490962, 0.24992128737534547, 0.1848075811400739, 0.24110033686137367, 0.23034460322460504, 0.2339004177813645, 0.19799430242784788, 0.1696756518980681, 0.09233755397950516, 0.17189444672397347, 0.14273396641963698, 0.18663559010428266, 0.15435954632866178, 0.20970321311745965, 0.17788431366958724, 0.1784184800999934, 0.1872144183073403, 0.19260813415361133, 0.17957450118376161, 0.17108020740059215, 0.18070020996904224, 0.17610734936046224, 0.17032868379395094, 0.1840800077880148, 0.18627814860605474, 0.1733762344488896, 0.18685309382989645, 0.16439289471409413, 0.18242725452568365, 0.20304781804708005, 0.17525058682772854, 0.17758536509155398, 0.2033534974700113, 0.17184732845225392, 0.4815216690379093, 0.1603601812696399, 0.14734413738845165, 0.15139426292535918, 0.1292844457613903, 0.13535932035735043, 0.16252458134435632, 0.4533962149401557, 0.3501623473995924, 0.1491456814661053, 0.35787956645104346, 0.16773196550638736, 0.30190484855782473, 0.16526885155219262, 0.24882138126129072, 0.15911223838665478, 0.1602832248290199, 0.19154788463367556, 0.19174383569602482, 0.18625925287297884, 0.18761910729764908, 0.1835516597114608, 0.19365910121957863, 0.18067881859450152, 0.22081564814116872, 0.21331235743927934, 0.17143490101547976, 0.0700674524366317, 0.0652823988464174, 0.06940435365421638, 0.0686912520284666, 0.07930233109024865, 0.05952510005923528, 0.06639772020057666, 0.07285411402926789, 0.07193452004451739]}, "mutation_prompt": null}
{"id": "fb991890-2d0e-46a2-a5c2-0467330eb6d1", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "3e600b43-90aa-4c1d-940d-d1225fe1f151", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            if fitness[idxs[1]] < fitness[idxs[2]]:  # Select better vectors\n                mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            else:\n                mutant = np.clip(a + self.F * (c - b), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] *= 0.7  # Directly multiply to preserve inertia\n            self.velocities[i] += velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refined selection of DE vectors and optimized velocity update for improved convergence efficiency.", "configspace": "", "generation": 44, "fitness": 0.17604428431880545, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.42417018604138124, 0.34519690271805104, 0.33267531798808747, 0.376262949633112, 0.4205847921577177, 0.37963768199223535, 0.3598054864635316, 0.38963662693903234, 0.37024350642932, 9.999999999998899e-05, 0.01615932716906887, 0.03705693770321217, 0.0892650725630938, 9.999999999998899e-05, 0.023083479032637855, 0.026190158827976484, 0.02686296904481955, 9.999999999998899e-05, 0.10550213936159347, 0.09277252052247131, 0.09921801336683223, 0.09246900243680689, 0.08460113469418229, 0.09004277508717695, 0.08982252891950615, 0.08993827994484271, 0.06078578167895443, 0.06781292145366258, 0.07716740118782128, 0.07065730830012273, 0.08027930301661323, 0.07480543057113576, 0.07272770609204782, 0.07143361722621033, 0.07664418660789019, 0.06920144376675508, 0.9857518502188148, 0.9857919228137546, 0.9865038982272772, 0.9930208242460717, 0.9849794837602225, 0.9851121244074128, 0.9849456051805876, 0.9853408264439442, 0.9857883466808561, 0.18947107937300844, 0.14387809841806776, 0.16782042237022488, 0.13493702731163337, 0.1949560520993472, 0.19916213234964275, 0.19392984161431281, 0.16850468222316872, 0.08627120953289902, 0.22797845429909125, 0.17922766420039282, 0.18018454703851416, 0.18582227403268636, 0.20011518862035116, 0.18348244795705426, 0.1987231488987352, 0.12522917133166045, 0.22084754870425194, 0.10030606624505778, 0.12348797627980135, 0.11253229753721439, 0.07695185637320101, 0.07761858745864825, 0.10729270686932302, 0.07762159656113321, 0.11076279178671788, 0.12594035408023574, 0.10316967673157995, 0.12732898385557478, 0.10879752444558455, 0.1319276576404158, 0.1087504047929464, 0.09611283674297844, 0.12176772642055456, 0.11021491545739193, 0.10795614737941828, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040451691681321233, 0.0669476833545285, 0.055813983781460075, 0.007584958434910916, 0.016767739919392288, 0.061671011058533454, 0.017414974014413942, 0.08107445785175582, 0.05286426184413917, 9.999999999998899e-05, 0.0007249728118154941, 9.999999999998899e-05, 0.0062381924256300625, 0.00452067353338681, 9.999999999998899e-05, 9.999999999998899e-05, 0.003412068777364219, 0.007072112533792141, 0.06555185997300983, 0.051464105545918626, 0.031385416588046944, 9.999999999998899e-05, 0.02441643382258496, 0.0029987213617052033, 0.08564441313584814, 0.0976661048490356, 0.09599513745791688, 0.317438491929221, 0.31742181889653376, 0.3246558069359857, 0.3452655136729106, 0.34775588978490757, 0.3370885404690004, 0.3166868506701418, 0.3375694430255666, 0.3363732850627016, 0.06895812560796388, 0.08697490457763757, 0.08497083662793481, 0.07328363294489082, 0.08445722553990487, 0.07334644088820319, 0.07603933892918124, 0.07563913266225541, 0.08012535767399165, 0.22619780618604735, 0.16785268153736888, 0.1628109427378105, 0.13604282482598196, 0.14656182521501504, 0.13319243896006483, 0.15151734365674197, 0.13063977090344958, 0.17810004963186388, 0.21978874123927272, 0.20936153783150613, 0.24120501615875978, 0.23641561928257426, 0.22071617023417334, 0.2502622677639914, 0.2538627039821687, 0.2539047275976821, 0.20179024938386858, 0.14124303679791572, 0.18417364060906682, 0.176315047891627, 0.18652574833733726, 0.15592826597817822, 0.14631009365780834, 0.17329931255863118, 0.1423061014488507, 0.15254696704778015, 0.17733977097727616, 0.16836018829623367, 0.16066891011456885, 0.18351393852154774, 0.1818425442872853, 0.17729942354675898, 0.19704208664386935, 0.2412749106814115, 0.1799754597752482, 0.17200486239733304, 0.18219496395073997, 0.18194089697610893, 0.1826203972627768, 0.18339254635409863, 0.1726775930783888, 0.18570316642920814, 0.17532811437339024, 0.17719930681751517, 0.17701109183980157, 0.19729739476396735, 0.27147072973782316, 0.16440182430224526, 0.19122360976362984, 0.17620717880216086, 0.4044553600881935, 0.16735259297310623, 0.1698449441512554, 0.2878985690571061, 0.3310550767083523, 0.16329239623657454, 0.16303170458066885, 0.1974313529119861, 0.11582875394747205, 0.22079676590149988, 0.1901329001880303, 0.19996688928947637, 0.19595097271586015, 0.18706808263586006, 0.18813838830470653, 0.18710747376801595, 0.18854887938643883, 0.19299949129504768, 0.19721446712657942, 0.21249583397432914, 0.18455846052512492, 0.06874539490048881, 0.062449334627574515, 0.07134725459817615, 0.04962875891272356, 0.07395586640952445, 0.07238378221770148, 0.07499799818147734, 0.06354401694467071, 0.07402133054992532]}, "mutation_prompt": null}
{"id": "1ec869aa-816a-44d9-a7c9-9a8c19609aeb", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = mutant if np.random.rand() < self.CR else population[i]\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update * (1 - 0.2 * (fitness[i] - global_best_fitness))\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Introduced an adaptive velocity update coefficient and optimized trial vector assignment to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.1062566628436264, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.12765583228138933, 0.29741642782437927, 0.17341100229625972, 0.33746858855685713, 0.2514514739580582, 0.2344984535895488, 0.15030505407749495, 0.20356744945063088, 0.1588697035458888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02150511192081883, 0.031230099088790708, 0.021345629908159802, 0.03308833736600192, 0.00431749434550599, 0.020938559124368483, 0.036387268906341697, 0.017400302979991067, 0.016959393187133687, 0.025755461160898996, 9.999999999998899e-05, 0.012579630230635797, 9.999999999998899e-05, 0.0014995578761437534, 0.007431738723274628, 0.005719080262413856, 0.004355338573191703, 0.0044567066052535464, 0.6050646705912696, 0.780400592441441, 0.7549469673132932, 0.9255720179550498, 0.8024391297787379, 0.958038009151256, 0.09349513958216282, 0.8561832871487456, 0.75162453115252, 0.024074675895627062, 0.0058769796334620095, 0.0346842925767431, 0.007294601961992164, 0.048730408056329, 0.044272250772902644, 0.0018773730973365987, 0.016297449584696366, 0.0016449545502577045, 0.07323319693150787, 0.08038170538607103, 0.09788168866711311, 0.10835972484415202, 0.10228009506253966, 0.08638143000261878, 0.09524364310544498, 0.06701520305433895, 0.07298159944776272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01517866941491297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009461367197268755, 9.999999999998899e-05, 0.02256780526062052, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.3433471977280892, 0.35738978230598173, 0.29548768490541666, 0.3203692666104846, 0.3032065310115628, 0.3239735718912634, 0.35244787699864033, 0.3872434119664169, 0.28345479246458594, 0.011722686542012362, 0.0021553220132347617, 0.02610144857256058, 0.0165859949278081, 0.02467138997217866, 0.019930968702087215, 0.04539366285508073, 0.005263231327017448, 0.034932486816425246, 0.1290877409141703, 0.13720701616172426, 0.11269113509042039, 0.12291780201040892, 0.14191280854582367, 0.1475318667197425, 0.12106698960826323, 0.13574089474709183, 0.14913345502070463, 0.17016639072537543, 0.17219761327103478, 0.2421588117649821, 0.2208869502608829, 0.1984268399564374, 0.19629845456971196, 0.19104532828439869, 0.20415486173292796, 0.18754846327452857, 0.06856120626412543, 0.0658026325250336, 0.08189404292986635, 0.07472090971032908, 0.09601031812988325, 0.09487162898205082, 0.09588739625433895, 0.12993398403394507, 0.084435247472471, 0.15822976306453507, 0.15479681382307242, 0.13882733184314888, 0.1657056860304127, 0.14790725968135898, 0.19166548649346238, 0.15629162382473316, 0.1508509817585546, 0.15543366319139584, 9.999999999998899e-05, 9.999999999998899e-05, 0.02335872432217878, 0.026076061699000452, 0.1135936852651872, 0.0673201124954852, 0.14956704737962667, 0.03356351246237266, 9.999999999998899e-05, 0.12400553874605869, 0.128362589654464, 0.13749991806163764, 0.12935276848162358, 0.2004911025941325, 0.16503681498623268, 0.11511711023051285, 0.13879422295895416, 0.1158406954929525, 0.20809091063505003, 0.10537859859443366, 0.06757077443891757, 0.08979881545003832, 0.12205830347366631, 0.08993085533775869, 0.14737196080894277, 0.23463755273495135, 0.16792984737779337, 0.18668115898795246, 0.19272247293902356, 0.18150930753115924, 0.1865880474726549, 0.19769262366014806, 0.17172017965956443, 0.17269546654001455, 0.19988501802616843, 0.18383886774492886, 0.03238583253567262, 0.028742682301609035, 0.0328179238059525, 0.026703304887616963, 0.021047160342960503, 0.05481722663016608, 0.03465952863175625, 0.027585844545653382, 0.031840373036075786]}, "mutation_prompt": null}
{"id": "058dcf4f-97bd-4828-a970-f8ebe34d4e7f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "01258984-2a91-462d-b500-7ece4cc9fa16", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "51316809-8e6f-4960-b9f1-f9039bf9281d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "d75d3e3c-efdb-40d9-9c88-63ed8fa06204", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "6c6cdbd0-be63-4d3f-b5f6-675d550ef407", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Slightly adjusted mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:  # Better balance between DE and PSO\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved mutation factor adjustment and reduced velocity update complexity for enhanced efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.32703429609403545, 0.3564286181041625, 0.36872975652576234, 0.39142250075457263, 0.40279210020872813, 0.3398928109811157, 0.35689213143646925, 0.4152189500964165, 0.39852723748631247, 0.07203229719712001, 0.021989703406040784, 9.999999999998899e-05, 0.020187341999119646, 0.020048061478282198, 0.017980574467163613, 0.027270768898555064, 0.08614911286557403, 0.012328642669025558, 0.0891835195188111, 0.11536907914618988, 0.06550777160144439, 0.08982416952639927, 0.06102007507950147, 0.10647736550434617, 0.08155894089216364, 0.0955627447227444, 0.08058208054833671, 0.0672156762752062, 0.07926553869107866, 0.08691901268327784, 0.08070626943548764, 0.10991526408761898, 0.0741585073570481, 0.08359179717387111, 0.07941386376234183, 0.08094463768711413, 0.9907648976443092, 0.9853317001846812, 0.9851675659692187, 0.9846636272251277, 0.9828521686567285, 0.9851765446439922, 0.9908906803716243, 0.988591909099176, 0.985210505653125, 0.18346494864548868, 0.16856243478538435, 0.18120133782588788, 0.23560625669426893, 0.13518965510442327, 0.13384506609425784, 0.16725709425412338, 0.1476917239533888, 0.06071295194881965, 0.19863659849551452, 0.20063785783703314, 0.2051012339078201, 0.15555426662062988, 0.18279244941402573, 0.22900097776853012, 0.1360401720358515, 0.2209026250848397, 0.21867730642748406, 0.1208726569295484, 0.11338783812512232, 0.10199446099748022, 0.08464342892927601, 0.09161449348756578, 0.10632002109754524, 0.12194101019432346, 0.113247430884035, 0.11016537820585037, 0.106291875801244, 0.10751390809825334, 0.028078466551550774, 0.10700283034127966, 0.11076136842962336, 0.1129516289203828, 0.12327895436302261, 0.12350054829924006, 0.12530401296868166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06120764447906801, 0.05109480670998967, 0.02295798197159571, 0.003895222676700394, 0.035895078724322405, 0.044875802329900405, 0.04944315512726294, 0.028321078814623646, 0.04114191321899874, 9.999999999998899e-05, 0.0016178187202707806, 9.999999999998899e-05, 0.0018798454499444617, 0.002300904883142718, 0.00011591926892617899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06266841158025449, 0.004474552583819236, 0.042967360761564155, 0.06911942235516455, 0.06975474663306303, 0.06855354871212493, 0.05527472750826479, 0.050991643755398774, 0.07429074122017487, 0.30627915012027596, 0.35016405829497, 0.33309912537349196, 0.3338350194858146, 0.32012411541483654, 0.35114767886187614, 0.34260723054404185, 0.3316105460408406, 0.3466982593819675, 0.08216339794525906, 0.07086969466210269, 0.085846622026019, 0.08061173380081688, 0.0707010570504164, 0.09335343459546497, 0.07146597691062195, 0.09114659411939552, 0.08751436108539057, 0.1684875813833251, 0.15970057235474377, 0.17114448496887436, 0.1607547118109678, 0.1409267083068908, 0.14655554085567035, 0.1853493096253631, 0.2116456215005209, 0.14560866823569518, 0.17473759696183822, 0.2346724625228509, 0.21117946730166082, 0.23667761571717205, 0.2467868494264157, 0.25790147141394826, 0.2376195967896404, 0.22822954462111178, 0.23439914905307646, 0.20453432421230222, 0.16647549239983606, 0.12056152569462664, 0.17905008582655335, 0.16328949571225315, 0.18095176524082013, 0.19869516603892767, 0.16267761930267355, 0.13422654730447703, 0.18161668389494245, 0.18397895768661643, 0.17840217221149945, 0.19245429517475765, 0.20400313362079947, 0.19297533047720272, 0.18806114486904268, 0.173176041688065, 0.18270684811598215, 0.16744472415162692, 0.20382855180001502, 0.16948235928319222, 0.17521127818544957, 0.166599633051013, 0.17479307431853564, 0.18904074658319958, 0.17474625879264372, 0.17462160537459315, 0.17156328219036954, 0.3830847898271337, 0.29974611644046245, 0.38477686427284463, 0.40485707607956967, 0.17742860872718558, 0.180737426020537, 0.46228737841017187, 0.4457171319414551, 0.19913715627387096, 0.08926167941133534, 0.152284464038706, 0.1448276942569411, 0.33775678454424973, 0.1845162585014195, 0.1499613509992005, 0.16313302019919917, 0.16150729106248196, 0.2035858496757439, 0.17064450225167604, 0.18765094993791454, 0.21191899388524948, 0.1918442551535694, 0.20800695427140448, 0.19691230449055297, 0.19133503368747085, 0.1945916117504014, 0.07646859630466318, 0.0595583591364679, 0.049234527314154564, 0.07884119374191523, 0.0693887405763085, 0.07321963096835205, 0.068616838750434, 0.104135325971772, 0.0763401997845573]}, "mutation_prompt": null}
{"id": "90d4047a-c952-406b-b1b4-a9ae52ae7fb0", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            # Improvement: Only update if trial is strictly better\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = 0.7 * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            # Efficient update: Combined update check\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Optimized update mechanism in DE and PSO phases for improved computational efficiency.", "configspace": "", "generation": 51, "fitness": 0.1750950631044356, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.33825998873815055, 0.3955262463338375, 0.37668577083461285, 0.37403281621932316, 0.39807876747719206, 0.36998105706039663, 0.3808775931327808, 0.3599288742596901, 0.41364364008230303, 9.999999999998899e-05, 0.04480642197851248, 0.02336259674247343, 9.999999999998899e-05, 0.030099520584517037, 0.04333075985283796, 9.999999999998899e-05, 0.007730111313694166, 0.0023761409263126643, 0.09278322897572666, 0.08551770840743389, 0.09364759937655542, 0.08506158339141434, 0.060890622679971584, 0.07565337393599836, 0.08485141306447619, 0.08535074511346141, 0.0886562440364358, 0.06823044878973394, 0.09363908785567054, 0.07317964895054285, 0.08757148090881561, 0.023662204250775143, 0.07243012519978698, 0.08744155491965688, 0.08084766744522276, 0.0651561596583855, 0.9915887712261577, 0.9848825110005478, 0.984685721850081, 0.9846551338700382, 0.9933534768115719, 0.9922774906534064, 0.9861611290460435, 0.985827432209741, 0.9928321473110538, 0.10209216478225769, 0.05737306817979737, 0.0583768338584163, 0.1282655803836118, 0.13754400014956958, 0.13054652005904022, 0.12571637557257387, 0.08617780261727692, 0.16949633304538825, 0.16270397583638352, 0.17039510635290522, 0.16986259043810148, 0.20224590416451627, 0.15221876267664702, 0.15248109660361986, 0.22734781024751827, 0.1628797726959732, 0.1471391051760802, 0.12052767637131978, 0.11019781367237136, 0.12251249817568155, 0.13709969009347567, 0.1066721230322748, 0.10444651218715717, 0.11254539568268651, 0.15101386377539783, 0.11082672581276898, 0.11699023442172418, 0.09113965014510872, 0.10712983986578561, 0.13898513048813055, 0.12339492751244019, 0.09180477357759287, 0.1142117022940069, 0.1100471183497348, 0.11822161339448944, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008116857353408502, 0.0001731381314981073, 9.999999999998899e-05, 9.999999999998899e-05, 0.005636084918934636, 0.06005591751374273, 0.028581783570954755, 0.051556243054868944, 0.07631340571308609, 0.06245900453327813, 0.052708546137544054, 0.0409506927746357, 0.04566912219692254, 9.999999999998899e-05, 0.004015027722897302, 0.0010702684989420952, 0.010640165938133439, 9.999999999998899e-05, 9.999999999998899e-05, 0.002394430304653361, 9.999999999998899e-05, 0.007035054636288063, 0.06379788893941407, 0.03628829454439508, 0.06409170859200275, 0.006608192451247108, 0.026312592109660193, 0.0040941409638166615, 0.08289281448188945, 0.05528357131994632, 0.08386151425532462, 0.35579814412918465, 0.34717871270371436, 0.3190928609403699, 0.3432369984745468, 0.36029621248738275, 0.34409349336634887, 0.31427584062871305, 0.30827864969446395, 0.30811304182009236, 0.09830436507706652, 0.06972177283346959, 0.07151569071919661, 0.06569088779320331, 0.08053406103133953, 0.0923639030856852, 0.07036856612883491, 0.06195882915544515, 0.07456157505214489, 0.13879172028558318, 0.15450080822993661, 0.19149101894227005, 0.13568455833445936, 0.14969836229349454, 0.17225193649643933, 0.19163331071819578, 0.16376298707806147, 0.14349702228873107, 0.2390738889220041, 0.21083828513347502, 0.24348184679191998, 0.2038207315868954, 0.2460975599668992, 0.24699754858400513, 0.2387719806526346, 0.22451570643028984, 0.1883091359190956, 0.1766652640989731, 0.1555892262694344, 0.14840785580866866, 0.18333437793503982, 0.17038336315187497, 0.16468946292885178, 0.19869965187726135, 0.20239433386113137, 0.18766107004311028, 0.1648171916941643, 0.18304445521284707, 0.1702460089997534, 0.17892950675092056, 0.1849546640706532, 0.19051398563723954, 0.18011821772912118, 0.1941254430507564, 0.19686370045510426, 0.17755337074190936, 0.1750166366959076, 0.18480994926747385, 0.19219133158194002, 0.1817734065137655, 0.17424321221348915, 0.18049314102620284, 0.1677417117989931, 0.17031362895057622, 0.18055468194602853, 0.17145035936089859, 0.18340969805908436, 0.4259917159369496, 0.3921486485932346, 0.18564285060327534, 0.19318692070368548, 0.4588659460849148, 0.15385532327836648, 0.33397982855998953, 0.16209008291152827, 0.12063468429200896, 0.23861847820862003, 0.22122758048527014, 0.1276213927717207, 0.20404804684315525, 0.18109854933626324, 0.15693923560614254, 0.1823335085595078, 0.20054368585697446, 0.18954363280169328, 0.18192316730898628, 0.18399585392299012, 0.19150450290036114, 0.20827646830802937, 0.18369515831352778, 0.18451252543353647, 0.09027929719855443, 0.06571246098514116, 0.06403751096007748, 0.05821867099480149, 0.0772665708332908, 0.06861813746486822, 0.07459698159564121, 0.06305779657134447, 0.08468592600222768]}, "mutation_prompt": null}
{"id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 52, "fitness": 0.2530081814198428, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "cf0e95a5-4d5e-42e4-bef2-9d8446509001", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "f5d1af4f-149a-4c19-9fc3-4a85d61159b2", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "3ee7b2b4-bbd1-4eef-8441-af11ef669dc4", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "25d19751-1078-4fcf-ae05-afc2711f556b", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "5b0e440c-4e97-4266-8bd2-af14814984e3", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "e13c3155-8a7a-49eb-a14f-f657b8b458e5", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "63c0925d-5e43-4456-8428-4c744f9878e8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "2f95ed0d-739f-46e8-93d3-71ee8cf4ea16", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(5, int(10 * dim * (1 - 0.005)))  # Dynamic population size\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.normal()  # Optimized mutation strategy\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved convergence through dynamic population size adjustment and optimized mutation strategy.", "configspace": "", "generation": 59, "fitness": 0.25287812289183503, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.7247695278685573, 0.7156187563676741, 0.7209360070307524, 0.7195119521822684, 0.6891247775965257, 0.7162614622253793, 0.7392123454057256, 0.735475684434607, 0.727610687511037, 0.03760489896227448, 0.379431397336614, 0.37061695906675074, 0.06064742818365043, 0.44552678860490436, 0.4109059629117323, 0.37149444109996965, 0.054582684249826485, 0.05163558985860672, 0.1191695063020849, 0.1213689881786566, 0.14204420942470752, 0.14123002497025794, 0.1545624136573922, 0.112024943016939, 0.15989454851683715, 0.15834651813485145, 0.1262236547987362, 0.13403475564404566, 0.1508892530974275, 0.12206402471301225, 0.0955356107861891, 0.12273562202874877, 0.12285876208052471, 0.1314211435264735, 0.11346229342954395, 0.12387291808672451, 0.9867171778451285, 0.9859273891849657, 0.9850988510826503, 0.9851324513738048, 0.9827107144108543, 0.9828163026236894, 0.9869740067685951, 0.9868602757866083, 0.9919176279373607, 0.3489446068133868, 0.30397346685184146, 0.33008557327644616, 0.14870341712657154, 0.41684527151052586, 0.26544434310129905, 0.36280052828932785, 0.38180759929587516, 0.33545005519506954, 0.3313877342154212, 0.22402457393484854, 0.212411183575542, 0.1888224451163365, 0.3343723943149286, 0.16080549494654262, 0.4678141631926296, 0.5518016355135481, 0.21317679376560417, 0.1706956749959878, 0.17497905938251912, 0.15665926979475953, 0.09154834421451274, 0.09725921149428873, 0.16187718266858186, 0.1107326462032302, 0.15573143134453948, 0.1221487046701506, 0.16328836942581837, 0.1673027810231017, 0.17215154331313876, 0.12680570735090624, 0.42991031794104206, 0.2807424057593615, 0.14698798411268144, 0.17626176213501787, 0.09661813314301071, 0.004773789879969126, 0.00425464402070741, 9.999999999998899e-05, 9.999999999998899e-05, 0.09675051259488132, 0.00021869414253428143, 0.039985387245854875, 9.999999999998899e-05, 0.07103835651552204, 0.05401499759288453, 0.031228650671359715, 0.07915824865345622, 0.003295328910748907, 0.07155467262301496, 0.031397111511616504, 0.05681624654756379, 0.03705451818271033, 0.04376649377273534, 0.07858762924470664, 0.02698544513588208, 0.03857860484032605, 0.0631360637587095, 0.07231149596712694, 0.057863189500206635, 0.05931719894491594, 0.07627508831007546, 0.060026507663673345, 0.05442445741688828, 0.03843070786216718, 0.06710840192975576, 0.11133171721570712, 0.20803027313885736, 0.14812917150543148, 0.045288971207747775, 0.11078893756683006, 0.07389058199619725, 0.4629215940392637, 0.47892629863256264, 0.467828700603384, 0.5284747555232936, 0.4530738360898532, 0.48132649611681233, 0.5116636581286653, 0.4902214064380105, 0.4992551101994507, 0.0965803430233444, 0.0765416267432032, 0.09612045472083008, 0.09294326324957913, 0.11320413484471592, 0.09352887098877638, 0.12467959197399925, 0.08158053375905916, 0.0679075618697933, 0.238857160690776, 0.1480204251185696, 0.18877402326642412, 0.16621363644652554, 0.2065160237468403, 0.33081284368084996, 0.22710601813865838, 0.19717412596903006, 0.23161433441783652, 0.35592652242616873, 0.3381200007344264, 0.2497392857058094, 0.20307442410681564, 0.39479879853040023, 0.3498466436624722, 0.39397877051721275, 0.3455613475280952, 0.2767542665209477, 0.1747905434275574, 0.218954483911719, 0.18939961686491003, 0.19862817045718317, 0.21929580123622672, 0.26038255274888356, 0.3117020531259662, 0.12928174785300184, 0.1652075176607195, 0.21573374318419347, 0.20168124424904876, 0.2088015026954093, 0.21513016513250405, 0.19880910948954555, 0.21959319075737427, 0.24886801399964564, 0.21356902444219383, 0.19829372223044817, 0.23967012928135834, 0.22760743560108, 0.22621566297578, 0.23187398548086413, 0.20890030569313667, 0.21776013316080478, 0.18421378096789354, 0.22988561699280885, 0.5373705909461541, 0.1875419304954179, 0.2080982677055927, 0.1983491019656589, 0.7310614703384586, 0.13687672079851854, 0.7915600484334935, 0.15629256836030003, 0.1683994444796797, 0.7895453415859564, 0.40567338591587243, 0.16810867961792608, 0.42041189042676874, 0.2105074146704855, 0.1497929166503743, 0.16802741966777268, 0.1754650382779036, 0.2962018844764758, 0.15303066446710856, 0.20620161759353461, 0.1964137268248125, 0.1872677447559029, 0.1932680518049359, 0.19445547643975303, 0.17717934498244525, 0.18818959407715108, 0.18970776681345247, 0.19518783569800036, 0.08369479586629291, 0.07376831433630304, 0.08478282419735383, 0.08551075115025997, 0.09304910714617942, 0.0772431729417945, 0.08378079087498158, 0.08108011709015261, 0.07131734760761232]}, "mutation_prompt": null}
{"id": "7221fa0d-fbc2-430e-816e-aa55cfb38f2f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "99e08984-af79-4a75-abd3-98262a57790f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  \n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.fromiter((func(ind) for ind in population), dtype=np.float)\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  \n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.7 - 0.4 * (self.budget - self.pop_size) / self.budget  \n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Optimized EnhancedHybridDEPSO with streamlined fitness evaluation and adaptive parameters for improved performance.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'float'.\\n`np.float` was a deprecated alias for the builtin `float`. To avoid this error in existing code, use `float` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.float64` here.\\nThe aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:\\n    https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations\").", "error": "AttributeError(\"module 'numpy' has no attribute 'float'.\\n`np.float` was a deprecated alias for the builtin `float`. To avoid this error in existing code, use `float` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.float64` here.\\nThe aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:\\n    https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations\")", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {}, "mutation_prompt": null}
{"id": "7c8ef188-1381-41fd-a946-43bde8fce3b0", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = min(personal_best_fitness)  # Optimized data access\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Optimized data handling and removed redundant operations for increased computational efficiency.", "configspace": "", "generation": 62, "fitness": 0.24274828230605652, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.715854102589475, 0.6779499397254365, 0.6849110552714953, 0.7012935707073049, 0.7125680587362822, 0.7254553752072717, 0.7056744228200351, 0.6853325617657764, 0.6514594677744245, 0.2789979963669048, 0.34752628233676885, 0.06767962052751286, 9.999999999998899e-05, 0.34951050774128767, 0.298529214604382, 0.23553975703932317, 0.4011567916472162, 0.04978612362696799, 0.11090864220896679, 0.13348976726403983, 0.13240677273379275, 0.12707655870867296, 0.1400892930110289, 0.14670106871983257, 0.09972271153406631, 0.10303262382285427, 0.13652156994987652, 0.1166148011085072, 0.11774986990147684, 0.115578865621071, 0.12847518677001957, 0.12238157649444947, 0.09923556214261975, 0.1280271807998815, 0.1047809255118578, 0.11354448909771941, 0.9912724839071453, 0.993802543213635, 0.9881418436917894, 0.9838578201787872, 0.9923505367101418, 0.9833656159028377, 0.9859363666408058, 0.985251049486922, 0.9918170008827164, 0.3277780138923624, 0.16374101945205566, 0.3549675065124577, 0.3050923706922708, 0.3306697487636068, 0.25966519315831393, 0.3692675414572304, 0.32031336067400584, 0.3208323119246542, 0.24594069927973683, 0.4533263765663882, 0.3435621068936423, 0.16119162996207037, 0.18749350075067517, 0.20021401359696334, 0.2339864210192809, 0.27500021824744014, 0.5253875368005376, 0.19075485917443025, 0.16927554962157498, 0.18094941200110226, 0.22996188052304145, 0.17864703035153884, 0.1187070021607386, 0.27201448801360717, 0.10555801238169837, 0.17418278538694032, 0.22878798454113347, 0.25265422215796673, 0.18019881137101024, 0.1705262563575456, 0.1663680118778208, 0.12233707210313371, 0.1917352293493887, 0.1825497447022314, 0.17026466805373242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030229138316187898, 9.999999999998899e-05, 0.0012541858412583595, 0.003964460192472097, 9.999999999998899e-05, 0.08440051922261971, 0.04063898388641696, 0.09922178962676842, 0.09774825626506012, 0.048851885949693474, 0.0018084267034439439, 0.0528416320303855, 0.07814518485869648, 0.040285619496712166, 0.026452728104076062, 0.02666637439045394, 0.0233356933678891, 0.07090351081714674, 0.1077298996147763, 0.11116531973370747, 0.053347662226406856, 0.07180528765117455, 0.06521605033219435, 0.04922233927441322, 0.009670750970730668, 0.127776068677665, 0.15645451988182468, 0.2092077071719176, 0.05672172830899269, 0.04597744919265856, 0.11968672645702305, 0.04648455248614247, 0.5157814288506544, 0.4579195091227073, 0.44829715856121877, 0.4462665805901693, 0.4967595578802759, 0.47644114295779993, 0.45636650211111596, 0.47292545101271877, 0.4742725293925568, 0.11857464299148557, 0.07847033436939876, 0.1378750497241925, 0.10715988532879472, 0.08220564306724865, 0.10514472783827111, 0.13076890636624938, 0.06043849007261848, 0.12842401958543215, 0.25939125184745393, 0.22970698075569684, 0.1467951473343594, 0.18738479115719964, 0.15565753220334955, 0.1904581965709191, 0.24333399578055992, 0.1746136262774075, 0.18987099657797168, 0.27359691198219815, 0.33182641687306624, 0.3699643650530252, 0.16002817867451835, 0.3641668342361488, 0.2776306829217192, 0.26919492927561117, 0.2734159298651303, 0.3217463399305842, 0.164790942716333, 0.2057896332624174, 0.16911255719814, 0.18568614708695164, 0.289856301266775, 0.2523709401565316, 0.24951733032536616, 0.18644286312278313, 0.25457949847430517, 0.19211173840675833, 0.18528686240002123, 0.1651742910110623, 0.19902265915193385, 0.19523217849154462, 0.2052320457504453, 0.19696547153688948, 0.23968316885963337, 0.2383672630614293, 0.20238978428814314, 0.19725016201287648, 0.187275924677894, 0.28709445941873846, 0.19943699283186245, 0.21623347417945338, 0.18892477069307156, 0.18681765918849969, 0.19971881215181442, 0.19341077922751837, 0.21235193448600187, 0.16590281191075706, 0.15875655844329795, 0.16592740208378542, 0.8074172200195417, 0.7991263996792913, 0.16625564216515143, 0.18747543085248453, 0.4541783773347011, 0.16764396069235266, 0.12665565509756038, 0.16788669209865348, 0.1512404190635207, 0.16902413843788255, 0.3008674810373446, 0.21215757297848636, 0.15135603062694658, 0.18098807251877214, 0.19106264570470477, 0.18174156414927745, 0.18395420329600343, 0.20488165609477305, 0.19826227033258692, 0.18516054990522268, 0.19142925760562235, 0.20542081911801935, 0.07713929080673099, 0.07696037742554873, 0.07658682128951078, 0.0810330970803147, 0.07996341427003772, 0.08876557800248774, 0.08077643456280381, 0.08949406819230443, 0.06596113733209563]}, "mutation_prompt": null}
{"id": "295a2c31-0d82-4332-b5f0-ba29d89dc3aa", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "e2d7c903-f778-42fe-9a75-50edfc5c1b41", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "8b355b7f-4837-4129-91a6-2cce2cf4a5fd", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.7  # Adjusted mutation factor for better balance of exploration and exploitation\n        self.CR = 0.85\n        self.c1 = 1.9\n        self.c2 = 1.9\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array(list(map(func, population)))  # Vectorized fitness evaluation\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.9 - 0.5 * (self.budget - self.pop_size) / self.budget  # Refined dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refined parameter tuning and vectorized fitness evaluation for efficiency.", "configspace": "", "generation": 65, "fitness": 0.2310141803492873, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.5972864270279932, 0.6603022527331261, 0.593354567610676, 0.6436455916469372, 0.6313595837952106, 0.6251421909554515, 0.6466411800561598, 0.6148771773063859, 0.6227786195771394, 0.26565667218130906, 0.06198869488971481, 0.26172998053596475, 0.3294805537428064, 0.2906899616403281, 0.2921091361441308, 0.2626627491764578, 0.046821110071049055, 0.0458226122199229, 0.16724731518558367, 0.1450368463070254, 0.17496970540375678, 0.1381334993892791, 0.15206922992957095, 0.0938035298640818, 0.15466893507667467, 0.1318029034074647, 0.11528376138829977, 0.09611096458366863, 0.12242209997845166, 0.10776289137836825, 0.13314697481938653, 0.08967750659463214, 0.11345410867521355, 0.09674415528949998, 0.15000517972639715, 0.09605498643429744, 0.9850927535905847, 0.9880738157830155, 0.9857330051759318, 0.991283479965128, 0.9838741864186454, 0.9843902907188705, 0.9908048767813716, 0.988223473668439, 0.9896590157996479, 0.29024640917340305, 0.28971475349656206, 0.33110096812076717, 0.1473315545387177, 0.30891371414750135, 0.28481039979851297, 0.32237189552589096, 0.28269091924205714, 0.3006524738336356, 0.296827521855361, 0.19166374326047575, 0.4254157238661074, 0.19603894177165593, 0.2485539588122968, 0.15820952902554253, 0.22064281031807442, 0.2635549250444539, 0.24445557435264553, 0.17826002944994324, 0.15449783146577012, 0.21567887829971955, 0.09671070030458973, 0.13322611115042893, 0.15623818695760816, 0.162538502797263, 0.16620639906849932, 0.15388007017732308, 0.14677597616298332, 0.14268717819395182, 0.0659776287855941, 0.1314076087034467, 0.13046011213181574, 0.1213350724972061, 0.20867823140725505, 0.19141333234391622, 0.17184446347122517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0070205833846342935, 0.005557993285366658, 0.06146605739711264, 0.04047760656386823, 0.032224413600039026, 0.043460992889625794, 0.026150107235760167, 0.027443091123277585, 0.0801759453266413, 0.06332184333532642, 0.05958530653020078, 0.05327617505511584, 0.02662187023319329, 0.029860263580171686, 0.05125299289727103, 0.14406906764048721, 0.04554152659462418, 0.060647378102385296, 0.05502472011877002, 0.06932426481573495, 0.0706295868250274, 0.12264441544840288, 0.09283289065892553, 0.15909952869445476, 0.14904040873470492, 0.07299360418607759, 0.07611915035636008, 0.07365549267300753, 0.04614201584158184, 0.443989291657086, 0.43127769430642293, 0.41707448471455777, 0.44732614114677494, 0.4635997565182247, 0.4413826151940846, 0.441929164333002, 0.42601916618089586, 0.4910916600779045, 0.09731615308154595, 0.08418813044002982, 0.10983463467925225, 0.13002419740880655, 0.09568288451165097, 0.08955974361534302, 0.07719066374018368, 0.1021899381192799, 0.10199951508190774, 0.14227020527241308, 0.26052086779980155, 0.20809537882158646, 0.21363590808853783, 0.14692268954291687, 0.1996884389527318, 0.2453818836629772, 0.22029737779666314, 0.17850801253398385, 0.25297617173139, 0.2873328045429694, 0.33193736246371175, 0.2740523854211677, 0.30638446687762, 0.19307593650756993, 0.31163246321299587, 0.3205938692268594, 0.264038231789153, 0.21743791379426192, 0.1834121628080817, 0.1843243084386217, 0.25826843718978565, 0.25423704077559384, 0.21308184022591004, 0.23980469979531394, 0.26134390566848564, 0.12954128797836417, 0.19763663629971095, 0.2061963346480512, 0.2241897044761323, 0.20181576221610298, 0.19581341485637394, 0.18267291285478793, 0.1888183218932581, 0.22885404507542195, 0.19492470428823527, 0.21553880750441634, 0.21513635184047986, 0.2057278044476617, 0.22214690694086603, 0.4084313077736621, 0.23016768847899427, 0.21566613886642438, 0.205061316105837, 0.1959357446031751, 0.1213333881795352, 0.14517296376280264, 0.16788606767823255, 0.7919424846568581, 0.19549198939427248, 0.16449367981816398, 0.15943682532803127, 0.16991094573999432, 0.1402957161901962, 0.40950755981680564, 0.36027756497990315, 0.24427956880381707, 0.21209658449629176, 0.16877022825451748, 0.16782875390435692, 0.20469202071006132, 0.15319181730710096, 0.21631957980348893, 0.20862434757340587, 0.18157310901466384, 0.18411478560244476, 0.1935783803930261, 0.17886907699080457, 0.18666313514173083, 0.20473193142568435, 0.20648621455123772, 0.1851097945586574, 0.07150657396561255, 0.07891423472605297, 0.09679274050627917, 0.11419841754320859, 0.09559127217798724, 0.07505317091720876, 0.08693262361044385, 0.10499328601044455, 0.0919463576923224]}, "mutation_prompt": null}
{"id": "d29092b0-1b7e-4817-a713-618e2b8226bd", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "e2257960-1468-4bca-b9cb-83d587d2dad0", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "5f6302c2-fa35-4b87-8ee3-41ba75a78d50", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "399b0044-f932-4389-81b8-62493f2dbbfa", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "0971ff8c-023b-47c6-ac07-65dcd3750dbe", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "8b9c8460-50cb-45c6-83e4-a89da97dc68d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "1d40ea06-6daa-42f5-9144-06faec748c7c", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "3ac37948-542f-4774-85c6-b4add1b08dc2", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "b9f5dcd1-6d35-43ef-883e-663bd6cf7666", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "d909d655-a120-40d8-9f6b-4783523e8ac5", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "cb19916d-c1f0-4f0a-8d34-049e674803b1", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "16e9e5ce-529e-4894-ac9b-6dd65917a262", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        use_de = True  # control flow change for clarity\n        while num_evaluations < self.budget:\n            if use_de:\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n            use_de = not use_de  # alternate between DE and PSO\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Optimized control flow and refined mutation strategy for enhanced computational efficiency.", "configspace": "", "generation": 77, "fitness": 0.2400649625875465, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6725562239935879, 0.6810275153153296, 0.6642733793731564, 0.6878444411017248, 0.6669630210981576, 0.7042768305439012, 0.682676658671955, 0.7012540570978605, 0.670707935119393, 0.38568033446826566, 0.06490931090793617, 0.37275475790090706, 0.04156444989566621, 0.04123550897124528, 0.3275408131160439, 0.052493246710307306, 0.052350908940606344, 0.04640021592879817, 0.10892614114635346, 0.11159944052356552, 0.13653190272528049, 0.1448320565732062, 0.14259106350959394, 0.11671769836912249, 0.1508389862238655, 0.12570187865438798, 0.12935818858414438, 0.1163252495667102, 0.13003468441282662, 0.11364044169056364, 0.10566344426392793, 0.0991371652361106, 0.10391786255704405, 0.117517215965948, 0.10510251872532439, 0.12909073739146237, 0.9791103103924409, 0.9809426010546973, 0.9799722807619904, 0.9815968040157943, 0.9776650137085833, 0.9706345545307756, 0.980690934363753, 0.9800146857898111, 0.9716294101765306, 0.3102892101804564, 0.3638145580496466, 0.34699243751124254, 0.3252235550344411, 0.3303493562842982, 0.2761773222389805, 0.3129474006482599, 0.3219101533127563, 0.2500726989368248, 0.2246138637808065, 0.16737442945068837, 0.28764668579621655, 0.18749326803422883, 0.19515794951893195, 0.31951584567780655, 0.22940601949340822, 0.21493114460781193, 0.42590408390891854, 0.16121150293429853, 0.09050860911933456, 0.1568317752323517, 0.1013199775036594, 0.09975233646310921, 0.16718812790816207, 0.14846980222892747, 0.16511745229226216, 0.15117629170007674, 0.12653623839049177, 0.17715358441850426, 0.221184016318558, 0.14879545480174805, 0.22688964060484162, 0.12135214391134053, 0.17406789662366917, 0.09739224211843045, 0.2970091108987827, 9.999999999998899e-05, 0.006086241663342151, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00378373736509785, 0.043622330414857635, 0.0037194194888258147, 0.0402271124259167, 0.07918098449981259, 0.027552634655506725, 0.033052634808170445, 0.0697106499690241, 0.015301008448557307, 0.026369915382022935, 0.11662002205570787, 0.06813117014282655, 0.232166039446701, 0.03503615186250064, 0.14391235382422107, 0.0706309196816417, 0.07071912264537972, 0.1463545463803153, 0.056673537632335846, 0.05414675446654271, 0.05233812915114977, 0.03912757064988259, 0.009008364164815985, 0.010069967830440008, 0.03557687062008641, 0.13784803722638395, 0.12250626121505792, 0.07563888619902681, 0.07249200381786958, 0.051027123433608046, 0.4509980726366952, 0.44078042181633925, 0.4616176358967834, 0.4555652467606601, 0.4861154836063911, 0.4681552198439164, 0.5041506972472305, 0.5066423198592519, 0.4557775801373809, 0.16647520901689006, 0.11624888869263073, 0.07878674189599555, 0.0963363598665764, 0.0937575829847308, 0.07207791083453208, 0.11017689907182815, 0.08709985136727827, 0.0973952080980236, 0.1678658525839124, 0.30285509413237244, 0.2179103442123479, 0.3235585590704023, 0.18483943770594546, 0.14672520175563808, 0.16941896643374077, 0.28289908152289267, 0.16098811922086043, 0.16431276898491565, 0.3137017152137863, 0.24480022943534885, 0.22355799230595585, 0.31318938870389934, 0.2922183710917545, 0.2699512105656563, 0.37313606305040725, 0.36462825254453923, 0.24048656063705487, 0.18307080362679462, 0.216459793055355, 0.18374536635875927, 0.24505668740300224, 0.2398093171889334, 0.23426942870904166, 0.18224172667171623, 0.18111459959315224, 0.20880884876671513, 0.21042432895692087, 0.20232911661731812, 0.18426888167577693, 0.18684265701830038, 0.20934966198354266, 0.21118724222932028, 0.2250851491831335, 0.22502414133713633, 0.20613989215424, 0.19614213084318155, 0.1898882655713714, 0.20059525648964882, 0.21757055206220843, 0.2131140465619593, 0.1940060074134714, 0.19664648819120678, 0.3241846812166548, 0.16771976550175882, 0.1718556120468927, 0.17021750587657347, 0.2065992372636778, 0.7746119458841878, 0.8168036263182696, 0.16357765930048795, 0.16818181202346127, 0.7189998270547413, 0.37112757055860746, 0.1670046561965588, 0.20490926874285664, 0.16488690271876494, 0.254942753342967, 0.16409881673631865, 0.476910240357581, 0.16617790014726508, 0.3019710040621658, 0.18898532747384877, 0.1936297443428372, 0.18014602771708255, 0.18066726137753852, 0.19014497326305024, 0.20370764623385562, 0.20305645895041846, 0.1924117329996935, 0.1879780954171436, 0.07487429938298518, 0.08402126573754976, 0.08808521239156675, 0.09193075487321278, 0.08944804622224489, 0.07822494232256683, 0.09029072558832507, 0.07514990978806635, 0.08090821344093979]}, "mutation_prompt": null}
{"id": "7de24417-6844-4e23-a2b9-c2bed07ac0f9", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "d7fa570b-4c07-4317-b351-fcac30e16d24", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "6b44176a-7a59-4cd9-a980-15e3b442e777", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n\n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()\n            mutant = a + self.F * (b - c)\n            mutant = np.where(mutant < self.bound_min, self.bound_min, np.where(mutant > self.bound_max, self.bound_max, mutant))\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * ((self.budget - self.pop_size) / self.budget)\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size:\n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved convergence speed with optimized logical checks and efficient mutation calculations.", "configspace": "", "generation": 80, "fitness": 0.24143590347473032, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6799812405856562, 0.6967173214909539, 0.684307598936139, 0.6870814865817655, 0.6923779787802051, 0.7148866533452596, 0.7157753844271291, 0.6742686913534661, 0.6930587162420522, 0.4122450693168419, 0.4190656703728389, 0.0369171766186952, 9.999999999998899e-05, 0.05972050393541706, 0.36170259275938665, 0.3768031979607881, 0.015090303250187787, 0.39506979096713035, 0.13230408227298818, 0.14316098454350046, 0.14466466714571746, 0.13795317615111724, 0.24341909436452625, 0.12716907010182588, 0.13073064924931055, 0.12354562543836167, 0.12708233220652287, 0.1615630052734548, 0.1282557246162923, 0.09879119820617233, 0.13189693054105878, 0.13049168256838017, 0.10829220550399898, 0.12953828484389085, 0.11021886139617454, 0.11124481955791321, 0.9820104240321998, 0.992383679470726, 0.9817741569094146, 0.9861912163340758, 0.9844424148381694, 0.9927875659493997, 0.9904080839090195, 0.9897560176457117, 0.9845637839388293, 0.37244766843387034, 0.3733916106425714, 0.3141951844731825, 0.1558958840317708, 0.3187256473971847, 0.2239135346080824, 0.38100940510273484, 0.3278348100202032, 0.3738111515723693, 0.2007924588397203, 0.18249608941380158, 0.42549647070824326, 0.19067303356569232, 0.15954340937725398, 0.1898954145237446, 0.185635197754335, 0.22720451455370283, 0.49751106823618385, 0.18332557676349304, 0.2054038190144004, 0.1182234888134237, 0.10347322058652186, 0.10066216990365251, 0.2534949787628812, 0.16225017390866125, 0.18616190332059435, 0.15564996186208446, 0.20567992699992677, 0.2143595856430338, 0.16952072553489705, 0.23775205666795574, 0.17635409908661237, 0.16852209153164643, 0.19636951091833632, 0.1726115735027841, 0.1873096589921851, 9.999999999998899e-05, 0.018972255726369958, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07588658869373177, 0.06799995887306487, 0.14667559081106551, 0.12274949691401249, 0.05737169609795745, 0.0002361452494539229, 0.03575272420005182, 0.03030546561214198, 0.03561022964947824, 0.04030178930290207, 0.025998056577608786, 9.999999999998899e-05, 0.06508743267255324, 0.0582510529559398, 0.062244159676877686, 0.10441260714894762, 0.05635074270142992, 0.049582861053541816, 0.040265679354809625, 0.009863604099333512, 0.08697554351594683, 0.1951065165613386, 0.03606774273146185, 0.005210649044791182, 0.07322048896149813, 0.04503681318128183, 0.047045984014358666, 0.46025528348865885, 0.4569510971955095, 0.46725261489363745, 0.47566985096336356, 0.46077377153774945, 0.4835795050444045, 0.4978399088665655, 0.4834407011547823, 0.5204081937573846, 0.07373247845501352, 0.10689174819429104, 0.09720471561669586, 0.08731263268927703, 0.15061115815297343, 0.10584427612486613, 0.109732427583213, 0.11184308415792221, 0.09242391389456062, 0.23569873101595928, 0.18820700685748692, 0.2576062204296653, 0.14058458544817587, 0.19004742078182923, 0.18850135750513242, 0.14086635252606505, 0.15321804110657555, 0.17374779856808564, 0.2909981468682986, 0.27948343759453964, 0.267489494482134, 0.1919091843726587, 0.3839248811667082, 0.31939518120817467, 0.256294524557651, 0.32773975731744, 0.2664744002870145, 0.13967407018954126, 0.2047218171730537, 0.22837949289051707, 0.2527314844399665, 0.184017705320359, 0.26829139594931095, 0.2592605217859707, 0.27789762007841745, 0.2662940304392466, 0.18444131312160017, 0.20497565047216093, 0.19954414567837098, 0.22040195883277092, 0.19134139542315298, 0.2085293850652944, 0.19846053062899083, 0.1911795145862124, 0.17929567895387555, 0.22360219655931335, 0.4970648915900806, 0.218216825417472, 0.18787541007059871, 0.22011295818027976, 0.36885009793418, 0.23045292460207534, 0.1951891606006737, 0.21444696099187865, 0.1297416060644373, 0.16459674316362072, 0.1909715394340995, 0.7790133922869207, 0.15707876014495037, 0.18367353131095965, 0.8387928293272827, 0.15994869535761425, 0.15741931454694114, 0.25076053487978534, 0.23589235456921687, 0.21146918251315372, 0.168343944527094, 0.20173573297103453, 0.2018755000251241, 0.15546751179774543, 0.16008261388510558, 0.0943806087392397, 0.1935316815693282, 0.18861672622705739, 0.19213611408500197, 0.21019739501168977, 0.19545156254483753, 0.20001783686439167, 0.19294896885533408, 0.18614370715327921, 0.20723432387666785, 0.08542570636493707, 0.07767567853964974, 0.08546499478163183, 0.07714241210323891, 0.07841683973832947, 0.07347023059796154, 0.07840988454271136, 0.08623182463286849, 0.08030378228633217]}, "mutation_prompt": null}
{"id": "fc7cabec-de81-406a-a5f7-bb8301582667", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "e21e8bf8-d9e2-49cc-a81a-edf02e18648e", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "e396f1dc-c0a0-4882-bb29-54f1f30ced15", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            if np.random.rand() < self.CR:\n                trial = mutant\n            else:\n                trial = population[i]\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refined selection in DE step and reduced complexity in PSO velocity update for minor performance gains.", "configspace": "", "generation": 83, "fitness": 0.25284759494167, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.751979164062742, 0.7628622714866344, 0.7262732495588268, 0.7283460783697335, 0.7595645681784483, 0.7322694349014145, 0.7832061262604308, 0.761164950942859, 0.7082177354819431, 0.035921621450525354, 0.03916649033661013, 0.07128263697123327, 0.44951352234083375, 0.4314026770178242, 0.5054290289317946, 0.5720967366890344, 0.046846005465789986, 0.012842381446559026, 0.12352786675673688, 0.15547083375493098, 0.19019971707584138, 0.14632080049536378, 0.14067732247554687, 0.07286234302466277, 0.15177419446772056, 0.46826019303549304, 0.11598148561117982, 0.12784244348497853, 0.12404374443992527, 0.09431706866563361, 0.092475166569154, 0.09720622201614038, 0.13624901930576439, 0.09668497170110424, 0.13964312465767093, 0.13831741902423567, 0.9841464617332393, 0.9860717580404028, 0.9867386116675635, 0.9856314028624378, 0.9836919438096781, 0.9854983902198347, 0.982968798765475, 0.9835725454529854, 0.9930779514989431, 0.3278497613761857, 0.4058068053542595, 0.36031905939544284, 0.301356115771902, 0.17206651696416753, 0.3435040629561922, 0.33601785563155206, 0.09495087271720226, 0.3221827827962612, 0.669747809567113, 0.5064079145471069, 0.22010424434440157, 0.360910134187192, 0.19759922795393448, 0.2935636817913282, 0.22980025567530804, 0.17183750802081266, 0.27501677368623767, 0.1245881773066927, 0.15991878195536735, 0.16626189695238913, 0.10614874148117437, 0.12322780074120432, 0.12608769978758227, 0.18126575933830147, 0.16507523094816645, 0.16409940114166532, 0.16628749650080876, 0.12829698136919887, 0.15103591108062486, 0.1549463199488802, 0.30324677209404527, 0.1497947413135371, 0.18407448111179814, 0.20682429613793807, 0.09811421487003658, 9.999999999998899e-05, 0.0053794285139942, 9.999999999998899e-05, 9.999999999998899e-05, 0.00022901589599710892, 9.999999999998899e-05, 0.00974534656493109, 9.999999999998899e-05, 9.999999999998899e-05, 0.11219616893031092, 0.06104457925489093, 0.07906405696072816, 0.06328119257831932, 0.1010626584786447, 0.14685660125364797, 0.04976938852816781, 0.07469749240471579, 0.058383310944106204, 0.03956896326862136, 0.040540252148473566, 0.169638738563343, 0.06329613063414885, 0.06940176016878652, 0.08151591270945668, 0.0832823758155149, 0.055945689021566936, 0.07399258777514717, 0.01046718927914625, 0.02005692686022198, 0.05949429316497101, 0.21072507355810988, 0.07329013174936683, 0.09850599829935858, 0.046001465961925114, 0.07902013992823143, 0.07549237281608911, 0.49042248814842637, 0.5268499553546538, 0.4808734559987573, 0.5311453573768542, 0.5018291324015856, 0.5177636898443198, 0.5034145943233339, 0.5064760901911822, 0.5060061175818075, 0.05452626758793089, 0.1286430020734115, 0.142296362263292, 0.12040285443814769, 0.11203832170228212, 0.09730403088168127, 0.12076006506036252, 0.0841181778627309, 0.07762715515293872, 0.24629911590455045, 0.23559817212732326, 0.1874284232969955, 0.14619250903180037, 0.17837972785973888, 0.1829143749928207, 0.14783946830220862, 0.19468537708981026, 0.18231324487046596, 0.19711714418159998, 0.2254238370792213, 0.28373327650495217, 0.3945139103752451, 0.3035820572279758, 0.32127939664977645, 0.3779456153900277, 0.3337526421854524, 0.280356042616946, 0.23341568916572142, 0.211613478719488, 0.23447992455778466, 0.3020356896701656, 0.17561179748879507, 0.12844605123988473, 0.24500203684884736, 0.14991164056240192, 0.19975846803274544, 0.19811570089641517, 0.20091697753881077, 0.1704642307520915, 0.1777615996701556, 0.18791766797540477, 0.222902510538451, 0.19291849513321124, 0.20898188927770767, 0.18928929433716257, 0.2372855746849627, 0.20147651594035443, 0.19117689757229228, 0.2234080220427601, 0.1870994976559588, 0.21445330538878427, 0.1946158204920494, 0.2205365986397424, 0.1960324421806543, 0.19576824388055758, 0.1867241279969014, 0.16630679339356558, 0.1630277322243483, 0.8502586081154831, 0.8640905702212821, 0.15071786832421663, 0.1510489662109452, 0.16443898103674415, 0.5366534179511542, 0.16810545858335257, 0.3731319281128501, 0.7576525427213631, 0.12292034922237616, 0.1668883329643781, 0.11112291584278466, 0.15345227827064956, 0.45861339205763807, 0.18809452548386374, 0.18573929349285923, 0.18550403652176672, 0.1708638070518973, 0.2198660380799915, 0.179366785888457, 0.20622743101870333, 0.1965665991630029, 0.19020671897213481, 0.08493113731939406, 0.07748956592894463, 0.14681811823509383, 0.07938329486690598, 0.09041113070262963, 0.08454551555022427, 0.08447532126768287, 0.08305499392137883, 0.08061660651896019]}, "mutation_prompt": null}
{"id": "88f5e1f3-7988-4467-8dd1-62502e7a5c67", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        idxs = np.random.choice(self.pop_size, (self.pop_size, 3), replace=False)\n        a, b, c = population[idxs[:, 0]], population[idxs[:, 1]], population[idxs[:, 2]]\n        self.F = 0.5 + 0.3 * np.random.rand(self.pop_size, 1)  # Vectorized adaptive mutation rate\n        mutants = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n        mask = np.random.rand(self.pop_size, self.dim) < self.CR\n        trials = np.where(mask, mutants, population)\n        trial_fitness = self.evaluate_population(trials, func)\n        improved = trial_fitness < fitness\n        population[improved], fitness[improved] = trials[improved], trial_fitness[improved]\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        velocity_update = self.c1 * r1 * (personal_best - population) + self.c2 * r2 * (global_best - population)\n        self.velocities = inertia_weight * self.velocities + velocity_update\n        updated_positions = np.clip(population + self.velocities, self.bound_min, self.bound_max)\n        current_fitness = self.evaluate_population(updated_positions, func)\n        improved = current_fitness < personal_best_fitness\n        personal_best[improved], personal_best_fitness[improved] = updated_positions[improved], current_fitness[improved]\n        if current_fitness.min() < global_best_fitness:\n            global_best = updated_positions[current_fitness.argmin()]\n        return updated_positions, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO2", "description": "EnhancedHybridDEPSO2 uses optimized vector operations for faster execution and improved performance.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {}, "mutation_prompt": null}
{"id": "30bc2ff4-355d-49cc-bb10-bf5ec8ec0aa9", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "020fdc4e-b108-49b0-b4a5-a7e0bd0b5774", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "5af44a61-40b2-4364-a092-7ad8054b2c0b", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "8127fdb6-663d-4e9a-8d99-8446ab55772e", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "4c76bd2b-8a8e-4d13-9ed3-a1ceb37bb38c", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "a7ca22e6-45a0-4f0a-bfac-311dfaf054f8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "d295efd2-0e2b-4704-a612-cb4d9b62c7dd", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "bded147c-32e4-492b-8c29-da5477ed6711", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "f01eae40-6cc5-4059-a64d-0576dbed643f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "964d2cb0-4729-49bc-aa42-79d1879b477d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.9 - 0.4 * (self.budget - self.pop_size) / self.budget  # Refined inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Slightly enhanced selection strategy and optimized parameter update for better convergence.", "configspace": "", "generation": 94, "fitness": 0.2170399679837787, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.5145306114412502, 0.5472062965527764, 0.5408692886913571, 0.5483892007515281, 0.526185084120439, 0.579756258039863, 0.5426647635744306, 0.5245736170637623, 0.5579165330593961, 0.20351826531971617, 0.14484346234300705, 0.2424466364983242, 0.2235955535072578, 0.17951995661987497, 0.03940135927677291, 0.15530191881676003, 0.011587718289957638, 0.14281005249697354, 0.15070479536044168, 0.12088804863646696, 0.1115027814250692, 0.11417124636565945, 0.09107087895600507, 0.13114149449648937, 0.09868436286002014, 0.15578101178189097, 0.12457350981510551, 0.08440673909089369, 0.11601918740910677, 0.09900801836415407, 0.11636072363952732, 0.10522927548336569, 0.10281370644864296, 0.09377033388060951, 0.09235454223576656, 0.08157567140726718, 0.9853180589891355, 0.9862813434203235, 0.9848212020338822, 0.9830017491448136, 0.982348620146887, 0.9824799547852163, 0.9850153830467319, 0.9851746313454585, 0.9842040841002359, 0.25637410192117904, 0.3176024752729234, 0.30335794737420085, 0.2520182560923546, 0.1415071793304844, 0.302320017193479, 0.18801263343530028, 0.2968762169771608, 0.32344790065229845, 0.321149245336129, 0.20157754721136567, 0.4902867149072636, 0.1573812580024565, 0.3649616010672371, 0.15270618188062657, 0.19371730468176485, 0.4264496029356354, 0.21937563142572436, 0.13214668074459368, 0.15357427261263168, 0.1607535623925076, 0.16194827707095705, 0.13125977359773133, 0.0982328565870716, 0.1572337863884422, 0.1408109268653729, 0.1563556450347391, 0.1139529625115927, 0.15940586886408603, 0.11417414480285204, 0.16836584219766204, 0.14725964541870418, 0.12590842740793196, 0.13222319831125373, 0.16010294467207054, 0.1553129817905139, 0.003331907115777133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01632798181935946, 0.04535706498042802, 0.001520842219007168, 9.999999999998899e-05, 0.09426668509124425, 0.002114737075284978, 0.014167989899415478, 0.05513159863394845, 0.05261978083425767, 0.02593336957842407, 0.027368935424391005, 0.04488110461048034, 0.04953654242370098, 0.03049449987560615, 0.07144467120940157, 0.035875021986215505, 0.03338144920903596, 0.04586986407399707, 0.13750881192451292, 0.036962370230674835, 0.11925368097450029, 0.0866596997289204, 0.13459772417340532, 0.10930396655962527, 0.0663608646592535, 0.16803860925005376, 0.04396319641117841, 0.42518337293883046, 0.389199079376913, 0.41725034358165847, 0.4447418159784904, 0.41828164083776187, 0.42875125886691345, 0.4094988471100449, 0.43124767091330674, 0.43192464522277574, 0.07034233089004305, 0.11382314354764822, 0.08730164906989957, 0.10541554479832771, 0.10892338893020281, 0.09341527820620055, 0.09470928224874331, 0.09539692361501895, 0.07994113765802413, 0.25852199395576136, 0.16001712040235305, 0.17150299532582614, 0.1664791030488172, 0.15045813722059087, 0.21261028998393594, 0.205451151462559, 0.14400718850541394, 0.18325064865232366, 0.2274103152786474, 0.3091755134363644, 0.2758438767515743, 0.316091926890663, 0.1869680238878395, 0.3024387224103998, 0.31186487754282577, 0.3171875069562813, 0.19360297228516254, 0.2117645754398969, 0.2437522950136618, 0.21204750226729585, 0.17288905625045425, 0.193501713888518, 0.1607057671002442, 0.19078211754523777, 0.18180039839743833, 0.2424527309278668, 0.19362979825095417, 0.18764247617190577, 0.17925421497611338, 0.18968626588307747, 0.2546495270944066, 0.1869024023445487, 0.2313961484104592, 0.21790990491736295, 0.21869647826818062, 0.17834963995939468, 0.3374419832842447, 0.20814023652557956, 0.22404174334457527, 0.20357815191673745, 0.20514119933488806, 0.21448598150945886, 0.1960281391956029, 0.1959125024174505, 0.14608761347729682, 0.18640653259926776, 0.12876696101429874, 0.15670130517198433, 0.18581973531411833, 0.1480390839203416, 0.5872136627896207, 0.16665903923193515, 0.13491493166173274, 0.19233622096058967, 0.15614800339787993, 0.28520089111911895, 0.40299516375237343, 0.10900134346888302, 0.16816721756364517, 0.16346427236829264, 0.3559075899554226, 0.2030100898884214, 0.1935909037782373, 0.2364671222273098, 0.19568728126164292, 0.1847035687434464, 0.19215615863536895, 0.18211902583671613, 0.20596064528103464, 0.1830634098776992, 0.20981607695590676, 0.08253632969478875, 0.08276902233095751, 0.09958536655061268, 0.08062814402643725, 0.08619106971394919, 0.07894492322431657, 0.08131208098982401, 0.0908529598536747, 0.061462155362339455]}, "mutation_prompt": null}
{"id": "ab23362f-d693-4850-8706-8a08816d6c68", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * np.clip((self.budget - self.pop_size) / self.budget, 0, 1)  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with optimized mutation and dynamic self-adjusting velocity for improved convergence.", "configspace": "", "generation": 95, "fitness": 0.2374898401120036, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6860492487168239, 0.6565444120377604, 0.7100641435929964, 0.679754892546806, 0.6274543743424486, 0.7000687708177065, 0.6964472125013492, 0.7095317836195967, 0.7132181188502547, 0.3732715625788422, 0.38603056111740275, 0.03688140791516692, 0.3398215840362583, 0.040788815901823705, 0.04111872048297904, 0.005705068454842643, 0.3523277114775132, 0.05298142041246223, 0.14286363400054125, 0.15891563775004236, 0.06906225904874186, 0.26174557797316755, 0.13034065420074603, 0.06947364025412006, 0.12394056677383247, 0.05578832409242784, 0.13832074214804868, 0.12441533962554219, 0.1360796543465902, 0.12347385166887392, 0.12933258938631675, 0.11615325461216708, 0.10254728741677355, 0.1323578225317873, 0.1265737396127794, 0.10126064416620206, 0.9858149415319077, 0.9872516981899938, 0.9851408306178483, 0.984848817025901, 0.9934083494217831, 0.9846607811591289, 0.9754445128506937, 0.992103918657052, 0.9843372090119205, 0.32867962181291077, 0.29241877324895904, 0.29407048623235055, 0.1506719501509728, 0.3183157804093285, 0.3174913105655922, 0.31604229834140607, 0.3340009772670407, 0.3225964538736751, 0.22353272053945616, 0.25042477132821217, 0.20340949429329092, 0.1879065765101411, 0.20013383533931772, 0.21812710563360715, 0.23094129998087753, 0.2184474530754773, 0.5285961922508386, 0.18595369365904568, 0.169682081291891, 0.16970963814432438, 0.1554009998613194, 0.09495554648516014, 0.10634667646130525, 0.2790399928385129, 0.16037646898847546, 0.1643835426127742, 0.10842830865534758, 0.1508360547281491, 0.21632552655475057, 0.13572051150818787, 0.3068989471444221, 0.11890574216847394, 0.2094617508208635, 0.15404217057460756, 0.16859522897077717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00253980661784059, 9.999999999998899e-05, 9.999999999998899e-05, 0.014418685041769685, 0.09329234576475554, 0.08450880015918338, 0.022823531645343786, 0.025196379833708704, 0.08055688732675936, 0.01340066216527791, 0.0656853030909661, 0.04660087174978633, 0.12568217737146037, 0.037853138940902475, 0.10997458871913546, 9.999999999998899e-05, 0.05619560227988951, 0.06778309067205479, 0.06225720421770531, 0.0535966221764822, 0.07631426490217985, 0.10781892105696445, 0.03926934224120815, 0.10469592693790852, 0.05832867066858749, 0.22523698686857008, 0.033183230471619196, 0.005572634470321081, 0.052160166754880666, 0.07657514302189594, 0.08748119682978706, 0.4506128066721634, 0.46890018331670225, 0.45712428643235103, 0.46872313287991096, 0.4691800536283949, 0.497409282597406, 0.4638511439246822, 0.48280836030490226, 0.4838691591470491, 0.11125616384192072, 0.10680834196280997, 0.12294300957312443, 0.11410875067745241, 0.0860336665832856, 0.12269137694515009, 0.07729319452923222, 0.11017642740104927, 0.07581104007573924, 0.23712733571571043, 0.22823664459497428, 0.27515012263798455, 0.18443047100059462, 0.15196807927654554, 0.3233580040544972, 0.22796785944791265, 0.25138925678908863, 0.20607281153560186, 0.2795565516296882, 0.20936607657539374, 0.3746065527111383, 0.2713505389260147, 0.3402920431494706, 0.25886680381844496, 0.3213480812735844, 0.2679128226467913, 0.25694265867072097, 0.18675280063444655, 0.21035381525896935, 0.18498572533362112, 0.2634366606770545, 0.21165764312879132, 0.25811640604586306, 0.23087837123769395, 0.22291189117078147, 0.15697837698033668, 0.24499896084380302, 0.19585542190681748, 0.1750819215440852, 0.1780007133015511, 0.19529219118563756, 0.1714006363445334, 0.20314085842447616, 0.1920258037873417, 0.22861160231540312, 0.1864927487301934, 0.19286532546750534, 0.18414716128126052, 0.31366858555941, 0.19540127543419683, 0.212573580588461, 0.19505886918775306, 0.20164096008085264, 0.23854081278059214, 0.17054577313231223, 0.18640436362723978, 0.18882622340955424, 0.20235741330007606, 0.7583518636368551, 0.7720519124222613, 0.1643068747467058, 0.16551019583639626, 0.20257414224313508, 0.3352796268799011, 0.1432991681725656, 0.18848192520198137, 0.22136884145656588, 0.14553091620963643, 0.2786346647775012, 0.16590587150620395, 0.1125107701572835, 0.20050699380306203, 0.21923483490326268, 0.17485651774972266, 0.18733784015350952, 0.18252431022557314, 0.1795475678537226, 0.18303835154635295, 0.20811884958555638, 0.18587584499986887, 0.2099741563494486, 0.08121605615334171, 0.08542854722942261, 0.08293470711290096, 0.09811634775324651, 0.07988995459521753, 0.07921695144855367, 0.07925634500671297, 0.0768163619094634, 0.0911739131220003]}, "mutation_prompt": null}
{"id": "b0f36d08-1b5f-4763-a2fd-ce6bf9fc52ac", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "02f8e51c-764a-4fa3-b13c-2bc92a4cbb32", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "af8efd51-c9c1-4778-a0a1-e8d3b96b4823", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
{"id": "03c23ad5-80b7-4e20-ba83-0608c857d6f5", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Adaptive mutation factor for better exploration\n        self.CR = 0.9\n        self.c1 = 1.8\n        self.c2 = 2.0\n        self.bound_min = -5.0\n        self.bound_max = 5.0\n        self.velocities = np.zeros((self.pop_size, dim))\n    \n    def initialize_population(self):\n        return np.random.uniform(self.bound_min, self.bound_max, (self.pop_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def differential_evolution(self, population, fitness, func):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = population[idxs]\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation rate\n            mutant = np.clip(a + self.F * (b - c), self.bound_min, self.bound_max)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n            trial_fitness = func(trial)\n            if trial_fitness < fitness[i]:\n                population[i], fitness[i] = trial, trial_fitness\n        return population, fitness\n    \n    def particle_swarm_optimization(self, population, fitness, personal_best, personal_best_fitness, global_best, func):\n        global_best_fitness = func(global_best)\n        inertia_weight = 0.8 - 0.5 * (self.budget - self.pop_size) / self.budget  # Dynamic inertia weight\n        for i in range(self.pop_size):\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity_update = self.c1 * r1 * (personal_best[i] - population[i]) + self.c2 * r2 * (global_best - population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + velocity_update\n            updated_position = np.clip(population[i] + self.velocities[i], self.bound_min, self.bound_max)\n            current_fitness = func(updated_position)\n            if current_fitness < personal_best_fitness[i]:\n                personal_best[i], personal_best_fitness[i] = updated_position, current_fitness\n                if current_fitness < global_best_fitness:\n                    global_best, global_best_fitness = updated_position, current_fitness\n            population[i] = updated_position\n        return population, personal_best, personal_best_fitness, global_best\n    \n    def __call__(self, func):\n        np.random.seed()\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        num_evaluations = self.pop_size\n        \n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best = population[np.argmin(fitness)]\n        \n        while num_evaluations < self.budget:\n            if num_evaluations % (2 * self.pop_size) < self.pop_size: \n                population, fitness = self.differential_evolution(population, fitness, func)\n            else:\n                population, personal_best, personal_best_fitness, global_best = self.particle_swarm_optimization(\n                    population, fitness, personal_best, personal_best_fitness, global_best, func\n                )\n            num_evaluations += self.pop_size\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Adaptive mutation rate and dynamic inertia weights for improved convergence and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06caf0d8-af48-4068-ad44-ff68f2e4d58e", "metadata": {"aucs": [0.6420782429245007, 0.674953248017329, 0.6496271500648352, 0.7424319003385016, 0.7068493598467018, 0.6900657298894513, 0.6932726422640196, 0.7084422152681633, 0.6563992687310429, 0.41672647999215773, 0.34350946255897585, 0.3876523529267284, 0.21503504271569895, 0.3359764287366377, 0.3595813196886969, 0.38529937021499683, 0.38953852775857645, 0.3652522599710004, 0.12397819857746706, 0.11541449048468277, 0.1493001307747216, 0.11245350978540214, 0.11622126959256585, 0.06952337154743471, 0.10478675471901278, 0.11784949444011361, 0.13606709515283255, 0.11470197224169298, 0.1302632313467137, 0.1209235184712425, 0.2318428418040579, 0.12351760265702305, 0.1183284199980672, 0.11514347290211357, 0.12868959188421836, 0.11601153510046536, 0.9843389211236314, 0.9936570125923271, 0.9858767125264098, 0.9806857686581337, 0.9828707746223573, 0.9854748950347247, 0.9819200974872391, 0.9841196851708456, 0.994210476604809, 0.3914424942141239, 0.06197058801744748, 0.3265381019634088, 0.1497786768744963, 0.2064922648564207, 0.15231292135544516, 0.2963915444007392, 0.3430913959206122, 0.33323142085624213, 0.2822251076097113, 0.16700028709632297, 0.2535379583569114, 0.18657050693094013, 0.1555497913757906, 0.2075871988072956, 0.152154778196117, 0.15919461713078176, 0.20959053344913858, 0.16237620570339273, 0.16010915886253185, 0.2881063118812204, 0.15754049969031125, 0.16606086066121784, 0.09989762104695132, 0.16730350293041263, 0.1615841737978886, 0.15780415242944423, 0.22951460233589205, 0.173913381053724, 0.15542493232484034, 0.17893339953882115, 0.15058662207533235, 0.12832986602379393, 0.26643612278800577, 0.10292451223967469, 0.13115407565624992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026896398513513664, 9.999999999998899e-05, 9.999999999998899e-05, 0.023437791148827047, 0.011543253053500901, 9.999999999998899e-05, 0.06502265466241175, 0.044942519282667126, 0.08742668669320197, 0.019427484156557373, 0.022574758515657267, 0.02290135266879001, 0.04253756180213819, 0.049176469687833735, 0.07160175021639914, 0.037866253831211893, 0.12735328902071685, 0.040952751552928546, 0.056589781396369054, 0.07300657579068559, 0.05681526016284255, 0.056588760272722194, 0.10037522188179959, 0.17290687706074626, 0.03547486634143493, 0.040664745544593095, 0.04386673394414742, 0.18190268238468787, 0.12311426491133792, 0.11109764367562769, 0.22204058169202356, 0.07854190318010845, 0.08418007702732189, 0.5057747463844674, 0.46183368198635166, 0.449880991268225, 0.5043351758005783, 0.4786680591243925, 0.4917357722591966, 0.4525070832117042, 0.48133679035728605, 0.45562662136139065, 0.08239315060106456, 0.07391715049462999, 0.11000467829767258, 0.11254729359254756, 0.08136831108750209, 0.1185047122735583, 0.08439109206177475, 0.10766344447909892, 0.07093701412601894, 0.19497994799909524, 0.15486440339091645, 0.4484963642920934, 0.3029949891401912, 0.30018086118603327, 0.1540958373632657, 0.1749984364511914, 0.18355007632204712, 0.18649716959955576, 0.2548544754067572, 0.28509884815313036, 0.23942932889157997, 0.22550888794187307, 0.19268221047060496, 0.3074611739775557, 0.20675414603534414, 0.36960688892244264, 0.33619127268256976, 0.23773169567702368, 0.20461583279505635, 0.23969563719225484, 0.2047600035635173, 0.14488793373986542, 0.20909297522522818, 0.22729578523975835, 0.1559164556080348, 0.20489858758663382, 0.19104421145516248, 0.22393825142438784, 0.21158926472965622, 0.1976954650585383, 0.18743927308449182, 0.20340353235757047, 0.19348290553840464, 0.1905915524570172, 0.2213073180740388, 0.21407688011312076, 0.21757056929622043, 0.21453631295450737, 0.23328859205053942, 0.2295295719483872, 0.44950048980889146, 0.19736536122263892, 0.24101562823927392, 0.20712136298652828, 0.791250121856846, 0.7301576716826653, 0.17197323856887214, 0.19865649607023061, 0.786976738010623, 0.5768879807705619, 0.1571784277892313, 0.14989783818068858, 0.2359523184970601, 0.31186626986497956, 0.367121090828874, 0.15339458421123164, 0.2802599090972987, 0.3781609906850868, 0.1686938717255, 0.6277821986908894, 0.751850785743789, 0.20970862152469405, 0.190140563580525, 0.17907504289643217, 0.1771115459078917, 0.17781475243826517, 0.17625243644235467, 0.2277983061821952, 0.19140434965379993, 0.19738639060670116, 0.18153528847258316, 0.08656689150716246, 0.08857672647688719, 0.07792334728736128, 0.08283885732064622, 0.07848664951305617, 0.06305127657580978, 0.0771934148811213, 0.08315388749687702, 0.08567678349402341]}, "mutation_prompt": null}
