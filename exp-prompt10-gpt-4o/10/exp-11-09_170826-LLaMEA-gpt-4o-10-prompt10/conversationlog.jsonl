{"role": "LLaMEA", "time": "2024-11-09 17:08:26.490256", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# "}
{"role": "gpt-4o", "time": "2024-11-09 17:08:37.359042", "content": "# Description: This algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.1:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:08:37.366711", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence. (Score: -inf)\n\nThe selected solution to update is:\nThis algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.1:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nAn exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 59, in __call__\n  File \"<string>\", line 40, in select\nNameError: name 'func' is not defined\n.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:08:48.954214", "content": "# Description: The algorithm integrates dynamic parameters and enhances crossover strategies to accelerate convergence by adapting mutation factors and crossover rates based on population diversity.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.fitness) / np.mean(self.fitness)\n        F = 0.5 + 0.3 * np.random.rand() if diversity < 0.1 else 0.8\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = (0.6 + 0.3 * np.random.rand()) if np.random.rand() < 0.5 else 0.9\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.15:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:08:48.956293", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence. (Score: -inf)\n\nThe selected solution to update is:\nThis algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.1:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nAn exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 59, in __call__\n  File \"<string>\", line 40, in select\nNameError: name 'func' is not defined\n.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:08:59.853593", "content": "# Description: This enhanced algorithm adjusts mutation strategy, crossover rate, and Lévy flight parameters to accelerate convergence towards optimal solutions.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.3):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.9\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.85  # Reduced slightly for more diversity\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, func, target_idx, trial):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.2:  # Increase frequency for exploration\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(func, i, trial)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:08:59.856071", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence. (Score: -inf)\n\nThe selected solution to update is:\nThis algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.1:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nAn exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 59, in __call__\n  File \"<string>\", line 40, in select\nNameError: name 'func' is not defined\n.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:09:10.023088", "content": "# Description: Enhanced Adaptive Lévy Differential Evolution with dynamic scaling and crossover rates for improved convergence speed and solution quality.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + 0.3 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.8 + 0.1 * np.random.rand()  # Dynamic crossover rate\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.1:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:09:10.026057", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence. (Score: -inf)\n\nThe selected solution to update is:\nThis algorithm combines Differential Evolution with Adaptive Lévy Flight to explore and exploit the search space efficiently, leveraging random walks and adaptive step sizes to enhance diversity and convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Apply Lévy flight adaptation occasionally\n                if np.random.rand() < 0.1:\n                    trial += 0.01 * self.levy_flight()\n\n                self.select(i, trial)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nAn exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 59, in __call__\n  File \"<string>\", line 40, in select\nNameError: name 'func' is not defined\n.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:09:23.834621", "content": "# Description: This adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.15:  # Slightly increased application probability\n                    trial += 0.005 * self.levy_flight()  # Reduced step size for precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:12:33.236499", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy. (Score: 0.2134845090720002)\n\nThe selected solution to update is:\nThis adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.15:  # Slightly increased application probability\n                    trial += 0.005 * self.levy_flight()  # Reduced step size for precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm AdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:12:45.359100", "content": "# Description: This refined algorithm introduces a dynamic population size approach and adaptive mutation strategies, while further enhancing Lévy flight precision to boost convergence speed in optimization tasks.\n\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        # Implementing adaptive mutation strategy based on current performance\n        F = 0.6 + 0.4 * (1 - self.fitness[target_idx] / np.max(self.fitness)) * np.random.rand()\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.8 * (1 - self.eval_count / self.budget) + 0.1  # Slightly adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n        # Dynamic reduction of population size to focus on promising regions\n        if self.eval_count > self.budget / 2 and self.population_size > self.initial_population_size / 2:\n            self.population_size = int(self.population_size * 0.95)\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Further refined Lévy flight application for precision\n                if np.random.rand() < 0.10:\n                    trial += 0.003 * self.levy_flight()  # Further reduced step size for higher precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:12:45.362155", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy. (Score: 0.2134845090720002)\n\nThe selected solution to update is:\nThis adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.15:  # Slightly increased application probability\n                    trial += 0.005 * self.levy_flight()  # Reduced step size for precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm AdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:12:55.212966", "content": "# Description: This enhanced algorithm boosts convergence by introducing a self-adaptive mechanism for scaling and crossover factors based on population diversity, improving exploration and exploitation balance.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def dynamic_parameters(self):\n        # Self-adaptive mechanism based on population diversity\n        diversity = np.mean(np.std(self.population, axis=0))\n        F = 0.7 + 0.3 * np.random.rand() * (1 - diversity)\n        CR = 0.8 + 0.1 * np.random.rand() * diversity\n        return F, CR\n\n    def mutate(self, target_idx, F):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant, CR):\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                F, CR = self.dynamic_parameters()\n                mutant = self.mutate(i, F)\n                trial = self.crossover(self.population[i], mutant, CR)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.12:  # Optimized application probability\n                    trial += 0.004 * self.levy_flight()  # Fine-tuned step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:12:55.216216", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy. (Score: 0.2134845090720002)\n\nThe selected solution to update is:\nThis adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.15:  # Slightly increased application probability\n                    trial += 0.005 * self.levy_flight()  # Reduced step size for precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm AdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:13:10.661271", "content": "# Description: This refined algorithm accelerates convergence by integrating dynamic population resizing, enhanced mutation diversity, and a memory mechanism for better guidance of the search process.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.best_memory = np.full(dim, np.inf)\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.fitness[i] < func(self.best_memory):\n                    self.best_memory = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        D = np.random.normal(0, 1, size=self.dim)  # Diversity enhancement\n        F = 0.8 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c] + D * (self.best_memory - self.population[a]))\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(5, int(self.initial_population_size * 0.5))\n            self.population = self.population[:self.population_size, :]\n            self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.dynamic_population_resizing()\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.15:\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:13:10.663916", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveLévyDifferentialEvolution: This adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy. (Score: 0.2134845090720002)\n\nThe selected solution to update is:\nThis adjusted algorithm enhances convergence speed by introducing dynamic scaling factors and adaptive crossover probabilities, while refining Lévy flight application to improve search efficacy.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.15:  # Slightly increased application probability\n                    trial += 0.005 * self.levy_flight()  # Reduced step size for precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm AdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:13:25.087831", "content": "# Description: A refined adaptive algorithm enhancing exploration and exploitation balance with dynamic Lévy flight and population diversity mechanisms.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)  # Ensure minimum population size for small dimensions\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.3 * np.random.rand()  # Slightly more dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.2:  # Slightly increased application probability\n                    trial += 0.007 * self.levy_flight()  # Slightly larger step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:16:37.421018", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolution: A refined adaptive algorithm enhancing exploration and exploitation balance with dynamic Lévy flight and population diversity mechanisms. (Score: 0.30000039648645516)\n\nThe selected solution to update is:\nA refined adaptive algorithm enhancing exploration and exploitation balance with dynamic Lévy flight and population diversity mechanisms.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)  # Ensure minimum population size for small dimensions\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.3 * np.random.rand()  # Slightly more dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.2:  # Slightly increased application probability\n                    trial += 0.007 * self.levy_flight()  # Slightly larger step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:16:47.702517", "content": "# Description: An enhanced differential evolution algorithm with adaptive Lévy flight and dynamic parameter tuning for improved convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.25 * np.random.rand()  # Reduced variance for more consistency\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly increased starting crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Adjusted application of Lévy flight adaptation\n                if np.random.rand() < 0.25:  # Increased probability for exploration\n                    trial += 0.005 * self.levy_flight()  # Slightly smaller step for controlled exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:16:47.705736", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolution: A refined adaptive algorithm enhancing exploration and exploitation balance with dynamic Lévy flight and population diversity mechanisms. (Score: 0.30000039648645516)\n\nThe selected solution to update is:\nA refined adaptive algorithm enhancing exploration and exploitation balance with dynamic Lévy flight and population diversity mechanisms.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)  # Ensure minimum population size for small dimensions\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.8 + 0.3 * np.random.rand()  # Slightly more dynamic scaling factor\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Refined application of Lévy flight adaptation\n                if np.random.rand() < 0.2:  # Slightly increased application probability\n                    trial += 0.007 * self.levy_flight()  # Slightly larger step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:16:57.063494", "content": "# Description: Enhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.7 + 0.4 * np.random.rand()  # More dynamic scaling factor for better exploration\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for balance\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-09 17:20:07.047959", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolution: Enhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence. (Score: 0.32965099943826615)\n\nThe selected solution to update is:\nEnhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.7 + 0.4 * np.random.rand()  # More dynamic scaling factor for better exploration\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for balance\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:20:15.825352", "content": "# Description: Enhanced Lévy-based differential evolution with dynamic control strategies for superior convergence speed and solution quality.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly larger population for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + 0.5 * np.random.rand()  # Wider dynamic scaling factor for enhanced exploration\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.8 * (1 - (self.eval_count / self.budget)**2)  # More adaptive crossover with quadratic relation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Increased probability for applying Lévy flight\n                    trial += 0.01 * self.levy_flight()  # Slightly larger step size to boost exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-09 17:20:15.828348", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolution: Enhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence. (Score: 0.32965099943826615)\n\nThe selected solution to update is:\nEnhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.7 + 0.4 * np.random.rand()  # More dynamic scaling factor for better exploration\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for balance\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:20:26.922505", "content": "# Description: Enhanced adaptive algorithm with improved dynamic mutation strategy, adjusted Lévy flight, and adaptive population size for accelerated convergence.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased to enhance diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + 0.5 * np.random.rand()  # Adjusted dynamic scaling factor for improved balance\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Fine-tuned adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Increased probability for applying Lévy flight\n                    trial += 0.01 * self.levy_flight()  # Optimized step size for better exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:23:36.906082", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolution: Enhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence. (Score: 0.32965099943826615)\n\nThe selected solution to update is:\nEnhanced adaptive algorithm further optimized by integrating dynamic mutation rates, adaptive scaling factors, and strategic Lévy flight usage to accelerate convergence.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.7 + 0.4 * np.random.rand()  # More dynamic scaling factor for better exploration\n        return self.population[a] + F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for balance\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:23:54.076015", "content": "# Description: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:27:47.451157", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:27:59.118807", "content": "\n# Description: Refined adaptive Lévy Differential Evolution with enhanced mutation diversity and adaptive parameters tuning for faster convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.4 * np.random.rand()  # Wider range for dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n\n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.5 * np.random.rand()  # Dynamic scaling factor adjustment\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        F3 = 0.7 + 0.2 * np.random.rand()  # Additional diversity in mutation strategy\n        mutant3 = self.population[r1] + F3 * (self.population[r2] - self.population[r3])\n\n        mutant_set = [mutant1, mutant2, mutant3]\n        return mutant_set[np.random.choice(3)]\n\n    def crossover(self, target, mutant):\n        CR = 0.95 * (1 - self.eval_count / self.budget)  # Enhanced adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Fine-tuned step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:27:59.121328", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:28:10.061480", "content": "# Description: Enhanced population dynamics and adaptive parameter control for improved convergence efficiency.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.6 * np.random.rand()  # Enhanced dynamic scaling factor with broader range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.4 * np.random.rand()  # Alternative strategy with distinct scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.6:  # Increased probability for strategy selection based on evaluation\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget) + 0.05  # Adjusted adaptive crossover probability for early exploration\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Enhanced probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Optimized step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:32:02.692224", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:32:15.630725", "content": "# Description: Slightly increased adaptive crossover and mutation diversity with refined population evaluation to enhance convergence efficiency.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.eval_count >= self.budget:\n                    return\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.4 * np.random.rand()  # Broader range for scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.4 * np.random.rand()  # Consistent diversity in alternative strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.55:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget) + 0.05  # Adjusted adaptive crossover range\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        if self.eval_count < self.budget:\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < self.fitness[target_idx]:\n                self.population[target_idx] = trial\n                self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Refined probability for Lévy flight application\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for incremental improvement\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:36:10.612536", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:36:22.288078", "content": "# Description: Enhanced algorithm with a greater emphasis on stochasticity and diversity in search strategies and adaptive parameters to expedite convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.3):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.6 * np.random.rand()  # Wider dynamic scaling factor range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.4 * np.random.rand()  # Adjusted alternative strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.6:  # Increased probability for using the better strategy\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Further increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Fine-tuned step size for better exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:36:22.291028", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:36:35.760523", "content": "# Description: Enhanced Differential Evolution with adaptive Lévy flights and dynamic crossover for improved exploration and exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for better diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.4):  # Modified beta for Lévy flight for improved step diversity\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.5 * np.random.rand()  # Adjusted dynamic scaling factor for balance\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.4 * np.random.rand()  # Slightly adjusted strategy for enhanced variability\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.6:  # Adjusted probability for mutation strategy choice\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for greater impact\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:40:25.067758", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:40:38.650019", "content": "# Description: Enhanced population diversity and adaptive parameter control for improved convergence efficiency.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.6 * np.random.rand()  # Adjusted dynamic scaling factor for more diversity\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.7 + 0.2 * np.random.rand()  # Slightly higher scaling for alternative strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.6:  # Increased probability for first mutation strategy\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget) + 0.05  # Adaptive crossover with slight randomness\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-09 17:40:38.653322", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:40:54.921651", "content": "\n# Description: Enhanced diversity and convergence through adaptive selection pressure and dynamic parameter adjustment.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n        \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.4 * np.random.rand()  # Slightly more dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Adjusted strategy scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.55:  # Adjusted selection probability\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Slightly adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.28:  # Slightly adjusted probability for Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly tuned step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:44:43.449160", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:44:55.639529", "content": "# Description: Introduce hybrid crossover and adaptive elite selection to improve convergence speed and solution quality.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveHybridEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.6 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.4 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def hybrid_crossover(self, target, mutant):\n        CR = 0.8 * (1 - self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        trial = np.where(crossover, mutant, target)\n        # Integrate elite vector into crossover\n        elite = self.population[np.argmin(self.fitness)]\n        elite_influence = 0.05 * (elite - target)\n        return trial + elite_influence\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.hybrid_crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:44:55.642318", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:45:13.289650", "content": "# Description: A refined adaptive strategy employing a more aggressive crossover and mutation approach with periodic population rejuvenation for enhanced convergence.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.rejuvenation_interval = self.budget // 5  # Periodic rejuvenation every 20% of the budget\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.4 * np.random.rand()  # Slightly higher dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.7 + 0.2 * np.random.rand()  # Alternative strategy with adjusted scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if np.random.rand() < 0.6 else mutant2  # Increased preference for mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.95 * (1 - self.eval_count / self.budget)  # Higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def rejuvenate_population(self):\n        rejuvenation_factor = 0.1\n        for i in range(self.population_size):\n            if np.random.rand() < rejuvenation_factor:\n                self.population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[i] = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            if self.eval_count % self.rejuvenation_interval == 0:\n                self.rejuvenate_population()\n                self.evaluate_population(func)\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Further increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Slightly adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:49:00.140248", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:49:20.222997", "content": "# Description: Enhanced Dynamic Lévy-Mutation Adaptive Differential Evolution with Improved Selection Mechanism and Adaptive Population Sizing to Boost Convergence Speed.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedDynamicLévyMutationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_population_size = max(4 * dim, 20)\n        self.population_size = self.init_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.55:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n        else:\n            # Simulated annealing-like probability to accept worse solutions\n            if np.random.rand() < 0.1 * (1 - self.eval_count / self.budget):\n                self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            if self.eval_count % (self.budget // 10) == 0:  # Dynamic adjustment of population size\n                self.population_size = max(self.init_population_size, self.population_size - 2)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:53:11.444385", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:53:30.435004", "content": "Below is the modified algorithm that aims to improve convergence speed by approximately 10% code difference, through adjustments in mutation strategies, crossover, and exploitation mechanisms.\n\n# Description: Enhanced exploration and exploitation through adaptive parameter tuning and random walk integration.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.4 * np.random.rand()  # Enhanced dynamic scaling factor range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.7 + 0.2 * np.random.rand()  # Narrowed strategy with higher scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if np.random.rand() < 0.6 else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / self.budget) + 0.05  # Adapted crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def random_walk(self, individual):\n        return individual + np.random.uniform(-0.02, 0.02, size=self.dim)  # Small random perturbations\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying additional strategies\n                    trial += 0.005 * self.levy_flight() + self.random_walk(trial)  # Combined influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:57:23.084324", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:57:35.619007", "content": "# Description: Adaptive Lévy Differential Evolution with enhanced mutation diversity and dynamic convergence acceleration.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.6 * np.random.rand()  # Broadened dynamic scaling factor range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.4 * np.random.rand()  # Adjusted alternative strategy scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        g, h, i = np.random.choice(indices, 3, replace=False)\n        F3 = 0.45 + 0.55 * np.random.rand()  # Added third mutation strategy\n        mutant3 = np.mean(self.population[[g, h, i]], axis=0) + F3 * (self.population[g] - self.population[h])\n\n        strategy_choice = np.random.rand()\n        if strategy_choice < 0.33:\n            return mutant1\n        elif strategy_choice < 0.66:\n            return mutant2\n        else:\n            return mutant3\n\n    def crossover(self, target, mutant):\n        CR = 0.8 * (1 - (self.eval_count / self.budget)**0.5)  # Enhanced adaptation through nonlinear scaling\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Further adjusted step size for influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:03:04.804473", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV2: Augmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed. (Score: 0.3623594118017986)\n\nThe selected solution to update is:\nAugmented adaptive algorithm with diversified mutation strategies and dynamic population interactions to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.5 * np.random.rand()  # Enhanced dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.6 + 0.3 * np.random.rand()  # Alternative strategy with different scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # Slightly higher adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for better influence\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:03:19.445128", "content": "# Description: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:07:10.078274", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:07:22.997340", "content": "# Description: Implements enhanced diversity control and adaptive parameter tuning for improved convergence in differential evolution.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for enhanced diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted dynamic scaling factor for stability\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Adjusted different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.6 else mutant1  # Increased bias towards more diverse strategies\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.2 * self.budget))  # More adaptive and aggressive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for more controlled exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:11:15.135291", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:11:27.563484", "content": "# Description: Introducing stochastic adaptive mutation scaling and dynamic crossover rate adjustments to enhance convergence speed in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand() + 0.1 * (self.eval_count / self.budget)  # Stochastic adaptive scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand() + 0.2 * (self.eval_count / self.budget)  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # More dynamic crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:\n                    trial += 0.008 * self.levy_flight()  # Slightly adjusted step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:11:27.566037", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:11:38.212061", "content": "# Description: Adaptive mutation scaling and dynamic population adjustment enhance convergence speed in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.base_population_size = max(4 * dim, 20)\n        self.population_size = self.base_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Slightly altered dynamic scaling factor\n        F2 = 0.5 + 0.25 * np.random.rand()  # Different dynamic strategy\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        mutant2 = self.population[a] + F2 * (self.population[b] - self.population[c])\n\n        if self.fitness[a] < self.fitness[b]:\n            return mutant1 if self.fitness[a] < self.fitness[c] else mutant2\n        else:\n            return mutant1 if self.fitness[c] < self.fitness[b] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / self.budget)  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_size(self):\n        # Adjust population size based on progress\n        if self.eval_count > self.budget * 0.5 and np.min(self.fitness) < 1e-5:\n            self.population_size = int(self.base_population_size * 0.8)\n        else:\n            self.population_size = self.base_population_size\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.dynamic_population_size()\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Increased probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Adjusted step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:11:38.215152", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:11:51.766874", "content": "# Description: Integrates a dynamic, adaptive scaling strategy and enhanced Lévy flight mechanism for improved convergence speed in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedDynamicLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand() * (0.9 + 0.1 * np.cos(np.pi * self.eval_count / self.budget))  # Dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n\n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand() * (0.8 + 0.2 * np.sin(np.pi * self.eval_count / self.budget))  # Another dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Adjusted step size for better exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:11:51.770224", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:12:04.516526", "content": "# Description: Enhances convergence by refining mutation and selection strategies and introducing dynamic exploration intensities.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Increased lower bound for scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Adjusted scaling range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.4 else mutant1  # Slightly increased mutant2 selection probability\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Increased initial crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.01 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-09 18:12:04.519362", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:12:16.713792", "content": "# Description: Introduces adaptive divergence and convergence handling through dynamic scaling and mutation strategies to enhance differential evolution's convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveDivergenceConvergenceDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.45 + 0.4 * np.random.rand()  # Increased variation in scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.35 + 0.5 * np.random.rand()  # Further dynamic adjustment\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Enhanced adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n        self.eval_count += 1\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Adjusted probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Slightly larger step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:12:16.716476", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:12:31.027876", "content": "# Description: Integrates adaptive dynamic parameter tuning and enhanced mutation strategies to boost the exploration-exploitation balance in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.35 * np.random.rand()  # Adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.45 * np.random.rand()  # Slightly varied dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.05 * self.budget))  # More dynamic crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.38:  # Slightly higher probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Adjusted step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:12:31.031251", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:12:47.858115", "content": "# Description: Introduces adaptive control parameters and dynamic exploration-exploitation balance to improve convergence speed in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted dynamic scaling factor for more aggressive search\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Balanced dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.15 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:12:47.861266", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:13:03.831774", "content": "# Description: Integrates adaptive mutation scaling based on population diversity and introduces a simulated annealing-inspired acceptance mechanism to enhance convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population, axis=0).mean()\n        F1 = 0.5 + 0.3 * np.random.rand() * (1 + diversity)  # Adaptive scaling with diversity\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n\n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand() * (1 + diversity)  # Adaptive scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def accept_with_annealing(self, current_fitness, trial_fitness, temperature):\n        if trial_fitness < current_fitness:\n            return True\n        else:\n            return np.random.rand() < np.exp((current_fitness - trial_fitness) / temperature)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        temperature = max(1.0 - self.eval_count / self.budget, 0.01)\n        if self.accept_with_annealing(self.fitness[target_idx], trial_fitness, temperature):\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:13:03.834961", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:13:16.522114", "content": "# Description: Enhances exploration through dynamic mutation strategies and adaptive crossover, improving convergence speed and solution quality.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for better diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.8 + 0.2 * np.random.rand()  # Adjusted scaling factor for enhanced exploration\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.3 + 0.5 * np.random.rand()  # Further varied strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Further increased probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Slightly increased step size for enhanced exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:13:16.524885", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:13:29.566921", "content": "# Description: Enhances exploration and convergence by integrating dynamic scaling factors, adaptive crossover, and an intensified Lévy flight component.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # More aggressive dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        choice = np.random.rand()\n        if self.fitness[a] < self.fitness[d]:\n            return mutant1 if choice > 0.4 else mutant2  # Slight bias towards fitter mutant\n        else:\n            return mutant2 if choice > 0.4 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.8 * (1 - self.eval_count / (1.2 * self.budget))  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Further increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:13:29.569679", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:13:48.890794", "content": "# Description: Introduces a self-adaptive mutation strategy and dynamic crossover rate to enhance convergence speed while maintaining exploration capability.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.best_fitness = np.inf\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                self.best_fitness = min(self.best_fitness, self.fitness[i])\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F_adaptive = 0.5 * (1 + np.exp(-self.eval_count / (0.3 * self.budget)))\n        mutant2 = self.population[d] + F_adaptive * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.4 * (self.best_fitness / np.max(self.fitness))  # Dynamic crossover probability based on best fitness\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            self.best_fitness = min(self.best_fitness, trial_fitness)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:\n                    trial += 0.007 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:13:48.893677", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:14:03.121464", "content": "# Description: Introduces dynamic population resizing and adaptive mutation probabilities to enhance the convergence speed of the enhanced differential evolution algorithm.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            if self.eval_count > self.budget / 2 and self.population_size > 10:\n                self.population_size -= 1  # Dynamic population resize\n            \n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Adjusted Lévy flight probability\n                    trial += 0.007 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:14:03.124327", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:14:19.501662", "content": "# Description: Enhances exploration-exploitation balance by augmenting mutation diversity and dynamic crossover strategies.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c, d = np.random.choice(indices, 4, replace=False)\n        F1 = 0.45 + 0.35 * np.random.rand()  # Reduced range for scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        e, f, g, h = np.random.choice(indices, 4, replace=False)\n        F2 = 0.35 + 0.45 * np.random.rand()  # Different dynamic strategy with increased scaling range\n        mutant2 = self.population[e] + F2 * (self.population[f] - self.population[g])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[e]:\n            return mutant1 if self.fitness[a] < self.fitness[e] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.55 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.15 * self.budget))  # More dynamic adjustment of crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.38:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Slightly reduced step size for refined exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:14:19.505011", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:14:40.490611", "content": "# Description: Introduces dynamic scaling of population size and a self-adaptive crossover strategy to speed up convergence in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass OptimizedEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.4 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + 0.35 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if better_fitness == self.fitness[a] else mutant2\n\n    def crossover(self, target, mutant):\n        adaptive_CR = 0.75 * (1 - self.eval_count / self.budget) + 0.1 * np.random.rand()\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight slightly\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size for nuanced exploration\n\n                self.select(i, trial, func)\n\n            # Dynamic adjustment of population size\n            if self.eval_count > self.budget / 2 and self.population_size < self.initial_population_size * 1.5:\n                self.population_size = int(self.initial_population_size * 1.5)\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))\n                self.population = np.vstack((self.population, new_individuals))\n                self.fitness = np.append(self.fitness, np.full(len(new_individuals), np.inf))\n                self.evaluate_population(func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:14:40.493349", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:14:58.644075", "content": "# Description: Introduces enhanced adaptive strategies by refining mutation strategies and incorporating an adaptive learning rate to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.6):  # Adjusted beta for exploration\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] <= self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.2 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.01 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:14:58.647920", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:15:15.446574", "content": "# Description: Incorporates adaptive crossover rates and Lévy flight adjustments to enhance exploration and exploitation balance, accelerating convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDEv4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.best_fitness = np.inf\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.3 + 0.5 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if better_fitness in [self.fitness[a], self.fitness[d]] else mutant2\n\n    def crossover(self, target, mutant):\n        adaptive_factor = (self.best_fitness / np.min(self.fitness) + 0.1) / 1.1\n        CR = 0.8 * (1 - self.eval_count / (1.15 * self.budget)) * adaptive_factor\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:15:15.450023", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:15:32.865963", "content": "# Description: Enhance stochastic selection and mutation diversity to accelerate the convergence of differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c, d, e, f = np.random.choice(indices, 6, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness in (self.fitness[a], self.fitness[d]):\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant1 + 0.1 * np.random.randn(self.dim) if np.random.rand() > 0.5 else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:15:32.869641", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:15:57.350353", "content": "# Description: Introduces dynamic population resizing and enhanced mutation strategies to improve convergence speed and adaptability.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1\n        else:\n            return mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # More aggressive crossover adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_population_size(self):\n        if self.eval_count > 0.5 * self.budget:\n            self.population_size = max(self.population_size // 2, 10)\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.adapt_population_size()\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Decreased probability for applying Lévy flight for faster convergence\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:15:57.354245", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:16:10.017989", "content": "# Description: Utilizes dynamic population resizing and adaptive mutation scaling for faster convergence in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(len(self.population)), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.5 - 0.3 * self.eval_count / self.budget) * np.random.rand()  # Adaptive scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.6 - 0.3 * self.eval_count / self.budget) * np.random.rand()  # Adaptive strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if better_fitness == self.fitness[a] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * np.exp(-self.eval_count / (0.9 * self.budget))  # Exponentially adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = max(2, int(self.initial_population_size - (self.initial_population_size - 2) * self.eval_count / self.budget))\n            self.population = self.population[:current_population_size]\n            self.fitness = self.fitness[:current_population_size]\n\n            for i in range(current_population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:\n                    trial += 0.007 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:16:10.021355", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:16:23.688982", "content": "# Description: Introduces a dynamic population scaling and focused local exploration to enhance the convergence speed of differential evolution.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.2 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Moderate step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:16:23.692875", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:16:41.297126", "content": "# Description: Implements dynamic diversity control and enhanced mutation strategies to improve convergence efficiency in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.initial_diversity = None\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n        self.initial_diversity = self.compute_diversity()\n\n    def compute_diversity(self):\n        return np.mean(np.linalg.norm(self.population - np.mean(self.population, axis=0), axis=1))\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = (self.compute_diversity() / self.initial_diversity) if self.initial_diversity else 1\n        F1 = 0.6 * diversity_factor + 0.2 * np.random.rand()  # Adjusted with diversity\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 * diversity_factor + 0.3 * np.random.rand()  # Adjusted with diversity\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.2 * self.budget))  # Slightly increased adaptive crossover rate\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Decreased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Decreased step size for more controlled exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:16:41.300600", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:16:56.518777", "content": "# Description: Enhances convergence by incorporating a dynamic mutation strategy and increasing exploration using adaptive step size scaling.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + 0.5 * (1 - self.eval_count / self.budget)  # Adaptive scaling factor based on progress\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        G = 0.45 + 0.45 * np.random.rand()  # Slightly altered dynamic strategy\n        mutant2 = self.population[d] + G * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, mutant2)\n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.4 * (self.eval_count / self.budget)**2  # More adaptive and aggressive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.009 * self.levy_flight()  # Further increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:16:56.522089", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:17:16.149376", "content": "# Description: Enhances diversity and convergence by incorporating elite solutions and adaptive mutation strategies based on fitness variance.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.elite_fraction = 0.1  # New elite fraction for maintaining top solutions\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_variance = np.var(self.fitness)\n        F1 = 0.5 + 0.3 * np.random.rand() * (1 + fitness_variance)  # Fitness-based scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.2 * np.random.rand() * (1 + fitness_variance)  # Alternative strategy with fitness influence\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def update_elite(self):\n        elite_size = int(self.population_size * self.elite_fraction)\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        for idx in elite_indices:\n            if np.random.rand() < 0.1:  # Small chance to apply additional exploration to elite\n                self.population[idx] += 0.005 * self.levy_flight()\n                self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:\n                    trial += 0.007 * self.levy_flight()\n\n                self.select(i, trial, func)\n            \n            self.update_elite()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:17:16.153121", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:17:35.114772", "content": "# Description: Incorporates a multi-strategy mutation approach and adaptive parameters to accelerate convergence in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.4 * np.random.rand()  # Adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.3 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n        \n        # Additional strategy using best solution\n        best_idx = np.argmin(self.fitness)\n        mutant3 = self.population[best_idx] + 0.3 * (self.population[a] - self.population[b])\n\n        best_mutant = min(mutant1, mutant2, mutant3, key=lambda m: func(np.clip(m, self.lower_bound, self.upper_bound)))\n        return best_mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.1 * self.budget))  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Increased probability for applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:17:35.118047", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:17:49.547295", "content": "\n# Description: Incorporates adaptive mutation strategies and maintains an elite archive to enhance the exploration and exploitation balance in differential evolution.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.elite_archive = []\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if len(self.elite_archive) < 5:\n                    self.elite_archive.append((self.population[i], self.fitness[i]))\n                else:\n                    max_idx = np.argmax([fit for _, fit in self.elite_archive])\n                    if self.elite_archive[max_idx][1] > self.fitness[i]:\n                        self.elite_archive[max_idx] = (self.population[i], self.fitness[i])\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + 0.5 * np.random.rand()\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n        if np.random.rand() < 0.3 and self.elite_archive:\n            elite_idx = np.random.randint(len(self.elite_archive))\n            elite_point = self.elite_archive[elite_idx][0]\n            mutant = (mutant + elite_point) / 2\n\n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.0 * self.budget))\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:17:49.550243", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:18:03.541023", "content": "# Description: Enhances mutation strategies and dynamic population adaptation for improved convergence in differential evolution.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.3):  # Adjusted beta to explore variations in flight\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def dynamic_population_adjustment(self):\n        if self.eval_count < self.budget * 0.5:\n            self.population_size = max(4 * self.dim, 20)\n        else:\n            self.population_size = max(int(3.5 * self.dim), 15)\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.4 + 0.4 * np.random.rand()  # Slightly modified dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n\n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.3 + 0.5 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.80 * (1 - self.eval_count / (1.15 * self.budget))  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.dynamic_population_adjustment()  # Adjust population size based on progress\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.40:  # Slightly increased probability for applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:18:03.544202", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV3: Introduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution. (Score: 0.399023432586528)\n\nThe selected solution to update is:\nIntroduces adaptive learning rate and fitness-based mutation selection to enhance the convergence of differential evolution.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()  # Slightly adjusted dynamic scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()  # Different dynamic strategy\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability for applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size for exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:18:21.633053", "content": "# Description: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:22:15.931591", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:22:32.620591", "content": "# Description: Integrates dynamic crossover adaptation and fitness-influenced mutation strategies to enhance convergence efficiency.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        best_choices = [self.fitness[a], self.fitness[b], self.fitness[c], self.fitness[d], self.fitness[e], self.fitness[f]]\n        better_fitness = min(best_choices)\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        CR_dynamic = CR * (1 - self.fitness.min() / max(self.fitness.max(), 1e-9))\n        crossover = np.random.rand(self.dim) < CR_dynamic\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.45:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:22:32.623616", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:22:49.070635", "content": "# Description: Introduce adaptive scaling for crossover rate and mutation factor with population diversity-based adjustments to enhance convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population, axis=0).mean()\n        F1 = 0.5 + 0.3 * (1 - diversity) * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * (1 - diversity) * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        diversity = np.std(self.population, axis=0).mean()\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget)) * (1 + 0.1 * diversity)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Adjusted probability of applying Lévy flight\n                    trial += 0.0055 * self.levy_flight()  # Fine-tuned step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:22:49.073635", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:23:04.404734", "content": "# Description: Introduces dynamic population resizing and adaptive crossover to enhance exploration and exploitation balance.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 + 0.15 * np.cos(np.pi * self.eval_count / self.budget)  # Adaptive CR for dynamic adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def resize_population(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = int(self.population_size * 0.8)  # Reduce population size by 20% after half budget\n            self.population = self.population[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.resize_population()\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:\n                    trial += 0.006 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:23:04.407748", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:23:18.715185", "content": "# Description: Refines mutation and crossover processes through adaptive parameter tuning and exploration-enhancing mechanisms to boost convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        selected_mutant = mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n        return selected_mutant + 0.1 * (self.population[target_idx] - selected_mutant)\n\n    def crossover(self, target, mutant):\n        CR = 0.8 + 0.2 * np.random.rand() * (1 - self.eval_count / self.budget)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.45:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:23:18.718135", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:23:35.614874", "content": "# Description: Introduces adaptive scaling of mutation and crossover parameters based on fitness variance to accelerate convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def dynamic_scaling(self):\n        fitness_variation = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        return 0.5 + 0.5 * np.tanh(fitness_variation)\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand() * self.dynamic_scaling()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand() * self.dynamic_scaling()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget)) * self.dynamic_scaling()\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:\n                    trial += 0.006 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:23:35.618026", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:23:52.000858", "content": "# Description: Refines mutation and crossover strategies with dynamic adaptation and stronger selection pressure for enhanced convergence efficiency.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.3 * np.random.rand()  # Adjusted mutation factor for enhanced exploration\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Adjusted mutation factor for enhanced exploration\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.95 * (1 - self.eval_count / (1.1 * self.budget))  # Further adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n        else:\n            # Attempt to further explore around the trial solution\n            trial = np.clip(trial + 0.003 * self.levy_flight(), self.lower_bound, self.upper_bound)\n            re_trial_fitness = func(trial)\n            self.eval_count += 1\n            if re_trial_fitness < self.fitness[target_idx]:\n                self.population[target_idx] = trial\n                self.fitness[target_idx] = re_trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Adjusted probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size for better balance\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:23:52.004186", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:24:04.089982", "content": "# Description: Incorporates dynamic mutation adaptation with chaotic sequences and adaptive crossover to enhance convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.chaos_sequence = np.random.rand(self.population_size)\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.2 * self.chaos_sequence[target_idx] # Adjusted F1 using chaotic sequence\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.3 * self.chaos_sequence[target_idx] # Adjusted F2 using chaotic sequence\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.1 * self.budget)) # Slightly extended CR adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:  # Increased probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:24:04.092819", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:24:16.686880", "content": "# Description: Utilizes dynamic population size reduction, enhanced mutation strategy, and progressive crossover adjustment for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.4 * np.random.rand()  # Increased dynamic range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.3 + 0.5 * np.random.rand()  # Increased dynamic range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.05 * self.budget))  # Slightly reduced CR for controlled adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            if self.eval_count % int(self.budget * 0.1) == 0:  # Reduce population size progressively\n                self.population_size = max(4, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n            \n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:24:16.689726", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:24:34.658195", "content": "# Description: It utilizes dynamic self-adaptive mutation and crossover strategies with improved selection pressure and diversity management for enhanced convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted mutation factor range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Adjusted mutation factor range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.4 else mutant1  # Adjusted selection probability\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.02 * self.budget))  # Slightly adjusted CR for adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.45:  # Increased probability of applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:24:34.661224", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:24:45.809078", "content": "# Description: Enhances the exploration-exploitation balance by integrating adaptive mutation rates and dynamic selection pressures for accelerated convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.4 * np.random.rand()  # Adjusted mutation factor range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.3 + 0.5 * np.random.rand()  # Adjusted mutation factor range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.6 else mutant1  # Dynamic selection pressure\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Slightly adjusted probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:28:32.471484", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:28:43.475825", "content": "# Description: Integrates an adaptive mutation control strategy with enhanced diversity maintenance to accelerate convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveMutationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population, axis=0).mean()\n        F1 = 0.5 + 0.3 * np.random.rand() * (1.0 - self.eval_count / self.budget) + diversity * 0.1\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand() * (1.0 - self.eval_count / self.budget) - diversity * 0.1\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  \n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    trial += 0.0065 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:28:43.479466", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:28:55.303672", "content": "# Description: Incorporates dynamic parameter adaptation and enhanced diversity maintenance to improve convergence and solution quality.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.F_min = 0.2  # Minimum F value for mutation scaling\n        self.F_max = 0.8  # Maximum F value for mutation scaling\n        self.CR_initial = 0.9\n        self.CR_final = 0.6\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = self.F_min + (self.F_max - self.F_min) * np.random.rand()  # Adaptive F\n        mutant1 = self.population[a] + F * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = self.F_min + (self.F_max - self.F_min) * np.random.rand()  # Consistent adaptive F\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = self.CR_initial - (self.CR_initial - self.CR_final) * (self.eval_count / self.budget)  # Dynamic CR\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Adjusted probability of applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slight adjustment in step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:28:55.306371", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:29:09.678127", "content": "# Description: Integrates adaptive dynamic scaling with enhanced Lévy flights and a refined crossover strategy for faster convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedDynamicLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted mutation factor range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # Refined CR for improved adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.45:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Fine-tuned step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:29:09.681070", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:29:22.119138", "content": "# Description: Improved convergence by optimizing crossover strategies and enhancing Lévy flight perturbation for better exploration-exploitation balance.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.6 + 0.2 * np.random.rand()  # Refined mutation factor range\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:  # Increased probability of applying Lévy flight\n                    trial += 0.008 * self.levy_flight()  # Adjusted step size for better exploration\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:29:22.121986", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:29:37.000126", "content": "# Description: Integrates adaptive population resizing and dynamic crossover rate adjustments to enhance convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n            if self.eval_count >= self.budget:\n                break\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.95 * (1 - self.eval_count / (1.1 * self.budget))  # Further adaptive adjustment\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_population_resize(self):\n        self.population_size = max(4 * self.dim, int(np.log(self.eval_count + 1) * 20))\n        self.population = np.resize(self.population, (self.population_size, self.dim))\n        self.fitness = np.resize(self.fitness, self.population_size)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.adaptive_population_resize()\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Adjusted probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Slightly reduced step size\n                \n                self.select(i, trial, func)\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:33:41.805348", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:33:56.585914", "content": "# Description: Introduces stochastic exploration enhancements and adaptive crossover rate adjustments to boost convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n        \n        # Encourage diversity by selecting the best fitness direction\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        # More adaptive crossover rate with slight stochastic exploration\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget)) + 0.1 * np.random.rand()\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # More frequent and random Lévy flight\n                if np.random.rand() < 0.5:  \n                    trial += 0.007 * self.levy_flight() # Adjusted step size and frequency\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:33:56.589201", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:34:07.581403", "content": "# Description: Optimizes convergence speed by integrating dynamic crossover adaptation and mutation scaling with fitness diversity to enhance exploration and exploitation.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand() * (self.fitness[target_idx] / (np.min(self.fitness) + 1e-9))\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand() * (np.min(self.fitness) / (self.fitness[target_idx] + 1e-9))\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        diversity = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget)) * (1 + 0.2 * diversity)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:\n                    trial += 0.006 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:34:07.583981", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:34:22.657009", "content": "# Description: Integrates dynamic population resizing and adaptive crossover strategies to enhance convergence efficiency.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        dynamic_CR = 0.8 + 0.2 * (1 - self.eval_count / self.budget)  # Dynamic CR adjustment\n        CR = np.random.normal(dynamic_CR, 0.1)  # Introduce stochastic variation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_population_size(self):\n        if self.eval_count < 0.3 * self.budget:\n            self.population_size = int(self.population_size * 1.1)  # Increase population size\n        elif self.eval_count > 0.7 * self.budget:\n            self.population_size = max(int(self.population_size * 0.9), 20)  # Decrease population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            self.adapt_population_size()\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Modify probability of applying Lévy flight slightly\n                    trial += 0.005 * self.levy_flight()  # Fine-tuned step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:38:32.800372", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:38:44.226118", "content": "# Description: Integrates dynamic scaling of mutation strategies and adaptive crossover rates to enhance convergence efficiency.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.3 * np.random.rand()  # Adjusted F range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.3 * np.random.rand()  # Adjusted F range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        if np.random.rand() < 0.5:  # Random choice for diversity\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.8 * (1 - self.eval_count / (1.1 * self.budget))  # Adjusted CR with dynamic adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:  # Adjusted probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:38:44.228801", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:38:56.233196", "content": "# Description: Integrates diversity control with adaptive mutation and crossover strategies to enhance convergence acceleration.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 25)  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.4 * np.random.rand()  # Adjusted F1 for increased diversity\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + 0.5 * np.random.rand()  # Adjusted F2 for increased diversity\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.1 * self.budget))  # Further adjusted CR\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:  # Further increased probability of applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:42:51.639767", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:43:15.973252", "content": "# Description: Integrates adaptive learning rates, diversified mutation strategies, and enhanced selection pressure to improve convergence speed and solution quality.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.learning_rate = 0.1\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n        \n        # New mutation strategy: hybrid combination\n        hybrid_mutant = (mutant1 + mutant2) / 2 + self.learning_rate * self.levy_flight()\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else hybrid_mutant\n        else:\n            return mutant2 if np.random.rand() > 0.5 else hybrid_mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        selection_pressure = 1.1  # Increased selection pressure\n        if trial_fitness < self.fitness[target_idx] * selection_pressure:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.45:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:43:15.976049", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:43:41.703027", "content": "# Description: Introduces adaptive scaling factor and dynamic crossover probability adjustment for enhanced convergence efficiency.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + 0.2 * np.random.rand()  # Adjusted scaling range for diversity\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.3 * np.random.rand()  # Slightly narrower scaling range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.8 * (1 - self.eval_count / self.budget) + 0.1 * np.random.rand()  # More dynamic CR adjustment\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.45:  # Further increased probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Slightly reduced step size for precision\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 18:43:41.705886", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV4: Enhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed. (Score: 0.4103756178027719)\n\nThe selected solution to update is:\nEnhances adaptive strategies by incorporating dynamic mutation scaling and fitness-based perturbation for improved convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 20)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + 0.3 * np.random.rand()\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + 0.4 * np.random.rand()\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.4:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.006 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:43:58.127911", "content": "```python\n# Description: Introduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed.\n# Code: \nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.4 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.1 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.5), 4 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Fine-tuned probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Slightly reduced step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:47:48.161564", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV5: Introduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed. (Score: 0.41479995336142456)\n\nThe selected solution to update is:\nIntroduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed.\n\nWith code:\n# Description: Introduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed.\n# Code: \nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.4 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.1 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.5), 4 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Fine-tuned probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Slightly reduced step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:48:11.675754", "content": "```python\n# Description: Enhances exploratory potential and dynamically adjusts crossover rates to improve convergence.\n# Code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c, d = np.random.choice(indices, 4, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        F2 = 0.4 + (0.4 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[a] - self.population[b])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], self.fitness[d])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 * (1 - self.eval_count / (1.05 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:  # Earlier resizing for more exploration\n            self.population_size = max(int(self.initial_population_size * 0.5), 4 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.35:  # Increased probability of applying Lévy flight\n                    trial += 0.007 * self.levy_flight()  # Slightly increased step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-09 18:51:31.939546", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV5: Introduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed. (Score: 0.41479995336142456)\n\nThe selected solution to update is:\nIntroduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed.\n\nWith code:\n# Description: Introduces dynamic population resizing and adaptive step sizes in mutation to enhance convergence speed.\n# Code: \nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(4 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.4 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.9 * (1 - self.eval_count / (1.1 * self.budget))  # Adjusted CR for better adaptation\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.5), 4 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.3:  # Fine-tuned probability of applying Lévy flight\n                    trial += 0.005 * self.levy_flight()  # Slightly reduced step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:51:47.372756", "content": "\n# Description: Combines enhanced crossover strategy and adaptive scaling for mutations to improve convergence efficiency.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)  # Slight increase in initial population size\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 + 0.05 * np.random.rand()  # Introduced slight randomness in CR\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability of applying Lévy flight\n                    trial += 0.004 * self.levy_flight()  # Slightly reduced step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 18:55:32.577845", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV6: Combines enhanced crossover strategy and adaptive scaling for mutations to improve convergence efficiency. (Score: 0.4901345416939218)\n\nThe selected solution to update is:\nCombines enhanced crossover strategy and adaptive scaling for mutations to improve convergence efficiency.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)  # Slight increase in initial population size\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        if better_fitness == self.fitness[a] or better_fitness == self.fitness[d]:\n            return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n        else:\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n\n    def crossover(self, target, mutant):\n        CR = 0.85 + 0.05 * np.random.rand()  # Introduced slight randomness in CR\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability of applying Lévy flight\n                    trial += 0.004 * self.levy_flight()  # Slightly reduced step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.27.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 18:55:47.712752", "content": "\n# Description: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:00:29.177490", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:00:44.928684", "content": "# Description: Introduce adaptive mutation strategies and enhanced population dynamics for improved convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.4 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Slightly increased factor\n        F1 *= np.random.choice([1.2, 0.8], p=[0.7, 0.3])  # Adjusted dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # More adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)  # Slightly increased resizing\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability of applying Lévy flight\n                    trial += 0.004 * self.levy_flight()  # Slightly increased step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:00:44.931609", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:00:59.788330", "content": "# Description: Introduces elite selection and enhanced mutation strategy to improve the convergence speed by focusing on the best-performing solutions.\n# Code:\n# ```python\nimport numpy as np\n\nclass EliteEnhancedLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        elite_idx = np.argmin(self.fitness)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c]) + 0.1 * (self.population[elite_idx] - self.population[a])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + (0.20 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f]) + 0.1 * (self.population[elite_idx] - self.population[d])\n\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.1 * (self.eval_count / self.budget)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:\n                    trial += 0.0025 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:00:59.791152", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:01:12.860830", "content": "# Description: Enhances exploration with stochastic local search and adaptive mutation scaling to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.35 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Adjusted scaling\n        F1 *= np.random.choice([1.1, 0.9], p=[0.75, 0.25])  # Slightly altered dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Adjusted scaling\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.8 - 0.15 * (self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def local_search(self, target):\n        step_size = 0.001 * np.random.normal(size=self.dim)\n        return target + step_size\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:  # Adjusted threshold\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability of stochastic local search\n                    trial = self.local_search(trial)\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:01:12.863519", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:01:29.771877", "content": "# Description: Improved balance between exploration and exploitation by adaptive mutation and crossover strategies.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget * 0.8)\n        F1 *= np.random.choice([1.15, 0.85], p=[0.7, 0.3])  # Adjusted dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget * 0.8)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:06:15.433928", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:06:32.563260", "content": "# Description: Introduces strategic mutation diversity and refined population resizing to enhance exploration and convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.75, 0.25])  # More diversity in scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F2 *= np.random.choice([1.0, 1.2], p=[0.7, 0.3])  # Alternative scaling enhancement\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.1 * (self.eval_count / self.budget)  # Slightly more aggressive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)  # Earlier resizing\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.18:  # Slightly adjusted probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Adjusted step size for stability\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:11:57.426628", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:12:10.389972", "content": "# Description: Introduces adaptive mutation strategies and enhanced exploration via Lévy flights for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.35 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.2, 0.8], p=[0.85, 0.15])  # Dynamic scaling fine-tuned\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n        \n        g, h, i = np.random.choice(indices, 3, replace=False)\n        F3 = 0.6 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant3 = self.population[g] + F3 * (self.population[h] - self.population[i])\n\n        fitness_values = [self.fitness[a], self.fitness[b], self.fitness[c], self.fitness[d], self.fitness[e], self.fitness[f], self.fitness[g], self.fitness[h], self.fitness[i]]\n        return min((mutant1, mutant2, mutant3), key=lambda x: func(x))\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.15 * (self.eval_count / self.budget)  # Adaptive crossover probability adjusted\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability of applying Lévy flight\n                    trial += 0.004 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:12:10.392739", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:12:21.887250", "content": "\n# Description: Fine-tunes dynamic scaling, crossover rates, and Lévy flight parameters for improved convergence speed in differential evolution.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAcceleratedLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.3):  # Adjusted beta for different flight characteristics\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.2, 0.8], p=[0.75, 0.25])  # Slightly adjusted scaling factor\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.05 * (self.eval_count / self.budget)  # Slightly adjusted crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.55:\n            self.population_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:12:21.889796", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:12:32.725810", "content": "# Description: Incorporates stochastic ranking during selection and adaptive mutation based on evaluation progress to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.35 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Slightly increased range\n        F1 *= np.random.choice([1.15, 0.85], p=[0.75, 0.25])  # Modified probabilities\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n\n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Slightly increased range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        # Adaptive mutation based on evaluation progress\n        if self.eval_count / self.budget > 0.5:\n            better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c])\n        else:\n            better_fitness = min(self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.1 * (self.eval_count / self.budget)  # Slightly decreased initial CR\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        # Stochastic ranking to introduce diversity\n        if trial_fitness < self.fitness[target_idx] or np.random.rand() < 0.1:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)  # Earlier resizing\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.15:  # Slightly reduced probability\n                    trial += 0.004 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:12:32.728501", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:12:42.435674", "content": "# Description: Introduces enhanced mutation diversity and time-adaptive population scaling to boost convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.55 + (0.35 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Slightly increased range\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Slightly increased range\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.88 - 0.12 * (self.eval_count / self.budget)  # Adjusted adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:  # Earlier resizing trigger\n            self.population_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:16:27.537113", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:16:39.283084", "content": "# Description: Introduces adaptive population resizing and enhanced Lévy flights for improved convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.2, 0.8], p=[0.7, 0.3])  # Enhanced dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # Enhanced adaptive crossover\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.4:  # Earlier resizing adjustment\n            new_size = max(int(self.initial_population_size * 0.65), 5 * self.dim)\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Adjusted probability of applying enhanced Lévy flight\n                    trial += 0.002 * self.levy_flight()  # Fine-tuned step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:16:39.285672", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:16:49.936941", "content": "# Description: Refines mutation dynamics and integrates strategic Lévy flight insertion to enhance convergence precision and speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass ImprovedAdaptiveLévyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Enhanced probability for Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Slightly smaller step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:16:49.939697", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:17:00.372255", "content": "# Description: Incorporates dynamic elitism and adaptive mutation strategies to enhance convergence speed.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        best_idx = np.argmin(self.fitness)\n        \n        F = 0.6 + 0.3 * (1 - self.eval_count / self.budget) * np.random.rand()\n        F *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])\n        \n        if np.random.rand() < 0.4:\n            mutant = self.population[best_idx] + F * (self.population[a] - self.population[b] + self.population[c] - self.population[best_idx])\n        else:\n            mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        \n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.15:\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:21:05.305101", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:21:16.936237", "content": "\n# Description: Enhances speed by refining mutation strategy, improving crossover diversity, and adjusting population dynamics.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.7, 0.3])  # Adjusted dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # Refined adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:  # Earlier resizing trigger\n            self.population_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.18:  # Slightly adjusted probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:21:16.939066", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:21:30.494269", "content": "# Description: Introduces dynamically adaptive mutation strategies and fine-tunes crossover mechanisms to enhance exploration and exploitation balance.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.2, 0.8], p=[0.7, 0.3])  # More dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.5 + (0.2 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # Slightly more adaptive\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:  # Resizing more frequently\n            self.population_size = max(int(self.initial_population_size * 0.6), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.15:  # Reduced probability for better control\n                    trial += 0.002 * self.levy_flight()  # Tweaked step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:21:30.496994", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:21:45.265226", "content": "# Description: Introduces a probabilistic self-adaptive control mechanism for mutation and crossover to enhance convergence speed while maintaining diversity.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])\n        F1 = np.random.choice([F1, F1 * 0.85], p=[0.9, 0.1])  # Self-adaptive F1\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F2 = np.random.choice([F2, F2 * 1.15], p=[0.9, 0.1])  # Self-adaptive F2\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)\n        CR = np.random.choice([CR, CR * 0.95], p=[0.85, 0.15])  # Self-adaptive CR\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.55:\n            self.population_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.18:  # Adjusted probability of applying Lévy flight\n                    trial += 0.0028 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:21:45.267813", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:21:58.508037", "content": "# Description: Enhance the balance between exploration and exploitation by adjusting mutation strategies and improving Lévy flight integration.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return 0.005 * step  # Slightly increased step size for more exploration\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.6 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Adjusted for slightly more exploration\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n\n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.45 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)  # Adjusted factors\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if np.random.rand() < 0.5 else mutant2  # More balanced choice\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # Slightly more aggressive crossover\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.55:  # Adjusted threshold for resizing\n            self.population_size = max(int(self.initial_population_size * 0.60), 5 * self.dim)  # Adjusted size factor\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Slightly increased probability of applying Lévy flight\n                    trial += self.levy_flight()\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 19:21:58.510473", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:22:12.676764", "content": "\n# Description: Introduces adaptive mutation strategies with diversified scaling factors and enhances global exploration through a refined Lévy flight step.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.15, 0.85], p=[0.75, 0.25])  # Refined dynamic scaling\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.85 - 0.15 * (self.eval_count / self.budget)  # Adjusted adaptive crossover\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size * 0.50), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:  # Increased probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Refined step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:26:56.313607", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:27:09.199480", "content": "Certainly! Here's a refined version of the algorithm with slight improvements to enhance its convergence speed while adhering to the 10% change constraint.\n\n# Description: Enhances convergence by incorporating dynamic mutation scaling and adaptive fitness-based selection.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget) + 0.1 * diversity_factor\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget) + 0.1 * diversity_factor\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        improvement = (self.fitness[target_idx] - trial_fitness) / self.fitness[target_idx] if self.fitness[target_idx] != 0 else 0\n        if trial_fitness < self.fitness[target_idx] or np.random.rand() < improvement:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.22:  # Slightly increased probability of applying Lévy flight\n                    trial += 0.0025 * self.levy_flight()  # Adjusted step size for more precision\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-09 19:33:10.832609", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedAdaptiveLévyDifferentialEvolutionV7: Introduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed. (Score: 0.5109281017821474)\n\nThe selected solution to update is:\nIntroduces dynamic scaling factor and adaptive crossover probability to enhance convergence speed.\n\nWith code:\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def mutate(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F1 = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F1 *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])  # Dynamic scaling introduced\n        mutant1 = self.population[a] + F1 * (self.population[b] - self.population[c])\n        \n        d, e, f = np.random.choice(indices, 3, replace=False)\n        F2 = 0.4 + (0.25 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        mutant2 = self.population[d] + F2 * (self.population[e] - self.population[f])\n\n        better_fitness = min(self.fitness[a], self.fitness[b], self.fitness[c], \n                             self.fitness[d], self.fitness[e], self.fitness[f])\n        return mutant1 if self.fitness[a] < self.fitness[d] else mutant2\n\n    def crossover(self, target, mutant):\n        CR = 0.9 - 0.1 * (self.eval_count / self.budget)  # Adaptive crossover probability\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_resizing(self):\n        if self.eval_count > self.budget * 0.6:\n            self.population_size = max(int(self.initial_population_size * 0.55), 5 * self.dim)\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.20:  # Adjusted probability of applying Lévy flight\n                    trial += 0.003 * self.levy_flight()  # Adjusted step size\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_resizing()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\nThe algorithm EnhancedAdaptiveLévyDifferentialEvolutionV7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.\n\n\nTake this code of an optimization algorithm and adjust it by 10.0% to \nimprove convergence speed. Make sure the modifications cover a broad spectrum \nof possible algorithm adjustments, considering changes across different \ncomponents without exceeding 10.0% in code difference. Your changes should \naim to improve the algorithm's ability to reach optimal solutions more quickly.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 19:33:24.562378", "content": "# Description: Introduces dynamic mutation strategies and adaptive population control to enhance convergence speed and robustness.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveLévyDifferentialEvolutionV8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = max(5 * dim, 25)\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def adaptive_mutation(self, target_idx):\n        indices = np.delete(np.arange(self.population_size), target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + (0.3 * np.random.rand()) * (1 - self.eval_count / self.budget)\n        F *= np.random.choice([1.1, 0.9], p=[0.8, 0.2])\n        mutant = self.population[a] + F * (self.population[b] - self.population[c])\n        if self.eval_count < self.budget * 0.3:\n            # Introduce a more explorative mutation strategy early on\n            d, e = np.random.choice(indices, 2, replace=False)\n            F2 = 0.6 + (0.2 * np.random.rand())\n            mutant += F2 * (self.population[d] - self.population[e])\n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.8 - 0.1 * (self.eval_count / self.budget)\n        crossover = np.random.rand(self.dim) < CR\n        return np.where(crossover, mutant, target)\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        self.eval_count += 1\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dynamic_population_control(self):\n        if self.eval_count > self.budget * 0.5:\n            new_size = max(int(self.initial_population_size * 0.5), 5 * self.dim)\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self.adaptive_mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.25:\n                    trial += 0.005 * self.levy_flight()\n\n                self.select(i, trial, func)\n\n            self.dynamic_population_control()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n# ```"}
