{"id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 38, in __call__\n  File \"<string>\", line 26, in update_harmony_memory\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n.", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 38, in __call__\n  File \"<string>\", line 26, in update_harmony_memory\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "0b791cac-3f19-482b-918c-abe06f44595e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "e94964d4-a7f4-4814-ba38-7571605b28de", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "23470b44-55d8-4c21-87f0-ca3b2895d8ef", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "75aad3a0-81a1-49c2-b32b-2ba09b6f369e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "fc704a85-337f-4478-8073-d06d00dbbf3d", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "fa326c92-60e3-46c9-aa87-60fb66ceaad3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "60042bb6-b762-4198-9697-bac1bf002766", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "813c114f-21c2-4300-8057-741873a4c8eb", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "fae15104-b9cd-454a-a620-841b0350d7b9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "0488a713-0a63-4c2a-b701-090739d04818", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "79e589cc-08f9-4c93-ae5a-6f3ea992222c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "8553235e-7490-4e34-b7a6-961e8c5c18b4", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "b956d875-4ce5-4acc-8b0f-1c4e25361c2e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "db0f3438-a65d-49fd-a59e-4174dfd27fd0", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "7ec894a1-5ea0-457d-b565-f788f978cc5c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a1cd5d5b-57d2-4aef-b0ef-41dc92ca3048", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "ead6fc95-f656-433c-8caf-6084d784688f", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "68cd5546-930e-4af0-8b2c-51e442e66010", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "5eb68450-1f96-4883-91f1-098d9e84bbce", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "93ae869f-942c-4f34-9b94-0d51c69f0ecd", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "2ea8f4de-adbc-4c8d-b0e7-0b4ae3da98c3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "016ce83a-5ba2-4917-9246-83284161f882", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "f6937d39-7d28-406a-850c-f0f60f147611", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "ff4fb652-0a82-41bb-9385-f0874d3c3866", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "35375dbf-8be3-4f0c-9357-21d7add25a33", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "24a43b5d-549a-4037-9e6e-db2e37037a76", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "aa47d4a0-a61a-4b34-b98b-ec8c7d579062", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "e38df55a-7589-49ff-a37e-ab5eece07639", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "0bd8ed4f-0b40-4589-836a-82dfbd40c064", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "8c0b78a1-9073-4185-82d1-88599ab039e5", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "82ab7cd2-986e-42c4-b22e-0379a77f5610", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "e837bdc7-ff97-47d0-b9e0-20c4c3725d48", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "167737e7-e6b8-4b06-91d8-7f04a3a8c065", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "4c350aad-2e17-41bf-b06c-aacfdffc25b6", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "16a8d6c4-2448-44ae-acee-94df23ab7e3f", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "6bb7078a-9f31-4940-8c36-8ab47590632b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "ece5b080-1706-4b1a-97c2-0699afa50dad", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "f202789a-7d9d-4310-8470-6ced06a5767e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "31c1a578-dbe1-4ee3-9929-ba1b9d1052db", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "b49397ea-408e-444c-8157-b75a1638a1f5", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "7b2ac9c1-d9d2-4ecf-8d1b-215bea951644", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "f691cb33-d667-4f49-b454-df1bca35f188", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "c3718cf2-e204-4ac0-b04a-13e1c0336ac8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "39799b41-33c1-4d22-b350-c10d28dbb747", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "67a5f17d-fe1d-4313-8f1e-1dc5a5b8df23", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "cbda7907-8730-4f2e-9f74-f6c819668e0a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "396061b2-942b-428c-b0af-4cad50a31066", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "1b57590e-d52d-4070-b09c-20a603e38042", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "3c7ddc6d-99ae-4f2d-b672-3459a2077959", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "2ed65abc-0517-4d9d-8efe-1359cc98c656", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a35d4f12-57f6-4439-8c3e-6aae642b4717", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a3c7200b-ba63-4dfa-8344-b4335861c8eb", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "68634c6f-2e77-4712-8fa6-e9c8c336e2d3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a6c99ab8-161e-4830-ab1d-2ec3b5f3b610", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "c5164600-dab8-4582-9288-e3812a6b0bf6", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a2106a14-733a-419d-9add-51e80bba4287", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "bac76f29-f4eb-43b2-8891-78252dd57ffd", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "021f8e10-e05f-4ad7-ac37-644a0b6d9cc9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "55e4e3cb-b2a9-4be4-acbd-a44fae95c137", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "3cd94ea4-4730-48dc-8543-eef0a0905685", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "18c324c8-ae7b-4be7-935f-3130425d28f3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "57b3c24d-1437-4f1d-9c0e-b40d8c11abdf", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a088fec6-281e-4109-895c-0d34c2af3dc6", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "3fbd1d45-b37e-4ece-8b24-daba9ce08bdd", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "41a898d3-44a8-40e7-ba28-6dc93b14f392", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "1b6a9b49-b23e-450f-9743-06f2bdaddeac", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "c8671a90-cae2-4ec6-941b-e456923d20b3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "62e9a370-3ced-4724-a2bf-9e2e2ae0cbd9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "c400017e-1bb8-4a05-9f96-743ac9b27c9c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "a766f7a2-c0e6-44f0-83b0-f9504db69a0b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "efc0e9af-2a2f-4163-81bb-abb6fc436331", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "e6dbf730-5264-4855-b0c9-ea9d950e35fe", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "bf9ef591-b81d-4884-aaf0-2288cf2ea1f2", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size, self.dim)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {}, "mutation_prompt": null}
{"id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 74, "fitness": 0.03602242468033667, "feedback": "The algorithm HarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_id": "28e5b1e9-8fb0-4521-81be-8b21e58956bb", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "8bd777b1-6536-4ed2-a8bd-4a47dca8f629", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "30e45fbf-6c4d-46b6-836b-776ea2ccb275", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "1c150f9a-0e2e-4628-aada-21d10f9ef003", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "10e69064-bd33-468a-a4ea-ff8a2919178e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "ce535306-b84b-42b1-ac63-09a9310e2314", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "2800e9f8-72a1-419d-9d14-d675012762a1", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "218a43e0-4b5c-49c7-ad72-8992ce6287b2", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "45614fda-d8bf-4706-a25f-a558ed50f540", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "a0653cb0-aa36-4031-95bf-3a5655e23b63", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "abcfdc4d-3281-4741-baa6-38fbdd518df6", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "430e4c6c-00bb-4a44-b5f4-e9e1f87dd444", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "97dfa650-8a3a-4b4d-ab13-090b3caf54bc", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "8df0e2eb-61f7-472e-9605-762bdddf1a22", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "48bfb487-e950-430a-9285-427130dc01e1", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "0ddb4724-cccb-4275-9a9d-61b7d61c0b38", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "a83fad5a-7c07-4bbe-99db-ef7fea60ff17", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "089a23e3-c87d-439b-b525-033582ea10d9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "ade0274e-79cb-4228-9869-265e3379a527", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "740204d9-5dc7-42b1-9639-86e3a12ffb18", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "c4eece0f-fae8-41f6-bf9e-0b38997113cc", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "16fc39b5-33f0-4369-bdb6-912cccbba4ed", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "3d6bd24b-1ddf-40e6-9ea3-ba52250e74e9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "c7d50f5c-25c4-4d0b-b36b-ad2d90dc66b8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "684f2e74-fd39-475f-970e-3bd37bcf1ac9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
{"id": "01ad03d9-7c39-4f34-bb0a-7703a925c913", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 20\n        self.bandwidth = 0.01\n        self.par = 0.7\n        self.hm_acceptance_rate = 0.95\n        self.max_imp = 1000\n        \n    def __call__(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n        \n        def adjust_pitch(value, lower, upper):\n            new_value = value + np.random.uniform(-1, 1) * self.bandwidth\n            return np.clip(new_value, lower, upper)\n        \n        def update_harmony_memory(harmony_memory, new_solution):\n            fitness = func(new_solution)\n            idx = np.argmax(harmony_memory[:, -1])\n            if harmony_memory[idx, -1] > fitness:\n                harmony_memory[idx, :-1] = new_solution\n                harmony_memory[idx, -1] = fitness\n            return harmony_memory\n        \n        harmony_memory = np.zeros((self.harmony_memory_size, self.dim + 1))\n        harmony_memory[:, :-1] = initialize_harmony_memory()\n        harmony_memory[:, -1] = np.array([func(sol) for sol in harmony_memory[:, :-1]])\n        \n        imp_count = 0\n        while imp_count < self.max_imp:\n            new_solution = np.array([adjust_pitch(hm, self.lower_bound, self.upper_bound) if np.random.rand() < self.par else hm for hm in harmony_memory[np.random.choice(self.harmony_memory_size)]])\n            harmony_memory = update_harmony_memory(harmony_memory, new_solution)\n            imp_count += 1\n        \n        best_solution = harmony_memory[np.argmin(harmony_memory[:, -1])]\n        return best_solution[:-1]", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for global optimization in continuous search spaces.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e59eb88-1c67-40bf-af84-7fd2394817ca", "metadata": {"aucs": [0.07172115044991989, 0.06423415049946268, 0.0916041897440597, 0.08943128444456905, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494895, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.010544468052148481, 0.0011187632349987098, 0.006570620486303191, 0.018150078853237606, 0.0, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972905156, 0.06379241875032016, 0.048891644393723954, 0.03910579656890878, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.10018685869141841, 0.03765971698870685, 0.006388112346703334, 0.004462664352365198, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.11132656536249108, 0.14829537673711224, 0.09416865854239476, 0.09699835892693376, 0.09571399605654951, 0.1239692985348404, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05923488925517317, 0.09846289938816166, 0.10844057434014054, 0.05633684591928945, 0.08799080449358876, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504964, 0.10838250165484564, 0.09252844271105898, 0.09302957300514958, 0.11411347464502575, 0.17369512487615557, 0.07775611701398777, 0.033222260335509235, 0.033911540361439396, 0.03771787956751227, 0.044555131067182674, 0.06397588396999365, 0.04621487005142011, 0.05639263182623633, 0.0937696983443237, 0.03447669264933573, 0.09154377975027184, 0.06577577691506542, 0.13336421106438578, 0.10280083939129603, 0.07846030762821943, 0.0884484575292579, 0.12237199858757519, 0.06484693399681651, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858689, 0.07457348599177205, 0.08157840845421893, 0.06709542404813529, 0.1207035396655618, 0.06652066617622099, 0.0723629269250583, 0.0963456876397184, 0.053579659675793145, 0.038145025866380244, 0.06524162289785895, 0.02042802051764192, 0.0505908534635271, 0.03728632333816162, 0.0454156150021221, 0.04680845216491614, 0.028511267269767604, 0.04133833534605058, 0.13471522306136396, 0.12828496744990658, 0.1475449842687161, 0.11590646924167103, 0.11393539758803017, 0.12456358843521431, 0.12841860706551977, 0.10853850474266824, 0.14680476350940785, 0.0, 0.013379484918498052, 0.03129662407793532, 0.02691798931623468, 0.01838917108525462, 0.008161729106915816, 0.011050559611514132, 0.0, 0.017358041372640187]}, "mutation_prompt": null}
