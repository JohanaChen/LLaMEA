{"id": "4e31603a-0ed0-4e3e-84e0-b89aaf2ffe13", "solution": "import numpy as np\n\nclass ADELS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n        ]\n        self.local_search_probability = 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.1\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "ADELS", "description": "Adaptive Differential Evolution with Local Search (ADELS) that dynamically adjusts mutation strategies and incorporates a local search phase for enhanced convergence.", "configspace": "", "generation": 0, "fitness": 0.4893852642219685, "feedback": "The algorithm ADELS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.31.", "error": "", "parent_id": null, "metadata": {"aucs": [0.9096732604643315, 0.9033077543105856, 0.9083204320942461, 0.910838956142286, 0.9131105720197487, 0.9119109564406047, 0.9025982550828096, 0.9004671251038947, 0.9154697796989955, 0.8178035208624029, 0.8122553076177501, 0.8386333784526008, 0.8403024650338027, 0.8271240307931802, 0.8312946948849453, 0.8350352587080895, 0.8360923199659968, 0.8330311374996943, 0.6786882150354818, 0.10240515784150939, 0.16672125999298681, 0.14847180840696927, 0.5812797127446121, 0.6972603135428257, 0.1403685452774649, 0.11188189276913896, 0.144832876837103, 0.11060297504702998, 0.1391012339424289, 0.10572325082952705, 0.11629010057659839, 0.10402407098829536, 0.1487228994580717, 0.11377958451807169, 0.12521942144486697, 0.17406081474054647, 0.9873397937880448, 0.9855154986517557, 0.9879046011192676, 0.976314183565911, 0.9788057785299971, 0.9764986184785793, 0.9710211155656873, 0.9830536485093793, 0.9886836338168122, 0.7469276208972762, 0.7100784227440067, 0.6989204135306152, 0.7252682370517999, 0.7368201673114128, 0.7271981146593768, 0.7217186293486948, 0.7387211380730305, 0.7272844787920649, 0.9197275132857723, 0.22958825053162912, 0.22573923035712606, 0.277750439232646, 0.21265745264417624, 0.8980947664031272, 0.8923554732928042, 0.1780950735336606, 0.23589336177787834, 0.7619708893722282, 0.6776512656126938, 0.7453956205445573, 0.13330755443791498, 0.7388704226475975, 0.6930885448326854, 0.7447022856098133, 0.7614432819936787, 0.6239440279421195, 0.6963435066865149, 0.6956520369344266, 0.7266974158006023, 0.7627243237126495, 0.7610060574361722, 0.796590988041056, 0.7464908400834394, 0.7377707498786084, 0.7181342324196798, 0.07080351356657844, 0.7001888617453605, 0.6215673790520042, 0.731416978353133, 0.6584641090219399, 0.6879190725172109, 0.688435984224926, 0.5717589687333595, 0.5619078687197125, 0.7007849050189585, 0.699199550830278, 0.8020632608070122, 0.7362055944752849, 0.7111179116363577, 0.6775618209314935, 0.7934188205346618, 0.7932597157363598, 0.782871311071958, 0.26947905879984857, 0.14040429288724754, 0.11202568099916277, 0.22469454736399508, 0.36395840854930506, 0.6481043061328302, 0.29153608304319, 0.4815925562516743, 0.15002119721675589, 0.6373623765734115, 0.6477843012848492, 0.6389678126187818, 0.5352185098668495, 0.6179027629374942, 0.6288236007983334, 0.5025575630691627, 0.635113242111079, 0.6188131962125389, 0.8648996168024448, 0.8627161215267178, 0.871919753958185, 0.8700934771981483, 0.8454147819989984, 0.8702068804330035, 0.8675854729875103, 0.8569577084440432, 0.8661988986882422, 0.12575357984158508, 0.1296822136404715, 0.09978829043330029, 0.10969100242196383, 0.10925909697012559, 0.1452429772585605, 0.1430660501259472, 0.11242703124426445, 0.10988568985469316, 0.3373378540294667, 0.2323094158054082, 0.3607899048070884, 0.18266680736109986, 0.6694201162878195, 0.14272542701577862, 0.8176916922562139, 0.2592093208881697, 0.24338226871642787, 0.37943867782378005, 0.46131984328822984, 0.5721483657704154, 0.56919450463255, 0.709749596313049, 0.5794224174031724, 0.5264108223947876, 0.609344818284598, 0.7060020323283089, 0.2807734250152073, 0.46701899715469375, 0.5270399960078097, 0.5402742130577601, 0.48728725004037976, 0.3632601148725564, 0.6466028346008471, 0.6017187235718484, 0.23479274026823804, 0.1970104448236707, 0.20416621104001975, 0.20883536693082072, 0.2278410643297334, 0.20919338513617902, 0.20133929182780652, 0.23037524030160472, 0.2559851987598647, 0.22989265470947695, 0.20231561742950566, 0.22037272920494977, 0.2445411292530436, 0.20890358558284683, 0.19183687226101198, 0.22161818792578492, 0.19299184927603485, 0.8177926934920564, 0.21883345686851996, 0.153667673559154, 0.15783137273346015, 0.15341886106629787, 0.1681150605560402, 0.19923399378241868, 0.11616587698569214, 0.14209720831237427, 0.15147527699446872, 0.16639736663254245, 0.9123761577838132, 0.168684173508439, 0.1270017151867714, 0.8740451428070946, 0.21157830185387938, 0.8474136582498175, 0.16774753582180435, 0.10478274465306658, 0.8774642822747359, 0.18611645060124504, 0.18199953519994128, 0.19134699946491895, 0.1966240967857188, 0.1889308457195551, 0.19091738097417732, 0.19357923561388235, 0.18629847682389278, 0.19581625142076842, 0.09108873752671076, 0.09080236912352446, 0.08997100497476163, 0.07798444693058737, 0.08774637063129664, 0.08740329100703526, 0.10703226831121226, 0.07811272859717278, 0.08421621415851477]}, "mutation_prompt": null}
{"id": "feb79bc3-b2a4-452c-aca7-125acfe77554", "solution": "import numpy as np\n\nclass DDEAS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n        ]\n        self.local_search_probability = 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        F = self.F_base\n\n        while evaluations < self.budget:\n            if evaluations % (self.population_size * 2) == 0:  # Adaptive scale factor adjustment\n                F = self.F_base * (0.5 + 0.5 * np.random.rand())\n\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, F)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, F):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, F):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.1\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "DDEAS", "description": "Dynamic Differential Evolution with Adaptive Scale Factor (DDEAS) that optimizes convergence by dynamically adjusting mutation strategies and scale factors with periodic local search.", "configspace": "", "generation": 1, "fitness": 0.46793444910471843, "feedback": "The algorithm DDEAS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.31.", "error": "", "parent_id": "4e31603a-0ed0-4e3e-84e0-b89aaf2ffe13", "metadata": {"aucs": [0.9111201520977832, 0.9033077543105856, 0.9083204320942461, 0.911617479735171, 0.9131105720197487, 0.9119109564406047, 0.9042191808572583, 0.9004671251038947, 0.9154697796989955, 0.8378515542854362, 0.8128788277484736, 0.8386333784526008, 0.8486525951615363, 0.8271240307931802, 0.8312946948849453, 0.8518699657389048, 0.8360923199659968, 0.8330311374996943, 0.15401811928046338, 0.09242503875131391, 0.16672125999298681, 0.11417518905369994, 0.16163281942079788, 0.6972603135428257, 0.14191585796259665, 0.1118819367688193, 0.144832876837103, 0.13680805235129156, 0.13995459191941173, 0.10572325082952705, 0.10726662829713673, 0.10405223968049782, 0.1487228994580717, 0.11392018349362498, 0.1252194879792078, 0.17406081474054647, 0.9873397937880448, 0.9855154986517557, 0.9879046011192676, 0.976314183565911, 0.9788057785299971, 0.9764986184785793, 0.9710211155656873, 0.9830536485093793, 0.9886836338168122, 0.817519951216751, 0.7519247903132857, 0.6989204135306152, 0.8092092831824654, 0.7642660732657394, 0.7271981146593768, 0.7726442129713913, 0.7591664011985837, 0.7272844787920649, 0.9197275132857723, 0.22958825053162912, 0.22573923035712606, 0.27774856132049597, 0.2127765698145564, 0.8980947664031272, 0.8923554732928042, 0.1780950735336606, 0.23589336177787834, 0.7288797517052221, 0.6940214207900515, 0.7453956205445573, 0.13330487749601294, 0.7516816262963499, 0.6930885448326854, 0.7174623673515992, 0.7723528654205865, 0.6239440279421195, 0.6415814893983002, 0.6985077104256786, 0.7266974158006023, 0.7538150264648333, 0.7699768027981692, 0.796590988041056, 0.7358313779416356, 0.731271260507916, 0.7181342324196798, 0.10504600429336586, 0.5378589207564666, 0.6215673790520042, 0.35944846876123693, 0.5587490985392615, 0.6879190725172109, 0.6876329492112963, 0.32158666694014904, 0.5619078687197125, 0.2786281582692721, 0.39641341193993485, 0.8020632608070122, 0.7959982856407172, 0.7266949185694527, 0.6775618209314935, 0.7264616428258701, 0.7981296577394722, 0.782871311071958, 0.26828455607057067, 0.12113025510928488, 0.11202568099916277, 0.21011514295196554, 0.2170218011018441, 0.6481043061328302, 0.26356041526891827, 0.4147124126164682, 0.15002119721675589, 0.4348134557471126, 0.6142874177613303, 0.6389678126187818, 0.3806522935570782, 0.48085832795020156, 0.6288236007983334, 0.5375537226772071, 0.51403823951037, 0.6188131962125389, 0.8146354156975953, 0.8637661553592568, 0.871919753958185, 0.8533030717233294, 0.7485997519668226, 0.8702068804330035, 0.8835204105802573, 0.816127374788024, 0.8661988986882422, 0.12127846565190825, 0.12968221574429972, 0.09978829043330029, 0.1000465082136558, 0.10968773996332604, 0.1452429772585605, 0.1434273029473161, 0.11244211894753353, 0.10988568985469316, 0.22525446067186883, 0.21340227460674643, 0.3607899048070884, 0.17719204431736324, 0.5818692632604328, 0.14272542701577862, 0.4958460179251055, 0.2615131946185212, 0.24338226871642787, 0.4880166491815032, 0.5155816935021734, 0.5721483657704154, 0.509035337145995, 0.6231759150858933, 0.5794224174031724, 0.35411725271005134, 0.6077301917544201, 0.7060020323283089, 0.29244002056350427, 0.4737057343893434, 0.5270399960078097, 0.3536462862428621, 0.42739940093061246, 0.3632601148725564, 0.385896723169429, 0.4106174979766104, 0.23479274026823804, 0.2030606236208965, 0.21415550606335954, 0.20883536693082072, 0.2099477877046223, 0.20925982622740702, 0.20133929182780652, 0.2744105306823521, 0.2719600512722502, 0.22989265470947695, 0.20233966747219356, 0.22037273505366395, 0.2445411292530436, 0.20890456604113983, 0.19183687226101198, 0.22161818792578492, 0.19299384999277402, 0.8191657937689263, 0.21883345686851996, 0.15366767434827144, 0.15783137273345915, 0.15341886106629787, 0.16811507450314989, 0.19923399378243, 0.11616587698569214, 0.1420972093650711, 0.15147527699522545, 0.16639736663254245, 0.9126949658792934, 0.168684173508439, 0.1270017151867714, 0.8827163043251216, 0.21157830185439885, 0.8474136582498175, 0.1677475394602509, 0.10478274465306658, 0.8774642822747359, 0.1855367482270286, 0.18355875572098024, 0.19134699946491895, 0.19577281017250903, 0.20696170184557583, 0.19091738097417732, 0.1885365696124064, 0.20252539264273406, 0.19581625142076842, 0.09125859046892093, 0.091193647197369, 0.08997100497476163, 0.09222725297044931, 0.08910678298500718, 0.08740329100703526, 0.09680624934922089, 0.08925580070973682, 0.08421621415851477]}, "mutation_prompt": null}
{"id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Focused Local Search utilizing adaptive control parameters for improved diversity and convergence.", "configspace": "", "generation": 2, "fitness": 0.5548612899400909, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.31.", "error": "", "parent_id": "4e31603a-0ed0-4e3e-84e0-b89aaf2ffe13", "metadata": {"aucs": [0.9140144154502393, 0.9119945627520508, 0.9190897798008978, 0.91183608256894, 0.9099934843631299, 0.9170534853354243, 0.9144412295593287, 0.9106313387873125, 0.9183457873814755, 0.8221626814309245, 0.8316930638134689, 0.8365665558815685, 0.8139602453560706, 0.8441850165993527, 0.8435791257361398, 0.8216000793522638, 0.8366230790128206, 0.8315703592206858, 0.1562727598276772, 0.14853521215746512, 0.7340107814974344, 0.14199049984727685, 0.14040341417125912, 0.16343319872473805, 0.6416542947348762, 0.6205713229662903, 0.16531922607957472, 0.09653114009140318, 0.16789997913852894, 0.11555527222978546, 0.10340409431363662, 0.13976484683428114, 0.14384919099629057, 0.14939723964673868, 0.13853316238002966, 0.09597173410495996, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9684145992849261, 0.982778729149947, 0.9814455014854574, 0.7776381566806911, 0.7828908197824755, 0.7550543795346965, 0.7732181081806159, 0.763257744689845, 0.7785925425382032, 0.7828390809602553, 0.7761960490465973, 0.7880837824622238, 0.8958033916382943, 0.9089728042682071, 0.897306932004205, 0.2145208953141453, 0.9130049917349844, 0.9314575641438199, 0.9002612365869824, 0.2357195542223418, 0.9140814483316259, 0.6781616392234586, 0.7726299154170521, 0.8068940348646947, 0.13324633689313592, 0.134355819322183, 0.6854868627750555, 0.745195073745869, 0.7202088041309084, 0.7792292110307495, 0.667501390394101, 0.6220390767462909, 0.7183443577686486, 0.6666393748830828, 0.7597416655786837, 0.13333059901630373, 0.6947526891011317, 0.6440665737267919, 0.7564843156506976, 0.7219214224772751, 0.6514505274762656, 0.7155630986916027, 0.7441276908358543, 0.6635837017339519, 0.7354536157778895, 0.7335376239155936, 0.74416335160023, 0.7491947838751403, 0.8061174202538456, 0.7316088143875581, 0.7977572964550663, 0.7910263146637371, 0.7367622475231217, 0.7478701709662106, 0.819438022203814, 0.7958346688938099, 0.7758375258608818, 0.13953901005808278, 0.41679023782137936, 0.41970464690819653, 0.6920357331712953, 0.5771305562688457, 0.687832112587665, 0.37964541152330467, 0.17165850458485, 0.5275795294822287, 0.6798264233208281, 0.6892116525851382, 0.6573733914798237, 0.6796207240332753, 0.6835486752364, 0.6970572349782318, 0.6922451272010304, 0.6272253932222868, 0.6929565048480276, 0.8683845120612302, 0.8773353364383439, 0.8724317324197234, 0.8809029147480993, 0.8581481885015517, 0.8717744887032091, 0.8842012076373399, 0.86620319181741, 0.8543622787443149, 0.12238264936782417, 0.14714334456592282, 0.1438696125110024, 0.13996881123243365, 0.1185265250328914, 0.13324793815450153, 0.14796879484122505, 0.13149817737367697, 0.15354236766925, 0.22990443200647304, 0.335978142190701, 0.1971971087634724, 0.162314913063221, 0.695926281761061, 0.5628428692033431, 0.23275657014774553, 0.6374158975692874, 0.24721856617943228, 0.5425800441545645, 0.7482068137379894, 0.6170853051641343, 0.43098491796878247, 0.7414060234855564, 0.7347877316763609, 0.765320416676722, 0.7630797596703737, 0.762833986794512, 0.46631438852842866, 0.5344988597271308, 0.6111024110812985, 0.2162061717008874, 0.2688146909484531, 0.6181713961831257, 0.5271851160036427, 0.4398717449440952, 0.5373403741754874, 0.24539544319278894, 0.2568477478723393, 0.2141368022837492, 0.20688236742043453, 0.2311096097381411, 0.23955853848662023, 0.2137511228769131, 0.21868464095996276, 0.20396547535479392, 0.1958789312097804, 0.2461788520395477, 0.751768827258565, 0.22200384076392898, 0.21948163331466575, 0.699331468324087, 0.77256451611345, 0.24361536253111593, 0.20639795745525802, 0.186250858665455, 0.1874245165090409, 0.2002637007321325, 0.9040752897558364, 0.20082548497785913, 0.9211038627629997, 0.14217891224175894, 0.15888704095767403, 0.9322662959038613, 0.9226289950752073, 0.8896422389634291, 0.9236763374448232, 0.889793682539842, 0.8395360074315519, 0.9079968794431068, 0.8787830581909154, 0.8861041768593099, 0.9129953020899249, 0.18818618486047356, 0.1949737938610021, 0.1896757515299451, 0.21042919713744734, 0.18015268360911052, 0.2157964078665613, 0.20505536545627634, 0.18906603526188015, 0.18671831382675286, 0.09228323923882598, 0.08589067829090602, 0.07724837419405195, 0.09146151137325209, 0.09542196917319157, 0.109119862695636, 0.09675473094404097, 0.10080113136245616, 0.08834698828339826]}, "mutation_prompt": null}
{"id": "a48c90ed-636f-4963-ad10-5cf1c5e79bbb", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F_base = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                F = self.adaptive_mutation_rate(fitness, i)\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness, F)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness, F):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness, F):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness, F):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + F * (p_best - population[target_idx]) + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def adaptive_mutation_rate(self, fitness, index):\n        if index == np.argmin(fitness):\n            return self.F_base * 0.5\n        else:\n            return self.F_base * 1.5", "name": "EnhancedCoDE", "description": "Improved Differential Evolution with Dynamic Strategy Selection and Adaptive Mutation Rate for Enhanced Convergence.", "configspace": "", "generation": 3, "fitness": 0.4031810694842246, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8158902802264523, 0.8123867614338459, 0.8160052018550634, 0.8312178162832442, 0.8378092719595432, 0.8421161320050715, 0.8211334423363963, 0.8179426398690689, 0.8173970665551107, 0.6741512247120305, 0.6884407740050775, 0.6990328516633254, 0.6769309265145818, 0.6801162832823604, 0.6675057145313346, 0.6962873771396784, 0.6897770149966209, 0.6841928790121171, 0.09363828006239305, 0.11283775959603459, 0.11119904277142978, 0.097763711503698, 0.10433079223894381, 0.12020438583181736, 0.0897279572818579, 0.1318547827727059, 0.11521923444526094, 0.11916859605595342, 0.09191977182314626, 0.08589262614775905, 0.11226953235582882, 0.08945994235966959, 0.10557060055018141, 0.08917525858576647, 0.08966911843483738, 0.10375618987495983, 0.9901990265942283, 0.9914111957996137, 0.982003485434364, 0.9846511158025699, 0.98491027584498, 0.9863030105434742, 0.966965458082286, 0.9812480846029284, 0.978350388728994, 0.5173414822593277, 0.46718375385110167, 0.4789269021502621, 0.5181255240242062, 0.48927981691037103, 0.4901691587003374, 0.4960549120217761, 0.5122533961556187, 0.5308350120535068, 0.8031405696926148, 0.7263295428981398, 0.7673630904545783, 0.7898398215296242, 0.8265948649613494, 0.7720794254969401, 0.7386351207678321, 0.7643605592790023, 0.7504657439430559, 0.5498415995440651, 0.5579259382017419, 0.5085264203133202, 0.5324913310739459, 0.49154169567368844, 0.5624915636790022, 0.5487254486358775, 0.4992549380524165, 0.5251563242920024, 0.5746053482465889, 0.44549319783613595, 0.5508289453252042, 0.5665412700193463, 0.4844136833202207, 0.5775067391792879, 0.5286938340052645, 0.4979617426328623, 0.5843084991098, 0.3907819527299451, 0.4089111154422802, 0.41899337564245, 0.4432391694466532, 0.39117701495396906, 0.3954786561042106, 0.38662649362138557, 0.38878152336386895, 0.441320891411228, 0.5318479408895174, 0.45962118270514696, 0.5272879186759953, 0.5926912320412276, 0.4701816690691404, 0.5729722015322998, 0.5749948900735936, 0.553308402654121, 0.6330290174313247, 0.22227673208207932, 0.1016144445231143, 0.1247149721902937, 0.17072798637684083, 0.3159402372601865, 0.3301801828751255, 0.2822932179296227, 0.19831540902057399, 0.160920250393758, 0.34443903024143874, 0.33269998728383976, 0.34362452629580775, 0.38515057501679784, 0.34779189550307943, 0.35351324722299393, 0.32725336347130196, 0.3408491573995096, 0.36247844156228737, 0.7218163675747248, 0.7446821630289155, 0.7441212975602793, 0.7420657198967655, 0.7341406295160775, 0.6921811216409718, 0.7218984418442849, 0.725907881234423, 0.7188786322703268, 0.10008143376420453, 0.09344182004793589, 0.09690956061635003, 0.08883842601731629, 0.10483900737792551, 0.09405502387456421, 0.09304028051078062, 0.10485850778211703, 0.10317702924467265, 0.1391850939164616, 0.3882955565826236, 0.15591286365960388, 0.13887391597589827, 0.1406511603566738, 0.143629793056681, 0.1493768808751783, 0.13967243413483577, 0.5151886840011081, 0.42126282390741, 0.3685276979462415, 0.3838937869972008, 0.3853834272922041, 0.3800578104368898, 0.402308813803797, 0.46101494988876957, 0.4294504397223705, 0.4230195419454198, 0.28232898531248085, 0.32208984123755513, 0.3465088372218498, 0.29622589567338875, 0.32261824032656883, 0.28877050924184244, 0.3092999301096484, 0.36197117987873373, 0.34122485689201454, 0.1812358582490895, 0.19755031808223333, 0.22799320385133548, 0.19961568693296672, 0.18384560853729393, 0.19212053073987656, 0.17207624927260856, 0.19372843990078492, 0.2010118305671056, 0.18723601790099875, 0.31766911596774405, 0.24223240079318387, 0.1910899834287052, 0.18679995509798486, 0.17689882752637187, 0.2069339898820245, 0.3917311135618837, 0.20674230915952363, 0.15149892393338882, 0.8314904247335587, 0.1529711339330021, 0.20424613018613846, 0.6782600855510947, 0.16579309122903307, 0.182450969894553, 0.70425360241208, 0.17064317948816043, 0.8258201425987327, 0.20944638154372164, 0.16711750475703846, 0.6390548266184792, 0.20751431650776453, 0.16247881031228573, 0.21005954790176207, 0.21124657924132528, 0.1547827613721543, 0.18485290168999002, 0.19996989808090615, 0.18629548561687148, 0.18565973387618828, 0.19495791227850745, 0.20416054875295397, 0.18222494802184608, 0.1930914336508167, 0.18765593780990575, 0.0806500559498532, 0.07797939424405509, 0.07588781764658215, 0.07720076704469392, 0.07146286240917377, 0.07528035900333252, 0.07264683606454214, 0.07704603263697951, 0.083422134719215]}, "mutation_prompt": null}
{"id": "ed916e92-dc35-482d-8ef9-3ae06076eba7", "solution": "import numpy as np\n\nclass AdaptiveQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.quantum_fluctuation_rate = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                if np.random.rand() < self.quantum_fluctuation_rate:\n                    trial = self.quantum_fluctuation(trial)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def quantum_fluctuation(self, candidate):\n        fluctuation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(candidate + fluctuation, self.lower_bound, self.upper_bound)", "name": "AdaptiveQIDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Strategy Adjustment for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 4, "fitness": 0.5341277395876334, "feedback": "The algorithm AdaptiveQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9112692965032274, 0.9050570295872499, 0.9116623127405977, 0.9162565360443742, 0.9140310670986306, 0.9082706710787677, 0.9098188463432516, 0.9163275443691139, 0.9125654982840824, 0.8154188139148765, 0.8181846578797751, 0.8129024990862483, 0.8162116210748421, 0.8217748933283006, 0.8264789873580446, 0.8271052398568635, 0.8185849888458889, 0.8206472349807191, 0.149157917562181, 0.13886833721688996, 0.1520650454245175, 0.13135787720200787, 0.12046459503853568, 0.14102862934098903, 0.14252968285091705, 0.16042990142272107, 0.17179292971260562, 0.17681108111098642, 0.12810964468880082, 0.10774559268848183, 0.11602920857210086, 0.12232601685011524, 0.13761569892274406, 0.10622459778811266, 0.15219418869046908, 0.16575034819676016, 0.9863793138826141, 0.9698508884241533, 0.9797285870846788, 0.9760424900688117, 0.9797706858978561, 0.972934134908421, 0.9812229682451877, 0.9877352064956213, 0.9411344611935587, 0.7474645644659006, 0.7423745726873363, 0.7681753657610011, 0.7487689679263057, 0.7745137280823648, 0.7761571157184921, 0.7686520904009738, 0.7721071509671129, 0.7680092801522195, 0.9074420627605531, 0.8974508496533554, 0.9021101507750798, 0.8976189709586943, 0.9163969589784555, 0.9092840850619355, 0.9297836056661765, 0.9181400380025415, 0.8963210439680839, 0.6365844292252778, 0.12800901651638996, 0.8003367805936652, 0.656595771847021, 0.6956935076269806, 0.13301065427540326, 0.7038804703148283, 0.6699637329005191, 0.7593138560837488, 0.7191230849604752, 0.6879169902531925, 0.7188847543572507, 0.699584696386222, 0.7581432930905935, 0.7178477327263506, 0.7529745650029096, 0.7980985431789331, 0.685211529454247, 0.7039329989094036, 0.7212096497535785, 0.6318709996918811, 0.6964595899700613, 0.6756914786187522, 0.5281301910365366, 0.6917473219615916, 0.6643501429740676, 0.7086253550104307, 0.7757596665733494, 0.7451990568170777, 0.7571530618712008, 0.7446786065065938, 0.742293118674555, 0.7384362121570252, 0.7897845556872218, 0.7634192740794796, 0.7954997005699973, 0.4492687326040975, 0.10514576947166421, 0.22754497647140015, 0.5166753035263117, 0.5962710147500497, 0.6674918480634393, 0.23840446041941443, 0.23083132285967123, 0.372700982613666, 0.6570884053349362, 0.6468744331182141, 0.6375244042995731, 0.6568568617706669, 0.6179041779941397, 0.6538726073045443, 0.632405930653594, 0.6227352719906347, 0.6463800337906389, 0.8367171776892911, 0.862234150052124, 0.8597801449907415, 0.863166489276033, 0.8554598656624774, 0.8335525936310244, 0.8742570979930363, 0.8471997422508112, 0.8689656328800879, 0.13970259576376065, 0.13583789546614644, 0.12718929893739928, 0.14677642132860602, 0.1430385979827632, 0.12929525368403705, 0.11566494903153202, 0.11557379795240008, 0.15296918767624046, 0.24502793207866247, 0.14975365714410438, 0.2392181361546315, 0.6412337367941814, 0.21923635774940387, 0.4954307977222524, 0.5031789587958018, 0.2191506606384238, 0.18944556322607065, 0.6904016282555416, 0.6557350042219965, 0.7313072919720349, 0.7318157831076753, 0.6075531938145629, 0.6262130707768574, 0.5913763149620626, 0.568311765105991, 0.739651935055907, 0.34522800979144996, 0.5240119875899418, 0.46114436288592386, 0.5848777023425106, 0.6356627554594418, 0.6278116660247872, 0.6400446816130176, 0.651777650770904, 0.6656752852518194, 0.21591856609792137, 0.211292977883346, 0.2427719508584839, 0.19840947131405662, 0.20800325581955148, 0.21272027794246617, 0.22483518021827964, 0.20842264155850532, 0.27068041192328707, 0.20840697551900134, 0.24952957591030167, 0.19743138563490903, 0.2420978219139377, 0.2054829550695737, 0.21754098049815718, 0.19501406567955681, 0.789953089330877, 0.19339950887032908, 0.9264749031366357, 0.18590795715505215, 0.15408463271532746, 0.9280446109805222, 0.1989980403378142, 0.9169336276625722, 0.1876666259705495, 0.19325275857057, 0.21114671682738673, 0.9192869772563537, 0.2126263623296395, 0.8948131622541274, 0.8819613812689291, 0.1545757236510239, 0.8746658818639385, 0.16672133533975664, 0.8929410895482917, 0.8894540098343462, 0.1968266479559413, 0.17507711648726998, 0.19424532795219907, 0.19014703943618816, 0.18061884194501976, 0.18009985242735782, 0.19300142352878213, 0.1857598033578256, 0.19344990119652516, 0.08694327525083934, 0.08972897482335396, 0.09793661887793315, 0.10305732579740035, 0.09069349285632489, 0.08771664959189529, 0.08192891524074697, 0.09382120024983509, 0.09138637711777087]}, "mutation_prompt": null}
{"id": "4dda8517-c7d7-4abf-820a-b97f647f716c", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_rand_2,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.exploration_probability = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evaluations < self.budget and np.random.rand() < self.exploration_probability:\n                    random_candidate = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    random_fitness = func(random_candidate)\n                    evaluations += 1\n                    if random_fitness < best_fitness:\n                        best_individual = random_candidate\n                        best_fitness = random_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_rand_2(self, population, best_individual, target_idx, fitness):\n        a, b, c, d = population[np.random.choice(self.population_size, 4, replace=False)]\n        mutant = a + self.F * (b - c + c - d)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05 + np.random.rand() * 0.1\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Stochastic Local Search and Dynamic Strategy Selection for Diverse Exploration and Efficient Exploitation.", "configspace": "", "generation": 5, "fitness": 0.31021662142357087, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.7562056073823594, 0.7508472950131606, 0.7456795521253633, 0.7332108113359908, 0.7330719794460331, 0.752522848230489, 0.7499962088028591, 0.7604882649727669, 0.7375937336174255, 0.5088788462136882, 0.5477070222402303, 0.5630712818726721, 0.5053742693961792, 0.5334103361694142, 0.5272266131892462, 0.5142735081985443, 0.5873518887890035, 0.4856552196694466, 0.11533077174891038, 0.10915964386770194, 0.09845118703966005, 0.10896493225360082, 0.09331252899038867, 0.10829776593439255, 0.09626793324286498, 0.11300625796704244, 0.11333857036372941, 0.08789219957494243, 0.08704336655955935, 0.08178451637957518, 0.09028836796952133, 0.08777507501069781, 0.10538201658923152, 0.10239372460544527, 0.09210534466161768, 0.08284667589231298, 0.6765539982757233, 0.8032612007290598, 0.9453085794124766, 0.8203848176916058, 0.8036930852765548, 0.5957082393989697, 0.6951875027485346, 0.7861415783091366, 0.8033481707816367, 0.38090559049665107, 0.3717215960190132, 0.32844699875513006, 0.36364859805285266, 0.3710725911957994, 0.426033433469201, 0.3608775431941431, 0.3651233839653152, 0.4369540874825414, 0.7071629309308829, 0.7322214429032299, 0.7169628284581138, 0.7558673711954503, 0.708827303768061, 0.714302591954187, 0.7232658323911707, 0.7156833136737308, 0.7001408131734136, 0.20626634961054902, 0.17084551789423674, 0.15395994455068596, 0.19117785269643472, 0.16729435445973817, 0.14929023098908023, 0.1653528597545212, 0.18295604782162844, 0.20921256761249385, 0.17267868413161325, 0.1675419986216501, 0.19554134237997145, 0.1400624216497519, 0.14083350999435584, 0.22964382530228478, 0.20508917704900886, 0.18153463525350677, 0.16215349006683377, 0.2993412428809643, 0.2587085417035635, 0.23833396574105814, 0.2291974394110854, 0.24654531669035407, 0.29172672959556745, 0.257603897480716, 0.26532501655420415, 0.2601954759416528, 0.4096647114233777, 0.369148912110152, 0.39032054519060466, 0.331190592063641, 0.18604935234129105, 0.09161170382951245, 0.44911549808754214, 0.40195898483116677, 0.4078185652643753, 0.07034574019409612, 0.1194935952546814, 0.1185027353112007, 0.12091560717242045, 0.08777928448984518, 0.13721753024538708, 0.11237203906702142, 0.10363024976043311, 0.07467956935854492, 0.26662755508997715, 0.24694496661374565, 0.23384282094951458, 0.25199589115198695, 0.26821675447427507, 0.273580291199646, 0.25193936715250154, 0.2441346690771733, 0.27436213657508557, 0.6218745450506893, 0.6292422438778541, 0.6521069858687595, 0.627649885404563, 0.6029547291916084, 0.6177937173078958, 0.6066677068634767, 0.6485264874296051, 0.6385972165863244, 0.09352973880942517, 0.10660690784322036, 0.09570580700472586, 0.08850766373333552, 0.09540725802435501, 0.12140694464958723, 0.10857823550148937, 0.08817397806809202, 0.11797750262345474, 0.13974760094753125, 0.13188557526537792, 0.1348877584815038, 0.14580664514141395, 0.18647193368821835, 0.1583315262069911, 0.13610997945883752, 0.12785501235471697, 0.13788703259238133, 0.3759933937529638, 0.34294340934329415, 0.3712364574606605, 0.3603342416539572, 0.3485079141464694, 0.35594384084005715, 0.3808623659618835, 0.36675083820182164, 0.3935892090816272, 0.28241059365931775, 0.2532478936314445, 0.29217768357470475, 0.2824324314457154, 0.2924713148443039, 0.28164593277271577, 0.30390906172481913, 0.28247607759345783, 0.30774449517592484, 0.18673121822602157, 0.17341102470370007, 0.1918588264014699, 0.17954625737503738, 0.18776699720842915, 0.22434118986678597, 0.19459717701210155, 0.17603584006037165, 0.20956003351255814, 0.17328697414346939, 0.18747498913964455, 0.1774451386387369, 0.17493415677583257, 0.17802463912744992, 0.17669483960876353, 0.17128585219039283, 0.17582335566012586, 0.1730073415344885, 0.2037019794761198, 0.19283735381519074, 0.16628619048123983, 0.7185618963985085, 0.18634624584889892, 0.6515811297574243, 0.5092913629176654, 0.4809234396391341, 0.6487477323308315, 0.19721624082940192, 0.20349580143059542, 0.1866637873983108, 0.24022001085928857, 0.19610368701454317, 0.26954143184105395, 0.18447845620512038, 0.21040891151111696, 0.19902080647520104, 0.18762405913657865, 0.186143273225849, 0.19045007235481048, 0.1807374702907777, 0.18513274945759084, 0.20814225120393004, 0.18370148909479322, 0.1809318644414225, 0.17807533207112303, 0.08540198444502944, 0.0788241235733611, 0.08313697486047511, 0.07728492716734636, 0.08047599572030872, 0.07873875954451726, 0.08425252800106009, 0.07886826658787272, 0.07976432492350727]}, "mutation_prompt": null}
{"id": "573d8ace-a79f-4b65-8c32-2db1effeb8b4", "solution": "import numpy as np\n\nclass AdaptiveDualPopDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.global_exploration_probability = 0.05\n\n    def __call__(self, func):\n        primary_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        secondary_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        primary_fitness = np.array([func(ind) for ind in primary_pop])\n        secondary_fitness = np.array([func(ind) for ind in secondary_pop])\n        \n        best_idx = np.argmin(primary_fitness)\n        best_individual = primary_pop[best_idx].copy()\n        best_fitness = primary_fitness[best_idx]\n        evaluations = 2 * self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(primary_pop, best_individual, i, primary_fitness)\n                trial = self.crossover(primary_pop[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < primary_fitness[i]:\n                    primary_pop[i] = trial\n                    primary_fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        primary_pop[i] = local_candidate\n                        primary_fitness[i] = local_fitness\n\n                if np.random.rand() < self.global_exploration_probability:\n                    global_candidate, global_fitness = self.global_exploration(secondary_pop, func)\n                    evaluations += self.population_size\n                    if global_fitness < best_fitness:\n                        best_individual = global_candidate\n                        best_fitness = global_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def global_exploration(self, population, func):\n        exploration_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        exploration_fitness = np.array([func(ind) for ind in exploration_pop])\n        best_idx = np.argmin(exploration_fitness)\n        return exploration_pop[best_idx].copy(), exploration_fitness[best_idx]", "name": "AdaptiveDualPopDE", "description": "Adaptive Differential Evolution with Dual-Population Strategy and Oscillating Search Dynamics for Enhanced Global Exploration.", "configspace": "", "generation": 6, "fitness": 0.3420662094726015, "feedback": "The algorithm AdaptiveDualPopDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.7904121387539604, 0.7361181783799358, 0.754065641673083, 0.7985549250720484, 0.7256792819839062, 0.7554018756682228, 0.8171848607734337, 0.7494270930898259, 0.7250060523142099, 0.5705495133656087, 0.5067492534718764, 0.5085491651915983, 0.6080135377656544, 0.5107522108977537, 0.4849780652059771, 0.5680086152117323, 0.5135681157589953, 0.4964061726055804, 0.1349110844960898, 0.11392176619847283, 0.11903817589698407, 0.1256352900949056, 0.0889777164061728, 0.1200617213408619, 0.10207485109014902, 0.11395152785091034, 0.1100559646441368, 0.08143107568900432, 0.08647154104032873, 0.09224683358355124, 0.1283057249810099, 0.09165289127340526, 0.09906079976789517, 0.09289762927015821, 0.07411720717449521, 0.09904881015715694, 0.9677899189034421, 0.9330364018090983, 0.939283129745845, 0.9572003324398538, 0.8778324338323715, 0.9137618439907981, 0.9852233698251932, 0.9857545080010495, 0.9705125053460366, 0.37565697851326874, 0.37335944058187676, 0.3546427844198543, 0.40864864071687, 0.35813549349746565, 0.3820945995270678, 0.42694825237551415, 0.37057548320690925, 0.3811517477526415, 0.7978082389130903, 0.6679587508581688, 0.6901993106056701, 0.8166578686522693, 0.7172290367983742, 0.2675538488102688, 0.7968926364177144, 0.7140048221825072, 0.7481941698859557, 0.2218258267648212, 0.2744670438339897, 0.2153034445831966, 0.2980090430083333, 0.2921815385765816, 0.2537552202125919, 0.2340221440906214, 0.2372073800809853, 0.2090973329251974, 0.2979640507981921, 0.24576341139200153, 0.1506528040414623, 0.252437036894391, 0.22399253226237836, 0.2906434822766668, 0.23390320867477143, 0.32542151964576627, 0.16569164702607087, 0.27443143902910194, 0.16054373702246683, 0.2087519447125924, 0.20778757036021211, 0.2062582583110143, 0.2584449101848908, 0.26501748348762, 0.24202038817439175, 0.21570624997203902, 0.41927114741692306, 0.37658053201759223, 0.3723340471148, 0.18866611124046218, 0.32421693056085166, 0.3537036077153669, 0.45497432207336685, 0.28666917780297896, 0.43017277701200596, 0.14031227375425592, 0.10725978502951872, 0.05209925445839869, 0.17111128983926915, 0.2026025701972799, 0.20835308700347255, 0.25724553940992156, 0.14195605024642022, 0.09132019087105236, 0.2610360639590269, 0.2369242717145258, 0.2796452753794403, 0.31482654369540763, 0.23121364442630887, 0.27045563959352126, 0.26523090658033277, 0.24484017283027693, 0.2495718229847027, 0.6989288875290957, 0.618893061620085, 0.6217809154862924, 0.6649370482070164, 0.6068058729138215, 0.6273106368694927, 0.6405371505607771, 0.5778425156630953, 0.6465935022400894, 0.11203333351920863, 0.09155543280918044, 0.09077165075360571, 0.09917410748710642, 0.07969650774084369, 0.0983569259789494, 0.11606146980705978, 0.10283418488759599, 0.08166049411578225, 0.13030264752664478, 0.2551524165601048, 0.14955512897458778, 0.147992886985033, 0.1511208459557396, 0.18925921573604143, 0.1485522911657572, 0.1304614321960591, 0.1378926974411706, 0.4140378350706766, 0.3497175961078556, 0.4004576947349199, 0.39002703186746746, 0.3677482130151616, 0.37040766381249945, 0.42334202963764156, 0.4107655734346324, 0.38431037678186664, 0.27635629273626694, 0.27036375979842575, 0.2963880211019654, 0.3145693026961659, 0.21414195454730645, 0.2917440077059016, 0.3829225931732122, 0.31634035010894057, 0.27623291655986526, 0.20102531283621106, 0.1795090817020304, 0.18985661854845426, 0.20682280936281294, 0.19183581834969698, 0.2041877777228045, 0.1997792519084608, 0.18724265207506097, 0.181243120116644, 0.18358547344301368, 0.17940021937355755, 0.17553348968925253, 0.22495527030193385, 0.21119895772599195, 0.18653180904681999, 0.18996360015308467, 0.17990038345613735, 0.21123947800018938, 0.19523428096272077, 0.17838521256488782, 0.1869662040844311, 0.8272659869154106, 0.18448643604820691, 0.7625619359868528, 0.18642747212538024, 0.6019903727853291, 0.38814224612175874, 0.7900235523080905, 0.23701476435899227, 0.2068126206624048, 0.6469284666323749, 0.6478029380106405, 0.7128521442871978, 0.7154342529393314, 0.6227701164828607, 0.7036796998790833, 0.17927134451895121, 0.17972914501191006, 0.18609037162756303, 0.17869310051623366, 0.19192958624016077, 0.18751887710965087, 0.19313479673938827, 0.18787414472269515, 0.16960739772836642, 0.08962583584563566, 0.07819575409825064, 0.0857459136235752, 0.08498693917809286, 0.07232824780331282, 0.07516400024767045, 0.08298227196250496, 0.07304488254056973, 0.08056679696018543]}, "mutation_prompt": null}
{"id": "04e51624-8349-4d9c-903b-011d82dd8038", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_factor = 0.8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.adaptive_factor * self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05 * np.random.uniform(0.9, 1.1)\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Diverse Mutation Strategies and Adaptive Local Search for Improved Convergence.", "configspace": "", "generation": 7, "fitness": 0.5170539934518698, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.32.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9261676004908391, 0.9229054624872316, 0.9250282783167156, 0.9181028428592503, 0.9244893766201933, 0.924326358224708, 0.9183487624238778, 0.9189828232290181, 0.922820972205737, 0.8112663468369281, 0.8453849800305149, 0.8456977864976057, 0.830808250222645, 0.8352455485309698, 0.8468137243760563, 0.8130609844093762, 0.8502776222966316, 0.8408681095600304, 0.15578148260432167, 0.15820920622801604, 0.15404046793342807, 0.1305367008168229, 0.1366346663194863, 0.179904108238767, 0.1465046109943925, 0.1690129556481923, 0.1384673821107263, 0.13932634799421884, 0.1281785977174682, 0.13388597282110115, 0.14083374164211437, 0.09358659731711827, 0.1064116552744605, 0.12276123932052652, 0.13860449706339295, 0.11474861059811536, 0.9864014410853714, 0.9913711903573187, 0.9813310004057934, 0.969138790792565, 0.9746640713963469, 0.9768523683127782, 0.9739347916441181, 0.9643840024775426, 0.9869516033009561, 0.7919789752021396, 0.786845602972886, 0.7715695551547117, 0.8023703586052116, 0.7906138503509211, 0.8026782891376929, 0.7783343617304486, 0.8060371199367152, 0.7783890369156247, 0.9178860913089206, 0.9151658048095481, 0.8979677638554899, 0.9333352553930515, 0.21406239162599805, 0.9089228096244514, 0.15050011046435097, 0.9262738440502934, 0.9064109444780607, 0.7486187408093827, 0.6571750428954235, 0.7005862405374906, 0.13460009185682298, 0.13463685051858576, 0.6941532136953441, 0.7063066782301208, 0.676007239809046, 0.7555055312813858, 0.7343957554385296, 0.769679674273952, 0.13120409713078063, 0.7224881997500517, 0.13560930760414736, 0.1331076954815621, 0.7312548320473261, 0.6844220637886108, 0.7455550674076485, 0.700216762489994, 0.7520370590898398, 0.4194606079761489, 0.7552195746617247, 0.7322934213264478, 0.6326726272150702, 0.5912249667805785, 0.7638462659959417, 0.766991999098527, 0.7882041724543799, 0.7221087979495695, 0.795091663592837, 0.7989923582017426, 0.7685438225906367, 0.7446499204150772, 0.7818465427654491, 0.7605554764713228, 0.7912502199932268, 0.13394676428598284, 0.13849451493913822, 0.21310066194362132, 0.7249737787005344, 0.5936885907221765, 0.41710878820521047, 0.18546397773937773, 0.2686289863040935, 0.2619355902736479, 0.6766862401997344, 0.7010136271565641, 0.6910028532896157, 0.6783817181854694, 0.710933554092153, 0.7064222235673931, 0.68838481486108, 0.6039745614551442, 0.6856091251358776, 0.8845933148001374, 0.8829009877816025, 0.8794050939354281, 0.8829060081788395, 0.874624510877363, 0.8740255634145505, 0.8884471731692615, 0.875555087556577, 0.8554145005404455, 0.16246983221366396, 0.6628262864591148, 0.6356706848469644, 0.12921786168219784, 0.114483828021406, 0.162131082293824, 0.15536080387898432, 0.14451106201683328, 0.15516284990493712, 0.23253061613346937, 0.3148774373313781, 0.22567097035941353, 0.2584869983173935, 0.2019249006560403, 0.5195296350655371, 0.501024541277938, 0.2413725335932566, 0.3551373191744176, 0.3150768381305248, 0.7304480146707546, 0.45367265747045626, 0.5425632234770346, 0.5787047210757529, 0.747139859501811, 0.7396431017736341, 0.7564971136257107, 0.7799725398025406, 0.542645190953052, 0.2459726217591035, 0.65233145292156, 0.5872290639860793, 0.5909096910882162, 0.566238968315288, 0.42675823497199483, 0.3756551707576057, 0.23256743370684752, 0.2244900543721915, 0.21830253677500788, 0.21592967555022335, 0.21537582902209873, 0.2164225181857441, 0.23938417387116884, 0.24950193532065168, 0.20854443875695916, 0.20811889721640842, 0.22021665781902477, 0.20516046212265127, 0.2456447119838031, 0.23929387706927852, 0.25279101143393945, 0.23999536807918864, 0.21691493162004416, 0.1928491290263562, 0.24328345849224575, 0.935628285422225, 0.18242509923927952, 0.20009682876356072, 0.9337569938366213, 0.20077184662962888, 0.9135097257510468, 0.914501936032661, 0.15757524605145756, 0.9074944593457777, 0.9263525350416328, 0.21164769670417916, 0.07351762983368915, 0.20968421605843546, 0.8685232019003846, 0.15642845082371226, 0.10449651006479399, 0.21311476188244005, 0.8810024885132528, 0.20769719160422784, 0.2097233461266903, 0.19423087903876135, 0.1889128879150499, 0.18604740835455624, 0.18610821173344128, 0.18444179244850634, 0.19628651213642323, 0.18154678974514882, 0.09349921044033871, 0.09133536716537272, 0.09673406388968775, 0.10110666796579604, 0.08792769825963354, 0.08971825628051011, 0.0921105074717552, 0.0882716977163478, 0.0982700888990683]}, "mutation_prompt": null}
{"id": "d1b160dc-144e-4c0a-8280-725d912205ff", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Focused Local Search utilizing adaptive control parameters for improved diversity and convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9140144154502393, 0.9119945627520508, 0.9190897798008978, 0.91183608256894, 0.9099934843631299, 0.9170534853354243, 0.9144412295593287, 0.9106313387873125, 0.9183457873814755, 0.8221626814309245, 0.8316930638134689, 0.8365665558815685, 0.8139602453560706, 0.8441850165993527, 0.8435791257361398, 0.8216000793522638, 0.8366230790128206, 0.8315703592206858, 0.1562727598276772, 0.14853521215746512, 0.7340107814974344, 0.14199049984727685, 0.14040341417125912, 0.16343319872473805, 0.6416542947348762, 0.6205713229662903, 0.16531922607957472, 0.09653114009140318, 0.16789997913852894, 0.11555527222978546, 0.10340409431363662, 0.13976484683428114, 0.14384919099629057, 0.14939723964673868, 0.13853316238002966, 0.09597173410495996, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9684145992849261, 0.982778729149947, 0.9814455014854574, 0.7776381566806911, 0.7828908197824755, 0.7550543795346965, 0.7732181081806159, 0.763257744689845, 0.7785925425382032, 0.7828390809602553, 0.7761960490465973, 0.7880837824622238, 0.8958033916382943, 0.9089728042682071, 0.897306932004205, 0.2145208953141453, 0.9130049917349844, 0.9314575641438199, 0.9002612365869824, 0.2357195542223418, 0.9140814483316259, 0.6781616392234586, 0.7726299154170521, 0.8068940348646947, 0.13324633689313592, 0.134355819322183, 0.6854868627750555, 0.745195073745869, 0.7202088041309084, 0.7792292110307495, 0.667501390394101, 0.6220390767462909, 0.7183443577686486, 0.6666393748830828, 0.7597416655786837, 0.13333059901630373, 0.6947526891011317, 0.6440665737267919, 0.7564843156506976, 0.7219214224772751, 0.6514505274762656, 0.7155630986916027, 0.7441276908358543, 0.6635837017339519, 0.7354536157778895, 0.7335376239155936, 0.74416335160023, 0.7491947838751403, 0.8061174202538456, 0.7316088143875581, 0.7977572964550663, 0.7910263146637371, 0.7367622475231217, 0.7478701709662106, 0.819438022203814, 0.7958346688938099, 0.7758375258608818, 0.13953901005808278, 0.41679023782137936, 0.41970464690819653, 0.6920357331712953, 0.5771305562688457, 0.687832112587665, 0.37964541152330467, 0.17165850458485, 0.5275795294822287, 0.6798264233208281, 0.6892116525851382, 0.6573733914798237, 0.6796207240332753, 0.6835486752364, 0.6970572349782318, 0.6922451272010304, 0.6272253932222868, 0.6929565048480276, 0.8683845120612302, 0.8773353364383439, 0.8724317324197234, 0.8809029147480993, 0.8581481885015517, 0.8717744887032091, 0.8842012076373399, 0.86620319181741, 0.8543622787443149, 0.12238264936782417, 0.14714334456592282, 0.1438696125110024, 0.13996881123243365, 0.1185265250328914, 0.13324793815450153, 0.14796879484122505, 0.13149817737367697, 0.15354236766925, 0.22990443200647304, 0.335978142190701, 0.1971971087634724, 0.162314913063221, 0.695926281761061, 0.5628428692033431, 0.23275657014774553, 0.6374158975692874, 0.24721856617943228, 0.5425800441545645, 0.7482068137379894, 0.6170853051641343, 0.43098491796878247, 0.7414060234855564, 0.7347877316763609, 0.765320416676722, 0.7630797596703737, 0.762833986794512, 0.46631438852842866, 0.5344988597271308, 0.6111024110812985, 0.2162061717008874, 0.2688146909484531, 0.6181713961831257, 0.5271851160036427, 0.4398717449440952, 0.5373403741754874, 0.24539544319278894, 0.2568477478723393, 0.2141368022837492, 0.20688236742043453, 0.2311096097381411, 0.23955853848662023, 0.2137511228769131, 0.21868464095996276, 0.20396547535479392, 0.1958789312097804, 0.2461788520395477, 0.751768827258565, 0.22200384076392898, 0.21948163331466575, 0.699331468324087, 0.77256451611345, 0.24361536253111593, 0.20639795745525802, 0.186250858665455, 0.1874245165090409, 0.2002637007321325, 0.9040752897558364, 0.20082548497785913, 0.9211038627629997, 0.14217891224175894, 0.15888704095767403, 0.9322662959038613, 0.9226289950752073, 0.8896422389634291, 0.9236763374448232, 0.889793682539842, 0.8395360074315519, 0.9079968794431068, 0.8787830581909154, 0.8861041768593099, 0.9129953020899249, 0.18818618486047356, 0.1949737938610021, 0.1896757515299451, 0.21042919713744734, 0.18015268360911052, 0.2157964078665613, 0.20505536545627634, 0.18906603526188015, 0.18671831382675286, 0.09228323923882598, 0.08589067829090602, 0.07724837419405195, 0.09146151137325209, 0.09542196917319157, 0.109119862695636, 0.09675473094404097, 0.10080113136245616, 0.08834698828339826]}, "mutation_prompt": null}
{"id": "5e902f46-4fd8-4e04-afaf-9b358d4fb1bf", "solution": "import numpy as np\n\nclass StochasticParamEnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F_min, self.F_max = 0.4, 0.9\n        self.CR_min, self.CR_max = 0.6, 1.0\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            F = np.random.uniform(self.F_min, self.F_max)\n            CR = np.random.uniform(self.CR_min, self.CR_max)\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness, F)\n                trial = self.crossover(population[i], mutant, CR)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness, F):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness, F):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness, F):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + F * (p_best - population[target_idx]) + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "StochasticParamEnhancedCoDE", "description": "StochasticParamEnhancedCoDE uses stochastic parameter adaptation in Differential Evolution with local search for robust and diverse convergence.", "configspace": "", "generation": 9, "fitness": 0.4227077050687398, "feedback": "The algorithm StochasticParamEnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8558918925327655, 0.8525478701629641, 0.8671045262621688, 0.8662161875922798, 0.8507213021776472, 0.8625245942964863, 0.8682123093764673, 0.8674908236760029, 0.8637294442333865, 0.7416882468807731, 0.7416466057794097, 0.7088609318949852, 0.718740620451228, 0.7251407586697414, 0.7567488099473741, 0.7207889256646169, 0.7320896470152964, 0.7527900979168556, 0.30600675399998756, 0.21327393137139794, 0.15110704741881653, 0.1484851048673299, 0.11278569369249403, 0.11471497528445052, 0.13357813356651516, 0.34580978737741663, 0.13496856021009462, 0.13362668953728918, 0.14520606106824396, 0.11113337230706255, 0.1166152907059933, 0.11383979497388952, 0.1297204675517003, 0.13256558860471013, 0.13169622471728926, 0.11516027189158196, 0.9754566212615603, 0.9839895219831357, 0.9850244647056905, 0.9818267306845035, 0.97796557957965, 0.9701084661788609, 0.9577786583556152, 0.968972245851286, 0.9548923315219847, 0.5673213496021449, 0.561449019574558, 0.5701102755081052, 0.5935990666898292, 0.5588201959200345, 0.6086708984685314, 0.6076093886654599, 0.5753602224562435, 0.6193665453080582, 0.7929114911064099, 0.7616692339901608, 0.798375265735755, 0.8078717093359026, 0.8047238330258132, 0.8240095313744471, 0.7863096123473496, 0.8179741830123691, 0.8613701972222104, 0.5442756405880897, 0.12495776522756841, 0.6049484252862702, 0.12858830966696821, 0.4884371682659152, 0.5608435585978506, 0.5325526815574331, 0.43180671537788307, 0.5726256309116147, 0.4897044284582781, 0.5019100268023229, 0.5198932694721553, 0.47448109666812477, 0.5799152903306132, 0.6171622110561732, 0.4624838141272358, 0.4390687228337464, 0.5495907797756143, 0.3024131828418528, 0.2176093708999145, 0.3367320781736768, 0.26826416766543215, 0.2718386103821494, 0.4235987028703144, 0.375231386344984, 0.2745066658957971, 0.39133905204330477, 0.39512537666889636, 0.42653995577363035, 0.5224608777267141, 0.37436341411666785, 0.4494833961505724, 0.49189715221689845, 0.43279823068174894, 0.46685369026757906, 0.523954860366584, 0.11165504661288783, 0.1060753660578585, 0.2541868868766918, 0.2844677689312781, 0.3488641359124729, 0.2636765198814801, 0.11318290992292424, 0.21857876701870682, 0.18946409351248628, 0.33381943923368995, 0.3614905431757416, 0.3767227231334338, 0.36498346504777257, 0.3589597501747067, 0.41442163891460904, 0.31232586298801057, 0.3049212072967915, 0.3913876745800249, 0.7294059155852546, 0.724397369595083, 0.7635191364504123, 0.7643476936370874, 0.7414544447627633, 0.7757716949506984, 0.7583730503805985, 0.7494991035013541, 0.7707882701730171, 0.10907715981428723, 0.10597218570679834, 0.1177823611681682, 0.10541700442787427, 0.09682104960366089, 0.12014193020055342, 0.11665294763309009, 0.11494123220459862, 0.10021518417186093, 0.1450242810276352, 0.1438718433391346, 0.16043586335146698, 0.2541881810051002, 0.14043180163360047, 0.15632652151257775, 0.15342201869332717, 0.47714755266457676, 0.13646270752544698, 0.454321156820358, 0.46976388733611407, 0.46171919121177984, 0.4618629779546264, 0.4344968566846549, 0.4918566184895472, 0.5284477847656888, 0.5220556736883881, 0.5666104349553508, 0.3643038966748019, 0.3230615352983014, 0.39326775263126035, 0.3606561125401583, 0.3195463564605051, 0.33801792804229036, 0.41874342503688833, 0.402183912639668, 0.4139416787047012, 0.20931739720980003, 0.19705033005910622, 0.1916310189299073, 0.2193096930929449, 0.22994446791212841, 0.1862910366617393, 0.20876949992127158, 0.23404976166181224, 0.21908770544125167, 0.21427137205911884, 0.5283189749000579, 0.2985093849055793, 0.2065292047987921, 0.4043847665981082, 0.2321162438562211, 0.315778688225825, 0.20010096426597224, 0.21188511607574279, 0.18330396830746565, 0.8254579823140353, 0.18212913399331898, 0.777543172667074, 0.19386540334749558, 0.19810609733322793, 0.6567996140339283, 0.1674066215012917, 0.8363163736258149, 0.8013176398495644, 0.21047843118287968, 0.20674529326164148, 0.6999080327405838, 0.708645917722768, 0.15221767456784785, 0.21117476120168033, 0.21081329647909153, 0.7404848162599253, 0.18629384680922523, 0.2171888183264833, 0.18248398280999134, 0.19400033809873085, 0.18005492723805128, 0.18643083873113364, 0.19212223747216794, 0.18311954735373714, 0.1875160492868212, 0.08608007687819663, 0.08296463218298955, 0.09565410233078253, 0.0885395292461939, 0.07879259483904077, 0.08536510920767848, 0.0819096285411639, 0.08121223554899681, 0.09412676982176071]}, "mutation_prompt": null}
{"id": "c4374013-b28a-4aaa-81a8-3ad940ef032c", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = self.select_mutation_strategy(fitness)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def select_mutation_strategy(self, fitness):\n        diversity = np.std(fitness)\n        if diversity < 0.1:\n            return self.mutation_best_1\n        else:\n            return np.random.choice(self.mutation_strategies)\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Modified Enhanced CoDE with adaptive mutation strategy selection utilizing fitness diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.5484274842619317, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.31.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9335217617218529, 0.9275233179774911, 0.9365604174744175, 0.9247239627818249, 0.9312906116473156, 0.9310765671108592, 0.9351402392008275, 0.9311577546357193, 0.9346400722372464, 0.838947731321107, 0.8530516101546769, 0.8601328907656475, 0.8355902984572193, 0.8639638869452877, 0.8634489909889562, 0.8381322598082236, 0.8541494255472619, 0.849786720869462, 0.15627398865194175, 0.14853698274356153, 0.7518876640646379, 0.1419919472900889, 0.14040459429021834, 0.1634345605483084, 0.6550508285568015, 0.6327748177665995, 0.16532092765949602, 0.09653098389608983, 0.1679016719934534, 0.11555555179921195, 0.10340590340221567, 0.13976501861723667, 0.14384901937253614, 0.1493984603791889, 0.13853374931274376, 0.09597177996979667, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9684145992849261, 0.982778729149947, 0.9814455014854574, 0.8101154541867704, 0.8021884430977785, 0.762293694807423, 0.7919260031698974, 0.7899230123456246, 0.8022705373803073, 0.8069139735800496, 0.7992805832201006, 0.8039455619668431, 0.901021714109337, 0.9089728042682071, 0.9137011050869356, 0.2145208953141453, 0.9213146986473516, 0.9306178462417105, 0.903839090915994, 0.2357195542223418, 0.9191019858578195, 0.7289055447056975, 0.7957073354378754, 0.8263754428241862, 0.1332468664075639, 0.1343637748754658, 0.7455963212007917, 0.8092619096268205, 0.7434219632073666, 0.8076442920099567, 0.7288741096990132, 0.6213884105787986, 0.7495868836098558, 0.725495294781658, 0.8032513191996518, 0.1333383889305103, 0.7548500084662604, 0.7230479908088456, 0.7883445269111888, 0.7560132153647868, 0.6641961841261088, 0.7466599496401758, 0.7646641205958077, 0.6825279801844566, 0.7408448604214113, 0.7508665994727666, 0.7619414386755049, 0.7695402511694873, 0.8140808368036357, 0.744226084166232, 0.8097879553187894, 0.7962675482267998, 0.7495561248066639, 0.7539544530950293, 0.8220732554954931, 0.8043767014193627, 0.7891430976554263, 0.15469497226985585, 0.4754312537654194, 0.4325697533690578, 0.7082174796360895, 0.6072946101991663, 0.7105866825459356, 0.46819974722355595, 0.21062061996785186, 0.5884632216768335, 0.5584303877473016, 0.5495312833637088, 0.5889056438198562, 0.6070626083538203, 0.7258192896417047, 0.7466276029173371, 0.5173836900784474, 0.6076912669908008, 0.5800302761605183, 0.8974891774753885, 0.9032672634690497, 0.9048842485818959, 0.8723296243475755, 0.7274921187786361, 0.8840084375421724, 0.8862591072344731, 0.8887975573750334, 0.8645258913471682, 0.12238439410184432, 0.14714907767130503, 0.1438679350679024, 0.1399689360346632, 0.1185268692724698, 0.13324803088448223, 0.14797303210804125, 0.13150273741331153, 0.15353943049429486, 0.22771507687371373, 0.32752225160670523, 0.19687131393134938, 0.16225430452701417, 0.7029894954308975, 0.5505795064870453, 0.23230794155329515, 0.6464294998900785, 0.24590109239457536, 0.46873129311780515, 0.31004517379830376, 0.35859459181096076, 0.43854742990930307, 0.5152533354675632, 0.45221703569539284, 0.6298883806869713, 0.3559507152538671, 0.5643991242242298, 0.3500449438804517, 0.5593343635167497, 0.4531615334142578, 0.21280163875144031, 0.2499898969576172, 0.38737632355477913, 0.37486042656194607, 0.4385843475580158, 0.4950141643099619, 0.24539544319278894, 0.2568477478723393, 0.2141368022837492, 0.20688236742043453, 0.2311096097381411, 0.23955853848662023, 0.2137511228769131, 0.21868464095996276, 0.20396547535479392, 0.19587995445313677, 0.24619115835309824, 0.775760164196511, 0.22200541394488438, 0.2194830889899132, 0.7179866406812139, 0.7858598062001119, 0.24361373925578123, 0.2063972807247384, 0.18625446703930237, 0.18742506949489435, 0.2002677143308047, 0.912997099454763, 0.2008284702617863, 0.9265794376599541, 0.14217918447671107, 0.15889009535038823, 0.9326064536179031, 0.9263292675894108, 0.8913859505068022, 0.9264308162563255, 0.892819817188129, 0.84616867738026, 0.9072945180108699, 0.883095440689768, 0.8987159011216866, 0.9169630842171077, 0.18818618486047356, 0.1949737938610021, 0.1896757515299451, 0.21042919713744734, 0.18015268360911052, 0.2157964078665613, 0.20505536545627634, 0.18906603526188015, 0.18671831382675286, 0.09228323923882598, 0.08589067829090602, 0.07724837419405195, 0.09146151137325209, 0.09542196917319157, 0.109119862695636, 0.09675473094404097, 0.10080113136245616, 0.08834698828339826]}, "mutation_prompt": null}
{"id": "dc57168f-adce-4447-a3c0-ace8fd762f3c", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.strategy_weights = np.array([1.0, 1.0, 1.0])\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies, p=self.strategy_weights/self.strategy_weights.sum())\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.strategy_weights[self.mutation_strategies.index(strategy)] += 0.1  # Reward successful strategy\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                else:\n                    self.strategy_weights[self.mutation_strategies.index(strategy)] *= 0.9  # Penalize unsuccessful strategy\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.reinforced_local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def reinforced_local_search(self, candidate, func):\n        local_step_size = 0.05\n        best_local_candidate = candidate\n        best_local_fitness = func(candidate)\n        for _ in range(5):  # Try multiple local search steps to reinforce exploration\n            neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n            neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = func(neighbors)\n            if local_fitness < best_local_fitness:\n                best_local_candidate = neighbors\n                best_local_fitness = local_fitness\n        return best_local_candidate, best_local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Adaptive Mutation Strategy Selection and Reinforced Local Search enhances exploration and exploitation balance for improved performance.", "configspace": "", "generation": 11, "fitness": 0.4781281107460693, "feedback": "The algorithm AdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9047166703944496, 0.8927700177685393, 0.8972694177479235, 0.9090445578090527, 0.8848028410140647, 0.8967505198023997, 0.9043615604889155, 0.9065040214659661, 0.9041022438594692, 0.7978043799422267, 0.7919612039987031, 0.7862667914931657, 0.7976008780041114, 0.7512509708312334, 0.790568491475109, 0.7584686796115819, 0.792115289335967, 0.7339904815882528, 0.10569430828762938, 0.13571447990296515, 0.12301137673379181, 0.12172860797212992, 0.13745425061492755, 0.1134218038647774, 0.08985603573564072, 0.11174316289545927, 0.64092689974889, 0.12162753171460061, 0.1116746375311144, 0.07814286006309445, 0.12490776460005404, 0.14295241390505564, 0.13390471763851297, 0.132892287478937, 0.10368900380418, 0.10274443488547746, 0.9762048936846739, 0.9731950785730303, 0.9754748826873884, 0.978443145621663, 0.9845766166610687, 0.9695492684522822, 0.9828113991381232, 0.979845755415618, 0.9696678133221156, 0.6861926384079069, 0.6851963219786038, 0.6596842490142006, 0.7173815484681887, 0.7027936496323398, 0.6884120955590678, 0.6794332838083634, 0.6853809136367756, 0.7092116851965553, 0.881413583307965, 0.8765050396091476, 0.8353431637694521, 0.9394762960720887, 0.8853062411566182, 0.8783394223290835, 0.23381983137312867, 0.23422636500384364, 0.1744833202725069, 0.7200702752530455, 0.49676540538599023, 0.6163834715961662, 0.6538710981939139, 0.6243661744256377, 0.5965834146092954, 0.13446986691697171, 0.6559859330108389, 0.6212003269078812, 0.7363215653114017, 0.6440771960741055, 0.6320691853428044, 0.7455944488260622, 0.6490946784471847, 0.7222988514085293, 0.6040991508162041, 0.6730287766319422, 0.668119372117661, 0.6573082278493645, 0.5404193281973227, 0.32883937992273304, 0.5091641334235333, 0.5860963526534092, 0.469424726009526, 0.6342313896974832, 0.5055394107331782, 0.5543063438860842, 0.7347304517712101, 0.6031790872436064, 0.679637153368138, 0.6810139645871294, 0.5093645826092126, 0.5716346725003205, 0.7168892107714255, 0.6544360764297863, 0.7139598681448345, 0.48922215855979656, 0.17905991589510106, 0.30834331630817113, 0.33737404552526284, 0.43704224855110074, 0.20604102994131213, 0.1507991458225515, 0.15399418107873075, 0.1650772927586388, 0.5491329491536889, 0.5503365361910539, 0.5658508670169213, 0.6196541465561445, 0.6306142497678777, 0.5426276764383595, 0.580026028888899, 0.5326201763637813, 0.5326831825309821, 0.8645635032530153, 0.8299147515054627, 0.828216574949048, 0.841808458921707, 0.8313721144981578, 0.8388243075586153, 0.8556955759542314, 0.8483981814788151, 0.8276863295101102, 0.12600316965518354, 0.12482017152620206, 0.14616175748003934, 0.11426073273150905, 0.13210704309230348, 0.1159312128101343, 0.16562182794309888, 0.13710912243537843, 0.14178887738135204, 0.1683384220167229, 0.32633998835079314, 0.22690525136044193, 0.17982570191770297, 0.40912656376931367, 0.16489361229739063, 0.5035007185502125, 0.19031488013925635, 0.23692782404763912, 0.6002280747457366, 0.4869720026048787, 0.6551522524404193, 0.5460961155297301, 0.6816139300109446, 0.6722098104258154, 0.7034905778832834, 0.631124833258891, 0.6220886119906273, 0.4511313125940496, 0.5059200020235028, 0.43652604100102355, 0.6046294835897508, 0.4487939746576085, 0.3280011975826356, 0.3073653733021847, 0.3041238004099338, 0.33574149708907974, 0.27043052329320494, 0.2252535483396072, 0.20325924253944216, 0.21629448945605523, 0.21326799251071693, 0.23072225241747202, 0.20831968385392785, 0.17881126448883755, 0.22082581804905377, 0.20375808030732567, 0.20084153540752336, 0.2131880317440611, 0.20542461518823663, 0.22130525496399278, 0.19561938050586347, 0.20919234632655992, 0.17850804615196902, 0.1955362526293576, 0.880105912591289, 0.18386911928082283, 0.18778770988787097, 0.9083520518584387, 0.19899034689173722, 0.8651126041478507, 0.9136205518343717, 0.9245814644101488, 0.16295341315864698, 0.8797325953224432, 0.21219709131717923, 0.8683006203085951, 0.2080087484379305, 0.2088786641346969, 0.16372560129902736, 0.210866582479745, 0.208947229055936, 0.15402508610408494, 0.18595106296502217, 0.2039451348784369, 0.18048149196171492, 0.20914292050707717, 0.1877248872971744, 0.18919745880790584, 0.1955900972355481, 0.19053141431909593, 0.20579781341578196, 0.11711045674115739, 0.09736537212200524, 0.09110033278946283, 0.09298864883521185, 0.08616285517901145, 0.0880950714912846, 0.09336023466671817, 0.09352896174953618, 0.08944159463840151]}, "mutation_prompt": null}
{"id": "a0f3de89-0f85-454f-ac7a-2c2ab0388036", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.05  # Slight change here\n        self.scaling_factor_adapt = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                self.F = np.random.normal(0.5, self.scaling_factor_adapt)  # Dynamic scaling factor\n                self.CR = np.random.rand()  # Randomized crossover rate\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Stochastic Adaptation Mechanism incorporating dynamic scaling factors and crossover rates to enhance global and local exploration capabilities.", "configspace": "", "generation": 12, "fitness": 0.41992272735710745, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8670389736814592, 0.8749500365987586, 0.8635523599093321, 0.8739240639924513, 0.8714963517943224, 0.866573637707184, 0.8657953600835634, 0.8731822836301821, 0.8694937474741824, 0.734457663457843, 0.7450442682251188, 0.7419513041763717, 0.7459398814607698, 0.764740204227077, 0.7439769235103852, 0.7487854679531312, 0.7601162665541441, 0.7650842069821078, 0.5181311569901974, 0.17145276648546826, 0.567644333768378, 0.5549327240895833, 0.5171566877504954, 0.48073020205677663, 0.5778278593540094, 0.5280187526130657, 0.5253763741549464, 0.1632552276083219, 0.16430697280286455, 0.16672392669897584, 0.16609337374801503, 0.17014548911989058, 0.40614935046304623, 0.1603890414287984, 0.17103031431287763, 0.40250543767011926, 0.9807418635751868, 0.9736676943531143, 0.9709123728026405, 0.9663251218102558, 0.9520323671200198, 0.9576632521962166, 0.9733517587727053, 0.96098572283521, 0.9718521746556983, 0.5814514184967046, 0.5847530119040285, 0.5915819930024644, 0.6049703798574217, 0.5865887496444402, 0.5915766169738088, 0.5139558638125684, 0.5436729311454054, 0.5405387128594357, 0.22609865827205444, 0.7876075553275689, 0.7982702641159758, 0.8065808492597442, 0.8649636820568374, 0.8341829773877596, 0.8290426710178516, 0.8223669681320476, 0.77504172688229, 0.4768047252695633, 0.33240537621212185, 0.44476723819297226, 0.12935046403210704, 0.5059899997547259, 0.346836482548733, 0.3431275396502187, 0.3686718764772038, 0.45113111922514004, 0.29025461912411, 0.361521064259427, 0.2762849962740046, 0.35259632168011656, 0.1286750771669536, 0.37253926048085373, 0.32033670308129136, 0.2456065221127487, 0.2803004189143298, 0.20953456092951794, 0.19919197538583655, 0.2685508086207351, 0.06910838244182183, 0.2544187546616299, 0.14299756718395762, 0.2539561092153836, 0.29421765438812586, 0.16627503618653716, 0.31208723328764076, 0.3184913139404384, 0.33285440137268296, 0.2558606269172048, 0.345844394576016, 0.21894421103608397, 0.38412671475302373, 0.35820332849589676, 0.3028954007443524, 0.12923417517548075, 0.056646607816249306, 0.081380456426702, 0.1513799829311263, 0.14623333754658963, 0.10870483399117525, 0.14725556911140048, 0.12874534896390033, 0.15524699480663562, 0.3048843417702265, 0.294522816255548, 0.28956819579495874, 0.33116004750822237, 0.3473706111019558, 0.3235176041952421, 0.2854917223221042, 0.28565393730997546, 0.28779319535733217, 0.6843554229046601, 0.749966377688319, 0.7320739909651877, 0.6873632776065548, 0.7227972003636408, 0.6460415406843019, 0.7487383796212357, 0.7199058838019585, 0.7215715054855494, 0.1238282281392914, 0.11382740523375867, 0.11715101231406111, 0.13666333668961284, 0.1192558952010675, 0.10584669911851374, 0.12760854721850157, 0.1397753833509312, 0.11544168062723525, 0.33943703614497744, 0.14404956035852934, 0.17324093505989258, 0.14758510307179273, 0.15643623600348489, 0.1443426065251735, 0.1356869359537184, 0.1660018744526629, 0.17639235985068846, 0.4842677278007521, 0.4772172698877073, 0.5367725149235567, 0.4387968951728828, 0.4834026247706512, 0.488537657654057, 0.5731600811747553, 0.5617874732332188, 0.520822693050665, 0.3126611069108308, 0.34591418384468564, 0.347396759985379, 0.311259945988827, 0.28686761750269196, 0.2775690862875394, 0.3709330814905165, 0.38308592531017716, 0.381246065636036, 0.21127723534207365, 0.23070095326954132, 0.20658728886672528, 0.2020881754900602, 0.21057172009091885, 0.21807754387127398, 0.198547520426676, 0.240633597920208, 0.20959121433235928, 0.22644136902563627, 0.20614234791842578, 0.4968794824919992, 0.5135873222166805, 0.5853119137846756, 0.6347327146661252, 0.5685062709336628, 0.20644002879966683, 0.232422414104561, 0.18194606785163192, 0.7658555358385821, 0.2002335518015107, 0.8482869625989095, 0.7927645476532629, 0.8314553004557641, 0.7638676735079523, 0.16692918374517052, 0.8339965731301177, 0.8018663572580175, 0.20827476604166817, 0.7287289266593135, 0.2070685931915741, 0.6726557254309391, 0.19747540939454356, 0.6535927770354473, 0.7646751186773495, 0.20279265578618022, 0.1854667831100778, 0.18811036933911374, 0.1864052029306411, 0.18473994705298946, 0.17195273389928567, 0.1956473921489087, 0.18785963368805103, 0.17877820329597782, 0.17571877388414958, 0.08975659775915079, 0.07160822147868662, 0.09559655040165327, 0.09397412763707802, 0.0899301870567979, 0.09205838641773367, 0.08734968330276405, 0.09416596098984098, 0.08780398229086417]}, "mutation_prompt": null}
{"id": "199318d1-040b-43e2-a651-f4913eae2402", "solution": "import numpy as np\n\nclass EnhancedCoDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.initial_population_size = self.population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.dynamic_local_search_factor = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n                        \n            self.local_search_probability *= self.dynamic_local_search_factor\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def adjust_population_size(self, evaluations):\n        reduction_factor = 1.0 - evaluations / self.budget\n        self.population_size = max(5, int(self.initial_population_size * reduction_factor))", "name": "EnhancedCoDEAdaptive", "description": "Enhanced CoDE with Adaptive Population Size and Dynamic Local Search Probability for Improved Performance.", "configspace": "", "generation": 13, "fitness": 0.5208728432328152, "feedback": "The algorithm EnhancedCoDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.32.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9219727572341554, 0.9239972742586091, 0.9223993907342722, 0.9234784924703486, 0.9174646817568212, 0.9214345509775352, 0.9168626132964861, 0.9196561982765767, 0.9161510968518038, 0.837990122011066, 0.8330795010019112, 0.8476298177603754, 0.8431417673647181, 0.8466622942356234, 0.8477365516159133, 0.8445735091924319, 0.8479205482255188, 0.8487975811245971, 0.13200682002336528, 0.149921878163514, 0.1746528905439707, 0.13773315935034258, 0.15565777061970443, 0.1455662457547311, 0.15118249014462215, 0.12716153146074416, 0.13412725563272976, 0.10736598740316916, 0.1460541538013096, 0.11943212010883564, 0.1356847607459125, 0.11825466282222641, 0.12459848394125927, 0.15496569222580237, 0.12927030014451024, 0.10359006170139817, 0.9843624953376913, 0.9491403817192968, 0.9748725437208005, 0.9822526120437285, 0.9859538202798825, 0.9798918964601288, 0.9798753746792558, 0.9766118080138472, 0.9893335180699159, 0.7983054159295659, 0.7873561368917752, 0.8164682967556988, 0.8020156016471317, 0.8218114446736691, 0.8123581814303796, 0.8024000212800696, 0.7978722676714913, 0.8191591243281116, 0.9124324806971195, 0.8960832859800189, 0.9020699153071432, 0.9276531767232115, 0.9204423021859434, 0.9040603362474406, 0.1506458719412621, 0.9190297023383851, 0.8928677547125267, 0.8038482546214981, 0.722807132526935, 0.6641713134441892, 0.7599933533815671, 0.6987185153509063, 0.7519579117019675, 0.7567589837903933, 0.13267107667914335, 0.7307120978048405, 0.6921936382224063, 0.7635162130182457, 0.7019559358238485, 0.13444237192546293, 0.7222145165071923, 0.6984887689528481, 0.7159240694268495, 0.7473894538640435, 0.7545669705655427, 0.754851579071502, 0.7880961979274052, 0.7792612890801474, 0.7408578141439413, 0.727680024842826, 0.6903529325926905, 0.7439857614406049, 0.7021689688934412, 0.763625789499726, 0.8212160976059381, 0.817510256924721, 0.3509895301382133, 0.3440827293359413, 0.7929063524162295, 0.3696671761585172, 0.7969096028538698, 0.831634734940788, 0.7842999368838592, 0.11494043380783991, 0.42058054622184826, 0.12621705107458037, 0.5236493593702995, 0.4114924734799281, 0.5468659727783459, 0.22001464926937286, 0.27295823755527604, 0.20368785689247915, 0.640525230942641, 0.5801065096705785, 0.7280980933741457, 0.49610124731972194, 0.6302634625749289, 0.7345753830103912, 0.473286453875576, 0.6440694937280558, 0.5486244389542193, 0.8621830165696764, 0.8129864711723961, 0.8769398736288023, 0.8890679842449228, 0.7486232832235749, 0.891767257564362, 0.8998352512269153, 0.8684407695769273, 0.8855712300230463, 0.1162877814337373, 0.6120965705790149, 0.10245402324589636, 0.1392572070682372, 0.11864922676064216, 0.13670176644369436, 0.12313200937635993, 0.11814798790129721, 0.13505489874596055, 0.23315222586332152, 0.5913646324223102, 0.7565382056191942, 0.25860595582791845, 0.24920262565132834, 0.1947792228449301, 0.18003701623857193, 0.21358668901447053, 0.3333179124885325, 0.6113031396880262, 0.717672425551515, 0.7912545573677513, 0.3923494973742848, 0.6458208691676297, 0.7741793684243667, 0.5372463139575334, 0.7909477943032979, 0.633297693283015, 0.6741983908370676, 0.41051805834860455, 0.47381307372519366, 0.4783162745690728, 0.24639267962961764, 0.4691659939325393, 0.6798804131805407, 0.551597020067174, 0.6072593959112325, 0.24940736419820764, 0.2307700167845338, 0.19197473752541605, 0.2118509074342967, 0.2015616197609431, 0.21347630123371142, 0.2137125216084057, 0.19676839184534778, 0.24658094738027225, 0.2067960887069138, 0.1922423365128597, 0.2482688296272919, 0.22363575556937554, 0.20408114655501053, 0.20507421094890155, 0.22934376702271408, 0.24307468999857107, 0.1947839009264335, 0.9366276746021186, 0.8840732179141326, 0.19905073256405692, 0.9252710713516751, 0.2011784713365815, 0.9063585469878911, 0.1424729236008061, 0.13612599875135334, 0.9200494878610136, 0.924105420147228, 0.21277895296241167, 0.12727044948805355, 0.12747403456148454, 0.16670746785209345, 0.2082774868715096, 0.20775622088293066, 0.9104371707059669, 0.21234890124216443, 0.2110467430330335, 0.202131738328456, 0.20634078379837406, 0.20377060380790146, 0.20188386856802698, 0.2306189198625369, 0.1987542252910296, 0.20901082468578613, 0.20035915007589034, 0.09616596443811631, 0.09893842643993234, 0.09988996114691362, 0.09486670573806844, 0.10426996508502817, 0.0999004833387166, 0.09399415333697092, 0.10039047001469059, 0.0894543076005595]}, "mutation_prompt": null}
{"id": "c861d524-db58-4a18-ac90-98c641e26d56", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.dynamic_F = 0.1\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.dynamic_strategy_adaptation = [0.33, 0.33, 0.34]\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_index = np.random.choice(len(self.mutation_strategies), p=self.dynamic_strategy_adaptation)\n                strategy = self.mutation_strategies[strategy_index]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        self.dynamic_strategy_adaptation[strategy_index] += self.dynamic_F\n\n                for j in range(len(self.dynamic_strategy_adaptation)):\n                    if j != strategy_index:\n                        self.dynamic_strategy_adaptation[j] -= self.dynamic_F / (len(self.dynamic_strategy_adaptation) - 1)\n                \n                self.dynamic_strategy_adaptation = np.clip(self.dynamic_strategy_adaptation, 0, 1)\n                self.dynamic_strategy_adaptation /= np.sum(self.dynamic_strategy_adaptation)\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Dynamic Local Search and Strategy Selection to Enhance Global and Local Exploration.", "configspace": "", "generation": 14, "fitness": 0.4102810302955653, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9053289317234839, 0.910076688733294, 0.8097688888293382, 0.8723872669998431, 0.907054745243091, 0.8141706773864101, 0.8968318981765668, 0.9051906031347561, 0.794443433912186, 0.8160164878181856, 0.8153022142204666, 0.661011237307279, 0.8058914806321159, 0.19200835100389546, 0.6660150164034997, 0.8046077821030312, 0.6487962080876003, 0.66052979217748, 0.14422039758963456, 0.1457963009331894, 0.10420025985730175, 0.38578335725610413, 0.15534537874746535, 0.11780037382524555, 0.1369532325530416, 0.45781125451074545, 0.11051063223627278, 0.13149362359572203, 0.1282077106973054, 0.09398099354286937, 0.12597648708732445, 0.10275779860912937, 0.09378959979553214, 0.11231249398375842, 0.10688196977853148, 0.08894120778773451, 0.9474840914444451, 0.800172535537574, 0.9085021862373677, 0.8240725330555693, 0.17576863344053217, 0.8725897194960505, 0.8406572237645732, 0.8654356564387208, 0.912122156313638, 0.434244265527054, 0.3549879166824952, 0.45352407923923543, 0.3814239425421262, 0.48787578679343546, 0.5061108840639404, 0.3629172677093039, 0.5620451297796935, 0.512087389917398, 0.8933585401965437, 0.9060449125910106, 0.739882819766565, 0.915198773307108, 0.8124914502129679, 0.7659491293332065, 0.932273351341341, 0.8856439042110176, 0.7693865231360018, 0.16821177494139994, 0.17935925275540343, 0.24747699879515106, 0.18856492239585199, 0.20157407726823917, 0.266430321962309, 0.30148763557989733, 0.17829142755352567, 0.17922510652285129, 0.17983723063899193, 0.16936568276883446, 0.21667545169362978, 0.16659725474493736, 0.16253791521985328, 0.22861424378184425, 0.15192523802506708, 0.1765100790942704, 0.3087217271431322, 0.6717291820734752, 0.5943815782847062, 0.34515475091302505, 0.6232959133457134, 0.6455787595307942, 0.317994879375997, 0.6139767844964334, 0.058436396766817555, 0.3340174724517646, 0.6815216337167485, 0.7111291700385349, 0.41651653588127224, 0.3482981704326389, 0.206476202601928, 0.21049484514706895, 0.3403818854671651, 0.41148794756281093, 0.5330972925143318, 0.16654722907277353, 0.1665283583685161, 0.06349175746705127, 0.6096115837405518, 0.677917759945553, 0.16425380537207634, 0.3594714407540668, 0.15051775769760278, 0.1352750703043828, 0.4901820973413794, 0.6366112076952375, 0.308632316007488, 0.37081652392172304, 0.5473867908427672, 0.32940746664637643, 0.5823992714583461, 0.6488284299397895, 0.3263239324890854, 0.8628460712306643, 0.8658400183420847, 0.7138530848160727, 0.8501031518014253, 0.8378508316680102, 0.6969588545141037, 0.8714725760882792, 0.8363945443595147, 0.7024733484598418, 0.1443208706627198, 0.11700794471172415, 0.09927844676249409, 0.31598207556756797, 0.14501274706653244, 0.09803866153429686, 0.4076720668617433, 0.15575426850179486, 0.09206543162089453, 0.16413956842739608, 0.20392673038606168, 0.1392356532829725, 0.14818984298466054, 0.38371424050409786, 0.14710212779778342, 0.1854719986367469, 0.49012040903898546, 0.17581297624173609, 0.6129666930702917, 0.5660504569564575, 0.41805231920583796, 0.6672439919591473, 0.6432890737106385, 0.4187062170087765, 0.6610141610266738, 0.6713499443535966, 0.43842346380201114, 0.5761350943506909, 0.5633910306657044, 0.28655704714773933, 0.4978011620669738, 0.5055434295238921, 0.2940052348450365, 0.5541603918135023, 0.5355221017374268, 0.3364017788477556, 0.2430114502118319, 0.2373964975122782, 0.18419079436827412, 0.23619605367349117, 0.2085721930235772, 0.17420720816473478, 0.2400685762158712, 0.21273924897315488, 0.19611621692964987, 0.194365936571248, 0.2053137189661467, 0.18234774161234812, 0.2427682390231496, 0.21953751595098225, 0.17744552948752335, 0.19615822587310283, 0.2352087223064926, 0.19638408914905559, 0.8724617267778905, 0.18480443262162238, 0.18099005475716212, 0.8622488901096077, 0.19563061292262496, 0.18278187949797542, 0.8360449724215017, 0.8348585540774076, 0.6888672057140033, 0.8925224324529827, 0.2067457080616789, 0.6201589808361512, 0.763105251723478, 0.23078502719169636, 0.1625247714029776, 0.2103803862541782, 0.22673411722464154, 0.20140185963941415, 0.1799100573198139, 0.20199880132478043, 0.18515556394468702, 0.19911196033666256, 0.18398097265048552, 0.17498693151752376, 0.19069165220781592, 0.1834498932031261, 0.17892980871381992, 0.08682187283219334, 0.09143113952294535, 0.07882822584377158, 0.09113462177327258, 0.09079671545210766, 0.08422402341691138, 0.09618573769205263, 0.09263343640949773, 0.0780800551088392]}, "mutation_prompt": null}
{"id": "61117c88-095f-451b-9a7e-e2260e4b3474", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_CR_min = 0.7\n        self.adaptive_CR_max = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                self.CR = np.random.uniform(self.adaptive_CR_min, self.adaptive_CR_max)  # Dynamic crossover rate\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Enhanced Local Search using dynamic mutation strategies and crossover rates.", "configspace": "", "generation": 15, "fitness": 0.5136242289657942, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.29.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9104407042207906, 0.9008663743284725, 0.9051710216060505, 0.904202184867587, 0.9030533818351455, 0.9036744343138392, 0.9002748472289267, 0.9084463487474373, 0.9090613367859114, 0.8107919221826357, 0.8234779163946109, 0.8272881655823219, 0.8096585256733115, 0.8113083895476688, 0.8346184120186523, 0.8228156487456815, 0.8159005999269178, 0.7919596208284013, 0.5801319403145764, 0.15992530638582048, 0.17314862705350065, 0.5941591148536889, 0.15528846759753523, 0.5489723854426067, 0.16487554714120856, 0.16277439650377423, 0.1491002319949234, 0.10632558757627941, 0.12045254507754821, 0.1658767013209428, 0.10981947696040917, 0.105971328653513, 0.12149864662039656, 0.14503518423576256, 0.13152519349517078, 0.13309916122826693, 0.98419037934674, 0.9695740765767642, 0.9750193768346019, 0.9685309377855325, 0.9454169749430414, 0.9784723160101757, 0.9761297832580796, 0.9681838532355096, 0.9833607200332894, 0.73147886911447, 0.7399552703790377, 0.7361152713288908, 0.7469255054912398, 0.7364576948262362, 0.7389962790760594, 0.7478154683178188, 0.7273408472329366, 0.7352094855788338, 0.9022586436377662, 0.8708658218656362, 0.8866646696828951, 0.8862735664689043, 0.8972853333041584, 0.8899934951679027, 0.9011999901850578, 0.8665830744789216, 0.23239732414790182, 0.6866936348323287, 0.6085827715793318, 0.6317122026496979, 0.7219698820034661, 0.588872334632838, 0.6455380758144529, 0.5940439086338629, 0.6905841634728493, 0.6292597381553477, 0.6786663034270115, 0.64294864867247, 0.6078263338443912, 0.6343934128551656, 0.6709733688313753, 0.6568899824738458, 0.6425669240020448, 0.6026803954575859, 0.6746619406993384, 0.561118996090581, 0.5698016363608991, 0.47016074456265666, 0.5673033408151715, 0.34437975052574943, 0.5347090726959961, 0.5972787301245628, 0.5519927032353968, 0.38068195373262914, 0.6536002369281942, 0.6594802758720788, 0.6414505615438728, 0.6523474664221407, 0.2544260540572595, 0.5807571683336259, 0.6914631154572003, 0.7033901852152966, 0.656425752140692, 0.08107517556043475, 0.10329002648334151, 0.22479724275023516, 0.520021218200683, 0.4317683954732815, 0.3962884579388286, 0.13949502259559454, 0.11429590668811274, 0.17738723507789145, 0.5116239319896061, 0.5310191667689987, 0.5300218018211955, 0.5721101265212396, 0.5854533850302921, 0.5778366313724979, 0.5389204324686878, 0.5482274718106972, 0.5346070198942494, 0.84705526431251, 0.8409205565641829, 0.8481188965821631, 0.8369862033311674, 0.8322480701791092, 0.8240709738344447, 0.8121631861519145, 0.8398617945278712, 0.8486978055411638, 0.09914955953865978, 0.1259097483869549, 0.14370009014172525, 0.1536064825558513, 0.12831189509582985, 0.4887121270464462, 0.1453256126820388, 0.11655412803459475, 0.14229232070488473, 0.12468814399618955, 0.22478686738901243, 0.21477072105240969, 0.4922201987754222, 0.3022335874947618, 0.41912863172833403, 0.347856466104708, 0.24426946819643458, 0.130877763105942, 0.6827885802886834, 0.463577482947634, 0.5434424038812635, 0.690163150264973, 0.6738595962664079, 0.5978732902484822, 0.6986483943896744, 0.6993213478126942, 0.7007783040833518, 0.4953880547662889, 0.5016619593391151, 0.4627755315324382, 0.5081352592804602, 0.5605059996382655, 0.4827569370852056, 0.5053125793488573, 0.5183286735827384, 0.47552544237492633, 0.2628950645517669, 0.23090933912092515, 0.215318195760277, 0.22676449611783345, 0.22994989083962636, 0.21305475044551436, 0.2272393092777737, 0.21088428938202008, 0.20599843313281307, 0.21821261976442496, 0.1930350669152734, 0.22160964333954525, 0.20872063049008127, 0.20319864319536607, 0.2380087963520987, 0.19408868226894282, 0.6903492309923439, 0.21644007425575817, 0.8888638622648961, 0.8878143636255054, 0.15365557167981114, 0.9152885600469763, 0.8794612438474995, 0.8887965258489907, 0.14139326695224808, 0.16777849476157203, 0.9010566047953753, 0.8874270526064678, 0.8538679520424344, 0.8450198781892625, 0.1668625043361015, 0.8582594122612881, 0.7972730675715232, 0.8545335080208482, 0.10447618158509087, 0.10471733596624966, 0.1808467022678818, 0.19393499872747577, 0.18071806632798526, 0.19115818966924647, 0.20688200314768157, 0.19029045891957164, 0.20722786872421073, 0.1902279861503442, 0.1943567668935462, 0.1050311068783385, 0.08293353011321702, 0.08586715284481161, 0.09124877961583733, 0.09070004937881859, 0.08544819788114999, 0.09514724880420633, 0.10137084840627175, 0.0893062888742685]}, "mutation_prompt": null}
{"id": "51f55ab7-5bad-4839-a352-7f1b32345843", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.strategy_usage = np.zeros(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_idx = self.select_strategy()\n                mutant = self.mutation_strategies[strategy_idx](population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.strategy_usage[strategy_idx] += 1\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = np.random.uniform(0.01, 0.1)  # Variable local step size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n    \n    def select_strategy(self):\n        usage_probability = self.strategy_usage + 1e-9  # Avoid division by zero\n        return np.random.choice(len(self.mutation_strategies), p=usage_probability / usage_probability.sum())", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Adaptive Strategy Selection and Variable Local Search to balance exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.4268126994446928, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9016794434793592, 0.9081071670700823, 0.9454888758877183, 0.9035960021056545, 0.9021244339036957, 0.9486527062447896, 0.9035617443208527, 0.9065374576566263, 0.7986296935224986, 0.807243693902001, 0.3066477093603084, 0.8524115274193668, 0.905164139413419, 0.21372003041267384, 0.8943899961528399, 0.8140061365295777, 0.8151536099336913, 0.6760827359573367, 0.14332863684764363, 0.1669606223773359, 0.11451118692681828, 0.16055238789727067, 0.1469080861796549, 0.1450280400684928, 0.15923481744827606, 0.15765601709935562, 0.11027891626496311, 0.10788322008473461, 0.1243790721042296, 0.10679070171042038, 0.120340479748546, 0.1160017590294452, 0.1176128202223643, 0.10642545727045272, 0.10961096300234408, 0.06338586481378239, 0.8832642490517859, 0.8266483502928212, 0.8919801850467379, 0.8829230878617461, 0.8578399730332942, 0.9906735756600863, 0.7631709034508289, 0.8256936063900643, 0.9906306365370311, 0.4133054728946528, 0.4462900791284413, 0.49395329745321304, 0.32037305208288, 0.32435271540675326, 0.45445587424134437, 0.425330837490168, 0.3550519956376169, 0.8377686235370517, 0.900367708972952, 0.8975178648087582, 0.9479350169174435, 0.2827663364326962, 0.9088581364748125, 0.7930249004908686, 0.24923942257633214, 0.819071415940154, 0.7652719146735258, 0.2016465763267139, 0.17629014285774847, 0.8061207797205955, 0.21013995711662814, 0.16658596101754264, 0.19326142833650728, 0.16703534094045935, 0.16426614995328037, 0.24325696626219462, 0.16984443147916428, 0.17241358757136316, 0.8535378404391296, 0.1794036722635043, 0.1624824661380162, 0.8263238088310308, 0.2133680286702898, 0.18689369828468838, 0.206431738223657, 0.19927671083694376, 0.679204259569615, 0.18212067101764728, 0.3883687044995042, 0.6656147503017833, 0.3443657890321946, 0.38871167105108195, 0.14945111262580157, 0.7869333269828146, 0.6816267644164958, 0.1540899518574146, 0.4749827407046102, 0.7650590891651222, 0.7066054204022838, 0.42065685450776524, 0.7326550550899444, 0.6869083154195146, 0.4802775557426653, 0.20983952488831892, 0.20752018313939746, 0.32581480750054115, 0.3415446984416207, 0.19293572035526552, 0.32394528924962385, 0.20087414386847713, 0.3337619111977167, 0.19270560829649408, 0.5232445990892727, 0.5315656230782173, 0.7782199060994786, 0.64329337256203, 0.5118276573803031, 0.6411763198000088, 0.6292115829009881, 0.29001973082684207, 0.30100275312206726, 0.7178224792500721, 0.7693451495333108, 0.7665168416874418, 0.9043506984072625, 0.8592669174905334, 0.6900839129339631, 0.8048947293629414, 0.866142356112657, 0.9176252252023918, 0.32914588789472377, 0.32239758872095037, 0.09717689150963382, 0.15634923487419639, 0.16219949408933265, 0.08571546372390981, 0.13496926554798816, 0.150436430147472, 0.09511181950401237, 0.3383603860196377, 0.2607896679196514, 0.16927200143593002, 0.18154899591399987, 0.13738238156418725, 0.14650129121818778, 0.29055368210365073, 0.30164850897290474, 0.14465732716551594, 0.6190303675617035, 0.6549882827788291, 0.3885567833621799, 0.6666839479336819, 0.5992770817556164, 0.4355902876731398, 0.6675568762011725, 0.6877172588762477, 0.6171040215476168, 0.5336448445105405, 0.5076592971897123, 0.3226523816062902, 0.5208471605051364, 0.5248812530348681, 0.54950862151282, 0.5502565620388589, 0.5594920170939816, 0.24173064944190326, 0.19960000401487177, 0.22552811897815006, 0.233852447292625, 0.23326915122690162, 0.2151498801819225, 0.20467641219243882, 0.23404312236548463, 0.2194413937146037, 0.25052171332317197, 0.6130934568101519, 0.22979759909625996, 0.2126698870797552, 0.2178724672472696, 0.20678391588079648, 0.1945051513890006, 0.20010018207121938, 0.20358024770109606, 0.187142632184489, 0.18578059788005397, 0.18470476486643528, 0.15866365172091224, 0.684539262195843, 0.7483430107100626, 0.20044126196367695, 0.8151104944283154, 0.6699317954450009, 0.7143335262265071, 0.940796169479246, 0.2101013996008967, 0.5563604348626852, 0.5462525713145365, 0.168834717694738, 0.20035816590129218, 0.10396785144094378, 0.7593600491747848, 0.20884563366642905, 0.19053923093821967, 0.20906477907392096, 0.1907112410582792, 0.3467449559406497, 0.18791309308578485, 0.2599052270653107, 0.19149380572935681, 0.19214868636827065, 0.17669697754461267, 0.09386873120969252, 0.0903334714712195, 0.09465499574652492, 0.09722060133498578, 0.10341484879217411, 0.11132294549692046, 0.09300410166165352, 0.0982171354258542, 0.08593265355182633]}, "mutation_prompt": null}
{"id": "0ac0f9ae-ab1a-4f38-80dd-d71adaf2d1b9", "solution": "import numpy as np\n\nclass AdvancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.global_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.global_search_probability:\n                    self.F = np.random.uniform(0.4, 0.9)\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdvancedCoDE", "description": "Advanced CoDE-based Differential Evolution with Adaptive Mutation Strategy and Enhanced Local Search for improved exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.4795713479899122, "feedback": "The algorithm AdvancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8649334985209395, 0.8717926701565679, 0.8613424815724299, 0.8751496661372468, 0.8787878342273774, 0.873302207715885, 0.8766248857370618, 0.871032176269392, 0.8691561332771457, 0.7708261000921639, 0.7873181330965402, 0.7515404057082355, 0.7742434686773989, 0.7887443190395349, 0.7604461747166595, 0.7564969259362886, 0.7890437350097471, 0.7803632507683405, 0.11324589597830181, 0.11338518995786473, 0.1621524260510725, 0.14067805035702963, 0.11311428266815693, 0.16675209891503529, 0.10347269947365145, 0.09381799471611629, 0.15224198640988396, 0.10271034777802812, 0.27171721745416344, 0.12834036789906345, 0.12389914189250761, 0.11896214885030765, 0.1344793205345235, 0.13450750504759346, 0.11220644041718475, 0.11376985294886166, 0.9809197313622354, 0.9742548437305938, 0.9769887479649976, 0.981344412990853, 0.975108338913445, 0.9769479275485803, 0.9859673917727176, 0.9912345386808358, 0.9785865502267272, 0.6341065849221614, 0.663016481006576, 0.6539741158612828, 0.6789655722265191, 0.6783420054777789, 0.6476672368846815, 0.6807704666600423, 0.7041551627095867, 0.651643047503883, 0.8478245069760526, 0.9035642871079489, 0.8449254888961595, 0.8373230814931236, 0.8878667011196524, 0.8472565399509915, 0.8574893598013009, 0.8770007347205425, 0.8554019624338878, 0.6307868562689252, 0.6325461256267415, 0.6462532075468315, 0.6329958924657276, 0.6447005424847763, 0.6486135785304772, 0.66018278525354, 0.6522597523862225, 0.640243817431122, 0.6093489796249827, 0.6374526876820732, 0.6699860722712923, 0.6503541294184991, 0.7165103458672268, 0.6217608120574158, 0.67007606708653, 0.6218441918479762, 0.6537598602172666, 0.6157119937305187, 0.6050622790978267, 0.5965411244897747, 0.6188100780236085, 0.6279417665507627, 0.6385222026358784, 0.6204438494304907, 0.5941471844168962, 0.6100183317453176, 0.6714605060132159, 0.7036103879350324, 0.6870420743748797, 0.6448552390380204, 0.6897857340013601, 0.6652633620845587, 0.7002409852803007, 0.7347822542304808, 0.6832790071007557, 0.2460557726948981, 0.2891164892793697, 0.22635984225565442, 0.3283105030877713, 0.5184626892430249, 0.49881951311397654, 0.246214760911454, 0.35252574243682233, 0.13408847024868287, 0.5087900968350128, 0.515947287226729, 0.5516914205211698, 0.5623040736006737, 0.5314930077185083, 0.5702846184648616, 0.5111257219796774, 0.5259467480348047, 0.5272453209444621, 0.8147516688594318, 0.8252691838147767, 0.8058379229518068, 0.802796715681044, 0.8107506148799444, 0.8026618703131042, 0.8110337921289444, 0.8155123309216845, 0.808721678059956, 0.11576240954587813, 0.13765854029131575, 0.11047294165148902, 0.10842115873900637, 0.09814312341846776, 0.15169410294096375, 0.0996300002231526, 0.14116490801578851, 0.11249373890103964, 0.405171822224634, 0.13998248098588406, 0.15550466071616809, 0.20594744107791463, 0.5382543319901392, 0.24161137250734688, 0.20061433420916708, 0.22578200035035756, 0.3642208435096451, 0.5559275147299358, 0.5047126750654992, 0.5730465611667638, 0.5741801806823406, 0.5316910886923016, 0.5733133355746984, 0.6343485062141367, 0.6179593094593568, 0.5470163434077828, 0.44669471764013746, 0.45253500140877123, 0.4697801901586448, 0.45266200464046225, 0.48009431069300934, 0.46008003229228467, 0.4693595948092616, 0.4838223348969538, 0.5066217536126782, 0.22645482097802982, 0.19464197386321813, 0.1862262714943026, 0.19148307282344046, 0.21828931358550563, 0.2095583777384209, 0.1972970868197671, 0.21033849153544293, 0.19294164094842203, 0.19602874617600596, 0.40679322236752036, 0.20823079295220737, 0.44508948951932326, 0.236160300701021, 0.23561192365906247, 0.22901135877238343, 0.23006801174774916, 0.20545889832773434, 0.1467348724333324, 0.15327308971866094, 0.15382385460597547, 0.8479470346044459, 0.19717921164317964, 0.19880295968592832, 0.18330443689918952, 0.21086062273497974, 0.8704285090523862, 0.8753984816006098, 0.21098208133575458, 0.8329933787757264, 0.20641395910892402, 0.20492382529184638, 0.16773065319842517, 0.20802954658431205, 0.20971905373311261, 0.1538335208285203, 0.20197797632580983, 0.18911464675394507, 0.18435543475987948, 0.17539392698043998, 0.1904667233935753, 0.17652530310842773, 0.19007862653565444, 0.18248403974029537, 0.1817068241748595, 0.07949882657006291, 0.08204030876687651, 0.0760307413247181, 0.0777614143558627, 0.07503440855758803, 0.08839259239591779, 0.08029399166764484, 0.08262148449056239, 0.072640570223651]}, "mutation_prompt": null}
{"id": "2e2d4339-3c6d-4232-ac86-b473e73afca7", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Focused Local Search utilizing adaptive control parameters for improved diversity and convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9140144154502393, 0.9119945627520508, 0.9190897798008978, 0.91183608256894, 0.9099934843631299, 0.9170534853354243, 0.9144412295593287, 0.9106313387873125, 0.9183457873814755, 0.8221626814309245, 0.8316930638134689, 0.8365665558815685, 0.8139602453560706, 0.8441850165993527, 0.8435791257361398, 0.8216000793522638, 0.8366230790128206, 0.8315703592206858, 0.1562727598276772, 0.14853521215746512, 0.7340107814974344, 0.14199049984727685, 0.14040341417125912, 0.16343319872473805, 0.6416542947348762, 0.6205713229662903, 0.16531922607957472, 0.09653114009140318, 0.16789997913852894, 0.11555527222978546, 0.10340409431363662, 0.13976484683428114, 0.14384919099629057, 0.14939723964673868, 0.13853316238002966, 0.09597173410495996, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9684145992849261, 0.982778729149947, 0.9814455014854574, 0.7776381566806911, 0.7828908197824755, 0.7550543795346965, 0.7732181081806159, 0.763257744689845, 0.7785925425382032, 0.7828390809602553, 0.7761960490465973, 0.7880837824622238, 0.8958033916382943, 0.9089728042682071, 0.897306932004205, 0.2145208953141453, 0.9130049917349844, 0.9314575641438199, 0.9002612365869824, 0.2357195542223418, 0.9140814483316259, 0.6781616392234586, 0.7726299154170521, 0.8068940348646947, 0.13324633689313592, 0.134355819322183, 0.6854868627750555, 0.745195073745869, 0.7202088041309084, 0.7792292110307495, 0.667501390394101, 0.6220390767462909, 0.7183443577686486, 0.6666393748830828, 0.7597416655786837, 0.13333059901630373, 0.6947526891011317, 0.6440665737267919, 0.7564843156506976, 0.7219214224772751, 0.6514505274762656, 0.7155630986916027, 0.7441276908358543, 0.6635837017339519, 0.7354536157778895, 0.7335376239155936, 0.74416335160023, 0.7491947838751403, 0.8061174202538456, 0.7316088143875581, 0.7977572964550663, 0.7910263146637371, 0.7367622475231217, 0.7478701709662106, 0.819438022203814, 0.7958346688938099, 0.7758375258608818, 0.13953901005808278, 0.41679023782137936, 0.41970464690819653, 0.6920357331712953, 0.5771305562688457, 0.687832112587665, 0.37964541152330467, 0.17165850458485, 0.5275795294822287, 0.6798264233208281, 0.6892116525851382, 0.6573733914798237, 0.6796207240332753, 0.6835486752364, 0.6970572349782318, 0.6922451272010304, 0.6272253932222868, 0.6929565048480276, 0.8683845120612302, 0.8773353364383439, 0.8724317324197234, 0.8809029147480993, 0.8581481885015517, 0.8717744887032091, 0.8842012076373399, 0.86620319181741, 0.8543622787443149, 0.12238264936782417, 0.14714334456592282, 0.1438696125110024, 0.13996881123243365, 0.1185265250328914, 0.13324793815450153, 0.14796879484122505, 0.13149817737367697, 0.15354236766925, 0.22990443200647304, 0.335978142190701, 0.1971971087634724, 0.162314913063221, 0.695926281761061, 0.5628428692033431, 0.23275657014774553, 0.6374158975692874, 0.24721856617943228, 0.5425800441545645, 0.7482068137379894, 0.6170853051641343, 0.43098491796878247, 0.7414060234855564, 0.7347877316763609, 0.765320416676722, 0.7630797596703737, 0.762833986794512, 0.46631438852842866, 0.5344988597271308, 0.6111024110812985, 0.2162061717008874, 0.2688146909484531, 0.6181713961831257, 0.5271851160036427, 0.4398717449440952, 0.5373403741754874, 0.24539544319278894, 0.2568477478723393, 0.2141368022837492, 0.20688236742043453, 0.2311096097381411, 0.23955853848662023, 0.2137511228769131, 0.21868464095996276, 0.20396547535479392, 0.1958789312097804, 0.2461788520395477, 0.751768827258565, 0.22200384076392898, 0.21948163331466575, 0.699331468324087, 0.77256451611345, 0.24361536253111593, 0.20639795745525802, 0.186250858665455, 0.1874245165090409, 0.2002637007321325, 0.9040752897558364, 0.20082548497785913, 0.9211038627629997, 0.14217891224175894, 0.15888704095767403, 0.9322662959038613, 0.9226289950752073, 0.8896422389634291, 0.9236763374448232, 0.889793682539842, 0.8395360074315519, 0.9079968794431068, 0.8787830581909154, 0.8861041768593099, 0.9129953020899249, 0.18818618486047356, 0.1949737938610021, 0.1896757515299451, 0.21042919713744734, 0.18015268360911052, 0.2157964078665613, 0.20505536545627634, 0.18906603526188015, 0.18671831382675286, 0.09228323923882598, 0.08589067829090602, 0.07724837419405195, 0.09146151137325209, 0.09542196917319157, 0.109119862695636, 0.09675473094404097, 0.10080113136245616, 0.08834698828339826]}, "mutation_prompt": null}
{"id": "8c37239b-77f0-4b25-8ff4-106349115bda", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability * (1 - evaluations / self.budget):\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Dynamic Local Search Intensity to Enhance Exploration and Exploitation Balance.", "configspace": "", "generation": 19, "fitness": 0.551152048199733, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.31.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9133670091921023, 0.9135038588398477, 0.9090904753793072, 0.9125560464746588, 0.9122951239224706, 0.9179931583229699, 0.9118209111863071, 0.9111210586501722, 0.9144297922954001, 0.8285411945656223, 0.8335146619437467, 0.8186293011839703, 0.8255742805371863, 0.8495754602282979, 0.8443449653931726, 0.8315647723988764, 0.8386272526408146, 0.8331913712681792, 0.15470109632231743, 0.13979346620284672, 0.1434332666420931, 0.12836386382969955, 0.13808348487751076, 0.1822006317685697, 0.15693927500026006, 0.14018592179508726, 0.13741869144618246, 0.13755866476659007, 0.13701802251573592, 0.12644685455081528, 0.11565516327228875, 0.13678505786150286, 0.12544051748034457, 0.13214779953100275, 0.11550742665764424, 0.08548321898526678, 0.9901128791996175, 0.991291444466859, 0.9818328571260316, 0.9747357852267311, 0.9828979096370326, 0.9813055881585543, 0.9684145992849261, 0.982778729149947, 0.9788071899514885, 0.7839007377435033, 0.7699420405189783, 0.7736488621143557, 0.7737082948119464, 0.7742281506730613, 0.7644301952093463, 0.793000850933517, 0.778570623799824, 0.7745647021766265, 0.9090473231531749, 0.8941649639991958, 0.9046634941901153, 0.21451696116896213, 0.916951653361721, 0.9193127385719544, 0.9035251827906978, 0.8995983576335694, 0.909432521969904, 0.6661484836563065, 0.7808431244322683, 0.7252290846274441, 0.13334527191465806, 0.13410597658187906, 0.7350858789685302, 0.782914700454394, 0.6698896335896343, 0.6627359690324807, 0.695283277845288, 0.6287156767056319, 0.7224508678556105, 0.6482866097655537, 0.7927899503368449, 0.6567212335914192, 0.6547562221925167, 0.6642278335495182, 0.7989524652805728, 0.7383596563388353, 0.678198465148228, 0.6535147914060209, 0.7283781842882737, 0.7390307226690983, 0.647158423399579, 0.7299122420466733, 0.7444634982650313, 0.7569827227379796, 0.8075612698401808, 0.7441446832410241, 0.7947117487569222, 0.7525655716299414, 0.6876345888297672, 0.7973016408761106, 0.8083863844621072, 0.770553862705806, 0.6582224952401632, 0.13965558214779195, 0.5954476672603288, 0.5155916800025568, 0.6655611652246797, 0.6328592790344647, 0.5055385239734742, 0.4803391271584124, 0.16832451269069537, 0.2785091552701845, 0.6735459305239366, 0.6834848928538972, 0.6957060960095611, 0.6804884579842799, 0.7076160358980053, 0.6949138954706391, 0.5820360383457939, 0.6888005187609848, 0.6719178060731048, 0.8509087012754724, 0.8701598318143987, 0.8741470154838213, 0.8846316214314218, 0.8708085450168548, 0.8439260853167312, 0.8760144319267442, 0.8687639503312767, 0.8606910671129901, 0.09503979603656043, 0.16788746350411787, 0.16443354889236927, 0.1244159466411302, 0.12705692962248927, 0.135756673235372, 0.14580363916863448, 0.16306706307692187, 0.1412933971033422, 0.6137015812305338, 0.6724612357004379, 0.7377839434436464, 0.19074619446754792, 0.22655626561190756, 0.5474282735381149, 0.22999556895482975, 0.6361973291756413, 0.5046556665803479, 0.6069891163357497, 0.7503216582528829, 0.7351263556546759, 0.7480916515572325, 0.7321575664650538, 0.7059784349045278, 0.7470469726291679, 0.7488206138091935, 0.5887351433748884, 0.5578450448934795, 0.28525177525794587, 0.47977643876427456, 0.21457904271075112, 0.6159283107965564, 0.3071518654977001, 0.6463052036785351, 0.6832864754396899, 0.2252788735171677, 0.23300191868499875, 0.20439513573324286, 0.19834203204156542, 0.2551595321960869, 0.2309915131334026, 0.19718224125282802, 0.2074725993876424, 0.24794293378413546, 0.23049256865030165, 0.2177987546897756, 0.2511432448362996, 0.24398911047241956, 0.7691088828688202, 0.24914396449954757, 0.22033436731744138, 0.7322404978528745, 0.2206479210448229, 0.2067641599846164, 0.1862558148862269, 0.1874102145826878, 0.20054653855733218, 0.9020319490971076, 0.2007905026145903, 0.19968029006427213, 0.1421745224421873, 0.15889304869775478, 0.9292592848273329, 0.9221013391315263, 0.875443756920254, 0.9091208281770138, 0.8947979323361155, 0.8335813570552104, 0.9011121197115294, 0.8834707818066125, 0.8881357766921438, 0.9253260557082776, 0.19333423056316468, 0.19763345361289242, 0.19372498163138008, 0.21313614124875335, 0.22516926117172198, 0.18447222669695562, 0.19934788927092462, 0.21192268910275924, 0.1942760898547753, 0.09636331470264614, 0.08874267994270757, 0.08960268522411408, 0.09671989006136117, 0.10207589382691473, 0.09661137058700842, 0.09776794173623438, 0.09946226878000575, 0.11700627026028121]}, "mutation_prompt": null}
{"id": "d25c97e0-acba-4b07-a54c-4db40acfc8dc", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.dynamic_F = [0.3, 0.5, 0.8]\n        self.dynamic_CR = [0.7, 0.9]\n        \n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.F = np.random.choice(self.dynamic_F)\n                self.CR = np.random.choice(self.dynamic_CR)\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Reinforced Local Search and Dynamic Parameter Adaptation for Superior Convergence and Robustness.", "configspace": "", "generation": 20, "fitness": 0.48192130921957893, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8947944561615517, 0.8998864229767806, 0.9024281262714414, 0.90453068546963, 0.9105305119261273, 0.9084402325668551, 0.8884001336248931, 0.8980168364856439, 0.9016752917760887, 0.7888537659333942, 0.8075972268126119, 0.8082717801107023, 0.8059994795451488, 0.8143092826805328, 0.8042799407685616, 0.7952232927079337, 0.7971459122256462, 0.8289900746283911, 0.1568279327121498, 0.1556908412690915, 0.5561870642982554, 0.15756759187953795, 0.5104185837051529, 0.16621507214840237, 0.13357870882012357, 0.5036013372699712, 0.14836814405599474, 0.14696229800474248, 0.13501995592534421, 0.14337984009406446, 0.1428420221161648, 0.10883224805404612, 0.13554057291753074, 0.16603849787168024, 0.15088076349245982, 0.12329707779258858, 0.984865135958567, 0.9724556189869626, 0.9571900075686269, 0.9772744277851969, 0.9685081193481737, 0.984392994310954, 0.9800396905510512, 0.9876860816084763, 0.9520678310663546, 0.7270819596745526, 0.7190028565906351, 0.7259457426713891, 0.705788685135205, 0.7240087719649876, 0.7160626010335419, 0.7400403835999365, 0.7068555252018298, 0.7288573832649937, 0.8795709928545755, 0.8529017901833121, 0.8649585171311389, 0.910345315135871, 0.864053761601353, 0.9022398832437444, 0.2337742885450973, 0.860429426612664, 0.2358500043380256, 0.5542083836661946, 0.5642663674810833, 0.6774317002624222, 0.5930717419205993, 0.6090128985194541, 0.6652911309006887, 0.6094489967688028, 0.6143724219138422, 0.6445688977196902, 0.5777188221565261, 0.5941161205817576, 0.13193558004221373, 0.6315368442937093, 0.6986038135015535, 0.6533250928299387, 0.644482749770525, 0.6438338343772555, 0.6126190255966284, 0.45773449334454086, 0.5525630104392442, 0.5345264298478651, 0.42380545435663586, 0.40625142861150454, 0.5008499201472267, 0.48489941815868853, 0.5348651146729697, 0.4797399880257772, 0.5262605902981128, 0.584634866832685, 0.6711217992954082, 0.6008088503283986, 0.6153022318143018, 0.5946716984836307, 0.618595002063199, 0.7009050283480125, 0.7044421318064555, 0.25934029480736065, 0.38934999672600423, 0.4043490093589005, 0.23756679831019667, 0.4609570890445027, 0.1435527753120205, 0.12872071902814985, 0.1187265364308181, 0.20771646178243974, 0.4430910473855513, 0.3819462896519791, 0.4654255452805387, 0.5165414128298749, 0.5247947955333321, 0.5372670158051356, 0.406262663058402, 0.47770042480632524, 0.44752643906613854, 0.8424388237334877, 0.8332320164189564, 0.8254045232958722, 0.8318688745901432, 0.8236015830660641, 0.808373209402916, 0.8044842514627413, 0.8146881986101756, 0.7905706485868653, 0.13526173439808098, 0.13420679255425116, 0.11491813599911271, 0.12314695705831236, 0.13768544462978993, 0.11744674719298054, 0.12185377296400768, 0.12216736005295648, 0.12967454999981165, 0.6659094290996916, 0.1681403736914504, 0.2518277392664633, 0.21043958101201532, 0.23512116808538785, 0.45869542200432134, 0.47823760230235146, 0.22169627495502453, 0.6098304833287231, 0.6565621489114462, 0.4812174526618307, 0.69405025303123, 0.6675752833629947, 0.2765832443848242, 0.6411638349286357, 0.6758169765864941, 0.7064879233673498, 0.6133017785348887, 0.5145564793048556, 0.4044013058709174, 0.4844394379757856, 0.5479749150396638, 0.27205323728330166, 0.4863141561361234, 0.504546908555803, 0.41871365476242894, 0.5847435473024494, 0.19283432542151235, 0.21004056118168468, 0.19735324326820292, 0.23829190186033455, 0.23672918672700016, 0.20670990561041824, 0.23032977540415522, 0.22636673272477903, 0.2624704367785393, 0.24702760572729, 0.2400267243221902, 0.2102600225208333, 0.7301659970094542, 0.21460792442818866, 0.21522750910562705, 0.23848181983426653, 0.24369079001784544, 0.22243212546122781, 0.15230580214859524, 0.15617178188570202, 0.1860796286960511, 0.17256125662510058, 0.19841550555443155, 0.19646225029995146, 0.14109225751416066, 0.17019369007176532, 0.8767075550313345, 0.8875683193708057, 0.21145525304713142, 0.12753944084358193, 0.8729553885568389, 0.8496316648740976, 0.859877462355174, 0.20938494518093764, 0.2112521049923738, 0.8516625607668377, 0.1977929005380059, 0.18492289997711964, 0.1875210222856657, 0.19504937734735706, 0.18697441047720464, 0.19892584051238993, 0.18138688058498853, 0.1883089964154383, 0.18087042980748524, 0.09412340574103473, 0.09083108516976046, 0.11540506643474369, 0.09838465641781113, 0.08963161029217603, 0.08626631811569418, 0.08832082176184941, 0.08748155967550542, 0.08149082443176359]}, "mutation_prompt": null}
{"id": "daacbe87-9b44-4aca-81fb-b9322e61c05f", "solution": "import numpy as np\n\nclass AdaptiveMSDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            # Adaptively adjust search parameters based on evaluations\n            self.adaptive_factor = min(1.0, self.adaptive_factor + evaluations / self.budget * 0.05)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05 * (1 + self.adaptive_factor)\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveMSDE", "description": "Adaptive Multi-Strategy Differential Evolution with Dynamic Local Search Intensity for Balanced Exploration and Exploitation.", "configspace": "", "generation": 21, "fitness": 0.5476804042370979, "feedback": "The algorithm AdaptiveMSDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.31.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9230383115232883, 0.9141557147359343, 0.9163529369138042, 0.9190226906046214, 0.9129734509107151, 0.9130464041116552, 0.9168285019852404, 0.913994586792497, 0.9202573880162087, 0.8221544320881125, 0.7948806955770163, 0.821251644325462, 0.8351481807524135, 0.8416179922885325, 0.8507068229885819, 0.8353863635660177, 0.8385217522008367, 0.8079933504934314, 0.5506338246328729, 0.6039665291928829, 0.5007619246416792, 0.17323680636436745, 0.5422617299977504, 0.1726299325170434, 0.13908962632505095, 0.6760878231254626, 0.1762890022315936, 0.13549124474736896, 0.13382575905269023, 0.12700679756395783, 0.16686693970669453, 0.16889502347891083, 0.088571898063458, 0.09403159321700882, 0.10931358795698198, 0.11340961133698313, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747363150057679, 0.9828977282248402, 0.977639260258256, 0.968414465697776, 0.982778729149947, 0.981445546737848, 0.7874597842899405, 0.7935982155766081, 0.7361347832571032, 0.7762439581589702, 0.7796008229888337, 0.7687276640771663, 0.7859320551815492, 0.7724780471795352, 0.7785410326252087, 0.22959480869798432, 0.9150323078036648, 0.9088938488661849, 0.21463583370611994, 0.9194791889517967, 0.9149266652040442, 0.9072075149650944, 0.23584234819247318, 0.9072383360266455, 0.637387683349542, 0.8263608731716965, 0.76949232012728, 0.6201806485679539, 0.1342746741370896, 0.7129865549248486, 0.7262027371068609, 0.6950795757487008, 0.7868122868497646, 0.700955060931347, 0.6387692618320376, 0.7084024279198908, 0.6958316761003152, 0.7613150709103577, 0.5905487795667254, 0.7730103917052396, 0.7089940061510775, 0.7238411459494898, 0.77585233105885, 0.7055087827899692, 0.6994578499943132, 0.7189966695209471, 0.6921385566091893, 0.7237526260795581, 0.745812657148779, 0.7437339922564075, 0.4213687127608394, 0.7870291671642825, 0.7797957819863008, 0.78599510348583, 0.7814085156054653, 0.7669870191082455, 0.7718471961871384, 0.7930435401404583, 0.8071954979004304, 0.7442310520764666, 0.17738520096507915, 0.23351268084663257, 0.33613568062993515, 0.6919494413402607, 0.701364366409921, 0.6643825465197329, 0.18431509744905927, 0.14689864188911883, 0.4641339278729313, 0.6640421788129084, 0.6794147235298785, 0.6879906413417199, 0.6791303555937498, 0.6889339055651724, 0.6766421095211723, 0.6845012341297001, 0.6546816247041187, 0.6715728465828721, 0.8656144422827925, 0.8763031826647054, 0.8795192922589226, 0.8734668486029142, 0.8709455496425416, 0.8562162179657485, 0.876110483900178, 0.8779217812962238, 0.8632421546890872, 0.14472926145755483, 0.17656285528419924, 0.17169716893368314, 0.16325949649324933, 0.1448534895447552, 0.1353055867577183, 0.13435335991176744, 0.12517149241758785, 0.09636233259603377, 0.5622845333740389, 0.21406331796010358, 0.26699477584036435, 0.186466580450539, 0.5612765977522411, 0.17535474926700367, 0.19320122879694457, 0.6058888639072735, 0.30630591512740935, 0.7198022396923887, 0.5708133024683409, 0.6257551924621139, 0.7439005561411937, 0.6314246442349192, 0.7415192508724485, 0.7013001811833177, 0.7423945504599181, 0.753359252715159, 0.5939670967654085, 0.6259055299960391, 0.3833963869872036, 0.49965331964399384, 0.3283291978385092, 0.5840312529642044, 0.262782098968944, 0.6830277302785639, 0.23600063227538748, 0.21376661263704366, 0.20622228501397044, 0.2134958381557267, 0.21031218502631377, 0.2243020153293943, 0.2061338417786468, 0.2144126671340265, 0.20940614730547313, 0.21240522278955942, 0.19714698899050764, 0.7927508456869974, 0.19987495912350361, 0.23487595073843648, 0.21705822589813606, 0.19920102275489704, 0.2049807878020833, 0.24303718558380183, 0.19912084931805973, 0.1861434721057902, 0.18743421681380035, 0.20023539532545243, 0.9203095492490948, 0.20087172772487716, 0.9163757963296716, 0.1421777145051728, 0.158890660240099, 0.9370385862462239, 0.9147852023137468, 0.8735112337220476, 0.9120833554465468, 0.8802788077686645, 0.21051165793258741, 0.8877082211816437, 0.8901837069691861, 0.8795400037818257, 0.9221037444616457, 0.19333241905314957, 0.21138434384650762, 0.18774519460947847, 0.2097872796123893, 0.18303537558540517, 0.1927826880855048, 0.1976483255174163, 0.19409039446707588, 0.20147789936429206, 0.08557507056108393, 0.0966465609161764, 0.09020640919629219, 0.08615058869944514, 0.09993968555719512, 0.09056399316233654, 0.08469939576914443, 0.0843070744117238, 0.0876586844632824]}, "mutation_prompt": null}
{"id": "0e37a32f-fbc2-4cf3-971b-23b9205ce895", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.sharing_sigma = 0.1  # Niche sharing parameter\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            # Apply niche sharing for diversity\n            fitness = self.niche_sharing(fitness, population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def niche_sharing(self, fitness, population):\n        for i in range(self.population_size):\n            for j in range(self.population_size):\n                if i != j:\n                    dist = np.linalg.norm(population[i] - population[j])\n                    if dist < self.sharing_sigma:\n                        sharing_factor = 1 - (dist / self.sharing_sigma)\n                        fitness[i] += sharing_factor * fitness[j]\n        return fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Focused Local Search utilizing adaptive control parameters along with a niche sharing mechanism to promote diversity and convergence.", "configspace": "", "generation": 22, "fitness": 0.342937513949703, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.7800384779347256, 0.7826830719140565, 0.7871061123658082, 0.772074342901663, 0.7930953691624518, 0.837900787145314, 0.5300225941710714, 0.5323464073155584, 0.508690195795305, 0.2631348892209907, 0.21369683913406956, 0.26005388146006503, 0.27825142553421034, 0.2822790258753004, 0.3112723003163531, 0.11590140732586474, 0.2995721741449894, 0.2534233760771448, 0.14190943962082658, 0.1299403645374816, 0.16294443706861073, 0.14772254324801992, 0.16613048965084176, 0.15006597405689115, 0.1633552272770834, 0.16607161265032355, 0.15238729622322988, 0.09562446210100328, 0.13370903284811086, 0.11318586315545276, 0.10663515934718892, 0.1337696507816558, 0.14605317658896855, 0.13316432061593875, 0.12933317171306757, 0.11292951180086075, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9655931831903666, 0.982778729149947, 0.9814455014854574, 0.3936665027010219, 0.40479254916344176, 0.3793874001813595, 0.3624335242754997, 0.37669990713345836, 0.37926130778607225, 0.35957095244821935, 0.35850557621491697, 0.31889950124095834, 0.894905255564612, 0.9064470224566437, 0.8900961197043503, 0.26994484629866533, 0.9315808222088862, 0.9025637944054488, 0.6664584534945368, 0.17871872137184341, 0.9196958143706153, 0.2477554125978364, 0.37975713200062755, 0.30679419152383147, 0.13310210552434343, 0.1332869957606847, 0.1634344781346495, 0.3146787711112444, 0.21839695214983257, 0.3858394565007799, 0.22995389127919075, 0.12370612178944151, 0.2296730412762471, 0.25368794028771013, 0.3038846085095771, 0.13296943016266505, 0.2493226616474572, 0.2564541815051583, 0.26173427983465614, 0.18344503100241338, 0.08182561835356139, 0.16987097386945005, 0.2699165875046309, 0.24319429511478863, 0.2699482885758775, 0.14807581735921083, 0.18831520842355787, 0.2126654952338357, 0.42316178859172304, 0.3310432288785127, 0.3882219967224372, 0.3149996043211579, 0.3917027533270895, 0.3871082996628, 0.42700101282747116, 0.3960432824551986, 0.40086205241330386, 0.04564700861005222, 0.06906719151267948, 0.09308708622322481, 0.10277167572612766, 0.07840224243271443, 0.09434360983465906, 0.13064424541749342, 0.10390516050976317, 0.18403187598091042, 0.1976760589062776, 0.1978124509524033, 0.18537923407082912, 0.1757948355918565, 0.17662832093165104, 0.15971972309178495, 0.16186258949689325, 0.15341058865267443, 0.14541600539668453, 0.4774532727943117, 0.47344290157478564, 0.4807438205600121, 0.4994765672239243, 0.5016809036344267, 0.49820976340218126, 0.5543474294334788, 0.573386434769388, 0.5408715380989393, 0.12221236969320559, 0.12897898551897546, 0.14055224398833321, 0.13099836859402747, 0.11755514792706379, 0.14274537608919013, 0.1431754242922496, 0.12911022988621845, 0.1025359048045239, 0.33240896924968477, 0.438067939732822, 0.1921086509269878, 0.3165202968573074, 0.30509843593111385, 0.23529754961966853, 0.21769699029234824, 0.3475129079449609, 0.23604645452541595, 0.3358200680758916, 0.311993823368633, 0.322585709554845, 0.3772188518849271, 0.35555128517693924, 0.41676782700072146, 0.394960638261157, 0.4201758497135286, 0.4412666306268158, 0.26790283956037364, 0.29432850006237865, 0.29325792216535806, 0.24881371439220779, 0.24599131111845496, 0.29368425229832174, 0.37267133948633613, 0.3257965219009671, 0.2857105730784947, 0.24706427810099363, 0.25614034244311146, 0.2141368022837492, 0.22004844846685379, 0.2459958508134391, 0.1981468493049514, 0.20916461788125784, 0.22472953270525087, 0.20396547535479392, 0.21202392279376758, 0.2094293540966271, 0.34790591128125725, 0.24179605798469817, 0.21884930955555892, 0.21581564957421118, 0.46133933587305476, 0.24318213631106533, 0.2059294549014864, 0.1862472948932351, 0.18743300790596573, 0.20042406386038003, 0.8532009797430438, 0.20076218235282017, 0.8487239096860524, 0.14215326414299967, 0.1659361596453477, 0.8207624075059728, 0.8082483048804017, 0.7744108903890369, 0.7552702538443768, 0.7958636206756471, 0.7952129236395137, 0.8300292041809045, 0.7933695698183751, 0.8490328292531526, 0.8764450489256929, 0.18818618486047356, 0.1949737938610021, 0.18673747896387083, 0.21042919713744734, 0.1897847562763587, 0.18732674493487134, 0.1955450887181861, 0.18775460355141327, 0.20661004961699236, 0.09288410775599965, 0.09124234597400394, 0.09944508113503692, 0.09641249499954052, 0.09437539863438471, 0.109119862695636, 0.09675473094404097, 0.09236221459832394, 0.09836364914801488]}, "mutation_prompt": null}
{"id": "0efc6d05-e7fd-4a39-af57-8f85e8ac3ea3", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.epsilon = 1e-6\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_CR = self.CR * (1 - evaluations / self.budget)\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.hybrid_crossover(population[i], mutant, adaptive_CR)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def hybrid_crossover(self, target, mutant, adaptive_CR):\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = (np.where(cross_points, mutant, target) + target) / 2\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Adaptive Parameter Tuning and Hybrid Crossover for improved exploration and exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.19668362880067886, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9128324706131947, 0.5484866811111899, 0.5381803786182708, 0.18558871277908207, 0.5436563440561958, 0.5671588991809047, 0.48048325279163406, 0.4858271477482572, 0.33540568963758743, 0.029831131114191667, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0326310176708996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16606608526992672, 0.12140195472799731, 0.11152114498823462, 0.14169039271221495, 0.10690590416475731, 0.13124406881590311, 0.117532394346897, 0.12265779801208809, 0.13911721096008367, 0.10036198171133914, 0.07276042037709163, 0.10587189145623832, 0.10196321941134479, 0.09451232195861614, 0.06786637867917633, 0.1048959264352719, 0.08762873572843677, 0.07377099543199406, 0.09699210292830918, 0.06974976596167193, 0.06983012215212203, 0.07434022802389861, 0.06645439354173155, 0.0931323262380156, 0.08693101526507618, 0.07409222864117615, 0.11633111405780694, 0.16700829920367555, 0.15485614449930052, 0.03735566015128622, 0.16866326035708734, 0.10466852055503406, 0.1384708595597436, 0.1892945781409856, 0.11499473292975781, 0.25159828095111403, 0.22716836999917223, 0.2306216336989626, 0.17122312963030295, 0.38361832110365846, 0.21497084667857402, 0.11738241041642505, 0.12498141914938443, 0.15137487348931045, 0.19613985238924647, 0.3413597172640426, 0.1329788136529061, 0.12085421871060975, 0.19466601106293258, 0.18409324272030236, 9.999999999998899e-05, 0.15714800157966546, 0.12683033284943013, 0.18762790015814412, 0.178764686912389, 0.18539758450184274, 0.3934005874368648, 0.15202518747466565, 0.15679845109382184, 0.14561324022066924, 0.15097747948839368, 0.15110975517554848, 0.14777054443138604, 9.999999999998899e-05, 0.048976125488061406, 0.010976217493095075, 9.999999999998899e-05, 0.06077197361594677, 9.999999999998899e-05, 0.008511181665395218, 0.01198800541420364, 0.050163174116769405, 0.15150491146881107, 0.15936501591255414, 0.2271423894985558, 0.06784735102704431, 0.0650929436148121, 0.059261521821156404, 0.14642309398721376, 0.1993134014922674, 0.10463999378230604, 0.0597328286448765, 0.09579845037160795, 0.0731367705546232, 0.09574629364984089, 0.04023872055391253, 0.027570008373150268, 0.15866127340873393, 0.12478497837955549, 0.09453795571866486, 0.1687838474926513, 0.1298610289201062, 0.11212674332887596, 0.019445730627576596, 0.15416514314138008, 0.0862522373507929, 0.15355420289503474, 0.17539682649207933, 0.08983532881942591, 0.4442036550061387, 0.4181885758474394, 0.44575637312059735, 0.41854644623321724, 0.35657938278386014, 0.36860279862001977, 0.6090943608908055, 0.5022663491325898, 0.5189152563848165, 0.06610600888881202, 0.08057446865747153, 0.06636446061512158, 0.11676098221021824, 0.07727103882678332, 0.11723227124155366, 0.18301065875993217, 0.1373192059913525, 0.1417676183707849, 0.2954776488513766, 0.28514730950728595, 0.2794637132759954, 0.2839020096083441, 0.27455917197349766, 0.25631075561815675, 0.1680987087760495, 0.328802734565112, 0.19966811423901343, 0.2308167791024759, 0.19020468374327126, 0.3732432188976279, 0.38839771870088335, 0.5079112068968381, 0.3558566072528092, 0.23056618186270694, 0.5466268680298982, 0.2587800095859818, 0.1424426387781712, 0.2421738398969252, 0.2785317266150721, 0.2113815142546417, 0.27000363453269305, 0.2607545987275045, 0.24405495216589723, 0.2708174089879134, 0.14254516133586947, 0.24023560606078143, 0.2458752107965887, 0.258162038353011, 0.25537086298216904, 0.2475060436368367, 0.2607189559194274, 0.2330451055553775, 0.2262179540839706, 0.24158746559280897, 0.19261356690876907, 0.17706390886813372, 0.19549093317151356, 0.18209002296766874, 0.18562168160243864, 0.1880789081976605, 0.18115351259526147, 0.1779964273321888, 0.1734965784361957, 0.18722735180461303, 0.18769682498234885, 0.19544756258391793, 0.7836846144572727, 0.19950265951767865, 0.1981215679462125, 0.7799692454467563, 0.1586640051858167, 0.7693471441200835, 0.5135974054835267, 0.21168132396603312, 0.5253536702088171, 0.7941737859934932, 0.15477125207824705, 0.14695147699366695, 0.16731467908895448, 0.28602291965456084, 0.3727097237406837, 0.17997987402598903, 0.18088775140815516, 0.20097681888444885, 0.22856176581554233, 0.19398068079475383, 0.17989055519061803, 0.18025918192321333, 0.1798451467948574, 0.19095191703869074, 0.0937561212626884, 0.09397755404927122, 0.07222785889398364, 0.09247977676987507, 0.10132804441531951, 0.09719114119861538, 0.08636180780296798, 0.09851100057066087, 0.09261953635342635]}, "mutation_prompt": null}
{"id": "ad9de6e1-a5d3-4ad2-a1ad-2029ab0db21f", "solution": "import numpy as np\n\nclass QuantumEnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.quantum_rotation_probability = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if np.random.rand() < self.quantum_rotation_probability:\n                    population[i] = self.quantum_rotation(population[i])\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def quantum_rotation(self, individual):\n        theta = np.pi * np.random.rand(self.dim)\n        rotation_matrix = np.array([[np.cos(t), -np.sin(t)] for t in theta])\n        rotated = np.dot(individual - 0.5 * (self.lower_bound + self.upper_bound), rotation_matrix)\n        return np.clip(rotated, self.lower_bound, self.upper_bound)", "name": "QuantumEnhancedCoDE", "description": "Quantum-Inspired Enhanced CoDE with Adaptive Quantum Rotation Gates for Optimized Global Exploration and Local Exploitation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (2,) into shape (5,)').", "error": "ValueError('could not broadcast input array from shape (2,) into shape (5,)')", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {}, "mutation_prompt": null}
{"id": "8b4299cf-feb2-4f1d-9785-6a9f0fde5788", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Focused Local Search utilizing adaptive control parameters for improved diversity and convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9140144154502393, 0.9119945627520508, 0.9190897798008978, 0.91183608256894, 0.9099934843631299, 0.9170534853354243, 0.9144412295593287, 0.9106313387873125, 0.9183457873814755, 0.8221626814309245, 0.8316930638134689, 0.8365665558815685, 0.8139602453560706, 0.8441850165993527, 0.8435791257361398, 0.8216000793522638, 0.8366230790128206, 0.8315703592206858, 0.1562727598276772, 0.14853521215746512, 0.7340107814974344, 0.14199049984727685, 0.14040341417125912, 0.16343319872473805, 0.6416542947348762, 0.6205713229662903, 0.16531922607957472, 0.09653114009140318, 0.16789997913852894, 0.11555527222978546, 0.10340409431363662, 0.13976484683428114, 0.14384919099629057, 0.14939723964673868, 0.13853316238002966, 0.09597173410495996, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9684145992849261, 0.982778729149947, 0.9814455014854574, 0.7776381566806911, 0.7828908197824755, 0.7550543795346965, 0.7732181081806159, 0.763257744689845, 0.7785925425382032, 0.7828390809602553, 0.7761960490465973, 0.7880837824622238, 0.8958033916382943, 0.9089728042682071, 0.897306932004205, 0.2145208953141453, 0.9130049917349844, 0.9314575641438199, 0.9002612365869824, 0.2357195542223418, 0.9140814483316259, 0.6781616392234586, 0.7726299154170521, 0.8068940348646947, 0.13324633689313592, 0.134355819322183, 0.6854868627750555, 0.745195073745869, 0.7202088041309084, 0.7792292110307495, 0.667501390394101, 0.6220390767462909, 0.7183443577686486, 0.6666393748830828, 0.7597416655786837, 0.13333059901630373, 0.6947526891011317, 0.6440665737267919, 0.7564843156506976, 0.7219214224772751, 0.6514505274762656, 0.7155630986916027, 0.7441276908358543, 0.6635837017339519, 0.7354536157778895, 0.7335376239155936, 0.74416335160023, 0.7491947838751403, 0.8061174202538456, 0.7316088143875581, 0.7977572964550663, 0.7910263146637371, 0.7367622475231217, 0.7478701709662106, 0.819438022203814, 0.7958346688938099, 0.7758375258608818, 0.13953901005808278, 0.41679023782137936, 0.41970464690819653, 0.6920357331712953, 0.5771305562688457, 0.687832112587665, 0.37964541152330467, 0.17165850458485, 0.5275795294822287, 0.6798264233208281, 0.6892116525851382, 0.6573733914798237, 0.6796207240332753, 0.6835486752364, 0.6970572349782318, 0.6922451272010304, 0.6272253932222868, 0.6929565048480276, 0.8683845120612302, 0.8773353364383439, 0.8724317324197234, 0.8809029147480993, 0.8581481885015517, 0.8717744887032091, 0.8842012076373399, 0.86620319181741, 0.8543622787443149, 0.12238264936782417, 0.14714334456592282, 0.1438696125110024, 0.13996881123243365, 0.1185265250328914, 0.13324793815450153, 0.14796879484122505, 0.13149817737367697, 0.15354236766925, 0.22990443200647304, 0.335978142190701, 0.1971971087634724, 0.162314913063221, 0.695926281761061, 0.5628428692033431, 0.23275657014774553, 0.6374158975692874, 0.24721856617943228, 0.5425800441545645, 0.7482068137379894, 0.6170853051641343, 0.43098491796878247, 0.7414060234855564, 0.7347877316763609, 0.765320416676722, 0.7630797596703737, 0.762833986794512, 0.46631438852842866, 0.5344988597271308, 0.6111024110812985, 0.2162061717008874, 0.2688146909484531, 0.6181713961831257, 0.5271851160036427, 0.4398717449440952, 0.5373403741754874, 0.24539544319278894, 0.2568477478723393, 0.2141368022837492, 0.20688236742043453, 0.2311096097381411, 0.23955853848662023, 0.2137511228769131, 0.21868464095996276, 0.20396547535479392, 0.1958789312097804, 0.2461788520395477, 0.751768827258565, 0.22200384076392898, 0.21948163331466575, 0.699331468324087, 0.77256451611345, 0.24361536253111593, 0.20639795745525802, 0.186250858665455, 0.1874245165090409, 0.2002637007321325, 0.9040752897558364, 0.20082548497785913, 0.9211038627629997, 0.14217891224175894, 0.15888704095767403, 0.9322662959038613, 0.9226289950752073, 0.8896422389634291, 0.9236763374448232, 0.889793682539842, 0.8395360074315519, 0.9079968794431068, 0.8787830581909154, 0.8861041768593099, 0.9129953020899249, 0.18818618486047356, 0.1949737938610021, 0.1896757515299451, 0.21042919713744734, 0.18015268360911052, 0.2157964078665613, 0.20505536545627634, 0.18906603526188015, 0.18671831382675286, 0.09228323923882598, 0.08589067829090602, 0.07724837419405195, 0.09146151137325209, 0.09542196917319157, 0.109119862695636, 0.09675473094404097, 0.10080113136245616, 0.08834698828339826]}, "mutation_prompt": null}
{"id": "c6f55452-01b4-4d6c-a85b-ea8819ba062e", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_probability:\n                    strategy = np.random.choice(self.mutation_strategies)\n                else:\n                    strategy = self.mutation_current_to_pbest\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.1\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Adaptive CoDE with Multi-strategy Mutation and Stochastic Local Search for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 26, "fitness": 0.4383569765501894, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9091974729974415, 0.9018419361053495, 0.9069908065832029, 0.9033425120220565, 0.9038312542544956, 0.9010803641715426, 0.9020485702709682, 0.9046270755067903, 0.9037126302611984, 0.8149092228470997, 0.8155556424959806, 0.8147558498205001, 0.7659607946026873, 0.23930111852343228, 0.28269014888111144, 0.11918489042677538, 0.3805781753144776, 0.8199127011883177, 0.13715467432635797, 0.5392955914915785, 0.11447819476720655, 0.17897289674457062, 0.15095201074486542, 0.1518762247789337, 0.13787031561564178, 0.14658059779102495, 0.15732695109505146, 0.1143327030689274, 0.1215102267499868, 0.1323010514847358, 0.12789167544997238, 0.1484370770120308, 0.1289720565902187, 0.11160662089008455, 0.12862223313814136, 0.14116128302596576, 0.9688547613717078, 0.9444305645266391, 0.866523427466793, 0.21644917006164566, 0.8526210657954457, 0.8868254723624758, 0.8837028276332832, 0.9162306235596349, 0.8690634473420932, 0.4107569587041279, 0.3582000910400295, 0.5229764841933942, 0.3935971428176184, 0.35079742978274375, 0.38931141432780914, 0.5690009180569428, 0.5166929640995496, 0.3769964244091438, 0.9040849691096023, 0.8807069072404915, 0.8924767848372231, 0.8993784499678154, 0.9036052698813585, 0.9112490324985607, 0.8780037908586186, 0.878420340218919, 0.8830376023169253, 0.1853742667122249, 0.2272826853584634, 0.17122366454479399, 0.19461728091732855, 0.16960463693992112, 0.23138452548060084, 0.20218421342977433, 0.18302463526456147, 0.2117393504615327, 0.18402041761571863, 0.15489343063672656, 0.17094965899608994, 0.15640429298601266, 0.16480459444064433, 0.14784378793345165, 0.27204007983254963, 0.15960224234418163, 0.16085996677726633, 0.6626120917616429, 0.6392828497621194, 0.3426496692774931, 0.6930185840290247, 0.7025729674631315, 0.6657148308604497, 0.20067847272301542, 0.6844237525640233, 0.6708499713536084, 0.47655199040311835, 0.6961869270969201, 0.2915736373647927, 0.6999707218626414, 0.4087071299784143, 0.6693089833800354, 0.7324763867939856, 0.7226064112893195, 0.6953335495757558, 0.266879923970743, 0.22922960481927823, 0.20003364722044648, 0.591184963538709, 0.29472227589178657, 0.22192453445009086, 0.22527342267335249, 0.36040295076799433, 0.11662741442094426, 0.38669712003849, 0.5739801281913726, 0.6466681257490268, 0.6639908038562103, 0.48542833570093336, 0.48369834286468305, 0.6457123453010204, 0.6225860685569312, 0.40588146763369803, 0.8608208033410207, 0.8643716561408813, 0.8715821891104443, 0.8597815958671694, 0.8081898020087095, 0.8560749031055626, 0.7251625452971177, 0.8663065833928256, 0.8544080312128788, 0.5360907786495125, 0.1317850357306023, 0.14761153789058445, 0.14549253553157793, 0.2631708430709957, 0.12245905438380911, 0.14666202819885943, 0.13207464933380675, 0.1302907165838476, 0.15256450727765258, 0.2583423726415177, 0.20481095207162026, 0.16173590947168048, 0.25964927969163876, 0.17789945309379962, 0.1346650825588802, 0.17566627624311426, 0.13510944490791754, 0.6393716938113692, 0.662272545829808, 0.6509124342327364, 0.6654281470860448, 0.6426193817894241, 0.6319494352437358, 0.6642783284316905, 0.7062466911675531, 0.6385781118948115, 0.5461113831074002, 0.5305348895389514, 0.5277769049979912, 0.534208403722156, 0.5700007118071522, 0.5351027278016856, 0.2599150153066695, 0.5896980462965866, 0.4633193021415235, 0.24188406955323494, 0.258692170055868, 0.2161050671479724, 0.26101381279469116, 0.2505688420526515, 0.23462769786304216, 0.237682066276111, 0.21224262618239698, 0.23378948151180012, 0.2114303162897725, 0.22559809742160064, 0.23339345109312593, 0.23883272557008406, 0.2136647307381646, 0.2018760657393739, 0.21475031488425467, 0.2263706906499412, 0.20527451831892818, 0.1844986084378456, 0.8731416461723284, 0.15209363409023102, 0.9152648488844832, 0.8343878977958239, 0.19694360024121738, 0.1400157761731593, 0.7921902149936992, 0.823833343450083, 0.8800957602805305, 0.16782088761099057, 0.8743948864769493, 0.6927225539862956, 0.5071941552510286, 0.8606707377053973, 0.2075780414651649, 0.15548718264041705, 0.4623071806970086, 0.19124580868897334, 0.19429862951739807, 0.19222684853634542, 0.17454831273561844, 0.18041208359867755, 0.19714803766285183, 0.19841876966256344, 0.1827132423020803, 0.18685535227567862, 0.08752995774766148, 0.09862890856505635, 0.13471306189857002, 0.10041175485482146, 0.0996260497525211, 0.09122203753126557, 0.09651034345497955, 0.10198420088578364, 0.09092109428272566]}, "mutation_prompt": null}
{"id": "4cdfc9a2-e232-4bcc-9722-dd9702f69d3a", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR_min = 0.2\n        self.CR_max = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                CR = self.dynamic_crossover_rate(evaluations)\n                trial = self.crossover(population[i], mutant, CR)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def dynamic_crossover_rate(self, evaluations):\n        return self.CR_min + (self.CR_max - self.CR_min) * (evaluations / self.budget)\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Stochastic Gradient Perturbation for improved exploration and exploitation using dynamic crossover rates.", "configspace": "", "generation": 27, "fitness": 0.3590888709028737, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8175223612748346, 0.8355821189600393, 0.8336628964868025, 0.8239175778217069, 0.8169692009808082, 0.8312805166809749, 0.8166781738497441, 0.8256354789127338, 0.8140896783156311, 0.6683392587656071, 0.6626997066248386, 0.6785117601013935, 0.6713419274252349, 0.6913686166747941, 0.6823618191416028, 0.67652474937516, 0.6649432686913124, 0.6809728183341026, 0.5796960727659484, 0.5819672046207933, 0.5411790701414592, 0.591571335488706, 0.5415005648514717, 0.5678979740902673, 0.5705668470743328, 0.5803733312428485, 0.49979114959880144, 0.5053040456528044, 0.4690351101120026, 0.16302786215564136, 0.40395950176967643, 0.16386738178892335, 0.4186033043716537, 0.49298010100625234, 0.4374980906138737, 0.44112340158990293, 0.9411070076874462, 0.9494812493651699, 0.9431291449254092, 0.925218854876219, 0.9600184102916771, 0.9360228929583003, 0.9391811580875603, 0.9479979492536029, 0.9429778996949219, 0.43452561143139135, 0.40663114306309567, 0.427071647625468, 0.4758831968870051, 0.4521871544191369, 0.44694007879508113, 0.3839165920295601, 0.4192285255711172, 0.40463553741289626, 0.4908241829022403, 0.5568519828504179, 0.5263028031183112, 0.5657992433973897, 0.5901346238559357, 0.5271838675109716, 0.5810188657000201, 0.6243516078583944, 0.5582128433737312, 0.2186146087037808, 0.29962934576976596, 0.24471866373516193, 0.26176150359713124, 0.24136722211742512, 0.1986062059428787, 0.2508770317454978, 0.2553912334765006, 0.2505187606184127, 0.23875636910210252, 0.2051171706599827, 0.2132310420963065, 0.24020765271843036, 0.26498118004247617, 0.2500781130548313, 0.242015136787205, 0.265813909217825, 0.2691196714343156, 0.022862951740940884, 0.030133896395465265, 0.03377207035030694, 0.03991510746198057, 0.02219667678283843, 0.027406284250560353, 0.06055493374170351, 0.05390488466244192, 0.04871818613673129, 0.22771016159780677, 0.11626966734295985, 0.14261217297873996, 0.09917768495372925, 0.14231433012733163, 0.09886065617602913, 0.15294883005683135, 0.1186498795369072, 0.16366266843296795, 0.07178733515007829, 0.08467825163038545, 0.08778089100799646, 0.057273327352954206, 0.08725851945908858, 0.045087261752713714, 0.15718415411830555, 0.04606900093125643, 0.1355117257514088, 0.19138246975981088, 0.17347479680515665, 0.166238707139984, 0.19098878512381556, 0.19806735329136593, 0.18606658680439847, 0.16177558777818213, 0.17781771561460824, 0.15155476011671798, 0.5588409470753002, 0.5590003632853806, 0.5702332946042827, 0.5512878550710183, 0.577191643818744, 0.5449554160139052, 0.5747760476651134, 0.571247089371311, 0.56975559317868, 0.08940298183746331, 0.11455523472059448, 0.14197528087860223, 0.0953188411231285, 0.09636944204649733, 0.13905302996315727, 0.09905912862823774, 0.08870562988078379, 0.10585506210349371, 0.18363055050293464, 0.21057868679173397, 0.19188883576149707, 0.2594481067648109, 0.14474093979761837, 0.23416578822791634, 0.20534985794003857, 0.15185877527578162, 0.15262638687234853, 0.36824987973280354, 0.3818558262043126, 0.37299143860871165, 0.3836738871145603, 0.3679894005559985, 0.3916996382140411, 0.4302585813038333, 0.43888781482385764, 0.43236013789836547, 0.24059189387674562, 0.2688212571251263, 0.22828241211930245, 0.23986554951735983, 0.2911552413010575, 0.2839351349722621, 0.2647265714852576, 0.2826955887123155, 0.3143780414412851, 0.19838288035089158, 0.20082235196943898, 0.22460649831475998, 0.2175274543630642, 0.20652107222341043, 0.22092256727577786, 0.1894947969881774, 0.21073310940689804, 0.22221317308508592, 0.3811797208659734, 0.5123555766276742, 0.22845514873146255, 0.397353803065678, 0.2201288671318844, 0.40080927070791506, 0.30193083497800965, 0.2256310963317124, 0.46387576902464445, 0.6159566662023512, 0.5899355282154479, 0.6777330846682696, 0.6418862617345586, 0.1809535861828263, 0.6941322136790988, 0.619062748563252, 0.6091828699778321, 0.6040152996103714, 0.5217378074491386, 0.20600404338195144, 0.5183235482147408, 0.5207311265489674, 0.16181782697919966, 0.18485493530885055, 0.2043146251436032, 0.5263096074726936, 0.4481960236302336, 0.19909593690371974, 0.19370666234602074, 0.1882015264198963, 0.18644348876534378, 0.19840328633386384, 0.17697641953484833, 0.1984579255358796, 0.17988550942247783, 0.17770231180435547, 0.07968924750131923, 0.08181262436377712, 0.0839068178538831, 0.08197393209003945, 0.09039179354060911, 0.0974193917493007, 0.08671313939244207, 0.09058566627961195, 0.07779809114023306]}, "mutation_prompt": null}
{"id": "c3de6e1a-a744-470c-bc44-30e2db5dae10", "solution": "import numpy as np\n\nclass HybridCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest,\n            self.mutation_rand_2\n        ]\n        self.local_search_probability = 0.2\n        self.adaptive_local_search_step = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = self.mutation_strategies[np.random.randint(len(self.mutation_strategies))]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func, best_fitness)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_rand_2(self, population, best_individual, target_idx, fitness):\n        a, b, c, d, e = population[np.random.choice(self.population_size, 5, replace=False)]\n        mutant = a + self.F * (b - c + d - e)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func, best_fitness):\n        step_size = self.adaptive_local_search_step * (1 - np.exp(-abs(func(candidate) - best_fitness)))\n        neighbors = candidate + step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "HybridCoDE", "description": "Hybrid CoDE with Adaptive Local Search and Dynamic Strategy Selection for Enhanced Convergence.", "configspace": "", "generation": 28, "fitness": 0.4396684441254024, "feedback": "The algorithm HybridCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8440342216210917, 0.8408391627965934, 0.8737993072322503, 0.8509052156593513, 0.851048679279828, 0.8756597536379415, 0.8572313655500269, 0.8473297975365586, 0.8563334412053645, 0.7315644196258101, 0.7356452624232446, 0.7520077933968063, 0.7293167846270684, 0.7277876828802927, 0.7492446488054973, 0.7423433212437639, 0.7504709396266918, 0.76548051032359, 0.12576259286894043, 0.13580734935456618, 0.1438355762241792, 0.13411656447215392, 0.13045483624887588, 0.1321928813562676, 0.1257162490223076, 0.13024835165475923, 0.156808998892359, 0.10948380575197736, 0.14127770077404234, 0.1178163067293655, 0.1142298537778117, 0.10939730835107564, 0.10217916240438352, 0.1403593205267314, 0.13405264124074878, 0.12249214218147841, 0.9750922621817181, 0.9637232066212857, 0.9721242699293113, 0.9836828791931196, 0.982934978634954, 0.9558254607196195, 0.9697966551246922, 0.9595965697807813, 0.9674886425642939, 0.6187638381570439, 0.6088335707420081, 0.5750977089462495, 0.6116262135969747, 0.6005360074377453, 0.6459659599054415, 0.5987195920063872, 0.6002750027486444, 0.6318842404845701, 0.8143853332202811, 0.8622299065905569, 0.8550111364456423, 0.8279274846599496, 0.8742102412089722, 0.21137013871396504, 0.8346854922757099, 0.848397057533726, 0.8751670893595584, 0.4777087336380915, 0.5195576770425161, 0.538528591048022, 0.1257471194937929, 0.49030379806075397, 0.6049211182318701, 0.5109390993139806, 0.6198392742145258, 0.5214211212211708, 0.5341106619993522, 0.47562336903554314, 0.6409667791242433, 0.45518836944493557, 0.6101330244722847, 0.5840292386729757, 0.5160089521891692, 0.6101400083986627, 0.538637979389168, 0.49695053157757185, 0.49209413376936717, 0.4099025108404474, 0.5077312913301677, 0.4990763359272299, 0.560391655084735, 0.5027321334680406, 0.5276600283941435, 0.5251437136858637, 0.5639855128146793, 0.5469186505804784, 0.6115670735016325, 0.4894559275167887, 0.5154475305931498, 0.5932946839002908, 0.618293441432534, 0.61258832892471, 0.625896840012637, 0.20652503616109497, 0.2996182238492976, 0.151438621881419, 0.4635392759343424, 0.17275565492829537, 0.4229626137195027, 0.19953093669987287, 0.34906765399530937, 0.25380298211054986, 0.48977025330148194, 0.4939882755224154, 0.5107744538992001, 0.5288583053487728, 0.5281251143919294, 0.5206845636818769, 0.469724496933832, 0.43798044433652716, 0.4351452029794828, 0.7555657662298167, 0.7138298789597346, 0.7549040002120148, 0.7195526488340196, 0.733312444001831, 0.771507011443682, 0.7642910014632653, 0.7144323208317428, 0.7367416780910507, 0.10411731933460655, 0.12584244832841118, 0.10983830037487219, 0.12657584899635999, 0.14358761500669404, 0.14450431002481345, 0.16297491309198253, 0.09479565057568784, 0.3582215944325652, 0.2557729386658453, 0.17839016384139683, 0.31521641483746077, 0.24159358208107828, 0.13814768775636743, 0.18876778555493146, 0.24618698238784797, 0.2549021303237139, 0.16243729532065276, 0.5105726834331127, 0.5196990990610977, 0.5421078244935758, 0.4805235612374007, 0.5320890060527828, 0.5828057039332175, 0.5858019937846978, 0.529502274320522, 0.5633055425512257, 0.33852016551874586, 0.37511560742350913, 0.2552242457002678, 0.36951461318340206, 0.39759347765218855, 0.4082371129156006, 0.4376105461445614, 0.4775978868671725, 0.42163091207647785, 0.19489343264924608, 0.22511952766642518, 0.1860546806672816, 0.19948562782211832, 0.21905914233733892, 0.22694778152169448, 0.1964766625399611, 0.20467185320860326, 0.22158487247723935, 0.23371030292563633, 0.21637512836825867, 0.23788713088364488, 0.19727310659478692, 0.21439387024923706, 0.22069046119430902, 0.19784961265995094, 0.20052005231515646, 0.24053151262521866, 0.8757176047582214, 0.18352925973820777, 0.15325147486412716, 0.19554953076531822, 0.19633977833648553, 0.19875884959553292, 0.14082928378619075, 0.1335174332128114, 0.8403593257172693, 0.16761879312488948, 0.7139290250736163, 0.8432940815408432, 0.16419064542982598, 0.20719190591423597, 0.150479858432903, 0.19986459697307557, 0.20945457538414824, 0.8469129241602323, 0.195569845420143, 0.18247259752058886, 0.19859663961291552, 0.1879614523720039, 0.18646058199467552, 0.18510083294300916, 0.19105151374678886, 0.17583359591729386, 0.1719752127062949, 0.10123376673060225, 0.07810113979591571, 0.07603696268428906, 0.08943070459877833, 0.08014462464290995, 0.0849087767879162, 0.09444916573399931, 0.09130764605878428, 0.0801209428462436]}, "mutation_prompt": null}
{"id": "fe31aa01-b34c-4459-983c-72831c5da2e1", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE-based Differential Evolution with Focused Local Search utilizing adaptive control parameters for improved diversity and convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9140144154502393, 0.9119945627520508, 0.9190897798008978, 0.91183608256894, 0.9099934843631299, 0.9170534853354243, 0.9144412295593287, 0.9106313387873125, 0.9183457873814755, 0.8221626814309245, 0.8316930638134689, 0.8365665558815685, 0.8139602453560706, 0.8441850165993527, 0.8435791257361398, 0.8216000793522638, 0.8366230790128206, 0.8315703592206858, 0.1562727598276772, 0.14853521215746512, 0.7340107814974344, 0.14199049984727685, 0.14040341417125912, 0.16343319872473805, 0.6416542947348762, 0.6205713229662903, 0.16531922607957472, 0.09653114009140318, 0.16789997913852894, 0.11555527222978546, 0.10340409431363662, 0.13976484683428114, 0.14384919099629057, 0.14939723964673868, 0.13853316238002966, 0.09597173410495996, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9747357852267311, 0.9828979096370326, 0.977639260258256, 0.9684145992849261, 0.982778729149947, 0.9814455014854574, 0.7776381566806911, 0.7828908197824755, 0.7550543795346965, 0.7732181081806159, 0.763257744689845, 0.7785925425382032, 0.7828390809602553, 0.7761960490465973, 0.7880837824622238, 0.8958033916382943, 0.9089728042682071, 0.897306932004205, 0.2145208953141453, 0.9130049917349844, 0.9314575641438199, 0.9002612365869824, 0.2357195542223418, 0.9140814483316259, 0.6781616392234586, 0.7726299154170521, 0.8068940348646947, 0.13324633689313592, 0.134355819322183, 0.6854868627750555, 0.745195073745869, 0.7202088041309084, 0.7792292110307495, 0.667501390394101, 0.6220390767462909, 0.7183443577686486, 0.6666393748830828, 0.7597416655786837, 0.13333059901630373, 0.6947526891011317, 0.6440665737267919, 0.7564843156506976, 0.7219214224772751, 0.6514505274762656, 0.7155630986916027, 0.7441276908358543, 0.6635837017339519, 0.7354536157778895, 0.7335376239155936, 0.74416335160023, 0.7491947838751403, 0.8061174202538456, 0.7316088143875581, 0.7977572964550663, 0.7910263146637371, 0.7367622475231217, 0.7478701709662106, 0.819438022203814, 0.7958346688938099, 0.7758375258608818, 0.13953901005808278, 0.41679023782137936, 0.41970464690819653, 0.6920357331712953, 0.5771305562688457, 0.687832112587665, 0.37964541152330467, 0.17165850458485, 0.5275795294822287, 0.6798264233208281, 0.6892116525851382, 0.6573733914798237, 0.6796207240332753, 0.6835486752364, 0.6970572349782318, 0.6922451272010304, 0.6272253932222868, 0.6929565048480276, 0.8683845120612302, 0.8773353364383439, 0.8724317324197234, 0.8809029147480993, 0.8581481885015517, 0.8717744887032091, 0.8842012076373399, 0.86620319181741, 0.8543622787443149, 0.12238264936782417, 0.14714334456592282, 0.1438696125110024, 0.13996881123243365, 0.1185265250328914, 0.13324793815450153, 0.14796879484122505, 0.13149817737367697, 0.15354236766925, 0.22990443200647304, 0.335978142190701, 0.1971971087634724, 0.162314913063221, 0.695926281761061, 0.5628428692033431, 0.23275657014774553, 0.6374158975692874, 0.24721856617943228, 0.5425800441545645, 0.7482068137379894, 0.6170853051641343, 0.43098491796878247, 0.7414060234855564, 0.7347877316763609, 0.765320416676722, 0.7630797596703737, 0.762833986794512, 0.46631438852842866, 0.5344988597271308, 0.6111024110812985, 0.2162061717008874, 0.2688146909484531, 0.6181713961831257, 0.5271851160036427, 0.4398717449440952, 0.5373403741754874, 0.24539544319278894, 0.2568477478723393, 0.2141368022837492, 0.20688236742043453, 0.2311096097381411, 0.23955853848662023, 0.2137511228769131, 0.21868464095996276, 0.20396547535479392, 0.1958789312097804, 0.2461788520395477, 0.751768827258565, 0.22200384076392898, 0.21948163331466575, 0.699331468324087, 0.77256451611345, 0.24361536253111593, 0.20639795745525802, 0.186250858665455, 0.1874245165090409, 0.2002637007321325, 0.9040752897558364, 0.20082548497785913, 0.9211038627629997, 0.14217891224175894, 0.15888704095767403, 0.9322662959038613, 0.9226289950752073, 0.8896422389634291, 0.9236763374448232, 0.889793682539842, 0.8395360074315519, 0.9079968794431068, 0.8787830581909154, 0.8861041768593099, 0.9129953020899249, 0.18818618486047356, 0.1949737938610021, 0.1896757515299451, 0.21042919713744734, 0.18015268360911052, 0.2157964078665613, 0.20505536545627634, 0.18906603526188015, 0.18671831382675286, 0.09228323923882598, 0.08589067829090602, 0.07724837419405195, 0.09146151137325209, 0.09542196917319157, 0.109119862695636, 0.09675473094404097, 0.10080113136245616, 0.08834698828339826]}, "mutation_prompt": null}
{"id": "ad2bd035-cf37-46ca-a215-5e964ca99450", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_local_search_probability = 0.2  # Adaptive local search probability\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = np.random.uniform(0.01, 0.1)  # Dynamic step size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE-based Differential Evolution with Dynamic Parameter Tuning and Adaptive Local Search for Enhanced Global Search and Convergence.", "configspace": "", "generation": 30, "fitness": 0.530436408811506, "feedback": "The algorithm AdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9208721017736031, 0.9179007722227075, 0.9169999162807793, 0.9171954275317024, 0.9223653354892263, 0.9207696693847055, 0.9133243056415716, 0.9135397711315535, 0.9181631155915869, 0.8255842763699665, 0.8216650937616495, 0.825575210143835, 0.8380683738539049, 0.8428095673514974, 0.831570010891262, 0.8104881153137389, 0.8256800135079545, 0.8379761055786858, 0.16199197977273494, 0.1728346250487781, 0.1542199732081404, 0.7065977769295907, 0.16185274438838637, 0.14356572745093998, 0.5173523332383061, 0.4393320559986915, 0.16882551911951793, 0.13959495175933767, 0.13810527537354866, 0.1342580629492378, 0.11340931851037717, 0.14183216198156512, 0.11045136629035646, 0.141786730506537, 0.15111566718315894, 0.13024342574107017, 0.9896619221271135, 0.9913711903573187, 0.9811180942073268, 0.9759715627103969, 0.9710397702150081, 0.9786870985971372, 0.9811004574591202, 0.9581127311683794, 0.9880384659581934, 0.7724619146311875, 0.7694714685225589, 0.7482394923939454, 0.7704801106598385, 0.7847736488998744, 0.7793532064480159, 0.7666394974088601, 0.7810042320272814, 0.7639123955863587, 0.9093192529260089, 0.9122715130271174, 0.8952454478738829, 0.9057146967103639, 0.27760997607144833, 0.22006365994923027, 0.9113217577728765, 0.9086262343262049, 0.21908401855386517, 0.694330162456209, 0.6619843059077044, 0.7143074114696784, 0.7188807923045757, 0.7353024606706963, 0.7349902148907692, 0.6649152497008731, 0.8124170387362588, 0.7843260911515177, 0.1343462692704095, 0.7141698316669218, 0.1289587168140075, 0.7291893706298406, 0.737934400629378, 0.8247227387443791, 0.7310712137904106, 0.13331108293085914, 0.1318183565424348, 0.576151892309292, 0.6776968510807153, 0.5407593986361439, 0.7162294137894449, 0.7304058371218236, 0.7082071365757907, 0.7273787902269323, 0.7208099915576877, 0.7225813304440751, 0.7994119408256635, 0.7640174128010286, 0.7218748885003036, 0.758361608883337, 0.7495489189397768, 0.7518107248506288, 0.7779691705324233, 0.7677648106139849, 0.8048266630711212, 0.5533033393756775, 0.2736803060690356, 0.5614306183636253, 0.4711525854319598, 0.59662547510795, 0.5805668807917661, 0.13477942964939083, 0.15185080995838274, 0.32885710554954817, 0.705458519563214, 0.6656255712799678, 0.6805842565935323, 0.7067662173820513, 0.6795665439256044, 0.6923711483829327, 0.6681337711305846, 0.6209063406278421, 0.6567544037556532, 0.8775059014049595, 0.857512575934227, 0.8799837399664343, 0.8643826427064634, 0.8773136030591385, 0.8665130868458286, 0.8724963106189303, 0.8720733955439964, 0.8486529901720955, 0.12003730981360927, 0.12894519526651527, 0.1545113857049618, 0.13400857482657047, 0.10438737364807926, 0.13088932903753048, 0.5409820001191858, 0.14650470736346144, 0.12712304416281694, 0.23392919926395384, 0.7576043746800979, 0.6210291766420717, 0.47417181280210086, 0.6002974643923975, 0.38719478204933344, 0.30861826169603823, 0.6307527722555748, 0.29394981405564014, 0.4930215910167898, 0.740593903594567, 0.7476327427533691, 0.7210779383407773, 0.6397180468569799, 0.7023134417136916, 0.6134535405113614, 0.7614213921018455, 0.7593129807859763, 0.487301526228764, 0.529465775086337, 0.1747857529680119, 0.6712146174107682, 0.5035571419013074, 0.48675417812953115, 0.6023957892728147, 0.5050062812969685, 0.5571497106220901, 0.20558153018889602, 0.20949713118131041, 0.21687475547516544, 0.26034847380475934, 0.22883723148115387, 0.19945573003546324, 0.23382531098146742, 0.21853807393067304, 0.2368430037689554, 0.20215125271530043, 0.7874112933119424, 0.2455419654552543, 0.19351851889780525, 0.20994147065533264, 0.20854615488445227, 0.22353391492362384, 0.22173475430918865, 0.24469702014340045, 0.1642898418050447, 0.9010732120739181, 0.20069894169582192, 0.9349788865556032, 0.20031276605515824, 0.1690499083622823, 0.14247372592808294, 0.15888616393944865, 0.9340641544399664, 0.919856376016159, 0.21104139887177564, 0.90670337309925, 0.1119824683481333, 0.8502320085755806, 0.15676917352385067, 0.10489179003108584, 0.10500505714514696, 0.9013738759491655, 0.20695350644510224, 0.17794243693567569, 0.2000809422383396, 0.17535923198270864, 0.18151928259879802, 0.18208801867920155, 0.17997384157531693, 0.19250909205524702, 0.18610092841685633, 0.09570392956642626, 0.09672976010278656, 0.09774308199481185, 0.10050104734735121, 0.09267848394336575, 0.11709836030481569, 0.08658652578043002, 0.08703019674055068, 0.09975124752900844]}, "mutation_prompt": null}
{"id": "1b84e09f-5b7b-4816-947b-fb41d5b0cd11", "solution": "import numpy as np\n\nclass ImprovedEnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F_min = 0.4\n        self.F_max = 0.9\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.05  # Adjusted local search probability\n        self.local_search_decay = 0.99  # Decay factor for local search probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        self.evaluations = self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                F = self.adaptive_mutation_factor(fitness[i], best_fitness)\n                mutant = strategy(population, best_individual, i, fitness, F)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    self.evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.local_search_probability *= self.local_search_decay\n\n        return best_individual, best_fitness\n\n    def adaptive_mutation_factor(self, fitness_i, best_fitness):\n        return self.F_min + (self.F_max - self.F_min) * np.exp(-5 * abs(fitness_i - best_fitness))\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness, F):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness, F):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness, F):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + F * (p_best - population[target_idx]) + F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "ImprovedEnhancedCoDE", "description": "Improved EnhancedCoDE with adaptive mutation factor and dynamic local search for balanced exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.4539626152056058, "feedback": "The algorithm ImprovedEnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8340780573794543, 0.8263502332712496, 0.8402589523569463, 0.8453189174680804, 0.8329149806378482, 0.8347323541688827, 0.8315722602234222, 0.8268528104864966, 0.8369819887296803, 0.7668482011449431, 0.7295382718821144, 0.772918834560818, 0.7586006968112708, 0.7656335040490808, 0.7725150618804044, 0.7786926101263014, 0.7395322857845201, 0.7826530547325463, 0.15742026098044537, 0.6511270703471366, 0.11518763771217688, 0.180060088194112, 0.15487989791016843, 0.11099341995352585, 0.11577563065085383, 0.11952426408292538, 0.15780965681955716, 0.11378486098676988, 0.1033276194711461, 0.12079379226535969, 0.14176547653362015, 0.13882529059308746, 0.08104729519591214, 0.14182646992626724, 0.1312049569778575, 0.14024427508653137, 0.9902966914824336, 0.9914426383045497, 0.9899414306729257, 0.9629686444111969, 0.9692234182943661, 0.9702421831097706, 0.9893790081817567, 0.9810775708223721, 0.9847845525412007, 0.6148539430338492, 0.6007356053522102, 0.5937596858659807, 0.5907539338242398, 0.5815698892289365, 0.5672487342167059, 0.6115140758613956, 0.5957805804328067, 0.6198083603742318, 0.8966132028855124, 0.886623986987422, 0.8730891367600804, 0.8459768900649414, 0.21561140565150438, 0.22195476197268282, 0.22425697305797965, 0.8901804403662851, 0.2356313418562922, 0.5744435018952041, 0.648708124828205, 0.605648791459641, 0.13426573094770244, 0.6207165471412897, 0.5647702055047892, 0.6832272886684934, 0.6370807252697688, 0.6209602308186994, 0.6224586036525841, 0.5434204070502979, 0.13573393694293767, 0.5872885798732761, 0.6017594874939831, 0.599252317173971, 0.6487744989974731, 0.6016563253729564, 0.13343488894013367, 0.6040884580899555, 0.6005689470968063, 0.4298071033199823, 0.6071498097490596, 0.5560486785369025, 0.534469647911264, 0.5996603881065221, 0.6026822798677411, 0.519412286783041, 0.6841445123448205, 0.5927810276635245, 0.6599239216710984, 0.5904490725397742, 0.6295898184903661, 0.6776994654503342, 0.6831194172213219, 0.6764054200227956, 0.5987128327752581, 0.27762916696655915, 0.30043946304044133, 0.3468418846652157, 0.5731426323436579, 0.3661745226891103, 0.38698235954507276, 0.38703110701932264, 0.381437083069341, 0.3911251957555759, 0.44309731313762224, 0.47423754734473145, 0.4735913271111415, 0.48545231340192374, 0.4745273581328514, 0.4514559291765947, 0.4309583788209781, 0.47769517723845933, 0.4449100651393495, 0.648237652271405, 0.7108122806293786, 0.7243597000314925, 0.6653018590821334, 0.6810531854283178, 0.6913446201179747, 0.7097932451587481, 0.7025670215165538, 0.7110161107290573, 0.10194351031487492, 0.14320948678700662, 0.15207982341950788, 0.10885453414482815, 0.14349129557711515, 0.13359331424950238, 0.1459807756077085, 0.1519948508158896, 0.1191851513522697, 0.46337802976009956, 0.23211986421799902, 0.32849465363944785, 0.5270475446114808, 0.2333253443283485, 0.6313960790983189, 0.652471876306012, 0.5697048268546365, 0.5662184660290934, 0.441314779301627, 0.4570486331345147, 0.48307233535528316, 0.4920571737706462, 0.4818544705209905, 0.4543588592982908, 0.4791148858325479, 0.5249262915516821, 0.24896690944055444, 0.2192577315169275, 0.4315296264222367, 0.4576478836410449, 0.17930167552789766, 0.4183392343941944, 0.4388357645200829, 0.3981793037676673, 0.4438530218597627, 0.25262003781802145, 0.2183718814934409, 0.2080037016915629, 0.23910488188878043, 0.21698799226468468, 0.20667414572764842, 0.22686405618818184, 0.2374162276359717, 0.20718875782505297, 0.22415666486530839, 0.2261205710018589, 0.2231469592269698, 0.21309289642705143, 0.18515082793312254, 0.21455275283527508, 0.19747537650148916, 0.21064799282854663, 0.20724977587775195, 0.24599663395966498, 0.1865040780116115, 0.18484055080927042, 0.1538397723144177, 0.9116026881919513, 0.1672020851838908, 0.20113372455098055, 0.8904094920737303, 0.1589246816980303, 0.8760283533696089, 0.8617206008534284, 0.21259834014963297, 0.07357534041067393, 0.8717780953048588, 0.8775859620912805, 0.16913800968582782, 0.10496013545776672, 0.8545671927981335, 0.15624102291179043, 0.1791357722556901, 0.19916635823670936, 0.177991927562122, 0.18339363088593608, 0.19605096960630874, 0.18261596182314233, 0.18294580076396327, 0.19535365493843415, 0.20078901946178973, 0.11364325395786201, 0.11095628879861197, 0.09291666296249945, 0.0908543928565907, 0.08858895653385357, 0.0942047248516561, 0.09086279245130024, 0.08965459476943904, 0.0907419506374707]}, "mutation_prompt": null}
{"id": "eed2a49c-46e6-46c8-93d0-887f7c645454", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.successful_mutations = []\n        self.F_adaptive = 0.5\n        self.CR_adaptive = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if len(self.successful_mutations) > 0:\n                    self.F_adaptive = np.mean(self.successful_mutations) * (1.0 + np.random.randn() * 0.1)\n                    self.CR_adaptive = np.mean(self.successful_mutations) * (1.0 + np.random.randn() * 0.1)\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(self.F)\n                    self.successful_mutations = self.successful_mutations[-100:]  # Keep track of recent successes\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F_adaptive * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F_adaptive * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F_adaptive * (p_best - population[target_idx]) + self.F_adaptive * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR_adaptive\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE with Adaptive Parameter Control using Success-Based Learning for Improved Performance and Exploration.", "configspace": "", "generation": 32, "fitness": 0.3505817541071856, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8470203101498557, 0.864944186247138, 0.8498284233030801, 0.8543163717210475, 0.8589943317809556, 0.8529924409636289, 0.8564510492416982, 0.8632556065523762, 0.864145127205057, 0.7394265965360409, 0.7328073807750661, 0.7378366393105118, 0.717944248337713, 0.7232923022325553, 0.7295734654657169, 0.708425942157952, 0.7473784099536394, 0.7260459660529432, 0.5805635356238357, 0.3920044566956983, 0.5410390797849893, 0.5703173944269695, 0.49887850859529037, 0.5649695486529627, 0.514173868902369, 0.5877704897377648, 0.5620593572973569, 0.4266646382881093, 0.16685961099277502, 0.16773246980110068, 0.1620002997547756, 0.16785030298674664, 0.15943948339388714, 0.1592291194621177, 0.48912046723996194, 0.16822913878959267, 0.9535405965393222, 0.9494361244350917, 0.9774835053362794, 0.9555933039606863, 0.9750767116052305, 0.9662241465222781, 0.9344137018489395, 0.9718134073788219, 0.9633519216061873, 0.46966220960474503, 0.45803650933637496, 0.46396567036663516, 0.5116241636189645, 0.4614624826497836, 0.49368131339727417, 0.4085936667256488, 0.38128329543162875, 0.4026834463395348, 0.6224885436469079, 0.6070425030268904, 0.6686921018749721, 0.5791486744219431, 0.6693566667857742, 0.728696630129952, 0.6890321217879811, 0.5659496376074129, 0.7191383038486294, 0.21621659182584563, 0.22030916324875038, 0.19260913695633153, 0.1866740708663387, 0.19425551671653496, 0.18005527985054648, 0.25370774466958124, 0.19819976822221974, 0.2192378469827393, 0.1957861389767669, 0.20280755626337477, 0.19594259979870043, 0.1689808861880563, 0.22918467210451632, 0.2156514733357755, 0.25203960660287217, 0.20614600780129655, 0.2872493758058172, 0.019220613243938756, 0.011978434521434767, 0.005011963723872803, 0.008748861940092278, 0.04260214492833003, 0.00019346478074022677, 0.028539844078773968, 9.999999999998899e-05, 0.00449942531635128, 0.08918899633273902, 0.11445513083940861, 0.10310852602128706, 0.08152067532474283, 0.06939997284491417, 0.12437260676007011, 0.14579627540963025, 0.10752587328396823, 0.08933432104690164, 0.04187891313062897, 0.025194005091233374, 0.030352407679085314, 0.07499495253425681, 0.0024481671620840695, 0.010707545208754388, 0.03789410792776493, 0.09873742988257805, 0.09913712560369425, 0.15470104202670232, 0.15406536813279903, 0.19199759811286043, 0.1942472926854567, 0.1883306093953795, 0.16331676822069108, 0.16660852405888527, 0.16345072976602892, 0.1565486692829352, 0.5509690543007214, 0.5441475353998753, 0.5493902144848734, 0.5520413844460694, 0.5176756589936902, 0.5489235139137383, 0.5767844020553154, 0.5536782130477342, 0.567322391135632, 0.10627676472300063, 0.12447181473197266, 0.10076211544309621, 0.10653731296459867, 0.10150506826715844, 0.09768362817356158, 0.11990919921080145, 0.12378892357957771, 0.12920997652961308, 0.1440265852666256, 0.17507037781576618, 0.1634855850124035, 0.2254960013077142, 0.1833396963735271, 0.1405123854358863, 0.13698542254326018, 0.17430650254596058, 0.16720827999270915, 0.4298331085628052, 0.3676158361265469, 0.3991005781799175, 0.37642020768516626, 0.40365719456836946, 0.43340175694254846, 0.4734190946690833, 0.46846136144911343, 0.4475774924483822, 0.306097474593262, 0.2718401592276304, 0.28616583969467846, 0.2713825976953155, 0.22300650636466612, 0.28319885951922974, 0.3079423944647869, 0.3039486833667725, 0.3019796257152566, 0.2436060771973182, 0.20323926867027098, 0.21381957470960633, 0.20995793195404577, 0.22252204925668273, 0.21659431110187144, 0.1995681012897791, 0.2350877581441203, 0.22357106092094892, 0.20540309029543935, 0.21846159307653035, 0.22634204626540777, 0.2380034554255247, 0.4583480634555591, 0.4427619349881533, 0.23403529061856676, 0.5559289125276008, 0.2289730154191928, 0.6902362335068566, 0.1830513359949707, 0.18340624304552133, 0.711737476991271, 0.19613807897865576, 0.8105694426813116, 0.7201822706129337, 0.19834933889729012, 0.7799617216809727, 0.5080977260597146, 0.4316574606351873, 0.4888723312595673, 0.5354114907500174, 0.4377431594588417, 0.20360273754093483, 0.5086889720240635, 0.15388512214312322, 0.4326777218113069, 0.17360116988521113, 0.17915816719251876, 0.19227245416614902, 0.1748562737871069, 0.17790735478410147, 0.18539617788194895, 0.17165701421494772, 0.17528953867681907, 0.1895371332843966, 0.08431358138024514, 0.08726681042307205, 0.08925736846077748, 0.09140879856969863, 0.09609408032698796, 0.0896201470733935, 0.09383626692070923, 0.0880833232314222, 0.08274029777276937]}, "mutation_prompt": null}
{"id": "77f8ca49-0b88-4687-864d-59871c786551", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15\n        self.dynamic_population_adjustment = True\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            if self.dynamic_population_adjustment:\n                self.adjust_population(fitness)\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n    \n    def adjust_population(self, fitness):\n        median_fitness = np.median(fitness)\n        if np.mean(fitness) > median_fitness:\n            self.population_size = max(10, self.population_size - 1)\n        else:\n            self.population_size = min(100, self.population_size + 1)", "name": "AdaptiveCoDE", "description": "Adaptive Differential Evolution with Strategic Local Search and Dynamic Population Management for enhanced exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 45').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 45')", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {}, "mutation_prompt": null}
{"id": "4fbd824a-cf2b-475a-b48f-31a200ca66ab", "solution": "import numpy as np\n\nclass ECoDE_GLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.guided_search_probability = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if np.random.rand() < self.guided_search_probability:\n                    guided_candidate, guided_fitness = self.guided_search(trial, func, best_individual)\n                    evaluations += 1\n                    if guided_fitness < trial_fitness:\n                        population[i] = guided_candidate\n                        fitness[i] = guided_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def guided_search(self, candidate, func, best_individual):\n        step_size = 0.05\n        direction = best_individual - candidate\n        perturbation = step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        guided_candidate = candidate + direction + perturbation\n        guided_candidate = np.clip(guided_candidate, self.lower_bound, self.upper_bound)\n        guided_fitness = func(guided_candidate)\n        return guided_candidate, guided_fitness", "name": "ECoDE_GLS", "description": "ECoDE-GLS integrates an Enhanced CoDE-based Differential Evolution with Guided Local Search for improved exploration-exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.5126475636029056, "feedback": "The algorithm ECoDE_GLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.32.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9109897449164058, 0.9250191635208647, 0.922479558715016, 0.913341624202046, 0.9305696052563984, 0.922147956349462, 0.9159920155183671, 0.917157227882887, 0.9102692839783432, 0.8429126149155779, 0.8336850273115772, 0.8190080837512602, 0.838357984475733, 0.8009307567395705, 0.837765609705538, 0.824105945862194, 0.835423655867299, 0.8223255543696683, 0.1598493525876422, 0.18954166483046408, 0.1453552600417164, 0.15620419019909781, 0.1624510857897552, 0.1331560972714586, 0.1569454032642148, 0.12522745871034713, 0.19044987476529274, 0.12043505208960537, 0.05668424063937494, 0.11268543745240145, 0.15837224746064693, 0.08277921667306942, 0.08021480595773423, 0.7791415024490018, 0.14692008400376566, 0.12389312271411868, 0.9691807558146575, 0.9640086345195004, 0.9802142448662227, 0.964461881848917, 0.9648517247502766, 0.9830928865713975, 0.9752587254029925, 0.9902876941388384, 0.9842064975993243, 0.7633945042618826, 0.7683525913726463, 0.804739294208327, 0.7582571190869238, 0.7854603759618567, 0.7851854342142854, 0.7579188638913814, 0.789616186905652, 0.7983676024286833, 0.9160619952929987, 0.9290630075731058, 0.9332692896263691, 0.9121216436981495, 0.9235950834230305, 0.9046804265302032, 0.9215757336607688, 0.23584288321822988, 0.896429836117501, 0.7683903373681611, 0.13456961539575563, 0.769727071609584, 0.13390938674335828, 0.8201606881992778, 0.7352680264003224, 0.7335429460647342, 0.8396732922313009, 0.13534054261200235, 0.7093974856949437, 0.7183895980417812, 0.6806507452301678, 0.7312786076594349, 0.8009956962696754, 0.7711254425076206, 0.7267372211061153, 0.6944501882979971, 0.7796572157109449, 0.715661340615976, 0.5714359091748413, 0.24812507623566105, 0.7369850264419932, 0.731812114132679, 0.7231807073963926, 0.7190283739806622, 0.672388771167865, 0.6281544018915379, 0.7668830667404973, 0.7173856751780169, 0.799777420268146, 0.7578722109375821, 0.3943359935771811, 0.8081535263726816, 0.7860790080518253, 0.7990861009814787, 0.8116271315561523, 0.17927911079213832, 0.22830944882099902, 0.19230943558456604, 0.6608729930361231, 0.34094730508232873, 0.2304630590642791, 0.4001320799352813, 0.1334618900277743, 0.23132195007454648, 0.6532909541300465, 0.666712778498667, 0.6360628955120842, 0.6617449622610376, 0.6508130317486607, 0.650175154298712, 0.6216708848063028, 0.6243139887414011, 0.6808929454348899, 0.8706387620894225, 0.863662245152437, 0.8798395233240807, 0.8844672576380713, 0.8709275962641428, 0.875117006732189, 0.8758964092789011, 0.8769242478620686, 0.8865438332445539, 0.1322501900377704, 0.11257139298127528, 0.13355774307957635, 0.186148103777803, 0.09065946204890774, 0.1111575427466287, 0.16160457798082517, 0.15842036036569263, 0.12499902197887591, 0.23111551691509946, 0.20967613783304506, 0.24077302621801877, 0.20585084387309383, 0.2819586545357826, 0.20231362174946887, 0.7997200070925177, 0.24333577361960357, 0.18974136109745765, 0.5766063594893295, 0.7616745817606417, 0.5815376137158212, 0.7152074563190016, 0.7349643499507008, 0.4829356867987624, 0.7481179128480924, 0.7742417982829374, 0.6486648815642748, 0.5537666129668903, 0.6356715229003731, 0.6121372514599197, 0.6257406803512726, 0.26390129030901, 0.6875585128138482, 0.6926313151351187, 0.33488096650254107, 0.6089613119635012, 0.22331654147765756, 0.22804600369871075, 0.22094391919045497, 0.21325327793524718, 0.20527930916156067, 0.24000317168526764, 0.19298251378366127, 0.22329849464466356, 0.21488114607625952, 0.189444117756439, 0.1870842379488007, 0.20436675727522768, 0.2164217404518759, 0.19770586363902254, 0.18337818554095242, 0.19253284444256435, 0.1921408051186042, 0.19902285709075873, 0.16560566117821163, 0.1854391041111968, 0.1879270876440221, 0.9367872295574957, 0.20031953137415826, 0.19944210180252142, 0.9225331826054322, 0.21148720901362505, 0.21262090335900785, 0.9336329606843826, 0.21260223792707533, 0.9003929811333438, 0.8926664721393816, 0.16832547018075406, 0.15546980545400124, 0.10458899810873468, 0.12772737313462545, 0.10455168827072048, 0.19368249414889271, 0.20428091078808452, 0.19719301760444696, 0.22088222784970757, 0.18603020639734358, 0.18381722999107608, 0.19970006601980173, 0.22219817034370104, 0.2036000834004278, 0.09736976515398343, 0.1051157617381352, 0.1057590231761405, 0.13182169513125974, 0.0961289936468358, 0.09595017633214742, 0.12789764397515901, 0.08996649131273282, 0.10889441505575381]}, "mutation_prompt": null}
{"id": "e7573074-ba68-48fe-ad1b-70d15d423f59", "solution": "import numpy as np\n\nclass ImprovedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_F_CR_enabled = True\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                if self.adaptive_F_CR_enabled:\n                    self.F = 0.1 + 0.9 * np.random.rand()  # Adapt F\n                    self.CR = 0.1 + 0.9 * np.random.rand()  # Adapt CR\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = 0.01\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "ImprovedCoDE", "description": "Improved Differential Evolution with Adaptive Mutation Strategies and Advanced Local Search for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 35, "fitness": 0.39628180476803315, "feedback": "The algorithm ImprovedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8720489401337077, 0.8665022044500984, 0.8557023091173335, 0.8621995064152409, 0.8627445084161606, 0.8532462745094338, 0.8567062525332672, 0.8622077440679461, 0.8490150395650498, 0.7136667940046195, 0.7436786994890155, 0.7487205115735365, 0.7582244206439898, 0.735981125161986, 0.7212298289135133, 0.7359306315335925, 0.7399352137310866, 0.7359303927636509, 0.4609444222927451, 0.5282623263924897, 0.5465240161834339, 0.438547416383288, 0.4424386385151009, 0.5426722210851764, 0.5909630486544044, 0.47306973108393635, 0.521975150200314, 0.4675180089098758, 0.17396091319754703, 0.15172659888807938, 0.1462250624245356, 0.14642310666599556, 0.4882407196648655, 0.5254134709233439, 0.1517914274954224, 0.13691371491506565, 0.9716598116500939, 0.9515231917673674, 0.981311511869517, 0.9609437907281277, 0.9708755572148248, 0.9817272342177378, 0.9819456135951984, 0.9862749463805561, 0.9666673922238753, 0.5861068613396733, 0.515554319347876, 0.5642819892731327, 0.5827922845215532, 0.5720098709602011, 0.5627997482925429, 0.5545875885049132, 0.4961389105152345, 0.530726758374658, 0.7977544925918459, 0.8116677928448601, 0.3671274185919161, 0.7848960477621858, 0.27320639615614484, 0.2761347886852553, 0.7930129036184634, 0.7525287894339935, 0.8073588080841527, 0.11993212344827264, 0.3435254841605927, 0.35624429593822926, 0.12746784704064917, 0.23513570474534595, 0.39842857343812044, 0.41631996604060184, 0.33944602378867417, 0.40988155239190516, 0.3209563366339251, 0.25552211836086103, 0.36097233268501683, 0.33721739013020857, 0.3110746096766186, 0.30546168065745927, 0.36387913294563545, 0.3298660074129959, 0.2594123899010934, 0.09024426258660989, 0.15394065676440483, 0.05134087763940698, 0.14223127411523417, 0.11229090818141862, 0.12206084228088798, 0.0529454165694615, 0.06496669216289375, 0.05203991507845018, 0.1306405188532801, 0.23340525374583898, 0.21694138496763282, 0.23415131844094916, 0.1535381191138817, 0.16514966039383105, 0.1664312882348007, 0.18650405081814048, 0.21221413413046541, 0.1637780808130569, 0.19874641699312, 0.1448513326961054, 0.16248152623000534, 0.16612484465440303, 0.10848912276945122, 0.10635397595431495, 0.12572699749141225, 0.13541771998746444, 0.21790001798244962, 0.2532485591375391, 0.22907669832184185, 0.2765394101423362, 0.27369282956435015, 0.2420791840240044, 0.21669741159417266, 0.2144736799332534, 0.2008410773798105, 0.6572475507048268, 0.6592040212596304, 0.6733876556305649, 0.6783401612113222, 0.6098196594565093, 0.6452102185541735, 0.6804347078462243, 0.7220771741975034, 0.6761775020517147, 0.12295134162920207, 0.12887288176480083, 0.10049986395428656, 0.12443220836490854, 0.1286957602664468, 0.10511886188635267, 0.10895680118055828, 0.11210493865578841, 0.13952073483017136, 0.2675975262992287, 0.20542814917201535, 0.47577805557815644, 0.14591623342798432, 0.18461400145511142, 0.1642315531266264, 0.15040605137240892, 0.29711252485969875, 0.1410440008916738, 0.45479580692755694, 0.49094200957627865, 0.47671872142671845, 0.43200557077443547, 0.4935243650670108, 0.4653785156262641, 0.5730754730263157, 0.5024647516511286, 0.5113301881600805, 0.23940487784543263, 0.23255095253854718, 0.3347648004208986, 0.352948096775651, 0.3009379558483031, 0.23604339762844517, 0.3138134162798518, 0.27426091130505736, 0.3911895474584156, 0.24028446919400437, 0.21682790744300418, 0.2027550264604524, 0.219695197136478, 0.2173578258951564, 0.220238954441224, 0.20157884515965363, 0.20774037777156595, 0.1944232331886684, 0.21945885910800866, 0.22774972057050102, 0.6126865722086683, 0.20218686776175132, 0.7360338889034171, 0.21122766973876184, 0.20675143303827404, 0.21634625450218337, 0.21871888092232883, 0.15392933885644777, 0.8234381023388748, 0.15086229799974848, 0.9022147244058851, 0.793210869216727, 0.8470410174187282, 0.7852941158213571, 0.829268312739045, 0.818853070130524, 0.779792271709048, 0.1550376031182501, 0.6954921606521354, 0.20738778833971216, 0.20636339338960974, 0.1663031972145278, 0.7414461517514523, 0.16607994484159594, 0.650056918574155, 0.17245028562901132, 0.17122422681408256, 0.1841482952665372, 0.20678851720615, 0.19206595630595313, 0.18094155404723022, 0.19222350526040644, 0.18832832218334283, 0.23494271158985125, 0.07960429925289447, 0.09481606891627292, 0.0847342725398712, 0.08027889102129959, 0.08722514527744407, 0.08908984113586282, 0.09172508694632797, 0.09027836994980465, 0.09334748203896726]}, "mutation_prompt": null}
{"id": "6ecab182-4700-4d72-b792-1912928c17e3", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F_min, self.F_max = 0.4, 0.9\n        self.CR_min, self.CR_max = 0.1, 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15  # Increased probability for local search\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                self.F = np.random.uniform(self.F_min, self.F_max)  # Dynamic F\n                self.CR = np.random.uniform(self.CR_min, self.CR_max)  # Dynamic CR\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.multi_strategy_local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def multi_strategy_local_search(self, candidate, func):\n        strategies = [\n            self.local_search_small_step,\n            self.local_search_large_step\n        ]\n        strategy = np.random.choice(strategies)\n        return strategy(candidate, func)\n\n    def local_search_small_step(self, candidate, func):\n        local_step_size = 0.05\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def local_search_large_step(self, candidate, func):\n        local_step_size = 0.1\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Dynamic Parameter Adjustment and Multi-Strategy Local Search for Enhanced Convergence.", "configspace": "", "generation": 36, "fitness": 0.297998818537078, "feedback": "The algorithm AdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.8257773129854108, 0.8202504166432717, 0.8206883431580774, 0.8126964399839056, 0.8189260091231403, 0.8275082205801211, 0.8120099812040177, 0.8144094800877943, 0.8104623272415783, 0.6426573484926413, 0.6660107100720012, 0.669616310496552, 0.6498125772688665, 0.6523728944335014, 0.6340041349519872, 0.6586920997994008, 0.6426910545887747, 0.6481248659064434, 0.2171307474747376, 0.13345495916785988, 0.23799641423233475, 0.13522479489872252, 0.17938286218621158, 0.15781157386338274, 0.1504595286957474, 0.18781896109395224, 0.1811841203201674, 0.12629198136680897, 0.13632103535832707, 0.131809397766383, 0.12598783719322149, 0.14588555123537028, 0.1458769552941187, 0.15715595261222226, 0.17940222518233473, 0.14792393320901864, 0.959118196287634, 0.9652241761657936, 0.953361501625629, 0.96969910130843, 0.9641315049152608, 0.9636732797807187, 0.9524160198499809, 0.9655643578965241, 0.9658426404059683, 0.41173343864962275, 0.3388577233996847, 0.3477668210125414, 0.38293266454470554, 0.38812388048004554, 0.3715514719524253, 0.3307965190488875, 0.34518916709164427, 0.35788850102442105, 0.5248653334927741, 0.4233156324664663, 0.5632918580522192, 0.5287023331735579, 0.5555512445123932, 0.5099928602388328, 0.5833668750604264, 0.5223129076602279, 0.46206094565242417, 0.21487052973290066, 0.19280290761559127, 0.2788135436665785, 0.23521309549653147, 0.23217008647577697, 0.2086700614808248, 0.23376918169482785, 0.21873237616500196, 0.2966777559201579, 0.21369097819249072, 0.1877841336746463, 0.22157937299149166, 0.2156511733801686, 0.24380913706705554, 0.2687806452538565, 0.22108675306682757, 0.24411191118944575, 0.19072310530815584, 0.010485733568618483, 0.001466576994016755, 0.010314090148478727, 0.006011920460915476, 9.999999999998899e-05, 0.00023816053743430654, 9.999999999998899e-05, 0.00795191789116656, 0.01796241776587848, 0.12667381321551163, 0.08969787694330078, 0.10715317882045927, 0.061086894565317906, 0.11490069302576522, 0.0782670477363141, 0.10290231738093003, 0.09032212158093067, 0.10177667705654325, 0.03608560086649382, 0.007147054840806466, 0.0259825662058234, 0.060378368381793, 0.06261746738294427, 0.012329186524537739, 0.036679803439786385, 0.005581075000671398, 0.010597400505652166, 0.12865887723844405, 0.13228808910088063, 0.1526474953663819, 0.15829603719127827, 0.13786643763826667, 0.1669460659819979, 0.14411763214253437, 0.13539772211956091, 0.10728739505657137, 0.5181130226909264, 0.5405806045628041, 0.5610650122740015, 0.5240058226467276, 0.5410543559695566, 0.5299246296211995, 0.5409977516097875, 0.5660827773902953, 0.5530408631173204, 0.10147194330654696, 0.11633947733554673, 0.11355587877495932, 0.10173938073089428, 0.10107518309476693, 0.09983191857744478, 0.1093742958358247, 0.10511100023202069, 0.12130451935054354, 0.17543700605793255, 0.17311538592772335, 0.16477323478885375, 0.1341172111243939, 0.13996660998556476, 0.18893652560771612, 0.14354255719856646, 0.14917682039333735, 0.1296193883932386, 0.3198062373357431, 0.3399169352238133, 0.37560236851978945, 0.3219270443816785, 0.3564870696531519, 0.3154981546040323, 0.38282084715165887, 0.40418852643500436, 0.3746700014342149, 0.26066149018129314, 0.23657807725974, 0.21436245881771832, 0.2099205106624732, 0.18253322083309398, 0.22883354682051238, 0.28863464717523535, 0.27492478498240147, 0.24538612461180953, 0.18722246677916266, 0.2093652431877593, 0.19002010264908598, 0.20607662200729593, 0.20839813973533305, 0.1838270814225833, 0.2049049702931931, 0.20310930500228308, 0.22343207735038095, 0.18778213409846534, 0.2103348868079311, 0.21203667962068062, 0.1847569580390328, 0.19490039084541544, 0.21386444378345015, 0.20936728155109152, 0.20469615112442996, 0.19271019612369777, 0.702789243163596, 0.17737948552119764, 0.1508929225745147, 0.7407458027105696, 0.19008930640331068, 0.18609501349447477, 0.6775909190467022, 0.5844648167064448, 0.6611041667230944, 0.45728879043475623, 0.2077870509341072, 0.27396590301544854, 0.20007991347331033, 0.3157124597776375, 0.3953894935886947, 0.14965646587877124, 0.20652934871421458, 0.2042827876525254, 0.17929599688866416, 0.17706762115720553, 0.19108943774021714, 0.18843433966623213, 0.1870710266058332, 0.1792348994233376, 0.18237513086998647, 0.21762025685390995, 0.17722946857717903, 0.0781853970996137, 0.08271467146386546, 0.08135807771186243, 0.07688888850132714, 0.07941604581388817, 0.08874056999532154, 0.08250548738839225, 0.07900882640305917, 0.07634164396646315]}, "mutation_prompt": null}
{"id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 37, "fitness": 0.5652031549481473, "feedback": "The algorithm AdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.31.", "error": "", "parent_id": "128ca289-cd1a-4bde-8ef1-b80205b3d5ca", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "70e7d131-9421-4d1e-93b7-83d99346f53a", "solution": "import numpy as np\n\nclass AdaptiveCoDEEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 0.1  # Added for diversity preservation\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                \n                # Stochastic exploration for diversity enhancement\n                if np.random.rand() < 0.05:\n                    trial += np.random.normal(0, 0.1, self.dim)\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            # Diversity check and reinitialization\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += self.population_size\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity", "name": "AdaptiveCoDEEnhanced", "description": "AdaptiveCoDE Enhanced with Diversity Preservation and Stochastic Exploration for Robust Optimization.", "configspace": "", "generation": 38, "fitness": 0.3581310488922253, "feedback": "The algorithm AdaptiveCoDEEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.5070429412230343, 0.5302834317697624, 0.5274978397821382, 0.503912662396046, 0.5159333009075648, 0.4983870651576361, 0.49343039418564205, 0.5153283616698193, 0.512160042970454, 0.380269523142553, 0.3670099412239096, 0.41934752311097, 0.3913917979718605, 0.38616944594100966, 0.35136780591565875, 0.36924454126214246, 0.3901553624404055, 0.39538785728468306, 0.20159513972163556, 0.13098106655291064, 0.1633115067706129, 0.1440560999249576, 0.1447399362324211, 0.14748496809672174, 0.17010456187217537, 0.14212770161328103, 0.15162316119479113, 0.11586133145665423, 0.13293370967579654, 0.13139062608785912, 0.12660845959771783, 0.13620701555812553, 0.12949765136444125, 0.1429136173875608, 0.12415524250193011, 0.12397061115107044, 0.9796170259258827, 0.9794628466266426, 0.9910595322813851, 0.9807236130727085, 0.9731124529998525, 0.9687742714003519, 0.9813708045004078, 0.983418847121606, 0.9683212237923374, 0.3373132855319043, 0.3621143154146379, 0.358417171348258, 0.36694140352583404, 0.3899838365245254, 0.35594829783744075, 0.42874654163314185, 0.3752105921899389, 0.3662316484203798, 0.9045319130507463, 0.2164091649649751, 0.9164782424127973, 0.9174088598567606, 0.8860755873859343, 0.9055372898554027, 0.9281907424912699, 0.8972327583139094, 0.8891676362687693, 0.2974269513456468, 0.38021163412564185, 0.28267051356506645, 0.1346157650700588, 0.1333101673310666, 0.29254411680135917, 0.37614369808204595, 0.29468950112715386, 0.3608635983368198, 0.2503805557208503, 0.27120078131572223, 0.33362233796168317, 0.2585617058520202, 0.27588132513525776, 0.3114460077287621, 0.3850782694671805, 0.22799651642682428, 0.39202695266684606, 0.32284186731252007, 0.35103369086032976, 0.3140690470106793, 0.33940787071748646, 0.3479178566783204, 0.26527450441011013, 0.31012681068956327, 0.34700340418345055, 0.32744209492961207, 0.44240255622944247, 0.40367899242731997, 0.41525967286798493, 0.4353271992734904, 0.4292897266891035, 0.4044582818454201, 0.43310707308635477, 0.44250498599084587, 0.4655938777249121, 0.1843623301668601, 0.054329370792862264, 0.22529125077744616, 0.12453292936233151, 0.11406043187493065, 0.22926663228974264, 0.03192160160877522, 0.14776302477540526, 0.13130510433234432, 0.24169745698324363, 0.22496313009874824, 0.25680916376196206, 0.2465216527128301, 0.24119083554821352, 0.189898932743627, 0.2577689129517772, 0.19647810987917647, 0.21493784443602504, 0.5089952931626015, 0.5363760198179239, 0.5297988716470003, 0.48942398259267117, 0.5220474146400987, 0.4829536927032094, 0.4808237755716278, 0.5209270475261518, 0.4871085367909168, 0.136113265154167, 0.13505641333865992, 0.11143344435875568, 0.15822426547667945, 0.12501955559335243, 0.1381504489254579, 0.1216318416859623, 0.11741163969981627, 0.14224160751441728, 0.3106081188522153, 0.30184682962763376, 0.16408358626353292, 0.22508874443204163, 0.3042369789138827, 0.30238896236971713, 0.26390047159003427, 0.20432051967068832, 0.26104191681876554, 0.33804588997611085, 0.32789475496399334, 0.34325788012709635, 0.3344157341242643, 0.32421940635161806, 0.3479878346090771, 0.33672341915765813, 0.3378319686219651, 0.3438732185658542, 0.3074249194501243, 0.30609941275718133, 0.30051617633851335, 0.3061453844273082, 0.2889442656760305, 0.30564575495143376, 0.3023978237634335, 0.30828104679178114, 0.3051328061104295, 0.20496860744448941, 0.2332317802818461, 0.21618980600374282, 0.23618485076120366, 0.26059314383748056, 0.2233895583567873, 0.2399810285974161, 0.22539590165867518, 0.24179122047410628, 0.23741386661708752, 0.21450808132698151, 0.22071935260335374, 0.22003428043711548, 0.19390327981749766, 0.21862854863398584, 0.21344700517038429, 0.22024640203150048, 0.23100013787132856, 0.8148447283519236, 0.15295972705633298, 0.7978032730936745, 0.8411807040914902, 0.4393641488201493, 0.19774255946579877, 0.7907393423951496, 0.16834770391900422, 0.6064548794409974, 0.9230514913705287, 0.2120367440393427, 0.877350932328938, 0.8520146291209335, 0.8604305383356737, 0.9043563431253627, 0.19672897585934102, 0.8201266094890763, 0.8756687441920594, 0.1848261745531392, 0.1880009881360971, 0.19625111634854786, 0.19254303300035291, 0.1950004747482752, 0.18127324900033437, 0.18247379404507325, 0.18755975412932935, 0.17963518226794017, 0.09164598347203368, 0.10580961482997531, 0.094275748327043, 0.08376882430402244, 0.09678350856563844, 0.09442564752951244, 0.09699012992278744, 0.09792786400474529, 0.08800482966620182]}, "mutation_prompt": null}
{"id": "c1db8187-ed10-4dc9-b5b7-f8ddc1c042cd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.dynamic_population_adjustment = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies, p=[0.4, 0.4, 0.2])\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if adaptation_counter >= 5:\n                self.population_size = max(5, int(self.population_size * (1 - self.dynamic_population_adjustment)))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n            else:\n                new_size = min(self.budget - evaluations, int(self.population_size * (1 + self.dynamic_population_adjustment)))\n                if new_size > self.population_size:\n                    extra_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (new_size - self.population_size, self.dim))\n                    population = np.vstack((population, extra_individuals))\n                    extra_fitness = np.array([func(ind) for ind in extra_individuals])\n                    fitness = np.hstack((fitness, extra_fitness))\n                    evaluations += new_size - self.population_size\n                self.population_size = new_size\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced AdaptiveCoDE with Stochastic Strategy Selection and Dynamic Population Size for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {}, "mutation_prompt": null}
{"id": "0f168d67-8ea9-40f3-9af1-f851792966de", "solution": "import numpy as np\n\nclass EnhancedCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_distance_based\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.variable_crossover(population[i], mutant, fitness[i], best_fitness)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_distance_based(self, population, best_individual, target_idx, fitness):\n        distances = np.linalg.norm(population - best_individual, axis=1)\n        closest_idx = np.argpartition(distances, 3)[:3]\n        a, b, c = population[closest_idx]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def variable_crossover(self, target, mutant, target_fitness, best_fitness):\n        CR_mod = self.CR * (1 + 0.5 * (best_fitness - target_fitness) / abs(best_fitness))\n        cross_points = np.random.rand(self.dim) < CR_mod\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedCoDE", "description": "Enhanced CoDE with Distance-based Mutation and Variable Crossover for Improved Convergence.", "configspace": "", "generation": 40, "fitness": 0.3261321048183046, "feedback": "The algorithm EnhancedCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9465161502655015, 0.9487664639402066, 0.9485218429003551, 0.952808635841893, 0.9513023335092559, 0.9407107945505284, 0.9451738272389029, 0.9470350385546054, 0.9356673532140394, 0.7700137371100338, 0.7632187552253602, 0.7650448853170224, 0.7424110696419692, 0.729299202420935, 0.744085886308714, 0.7592379265176, 0.7029648990328636, 0.7737262970317087, 0.11897798270123217, 0.1478024064591713, 0.12606776506735629, 0.10537201406208063, 0.16030254977020253, 0.1896059717767974, 0.1874788861610317, 0.19227660091187393, 0.12550027016760812, 0.07232835221982792, 0.09869672552015385, 0.13514438980221788, 0.12255395650794798, 0.16080025711843737, 0.11980792765936188, 0.1418556084075432, 0.18488719926706387, 0.11407615906090474, 0.9457663135200893, 0.947174258530175, 0.9515445550810241, 0.97784664885967, 0.9897762221397659, 0.9854742665886165, 0.9776384086842622, 0.9742964964315829, 0.9854962626280943, 0.5218726652005873, 0.3873598557720227, 0.5053739094208878, 0.43532705229475177, 0.27125598890266256, 0.3655486602667881, 0.6981388418215666, 0.7519074997160633, 0.6902248719631121, 0.17104650861444448, 0.20850190601542706, 0.2214557076414836, 0.2203337021543318, 0.20455677890933, 0.20529724124574844, 0.24947938642416279, 0.22655507250162654, 0.23780015579502056, 0.33589391489649223, 0.5171918032314984, 0.12006341491331807, 0.660769274553664, 0.6066704705406427, 0.6443865039670212, 0.5707957902556822, 0.16009535230489724, 0.570029771144882, 0.5954625795968329, 0.12251847337646304, 0.36202225804342947, 0.6038377694098287, 0.5763547096360719, 0.590116105987319, 0.11267221405417094, 0.14126304608552398, 0.12455778168408893, 0.0016092485029112202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009140397575271297, 0.00017053470854222486, 0.006547417108120679, 0.09432880991968018, 0.09608327634893088, 0.1171305181795147, 0.12178343047094553, 0.08817159760186166, 0.08165143357822013, 0.056033563471021064, 0.11675907006656072, 0.10264406710192342, 0.09966407267625776, 0.1110976948560819, 0.02053690779226003, 0.06280593537430756, 0.05407564016169486, 0.07945914512893737, 0.0854045037083544, 0.14878679544509943, 0.055694478630663236, 0.09493444130339612, 0.09010893208661286, 0.18715869485030356, 0.12976601755327122, 0.13611591083283148, 0.08578901380597803, 0.08317760315728717, 0.08034836754573849, 0.13426013225204514, 0.6141652503997949, 0.6286667878858003, 0.7164915976153134, 0.6630051377340731, 0.6003498874331099, 0.6439426935361099, 0.656123914234578, 0.703553098679363, 0.6826346814926516, 0.06880847296752579, 0.04335321646077195, 0.09734794011923276, 0.06641783725886452, 0.06375328348205511, 0.132050860808423, 0.08593682970675998, 0.10184044776691659, 0.10561316755682326, 0.19085373998980448, 0.2090035397431924, 0.1558616810604242, 0.2644963581914517, 0.1653684299360184, 0.2362759430143544, 0.24730820966233924, 0.16736546751304815, 0.15055782582621013, 0.25655354507370076, 0.18607345207037496, 0.2779611657869441, 0.18383695679688672, 0.20771980392565148, 0.2139401404626301, 0.24388403587822882, 0.22236351518399866, 0.2085158763059748, 0.1639887536729402, 0.2267237696882235, 0.19689848488698558, 0.1609173190153742, 0.22349368074360498, 0.18772492820894782, 0.30199914901247893, 0.20105603950475548, 0.20150096850549826, 0.2503456054709656, 0.14299368678272661, 0.2236854224568543, 0.2192412765929107, 0.18332034340650494, 0.21094588873368503, 0.24124585992099135, 0.1788577357206561, 0.2332046246688555, 0.19099315750276413, 0.18970516819679129, 0.1824398885774411, 0.17040993398382975, 0.17882828402274753, 0.1980340385098518, 0.19079626610612332, 0.19410788220442177, 0.2173688692183834, 0.893914436050529, 0.1673307574201035, 0.16982050722260156, 0.7567482692051059, 0.6328836826453033, 0.7290631773627532, 0.1430877611172493, 0.16970662786145074, 0.9446971730099525, 0.925148322169063, 0.21355652272774517, 0.12685382724482097, 0.8979516764863565, 0.8742033238197193, 0.15628638773236692, 0.8009190060568085, 0.1647913814653399, 0.15191044215266525, 0.1887551649747614, 0.19921549394461913, 0.18695051390721318, 0.17788689683691206, 0.1890145851337659, 0.17238707381203422, 0.1877396407215295, 0.19125938955775135, 0.2277417049996151, 0.09891731398098202, 0.07219982738757613, 0.0602045426361848, 0.0779583779974875, 0.0982042595913859, 0.0902486101488379, 0.0926440388810188, 0.08788864742423508, 0.08832157414893249]}, "mutation_prompt": null}
{"id": "9ea2ac1d-15c2-49aa-9c9d-110a0ab5dc09", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20 + dim * 5\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest,\n            self.mutation_hybrid\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if evaluations % (self.budget // 4) == 0:\n                self.population_size = max(10, self.initial_population_size - int((evaluations / self.budget) * self.initial_population_size))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_hybrid(self, population, best_individual, target_idx, fitness):\n        rand_mutant = self.mutation_rand_1(population, best_individual, target_idx, fitness)\n        best_mutant = self.mutation_best_1(population, best_individual, target_idx, fitness)\n        hybrid_mutant = (rand_mutant + best_mutant) / 2.0\n        return np.clip(hybrid_mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced AdaptiveCoDE with dynamic population size and hybrid mutation for robust optimization.", "configspace": "", "generation": 41, "fitness": 0.5189265200852856, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.31.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9309933995745038, 0.9323023728353681, 0.9278980907854442, 0.9313119412143198, 0.9182891931090639, 0.931080943404394, 0.9289413448234902, 0.9288391615348998, 0.9287085347225219, 0.8781184369560873, 0.8322832572433463, 0.8468122298640764, 0.8474209559552557, 0.8510269644614933, 0.8506625119114798, 0.8544011461260801, 0.8524992800340906, 0.8359614939833842, 0.1070524055496973, 0.14733949139860836, 0.09157790355502382, 0.17227334312981657, 0.7060990202211497, 0.13899175409811249, 0.0910315605444093, 0.15316880258993837, 0.152496211192923, 0.14361813776797538, 0.14177940591989413, 0.1508729966397353, 0.0965456212689293, 0.1497506267001787, 0.1166595512486811, 0.14061491870496012, 0.12972754120630048, 0.12454455725591274, 0.9822453959998081, 0.9594812339577176, 0.9749324207336906, 0.9512916719013331, 0.974885528427272, 0.9631741339284395, 0.9633144635778035, 0.9764090003771793, 0.9716948573749465, 0.8198303600264035, 0.8056125801068008, 0.821760400492355, 0.8149043805818805, 0.8095215655775965, 0.820946314268451, 0.8242828659823205, 0.8236236165352563, 0.8147105889631722, 0.9250295483486197, 0.9274840633812658, 0.9237009025214035, 0.28161582025320875, 0.2800231704155627, 0.9296659617859314, 0.9026285771267057, 0.9305189562975684, 0.9305354015175703, 0.728326496349124, 0.608160487258824, 0.7654245833985266, 0.8196606718226471, 0.7685854444469311, 0.7036888870160195, 0.7763542178951585, 0.7059945464336363, 0.7140380975143117, 0.7263341175284727, 0.7092179993994823, 0.6745297946166573, 0.7065180746671103, 0.701496605394551, 0.7165250618698857, 0.7338602974665998, 0.5970587408828667, 0.4969661088619508, 0.4045078999829188, 0.7693545043178701, 0.22780773468307092, 0.31282537689730827, 0.7010090565016086, 0.7404674992031663, 0.7934774968722491, 0.710276803576148, 0.09879261400618344, 0.8303948911022307, 0.8058875421205125, 0.7132862110603023, 0.7497209598560982, 0.47288030707181383, 0.7579274725479458, 0.8341876781855582, 0.8126281141555534, 0.8201233649576272, 0.1272106787516215, 0.1504906444871671, 0.35871290058725713, 0.5840041331983495, 0.6205005829393733, 0.27933470134972915, 0.17505217197194856, 0.20360127052990584, 0.30223811435187264, 0.5494712289416146, 0.6701420140194538, 0.6737550355950076, 0.7400414287745666, 0.6536128123857294, 0.574041377160826, 0.6905320835695093, 0.6407431531392427, 0.4646559746601292, 0.8919528011845412, 0.8196026920099898, 0.8849484301786775, 0.8848431613951594, 0.8837390451683189, 0.7284680356960112, 0.868845019915748, 0.894720430765041, 0.8743544456531682, 0.11525495023313237, 0.17923541801790055, 0.17555399251165416, 0.17323482544056334, 0.1845599732883656, 0.15460489919011633, 0.17365545190526233, 0.14640753375324544, 0.12781162123257817, 0.2724982502899044, 0.46247498822075717, 0.21725884742408463, 0.7921555002308631, 0.6727750449101443, 0.6978918327318426, 0.6329043556392963, 0.5306835395069807, 0.5448911103675073, 0.5260423444209971, 0.5940298747016353, 0.39109685704327823, 0.3821546676056543, 0.5835329595052272, 0.6007089365092284, 0.7550688543851783, 0.5790292724442944, 0.618460569814525, 0.2596321520085727, 0.473997866641946, 0.4698492343313344, 0.3305091381139147, 0.7068928780633854, 0.7307459669325429, 0.6006894279837287, 0.7141231282606594, 0.245708337588737, 0.22908304751734643, 0.23429797576933065, 0.20973997074232031, 0.2305805652050288, 0.22016945578313218, 0.21360945499761963, 0.20142781379266517, 0.21378006433300112, 0.22596131802200803, 0.8484684444882251, 0.20806900110359583, 0.22081748050120986, 0.2075607151825556, 0.24759341301907933, 0.2252243295033749, 0.1788384300950463, 0.21383906130166108, 0.19057059047557545, 0.9454846308125603, 0.1843898677468241, 0.15338132851987119, 0.15617050851758174, 0.2001621478282375, 0.14802064130502735, 0.14246446521379108, 0.1679380233185016, 0.16732247230150987, 0.9339559902457819, 0.21129520787946776, 0.07353353373383653, 0.9311518216552128, 0.16810326138092113, 0.15571021623581105, 0.15522491592986754, 0.9001456737093265, 0.8898786944516736, 0.1907288306580197, 0.18373059468741026, 0.1949976385953065, 0.19957136696348576, 0.19221502692960035, 0.19095189671988244, 0.20163257473048624, 0.192225757279469, 0.19453932237923488, 0.09447480507960249, 0.10002454977262132, 0.10238729743600616, 0.09520587008773074, 0.1079615116267405, 0.08869179862276544, 0.09459717907642695, 0.08847325475499346, 0.09220091286159182]}, "mutation_prompt": null}
{"id": "ad184fcf-1b4f-4ded-9e7f-a122052f2ede", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20 + dim * 5\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.strategy_selection_probability = np.ones(len(self.mutation_strategies)) / len(self.mutation_strategies)\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_index = np.random.choice(len(self.mutation_strategies), p=self.strategy_selection_probability)\n                strategy = self.mutation_strategies[strategy_index]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.strategy_selection_probability[strategy_index] += 0.1\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.strategy_selection_probability /= np.sum(self.strategy_selection_probability)\n            \n            if evaluations % (self.budget // 4) == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n                population = np.resize(population, (self.population_size, self.dim))\n                fitness = np.resize(fitness, self.population_size)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Adaptive Mutation Strategy Selection and Dynamic Population Size for Enhanced Performance.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {}, "mutation_prompt": null}
{"id": "2dc508a6-ba06-4581-8c32-8d427b69c87c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20 + dim * 5\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.population_size = max(10, self.population_size - int(0.1 * self.initial_population_size)) if evaluations > 0.8 * self.budget else self.population_size\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced Adaptive CoDE with Dynamic Population Size and Feedback-Controlled Step Size.", "configspace": "", "generation": 43, "fitness": 0.5649581974588593, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.31.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.3807713228282792, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.3352563746124184, 0.37913362750009827, 0.5496343531721619, 0.6428654498617979, 0.678338418078118, 0.5222914524021435, 0.1879687834902496, 0.17916276269637887, 0.18616831645346887, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180533538, 0.30914134337218224, 0.1695397905305015, 0.4194018531168793, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.545528171729824, 0.7679558838560596, 0.6378563769392043, 0.5556920899165669, 0.576058943356436, 0.6059102045825047, 0.6436396792647996, 0.2594518940628522, 0.4770278972610137, 0.6920494763257583, 0.5717561052893205, 0.6727352552990246, 0.22169890982323748, 0.23607339650927694, 0.23320110638282665, 0.23022159656005647, 0.217884313442247, 0.2031927397520158, 0.2145295822353528, 0.22012425625258114, 0.22478457336860125, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.1936507980727743, 0.20455412310519272, 0.18692590704678114, 0.21105551526565924, 0.1892320777114035, 0.17579054224853585, 0.2140603297810535, 0.1723090452518531, 0.21193153416147703, 0.09023086824409399, 0.09352218329662121, 0.09588531049823357, 0.09595440688722923, 0.09478990954209221, 0.0933202232767979, 0.09163415028314215, 0.09443371676258538, 0.09535636519555568]}, "mutation_prompt": null}
{"id": "cabc2b0d-f210-4cce-bd13-9cffcce31881", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.min_population_size = 10\n        self.max_population_size = 30 + dim * 5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.dynamic_population_size(adaptation_counter)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def dynamic_population_size(self, adaptation_counter):\n        if adaptation_counter > 5:\n            self.population_size = max(self.min_population_size, self.population_size - 1)\n        else:\n            self.population_size = min(self.max_population_size, self.population_size + 1)", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced Adaptive CoDE with Dynamic Population Size for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 45').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 45')", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {}, "mutation_prompt": null}
{"id": "da38450b-d63c-473b-922b-2a7f3c01926f", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "3f7db1c5-6383-47ef-bfa6-1474c59c7b88", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "71d0d2f6-9d3b-4636-a0c3-30c1ee7bcfa7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25 + dim * 3\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.dynamic_population_size = True\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n        dynamic_rate = 0.05\n\n        while evaluations < self.budget:\n            if self.dynamic_population_size and evaluations % int(self.budget * dynamic_rate) == 0:\n                self.population_size = min(self.population_size + 1, 100)\n                population = np.vstack((population, np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))))\n                fitness = np.append(fitness, func(population[-1]))\n                evaluations += 1\n\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.multi_strategy_crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def multi_strategy_crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced AdaptiveCoDE with Dynamic Population and Multi-Strategy Crossover for Robust Optimization.", "configspace": "", "generation": 47, "fitness": 0.5170038061253391, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.31.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9261599406736926, 0.9188810737092213, 0.9226451881328261, 0.9270097268225573, 0.9184112428666484, 0.9296354222220861, 0.9255071014632815, 0.9187538766214509, 0.9156186694519834, 0.8553943545663888, 0.8455004765442702, 0.8386217985349024, 0.8446103078300271, 0.8246598721602825, 0.8436624465675399, 0.8573646548374022, 0.8665401113177548, 0.8494901021656768, 0.14200783518699023, 0.1536663636902027, 0.15142968997260797, 0.8043770127475629, 0.7199274615496898, 0.17335652943609325, 0.6168028832361958, 0.11829358192946782, 0.15546581416403538, 0.11882395504449994, 0.10588698856271894, 0.11368697404823402, 0.12034555059353713, 0.13717349349591967, 0.0837888608928512, 0.11398711682327445, 0.11708212446026589, 0.11252657668933319, 0.9792605242597135, 0.9777208968367629, 0.9819162123212216, 0.9869150970942465, 0.9650386871974859, 0.9556551147611095, 0.987665961838578, 0.9615859146282811, 0.98269258720906, 0.7949555872905891, 0.8092982048495887, 0.7867296213660255, 0.8016770228804765, 0.7882834709498068, 0.7948209961333939, 0.8214130954139689, 0.8115585253257334, 0.8077108757707925, 0.9150937107803968, 0.9124421902234452, 0.39892165698252346, 0.21391277607494308, 0.9139492337579079, 0.9276117966270927, 0.23337681460521298, 0.23434150805678067, 0.9162228853228036, 0.13415571857365927, 0.13086920277834047, 0.13512765795059734, 0.13518905945610682, 0.7360832757778113, 0.7177183620619074, 0.8020836940600204, 0.7355051400148411, 0.1328949959911142, 0.73806573342628, 0.6736380644979503, 0.6264061356221966, 0.1354424337924207, 0.729965734852173, 0.8185022638774775, 0.7426972126154074, 0.6854370968391228, 0.12472158633365271, 0.7544699189767283, 0.5477997572703678, 0.7480679174069906, 0.6588676282804087, 0.7631997837488104, 0.7325527394347089, 0.7675072562588504, 0.7783412198629025, 0.7539277139522574, 0.8092381989245868, 0.699005095766579, 0.8081926004572989, 0.8071622711101437, 0.8132153100799613, 0.7014509871185982, 0.8172213278318154, 0.8083218596384399, 0.7914330120524835, 0.4337410277480295, 0.3034131411912636, 0.18701875104140153, 0.48670434947748986, 0.7100816549277043, 0.6057031913961093, 0.42459879352872487, 0.2735726026927914, 0.24616401677439126, 0.7010228141316124, 0.704790087286975, 0.6336414101432004, 0.7363992625921303, 0.7269459507062853, 0.6838791872614207, 0.7034572784092261, 0.4494269928328485, 0.6844087769742238, 0.8843967708834863, 0.8946056337843918, 0.8792893805861737, 0.8866206276143085, 0.8692629734944082, 0.8537918363293497, 0.8809318137614826, 0.8744045169453311, 0.8803869405992437, 0.15750905706489826, 0.14150389199700386, 0.13154643621356676, 0.6118171859517099, 0.15775274190548205, 0.14486809525442046, 0.15985639891326586, 0.1725345560597189, 0.14791933207163943, 0.32653559479798555, 0.19454275784109698, 0.2593149675341049, 0.3287126416042395, 0.2940695098149928, 0.5306785313006204, 0.24659562480450592, 0.40119725128703176, 0.30389478486557664, 0.7305582975826981, 0.5759994942559007, 0.7833208889141103, 0.64783181223218, 0.46858837224560634, 0.7694054420338661, 0.7562139079892793, 0.5643064141053562, 0.7779285915805876, 0.5700516129519522, 0.46467884319365194, 0.5084870509815271, 0.6048367882296555, 0.5055527758944782, 0.5249832109581192, 0.7009580312144041, 0.7239996790156877, 0.26342432776131586, 0.21593524956411725, 0.19778670903219508, 0.2559583132596436, 0.193040458583276, 0.2502659156673439, 0.2519931721212215, 0.24092927953941934, 0.24964118574021832, 0.23315294936972064, 0.24032433862037128, 0.25042845200869246, 0.2059011709416011, 0.8055631341563436, 0.24897974903991427, 0.2309191164916241, 0.24403528739156066, 0.2073838219602916, 0.20704896398832462, 0.1621105565993305, 0.909458832743624, 0.15393192153998658, 0.9336443119507881, 0.16599773780445393, 0.19982808282356435, 0.18602406686209438, 0.17708815139437062, 0.16665669113733295, 0.9270752231930489, 0.2129735992132631, 0.9143696194069325, 0.21205444255493844, 0.21223153265213435, 0.8814056596635393, 0.21189820167654383, 0.16697968412809183, 0.21245816992788547, 0.1807681371226887, 0.18828318835703217, 0.1898001027430376, 0.19076261968199937, 0.2017440754060288, 0.1797855617998102, 0.18047406638915076, 0.19735994520310474, 0.1830790599318214, 0.09238003762653935, 0.09490328095463296, 0.10669317696121938, 0.08555874209589587, 0.1046834722547565, 0.09290096848972829, 0.09241548935134902, 0.0880121269185905, 0.0947655212393953]}, "mutation_prompt": null}
{"id": "04bd6829-690c-463d-adf6-835c3ca0655f", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "0bf81de3-212b-49d4-84dc-0d0314799e71", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability * self.cooling_factor:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.cooling_factor *= 0.995\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced Adaptive CoDE with Stochastic Cooling and Dynamic Fitness Scaling for Robust Global Search.", "configspace": "", "generation": 49, "fitness": 0.5485256172538244, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.31.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9125458448874902, 0.9182056257226062, 0.9108731714425803, 0.911631194305028, 0.9120788250715446, 0.9182196175533498, 0.9186389317865431, 0.9138157345792475, 0.9191123147189343, 0.8104241012292901, 0.8243373949227015, 0.8344480098938882, 0.8273827885673986, 0.8358201426552408, 0.836301895632678, 0.8287516209606255, 0.8402330313197373, 0.8405242734409417, 0.14436411833704876, 0.14651125553283273, 0.1396029505212627, 0.11258063053677436, 0.17619358623339743, 0.16965387240310137, 0.16519373405731108, 0.1741898540296155, 0.15044710989701593, 0.11068892869296654, 0.12810505185075471, 0.10558593950479667, 0.12858267717757976, 0.1454856039465401, 0.12474073298765309, 0.13148811835285812, 0.1338041938994493, 0.14291964946563185, 0.9901128791996175, 0.991291444466859, 0.9818328571260316, 0.9745408270623441, 0.9828961041443951, 0.9813055881585543, 0.9684129198151669, 0.982778729149947, 0.9788078579490072, 0.7933916323128809, 0.7767437779745319, 0.7658394003915644, 0.7720064142205536, 0.7731636267966547, 0.7746696322143485, 0.7806973251773632, 0.7753896923664076, 0.78510899866052, 0.9163397936657641, 0.9100775083699902, 0.22866108284112507, 0.9196800366373357, 0.9139975718389384, 0.9284430019646435, 0.8936670028408463, 0.8899315609918642, 0.9095838256538711, 0.8018616565613927, 0.8197008764453807, 0.7438471541092153, 0.7151269368196556, 0.7150620293251001, 0.7659397286282688, 0.6659088545472266, 0.6803092670247723, 0.757958022433588, 0.703727916918382, 0.5356521004561259, 0.6868147412384452, 0.7646043322159524, 0.7883523213001347, 0.7714304359224133, 0.6639125219820228, 0.6822608733428922, 0.7897248703582046, 0.7548072788159623, 0.7014703499291337, 0.5510355711803647, 0.6853816688003505, 0.6676363382288595, 0.6906649984758795, 0.719748414292043, 0.741002029895183, 0.7456090417308592, 0.8062281252129739, 0.7780897211593192, 0.7927794488904136, 0.742180611329638, 0.7144304145689143, 0.7921186284523041, 0.8149513160462578, 0.7769571132468752, 0.7981487042873963, 0.3643026044643839, 0.26764181869521775, 0.5868976046469876, 0.41987722896280544, 0.6566998962521344, 0.6559071927180737, 0.1885821178136966, 0.16088888707160098, 0.16946533832295485, 0.6693349066904879, 0.689270655267231, 0.6206848070689798, 0.7145210880413257, 0.6926946760834973, 0.7066206037318652, 0.641368326797196, 0.6778969064940509, 0.6744531572727579, 0.8682057065996561, 0.8642686827738438, 0.877826457588451, 0.8762141600530724, 0.8653918747378577, 0.8613290356029768, 0.8821859554488596, 0.8764184813259357, 0.8639742537353405, 0.11281326758654764, 0.13418773058732492, 0.13078544664893577, 0.12980103185118097, 0.5761957926072987, 0.13536094048326597, 0.1500116091305106, 0.13981321107811984, 0.09991851445088795, 0.48125016916888297, 0.1890044593460879, 0.28576611840406263, 0.2729303530105861, 0.170186785698916, 0.5935546518585395, 0.18238807072132224, 0.7569103336179276, 0.2655582671901089, 0.6148593253884738, 0.7263646526527869, 0.7283868482008637, 0.7200171695000718, 0.749343174118825, 0.6252691479178918, 0.7483656547497319, 0.6469680403011595, 0.6457490114348624, 0.6543759102135605, 0.5402464340148523, 0.5565244803560361, 0.6133582855871741, 0.2439611430290114, 0.6025431618385777, 0.6872732905800696, 0.6652810167809798, 0.6542844158099579, 0.22019943014158117, 0.2306469138923587, 0.20061186136722564, 0.21200473567093725, 0.23521333453280235, 0.24695476252702853, 0.2049245301331124, 0.20118788293082757, 0.23809171222067482, 0.20701323320725873, 0.24383102331205475, 0.24178717605490396, 0.665892496357807, 0.21963652571534975, 0.1897091319650709, 0.2178210250048528, 0.21484024574476457, 0.2064204971168686, 0.18652198982124335, 0.18745198962694654, 0.20049148341820455, 0.9170227113413757, 0.20075826222003457, 0.19953905295038155, 0.901517860698259, 0.15774607378143302, 0.9284878695875266, 0.9130319716614061, 0.21097714342844953, 0.9068402729900713, 0.20890522115108157, 0.21004530631093543, 0.9032912157898119, 0.8798168541937421, 0.9028043585643521, 0.9129663942419909, 0.2046326111720287, 0.2067766327374888, 0.18652602177357736, 0.20926728576373954, 0.20070311939569951, 0.2139898349601448, 0.1914482468082408, 0.18914931949268676, 0.1936559546853136, 0.08750999651939606, 0.09124040619116791, 0.0977511651402998, 0.09220066855814779, 0.09722815738141088, 0.10181166053176771, 0.0843902106146992, 0.09300228831272617, 0.08442882465874813]}, "mutation_prompt": null}
{"id": "22be7069-df7b-401e-a463-1d8071b38179", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "011dea8f-a005-4ff1-9edf-62539bbcf8c5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15\n        self.adaptive_step_size = 0.1\n        self.dynamic_crossover_rate = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.dynamic_crossover_rate = min(1.0, self.dynamic_crossover_rate * (1.1 if adaptation_counter < 3 else 0.9))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < (self.CR * self.dynamic_crossover_rate)\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "An enhanced variant of AdaptiveCoDE utilizing adaptive learning rates and dynamic crossover for improved exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.2771842072298617, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.7747496878879067, 0.7733856493936153, 0.7828541027751538, 0.7760757776214726, 0.7438395742835564, 0.7594443393620852, 0.7782725695003352, 0.7644507299925879, 0.7555413109293737, 0.614969480220658, 0.5922793684721039, 0.5820347287069757, 0.5848634112978279, 0.6017929955622757, 0.5987021625524964, 0.6078532086317568, 0.5760777807846228, 0.5671756671493219, 0.5678058618834283, 0.490391700030256, 0.5381885714733237, 0.5277635452068239, 0.5725467435580482, 0.5338652494728967, 0.5538273503594894, 0.5343325715435281, 0.5027902347548319, 0.4772318973314227, 0.4571375485130581, 0.4438290731622525, 0.48897547028929633, 0.4444297267240852, 0.49124364626238226, 0.45849064938205986, 0.5197367125954364, 0.462682351539873, 0.9249295875156441, 0.9477470356832836, 0.9259590499664203, 0.9161402285881475, 0.9244120524885937, 0.924420660670246, 0.9308836628302217, 0.9477146359735896, 0.94808509291485, 0.22421624906133597, 0.1951477818611016, 0.20719720486268856, 0.2189220247174406, 0.21512012867357422, 0.23551069399213043, 0.1929245505775028, 0.19487257508194722, 0.19119774729277184, 0.16528175183519778, 0.1901846313609299, 0.21432469169839674, 0.2774583076928008, 0.25435574591007803, 0.2437091776243716, 0.21158072284719742, 0.27125061707930975, 0.2286117469133635, 0.20077720068844518, 0.18813526095587252, 0.1657853488201967, 0.13565873566408482, 0.20242169418881573, 0.19594981490146868, 0.17863274338790802, 0.1725082419629651, 0.18540198073528247, 0.13773724450981284, 0.13919073059323894, 0.12501014604819116, 0.16451036622864157, 0.13501658345641732, 0.15462446551478093, 0.14263869454983524, 0.13391734431981217, 0.14774744981367272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07658347512730002, 0.08360862385313772, 0.07432939219766099, 0.09579959008159655, 0.0740514043469378, 0.09027012396957856, 0.15533470324177912, 0.08617674818600896, 0.11230566666723862, 9.999999999998899e-05, 0.003230307418356282, 0.009941507575899733, 9.999999999998899e-05, 9.999999999998899e-05, 0.025398461261839644, 0.00046034843113340607, 9.999999999998899e-05, 0.005441400333479396, 0.09528887939988673, 0.09161486404089991, 0.08581977730760049, 0.12815345876360518, 0.1080780370641129, 0.10626459395846322, 0.10221376237085078, 0.09431502039624573, 0.10318199695082164, 0.41908947368736427, 0.42175580606040597, 0.43842226864044975, 0.4351089141063126, 0.4266641831761885, 0.3956235867724961, 0.441283021739602, 0.4579462498020507, 0.4484925737788291, 0.11995927549363972, 0.11825144603659099, 0.10206888904653022, 0.10125200849032068, 0.09782457195604877, 0.10007594159191036, 0.1082369379159549, 0.09660704813340304, 0.09576551048045145, 0.21905774081863483, 0.1411859045165773, 0.13205214642478857, 0.14828028436049967, 0.15179904020890844, 0.15193217347700594, 0.1359617407996111, 0.14943836291891366, 0.1792336783924744, 0.24424177033628336, 0.26662697816258796, 0.2590134927641575, 0.27452088678021114, 0.25544018843130445, 0.2577259238696594, 0.2613143287573002, 0.28099151322126215, 0.25512345269431935, 0.17940126359342357, 0.18197894934351888, 0.17893879642497923, 0.2025668131582118, 0.1619613773169769, 0.17797929924668698, 0.20627815695095708, 0.1894253159887065, 0.20054078265463182, 0.1992886842864977, 0.21198319084917971, 0.20080378122811215, 0.21913542741741399, 0.20659339719262793, 0.1957214612081527, 0.20502443991181318, 0.20690982653848988, 0.22342617035571732, 0.2081149464182689, 0.23420488725529665, 0.23036267666199028, 0.21956532015741137, 0.23747705711978917, 0.19936607286886132, 0.26039390799013884, 0.21442853921262917, 0.22247434700405333, 0.16776474457794588, 0.17733841352917956, 0.42062363001621883, 0.32706100783029946, 0.45149205755317057, 0.37627243934764254, 0.2637541142689419, 0.3656846473406883, 0.163567355290971, 0.27413796682120406, 0.23048045823989582, 0.2864798959865258, 0.285507610400749, 0.2381170652411032, 0.17305601691932204, 0.2769497298781629, 0.2707542059859528, 0.23582313469982996, 0.19464908462865838, 0.19808404482569353, 0.18362575141368853, 0.17482256981480748, 0.18350516544083884, 0.19170101725198685, 0.17914453771210248, 0.18582878039786177, 0.19076086748168786, 0.07602305671599585, 0.07685895432757972, 0.08048590744547168, 0.07026031856843162, 0.08239570634048377, 0.07472666461044486, 0.08651992528645369, 0.07680401977621354, 0.08139969928270652]}, "mutation_prompt": null}
{"id": "f18189a3-198c-4913-9c84-2c58dc8dc629", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.alpha = 0.2  # Differential learning rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.alpha:\n                    peer_idx = np.random.choice(self.population_size)\n                    diff_vector = population[peer_idx] - population[i]\n                    population[i] += self.alpha * diff_vector\n                    population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                    fitness[i] = func(population[i])\n                    evaluations += 1\n                    if fitness[i] < best_fitness:\n                        best_individual = population[i]\n                        best_fitness = fitness[i]\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced Adaptive CoDE with Differential Learning for Faster Convergence.", "configspace": "", "generation": 52, "fitness": 0.5089303559495116, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9175384996742311, 0.9069877098876682, 0.9145096028071403, 0.9114782292926037, 0.9105414848845358, 0.9067523953975922, 0.9082538410088531, 0.9145551194199196, 0.9149022220536193, 0.8252926370309019, 0.8231465050855628, 0.8306077821092501, 0.8114672477968705, 0.8219923071857134, 0.8293064298874238, 0.813347902126321, 0.8197682123242005, 0.8434918584655701, 0.1707216390956462, 0.1848159421905382, 0.14813253721987352, 0.14183509738313294, 0.1533592013301266, 0.18030527941000396, 0.15047969549590456, 0.15401025292875892, 0.15181690882944132, 0.10674769000197937, 0.09090073575037838, 0.10119670399209368, 0.11956715778384364, 0.11460730637222427, 0.1155801646768283, 0.12167455992586707, 0.11473227785132711, 0.10685200442265341, 0.9854835887101545, 0.9900155102195042, 0.9797407263474295, 0.9794151462819053, 0.9852085139312063, 0.9885890459961648, 0.9792494024458341, 0.9743657858769345, 0.979204994696465, 0.769850007233032, 0.7633820520844403, 0.7524223607531499, 0.7744996164002845, 0.7434127508699327, 0.7649401934690592, 0.7921338535604261, 0.7507813620804625, 0.7760202258581449, 0.9147465541916433, 0.9254334622631301, 0.920945061269266, 0.9235581964448843, 0.912461039110979, 0.2809417623208559, 0.8802877496303271, 0.9039156714082148, 0.8951877194371686, 0.6619150796350162, 0.7256392128315845, 0.734932886413797, 0.6162737515059125, 0.7344909708645309, 0.6623817724026594, 0.6895361386994141, 0.7023970329170796, 0.7192933012849405, 0.6184633086043814, 0.5427822931430285, 0.6591148494988953, 0.7481918768092398, 0.5804437898337544, 0.7447752941482839, 0.6888717231010402, 0.7053490556326869, 0.6413641519375264, 0.5157154147818761, 0.650211042139134, 0.6512131931555676, 0.6617925669336098, 0.6265252708967666, 0.667773937851249, 0.7138229767226969, 0.6140804164101926, 0.2748693943347731, 0.7825695491129072, 0.7768597964671596, 0.7810334769501945, 0.7300157871014571, 0.34238582249200833, 0.2938572343887609, 0.7690958250765696, 0.4914898452797436, 0.748934738432097, 0.11874819853405405, 0.34579978266643896, 0.22867147443242442, 0.5793580459925973, 0.5521408699221823, 0.6235101831895107, 0.18162513170210948, 0.1879086321239931, 0.2957818805310325, 0.6759185130258734, 0.5648754161380634, 0.6339584050343017, 0.6670398081881561, 0.5526146366597445, 0.6824893160792223, 0.6154025061276256, 0.4757153527972694, 0.6373527845760469, 0.8704631304789519, 0.8661407117114005, 0.8719529815039768, 0.8671214058182263, 0.8403809763492085, 0.867046061127737, 0.746870043050778, 0.867619269711297, 0.8682435729669575, 0.18177298913201512, 0.15273802391310565, 0.13687174627121146, 0.17432534602259642, 0.1489939122381928, 0.17757927611201996, 0.15225571225695422, 0.15575041393669742, 0.13798490215044168, 0.27819987932153556, 0.7501761672705631, 0.3947624853715088, 0.2042308943174933, 0.2199887245199953, 0.43587429674571543, 0.18999819201708523, 0.4491668473313909, 0.2597473376499113, 0.5671575078831317, 0.6296425847532429, 0.6323620501725802, 0.5059125959234368, 0.7553805367826301, 0.7660697590369231, 0.5371544292156674, 0.7775891025486651, 0.31621770555313955, 0.5554930495111221, 0.4713742017188599, 0.31371596071177765, 0.3908969731639852, 0.5337317913103776, 0.32950901271748856, 0.33432712364251427, 0.49838587036865467, 0.47972570530737235, 0.21787167923405149, 0.2159118501628553, 0.23067654017745587, 0.23048652217256393, 0.24838521901817745, 0.20667137765459698, 0.24240600860570505, 0.2072988725656193, 0.24579872521138602, 0.19835966065424127, 0.20707848974474408, 0.19832513871066204, 0.20981179103184266, 0.1819881114010835, 0.20333138651146487, 0.2226956514770514, 0.1995276631363202, 0.21867738037236595, 0.1837790322902676, 0.9213815879889093, 0.20067666475221901, 0.9392576333857635, 0.199297071226888, 0.19983923212446042, 0.1420354361838626, 0.15723786877876755, 0.1673933843887646, 0.9171799849292048, 0.21101822021635963, 0.8558272020757537, 0.8924978686459077, 0.2114663482331426, 0.15511502150939416, 0.16762830531009654, 0.8531294363896651, 0.9094928296157827, 0.2739017845383097, 0.19156434202288775, 0.22072247520527788, 0.18386708345262803, 0.21917218170147235, 0.226101305292973, 0.20266528813059004, 0.2134755040422458, 0.21994356114091884, 0.1525191363664813, 0.09462264225348349, 0.08964043283153111, 0.10273964111077005, 0.09989211009866417, 0.0853060158274851, 0.09054801875601204, 0.10797489307544417, 0.09900280424061625]}, "mutation_prompt": null}
{"id": "7babdc9c-8202-4aab-bc28-308428b61186", "solution": "import numpy as np\n\nclass QuantumAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.entanglement_factor = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                # Introduce dynamic entanglement\n                if np.random.rand() < self.entanglement_factor:\n                    entangled_candidates = self.entangle(population[i], best_individual)\n                    for candidate in entangled_candidates:\n                        candidate_fitness = func(candidate)\n                        evaluations += 1\n                        if candidate_fitness < fitness[i]:\n                            population[i] = candidate\n                            fitness[i] = candidate_fitness\n                            break\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def entangle(self, individual, best_individual):\n        entangled_states = []\n        for _ in range(2):\n            q_state = individual + np.random.normal(scale=self.entanglement_factor, size=self.dim) * (best_individual - individual)\n            entangled_states.append(np.clip(q_state, self.lower_bound, self.upper_bound))\n        return entangled_states", "name": "QuantumAdaptiveCoDE", "description": "Quantum-Inspired Adaptive CoDE with Dynamic Entanglement for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 53, "fitness": 0.5153839038773744, "feedback": "The algorithm QuantumAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.31.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9148218761733029, 0.9020167540734185, 0.9071089900781618, 0.9115649459805277, 0.9107978887732966, 0.9062672037732036, 0.911454190079158, 0.904819754007303, 0.9062324936181672, 0.8056476646903084, 0.8309287418478711, 0.8305604429487266, 0.833421564756946, 0.8317964783161891, 0.8292818028379394, 0.8149552148960546, 0.8287113348298115, 0.82966857678958, 0.162120208291052, 0.6187553063345663, 0.15512393765703014, 0.7610254163968293, 0.13805052681382513, 0.1534525326482562, 0.15608887867527432, 0.1270982076276277, 0.17161950987197283, 0.13695643989025774, 0.10794764726155914, 0.15473160927067497, 0.14114265721063712, 0.11275810739274983, 0.10435613956109935, 0.1456799124626572, 0.11974573824914969, 0.1324659864775949, 0.9713635995396964, 0.9764940572835532, 0.9820981201442206, 0.9663020529370238, 0.9595737202826333, 0.9822663696500584, 0.972421160468596, 0.9902874084508504, 0.9516820973520125, 0.7373681625254418, 0.7800738308382194, 0.7663735729975847, 0.7371584441852082, 0.7580818696409879, 0.7603176606577813, 0.7659088609971352, 0.7636890602622399, 0.7697480727994317, 0.22985473499493236, 0.9041907198849808, 0.8846683697539677, 0.9372799570607084, 0.21205137786746842, 0.9134553746602652, 0.9112220787741133, 0.8865444504093811, 0.9046987705294925, 0.7202714935219996, 0.6618853621751997, 0.7919789931395697, 0.13214315489163908, 0.722069794530301, 0.6504853506247817, 0.677082490274715, 0.7188992724149441, 0.6695787782085458, 0.7256409094775721, 0.6853214177791931, 0.7639484635677161, 0.7792883738279398, 0.6644847336492592, 0.7281123907081367, 0.7744384891878341, 0.7140900201119702, 0.7491940828653327, 0.5957240749858929, 0.7251662620229529, 0.6986388582977016, 0.6304898122100682, 0.7012673977201194, 0.6551122653350246, 0.7215007432583029, 0.7196486650303628, 0.7294109699123885, 0.7705760041550415, 0.7383133670630908, 0.7692073292570164, 0.7751345221727945, 0.7718302229808247, 0.5525658753625853, 0.8034046349637267, 0.7848282884319937, 0.47100783401058954, 0.27948665864187583, 0.1069356075988046, 0.1422256965117844, 0.5900244011761302, 0.18699870794550344, 0.6483741479265441, 0.2324111660392688, 0.35330584323961234, 0.4005803316093588, 0.632022951378788, 0.6655364376009578, 0.663275694604505, 0.6693583704139178, 0.6937052750307715, 0.6740516056015659, 0.6398060261824032, 0.651987782304305, 0.642525052502197, 0.8581584419446836, 0.8602502152394085, 0.875891505276806, 0.8769767850022311, 0.8710849869405425, 0.8593822600905068, 0.869769295012379, 0.8625947407513986, 0.8717752762669045, 0.1721391216468523, 0.17703997380762482, 0.11047867085966157, 0.1456290638813723, 0.13251846815113422, 0.13685377759660877, 0.13007313337188642, 0.1489858747530476, 0.15854735542954113, 0.303512702151883, 0.17626163488512736, 0.19180260988221587, 0.22233182081056935, 0.5642797169828042, 0.37666064559799406, 0.2782157303315501, 0.16568160193747083, 0.1843851313020396, 0.7038419971606074, 0.689958545704725, 0.7137893937278288, 0.7062117715369156, 0.5421848664851618, 0.7348909299496325, 0.7259888011274436, 0.625563947130745, 0.6014209101018926, 0.5387735780777796, 0.6096395508959652, 0.4886860839877676, 0.5955099697644395, 0.5288533235905473, 0.2288481633565076, 0.6107341564911084, 0.4713132123118543, 0.6859213828705526, 0.2103639315731881, 0.21233989447121637, 0.21385494705498853, 0.19926577303718784, 0.2197026584761297, 0.2305697415194221, 0.22338074681710463, 0.20855981669491586, 0.21656829798235888, 0.24219626899048385, 0.7271567209706857, 0.20743201575024606, 0.2024548690641529, 0.1948385496157108, 0.22364198968895754, 0.19085289030232955, 0.22384555112775484, 0.19089456308190655, 0.16560104874309223, 0.16749075567002802, 0.15416222320090178, 0.9311468661355249, 0.20035208108169922, 0.2000765175972965, 0.17637135098378987, 0.20701692072893607, 0.8623499968366466, 0.9074848257230497, 0.1688843899730147, 0.9146176523180792, 0.8907566165669539, 0.16762526383060394, 0.1681656878157317, 0.10448821268217268, 0.11246843803173634, 0.10473476465422082, 0.19450049100750477, 0.2028469998693162, 0.1868356856741007, 0.19779056444547927, 0.1831313439205302, 0.18135027873984422, 0.19738424283371436, 0.20161543454210296, 0.18395751664098747, 0.0955280115743492, 0.09386720063935294, 0.08736932553268995, 0.08433318084308361, 0.09448583930712962, 0.10368385961079962, 0.09594543573568715, 0.11647375786010739, 0.09699901582195947]}, "mutation_prompt": null}
{"id": "366458da-c0e5-44c5-be3d-6d11c1b817a1", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "c60fb5f3-5337-41a7-a62d-422e0e914c8d", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Stochastic Step Size for Enhanced Local Search and Exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.1292196900163235, 0.1492688283258694, 0.17648957516114605, 0.15668186467629241, 0.13570242631622098, 0.617196753638718, 0.13759425967159045, 0.17547458408766892, 0.13474677104602995, 0.11896328542299239, 0.12723744143408, 0.1324947550835217, 0.14874280185404132, 0.1275340233587332, 0.14136619935529726, 0.13417658752804196, 0.11219389599451712, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6839848983606052, 0.637421718217472, 0.6854753534888879, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.108392488833433, 0.1473543866736744, 0.17190016584155732, 0.10295122102240073, 0.1333502948798243, 0.15720729560171764, 0.1340491807696319, 0.12197132087760187, 0.1408990852227615, 0.6847240630975421, 0.8064795999398799, 0.3316909180529658, 0.30914134337218446, 0.1695397905305015, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.716803695356218, 0.715808517729795, 0.7346991578034179, 0.7194468427013807, 0.7112477747286412, 0.6918571265754274, 0.5455279305564029, 0.7679558838560596, 0.6378563920481208, 0.555695356835497, 0.5756641521827441, 0.606014820690233, 0.6524694687716099, 0.2594499454960548, 0.47708066435022334, 0.6920494763257583, 0.571753993114675, 0.6727352552990246, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496773052, 0.24954120677691205, 0.2089355077776932, 0.7127353020253682, 0.20214899961646027, 0.22073347337720295, 0.2016463674979404, 0.7843193504840147, 0.24272735715180593, 0.18651505573874105, 0.18745256279014777, 0.2003050418035459, 0.9151272172316909, 0.20079593464576884, 0.920504483371455, 0.9091934308991853, 0.1578329482126828, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559472, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "12bf6d09-609a-4908-8f68-00f4fd1992fc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.exploration_exploitation_ratio = 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n        dynamic_population_size = self.population_size\n\n        while evaluations < self.budget:\n            dynamic_population_size = int(self.exploration_exploitation_ratio * self.population_size)\n            for i in range(dynamic_population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.exploration_exploitation_ratio = 0.5 + 0.5 * np.tanh(0.1 * (evaluations / self.budget - 0.5))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced Adaptive CoDE with Dynamic Population and Exploration-Exploitation Balance through Adaptive Control Parameters.", "configspace": "", "generation": 56, "fitness": 0.19619341547506725, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.39263838950591057, 0.32756432881849995, 0.34873018239272124, 0.36264447853655835, 0.3502807797568781, 0.35693108972989107, 0.34695070521293925, 0.3434473459983979, 0.3271847343913068, 0.002533881525101034, 0.006867608311573181, 0.009952363215267379, 0.022807518825479156, 0.0001590520561119968, 0.06269109285302821, 0.00873000312977712, 0.013293419055801836, 0.05344718315735697, 0.09965480791166537, 0.08653228750617947, 0.08532696153207908, 0.08797194922003404, 0.07607442319546875, 0.08067600687056786, 0.09158347437693082, 0.09113475525744397, 0.0918204730013622, 0.07518450270679755, 0.06519620125407932, 0.06664528119432944, 0.07040147318158285, 0.06261116977225101, 0.0858975627530899, 0.06271079907860533, 0.07283348235654286, 0.07286427603272783, 0.9872301728850025, 0.9929661081665121, 0.9842973342429986, 0.9864434010003114, 0.9830795953128801, 0.9843402953530722, 0.9872431666264241, 0.9743773217850958, 0.982782664617006, 0.17512325402929563, 0.14033783523345378, 0.16088869035419318, 0.15213192619029725, 0.15605232482376885, 0.220639447746088, 0.15957142699698745, 0.1592146404502497, 0.18175726699467487, 0.22367555177466658, 0.35882336841239626, 0.7134931270754677, 0.2092730326924187, 0.6566864813943969, 0.7834933022381962, 0.3285672509571044, 0.3830208669111069, 0.2262280807456849, 0.176450445897678, 0.10829882717849448, 0.12582126774448332, 0.1059652516026316, 0.1374639284537461, 0.10865121691646507, 0.11559890572797737, 0.09735464993730925, 0.1203701421660116, 0.10367745396447647, 0.09529127811304827, 0.1022164520935579, 0.12239986712975592, 0.12933382412526684, 0.10878216767372273, 0.12312314971615068, 0.09703922625819084, 0.12812430432083288, 0.03964407689265603, 0.04652884565595683, 9.999999999998899e-05, 0.0003553390894339703, 9.999999999998899e-05, 9.999999999998899e-05, 0.00134091630355615, 0.013129883743223547, 0.0003581200419273678, 0.0924173569948411, 0.06797983973564314, 0.07304222568190744, 0.10724021918325011, 0.06771014371513995, 0.10200027144666513, 0.1325372574201399, 0.10286599796376339, 0.08767877212622477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06694021543200956, 0.05988759569746793, 0.06290337023973513, 0.07285543595576549, 0.049199919888645804, 0.05567250722489203, 0.042662858275039794, 0.04729469800802255, 0.05021835733165225, 0.31820069340929236, 0.31678152788339853, 0.35270797237548124, 0.35698027784636066, 0.32625234737654096, 0.3177389508373911, 0.3796710415535024, 0.31572539432902724, 0.34671461921754543, 0.08464124512665472, 0.07943170586344672, 0.06997957150470957, 0.08576280821725668, 0.09660172524361155, 0.07437035143694992, 0.06655003817421312, 0.08558258985435807, 0.08009288117724189, 0.1486359544887479, 0.13789364155650363, 0.18880443924401258, 0.12231705050027719, 0.13397306381832164, 0.1390142881064752, 0.14380410031565405, 0.13489193503640362, 0.15392467921817954, 0.22574532525260893, 0.24883998632550752, 0.24700254242918473, 0.24618634698656094, 0.22017616564077758, 0.26872515470911296, 0.23054182067019435, 0.2303702054891993, 0.2465660292895525, 0.1714037561301497, 0.16184774946614, 0.19004037808506313, 0.16113971060522714, 0.18152749051358286, 0.16533287872966007, 0.16045405011746838, 0.18449659328475632, 0.1895944833282277, 0.20799915005648462, 0.18590985547331274, 0.1949855737996229, 0.1874991431044679, 0.18286775375075126, 0.196712310133065, 0.18967727908760712, 0.1717789770602216, 0.21547458221060256, 0.17672540485355748, 0.17088543209318308, 0.1722364216402641, 0.1830112780501647, 0.16503035356588458, 0.17512393470231524, 0.17082724871849186, 0.16936479619133915, 0.1597867079741916, 0.1780050329572126, 0.40774875089925466, 0.3078880739723552, 0.4948497368899486, 0.19183322721353457, 0.1951806156405691, 0.3862691825101052, 0.19561422889687363, 0.4390316415065505, 0.4214818243535535, 0.20349967478570208, 0.3943118036337917, 0.3058191400648903, 0.1983525962979238, 0.3143552709250498, 0.20946561603677705, 0.22051327243571217, 0.35832691349393664, 0.17775936887799493, 0.18712075609803092, 0.18814324021141127, 0.21577327151516057, 0.17932164346277935, 0.18859398151021334, 0.17917054172395142, 0.17384939192244497, 0.1911795555006639, 0.07169066048805128, 0.08017277315904192, 0.0733410401784349, 0.07821180514519543, 0.06607824282147523, 0.06137330005949482, 0.07006548562231552, 0.07693882019141585, 0.07017693663120972]}, "mutation_prompt": null}
{"id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Improved Adaptive CoDE with Enhanced Diversity Maintenance for Robust Global and Local Exploration.", "configspace": "", "generation": 57, "fitness": 0.5659799771222236, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.30.", "error": "", "parent_id": "d0662acd-7ea7-440b-b1f2-db6090fa0509", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.13082243391408332, 0.14926882832655353, 0.4871502730920929, 0.1566818646751459, 0.13570242631640106, 0.617196753638718, 0.1434970705283406, 0.17547458408710936, 0.13928315457245588, 0.1189632854231788, 0.13000621709587412, 0.13249475508348774, 0.14874280185365985, 0.12753402335912323, 0.14136619935343897, 0.13437263489837425, 0.13224867351621183, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6838500505938747, 0.6374214476331126, 0.6777146197687898, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.10839248883327424, 0.14735438667347678, 0.17190016584136014, 0.10295122102213972, 0.13335029487955397, 0.15720729559937097, 0.13404918076899575, 0.12197132087737994, 0.14089908522209627, 0.6847240630975421, 0.8064795999398799, 0.33169013459262564, 0.30914131438775505, 0.16953977388728259, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.7034778980630669, 0.7097195853213218, 0.7274573919572764, 0.7146626855679129, 0.6997498948705058, 0.6792506696181246, 0.5455138719437629, 0.759666167706329, 0.6360804614621964, 0.5546263845368586, 0.5628789544136292, 0.5889206638705538, 0.5923266609197938, 0.2594499454960548, 0.47691450874840047, 0.6778095954785703, 0.5714513874489102, 0.6741277609996407, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496757575, 0.24954120677673663, 0.2089355077776709, 0.7127353020253682, 0.20214899961642407, 0.2207334733772448, 0.20164636749791687, 0.7843193504840147, 0.2427273571520273, 0.18651505573874283, 0.18745256279014155, 0.20030504180354325, 0.9151272172316909, 0.20079593464574463, 0.920504483371455, 0.9091934308991853, 0.15783294821268368, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559195, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "04e714e7-02a0-403f-953d-1ce51ceb124d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDEPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.dynamic_CR = self.CR\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.dynamic_CR = max(0.2, min(1.0, self.dynamic_CR * (1.1 if adaptation_counter < 5 else 0.9)))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDEPlusPlus", "description": "EnhancedAdaptiveCoDE++: Optimized Adaptive CoDE with dynamic parameter tuning and enhanced exploration-exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.3107600186995476, "feedback": "The algorithm EnhancedAdaptiveCoDEPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8485856272298122, 0.8546582385511334, 0.8564104776080748, 0.851971815780846, 0.8267661103156332, 0.8745227859947249, 0.8357645996573204, 0.8218725544791982, 0.8365800492865412, 0.6749555885902678, 0.6728148305480237, 0.6907929041043491, 0.7024258006189035, 0.700264896286761, 0.6967150558854027, 0.6754556354694927, 0.7281448179095007, 0.6959594238436903, 0.55052885275872, 0.5491399499941534, 0.5178165007343061, 0.6087141314961595, 0.6109981487188867, 0.5498982889716049, 0.5825195193624138, 0.5803178413603503, 0.5872836906506556, 0.5373304144194846, 0.5391714582018745, 0.5041876778819481, 0.14831047952085097, 0.4903072887234099, 0.5274492906673847, 0.3824608767146498, 0.17230378036120741, 0.4482358194146222, 0.9895195481190271, 0.9912116985763993, 0.9779486850255921, 0.9657803911556305, 0.9597236864251628, 0.9841229486466692, 0.9655334962501001, 0.9680163556289763, 0.97965757516349, 0.32538848040101087, 0.2910435421352674, 0.29189861738711065, 0.32246840767356677, 0.3337005802829486, 0.2877063901842164, 0.23902642562154974, 0.27213330627185806, 0.2571939665890868, 0.32067615720339104, 0.30149057409482916, 0.28771301305480734, 0.2979765792518303, 0.32912424254565753, 0.3530037147306532, 0.25488433717197545, 0.22447404850317676, 0.28309369096230563, 0.16423186470373552, 0.1626451610038412, 0.1515705825887308, 0.17042948355404985, 0.180938130207149, 0.20500684841091255, 0.20564101181489236, 0.17061175571400544, 0.27024400867683984, 0.18080896047935868, 0.11173958006948759, 0.12967460177100254, 0.21088018259736596, 0.16354237377638803, 0.14357250286952383, 0.18942419515307363, 0.16716392076336162, 0.11224035150958789, 9.999999999998899e-05, 0.03558582056552417, 9.999999999998899e-05, 0.012776250386067445, 0.0243660052104111, 9.999999999998899e-05, 0.0032177064645307896, 9.999999999998899e-05, 9.999999999998899e-05, 0.14361111912073443, 0.053252503569986565, 0.11257614335301735, 0.08796132559436631, 0.03985434169246038, 0.05547748745470804, 0.13635249740898747, 0.12049454423858241, 0.12545927616628538, 0.04602765526647257, 0.006816036919373825, 0.03391002066833282, 0.06958534085611279, 0.025757248583386905, 0.00042550340900271433, 0.03934409978955267, 0.008254678165392382, 0.030652309621722496, 0.12101722494136391, 0.12377402586277442, 0.19601499088478602, 0.12775707266211522, 0.11579325870995927, 0.17544224408817521, 0.10132256438758236, 0.07447712983095245, 0.13666449644632828, 0.48504938949898, 0.5089116999778382, 0.4925432038382582, 0.47276413303975473, 0.49088694905506824, 0.4812602697018119, 0.4983179122784701, 0.5162765266712245, 0.49998717819989735, 0.1178982215987806, 0.1347700618906782, 0.13189688703093183, 0.12984199526963236, 0.1126660847746731, 0.11840110788530878, 0.14060212140658046, 0.1134430418354363, 0.09400877012408926, 0.17968604064496962, 0.15576419267044217, 0.17665061174907604, 0.1619319677550879, 0.15185296111905588, 0.1515093304047136, 0.21541539374894914, 0.1463532526748963, 0.14547714004044032, 0.3014500042427256, 0.2963827621645093, 0.3179329678128948, 0.2880515078535998, 0.3110190493394902, 0.34238482821800065, 0.35324445749092526, 0.3545767268865363, 0.3423875787511078, 0.19302415384719174, 0.2294048975475398, 0.23156671006122465, 0.21283758986354995, 0.21857737184500103, 0.276211814124651, 0.23724100770406908, 0.24794597912034, 0.18720859477167917, 0.2253477993494455, 0.2132232521915588, 0.21867215926910233, 0.1998069522560173, 0.20318098958930664, 0.21176716643520177, 0.2131344221045418, 0.2071911416083705, 0.21295243530257324, 0.2338836686482868, 0.21505757306101525, 0.21877255342981183, 0.25247768670414084, 0.22571024825305608, 0.21851519973662792, 0.45336242493715306, 0.2695655251302994, 0.3135065420650325, 0.18444532581841955, 0.5050823367616407, 0.19604456945361304, 0.6046680298426084, 0.46587126540126234, 0.5261403868872103, 0.2866289166371676, 0.34964864292057274, 0.6972635589303893, 0.4617072583439644, 0.21000673354509458, 0.3876084706000049, 0.20329819138205296, 0.1972909846390054, 0.16634702376359, 0.1611004287328851, 0.1051005571141086, 0.37340814411429823, 0.1985127507903669, 0.2088576609643803, 0.18204567053230325, 0.18110022547959004, 0.20350273329182134, 0.19110683935990447, 0.2082593591292422, 0.17969110530188137, 0.19302795864486144, 0.07727795932347858, 0.09438916203334868, 0.08486076471988457, 0.08584076979363997, 0.09507309781209261, 0.08244823451034777, 0.08137895725147537, 0.07854440915627181, 0.08381125036687609]}, "mutation_prompt": null}
{"id": "b91b693b-6a91-4f40-af38-496df6bb43a7", "solution": "import numpy as np\n\nclass OptimizedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.strategy_probabilities = np.array([1/3, 1/3, 1/3])\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies, p=self.strategy_probabilities)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.adjust_strategy_probabilities(population, fitness)\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def adjust_strategy_probabilities(self, population, fitness):\n        # Adjust probabilities of mutation strategies based on success rate\n        success_count = np.zeros(len(self.mutation_strategies))\n        for i in range(self.population_size):\n            # Increment success count if the new fitness is better than the current fitness\n            if fitness[i] < np.min(fitness):\n                success_count += 1\n        success_rate = success_count / np.sum(success_count)\n        self.strategy_probabilities = 0.8 * self.strategy_probabilities + 0.2 * success_rate\n        self.strategy_probabilities /= np.sum(self.strategy_probabilities)", "name": "OptimizedAdaptiveCoDE", "description": "Optimized Adaptive CoDE with Dynamic Strategy Selection and Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {}, "mutation_prompt": null}
{"id": "f43efc24-216d-4fb6-9441-b46d757dd7fe", "solution": "import numpy as np\n\nclass AdvancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n            # Introduce stochastic gradient descent\n            if np.random.rand() < 0.05:\n                gradient_descent_step = self.learning_rate * np.random.randn(self.dim)\n                best_individual += gradient_descent_step\n                best_individual = np.clip(best_individual, self.lower_bound, self.upper_bound)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "AdvancedAdaptiveCoDE", "description": "Advanced Adaptive CoDE employing Stochastic Gradient Descent for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 60, "fitness": 0.5304118377464584, "feedback": "The algorithm AdvancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9198427323297064, 0.9113230540537618, 0.9165822201066394, 0.912792236511203, 0.9118441085138952, 0.9194770986406954, 0.9136193396027561, 0.9145565202129627, 0.9181914959237931, 0.8305426158778291, 0.8333106963571589, 0.8274078642968798, 0.8278783039433075, 0.8314529213984172, 0.8455326093700934, 0.825387436872887, 0.8333284921493325, 0.8347426938922409, 0.47018156722273985, 0.15424822004273497, 0.161148184217907, 0.13727084704034154, 0.15702277948987942, 0.1536445464514269, 0.1663907480798129, 0.14442065625682932, 0.1691524996599636, 0.11781750298972316, 0.13506403313117876, 0.15224283408473438, 0.11355620742969441, 0.1200391929437794, 0.12467077784124436, 0.15808349232597063, 0.1469428655718069, 0.11901562402291621, 0.984589658969341, 0.9883507182031519, 0.980243384882362, 0.95705281638699, 0.9692284674225856, 0.9789566004433181, 0.9640370767639986, 0.9575065511411788, 0.9814459544822531, 0.7658259175326729, 0.7686881083652815, 0.7341986976454583, 0.7687499789801443, 0.7789125412607557, 0.7609563312234646, 0.7634632159970453, 0.7548401801797128, 0.7425996650984608, 0.9093737232794615, 0.9083800106517415, 0.9141328125497284, 0.9330355076116853, 0.2134621923520692, 0.9106382342018757, 0.8939891367268709, 0.9083127491237005, 0.9211694072911363, 0.7328097179079276, 0.690700570215617, 0.699672068961729, 0.6326632600505591, 0.699222558694469, 0.7044395308904258, 0.7867573591607824, 0.7342556247989763, 0.6533603292242751, 0.13453706850361158, 0.6200336755231315, 0.6808019320457769, 0.7128094362679139, 0.6783317634447465, 0.13267634021695507, 0.7224585863261399, 0.7212397843683698, 0.6619984772859219, 0.6375873971010797, 0.6214573314112017, 0.6780517032838304, 0.7186372075515401, 0.7005202144610301, 0.6574119236748446, 0.7212093688455425, 0.7062336885637899, 0.7253626026943829, 0.7924564790674365, 0.7373683367541346, 0.7839418103654265, 0.7657386600398126, 0.7341334836509043, 0.7792738131526404, 0.7699065571268998, 0.707799221115673, 0.7906057939404436, 0.1611432789838545, 0.1188164048467012, 0.28814374120998565, 0.4942675858814799, 0.48806513033619126, 0.6919728309119738, 0.487099911413026, 0.31900263018478503, 0.1562682478516212, 0.668550687137343, 0.6675183996781638, 0.6447628266243703, 0.691395556084911, 0.6647967617627825, 0.6771177022395163, 0.6621983700781856, 0.6434750531210724, 0.5532170910486198, 0.8741003964078479, 0.8711929926554722, 0.8738236627038718, 0.87747473480387, 0.8784914284692915, 0.8360556198145701, 0.8732922086991523, 0.8530456212075219, 0.8681648840422792, 0.12407410077686787, 0.11372648243156946, 0.11837490910119342, 0.1439331207875617, 0.11789482997233758, 0.13601610857280388, 0.14858189157074686, 0.10947536332343921, 0.11583956540147322, 0.16239694539781613, 0.5172589590415151, 0.28740652491893215, 0.4192626476732121, 0.20934923196903898, 0.23219761132238226, 0.41456196462575257, 0.20781257563957212, 0.6061585978847084, 0.605590338863472, 0.7243031067256074, 0.40871509256017935, 0.701430197297537, 0.6233770157875721, 0.7081106850460211, 0.7370031164062625, 0.7198747770491487, 0.6210688619133362, 0.42995779531433753, 0.5238150150890882, 0.4990301551904698, 0.46621339925384697, 0.6294079463906064, 0.597631362622002, 0.6144047503501411, 0.5513017802061367, 0.5584446807445912, 0.22036107126982463, 0.21767800619747957, 0.20467494319040547, 0.20839146083604554, 0.2548626147612053, 0.20389566012542315, 0.19818200412050124, 0.2029285178259288, 0.21516914679175503, 0.20673412050101136, 0.20882284201927181, 0.2451865168117887, 0.2062728504973339, 0.7643638855720991, 0.21957295995745862, 0.2232696048051689, 0.7835061634517161, 0.8050760122696295, 0.1859225028084719, 0.15737895654444312, 0.20056431027144517, 0.9254854648713159, 0.20003235663838825, 0.19857078692663532, 0.9117558598049421, 0.1582099449853056, 0.9155688785042259, 0.921786924130575, 0.21197562404164705, 0.93006863325736, 0.20995209919636026, 0.21019970495705598, 0.8996633303250929, 0.20480693266035133, 0.10454884026791711, 0.9277337520502194, 0.18174619483532806, 0.18109363714831117, 0.1857378421963113, 0.20926728576373954, 0.19590133311861102, 0.18434255230846253, 0.1870884174081786, 0.18852504099008438, 0.19338556602449064, 0.09555240152862365, 0.0960262633363258, 0.08694841991270152, 0.09169350186153602, 0.08672901965133828, 0.10064547998492257, 0.0953281626005249, 0.09419232883951922, 0.09679662274982237]}, "mutation_prompt": null}
{"id": "4a10c401-0ccd-4ae4-8a06-419c42375e93", "solution": "import numpy as np\n\nclass DynamicAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.strategy_weights = np.ones(len(self.mutation_strategies)) / len(self.mutation_strategies)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.strategy_weights)\n                strategy = self.mutation_strategies[strategy_idx]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                        self.strategy_weights *= 1.1  # Increase weight of successful strategies\n                        self.strategy_weights /= np.sum(self.strategy_weights)\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicAdaptiveCoDE", "description": "DynamicAdaptiveCoDE: Utilizes dynamic control of mutation strategies and population rediversification to enhance global exploration.", "configspace": "", "generation": 61, "fitness": 0.5355564373268984, "feedback": "The algorithm DynamicAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9099823729663492, 0.9088860505276607, 0.9108437760997048, 0.9130987168101952, 0.9129507752612647, 0.9093488318047578, 0.9139778301769205, 0.9135652173218273, 0.9058472013955143, 0.8103035088703489, 0.8202843599530776, 0.8167430063850638, 0.8360810955037077, 0.83794854090044, 0.8248064943438086, 0.8253992504676584, 0.8463748968875743, 0.8269761434110237, 0.1731578456090208, 0.1565628198872877, 0.45235513212609924, 0.6565955910934919, 0.16030506362427, 0.12632866974915435, 0.12732000663517096, 0.17376774220089408, 0.6818457692612483, 0.10664653970608362, 0.1376656424666144, 0.11365110013244972, 0.12575174850825188, 0.12044047349993581, 0.13284933231816376, 0.14046847565383325, 0.12711631207033347, 0.12402490414069456, 0.9816178770414158, 0.9823612037099408, 0.9797048286235684, 0.9705792452906227, 0.9729807999912031, 0.9823145645881084, 0.984997262401033, 0.9725629500305153, 0.9576359796229614, 0.7670581954407591, 0.7879582554926302, 0.756967955575319, 0.7827032818486982, 0.7547878081862046, 0.7803346331615755, 0.7945121410178762, 0.7816113187750469, 0.7653908303793834, 0.8960937871893313, 0.8970462523347981, 0.8887779904409012, 0.9011402455189277, 0.21336583048291535, 0.9111354110640206, 0.2393130652431571, 0.9049652299201942, 0.9004430040515503, 0.7683451821914477, 0.7217539398742461, 0.6974936202238584, 0.7738447681678142, 0.7620312723888873, 0.7026699748748213, 0.7166748558439525, 0.6674146412808404, 0.7366368156287073, 0.7904074303836013, 0.7261327109357585, 0.7155165855358359, 0.7419978562571878, 0.6668345421455448, 0.13442968863228966, 0.7055550104145221, 0.7399625714977881, 0.6964234271094693, 0.7428496372890556, 0.7395689330453965, 0.6333992969167866, 0.7562316627448604, 0.7329483116894304, 0.6514823472320541, 0.6967394216650062, 0.255468812710277, 0.5940483276530852, 0.7709598490535572, 0.7939602545542545, 0.7479927839640692, 0.7463320169192352, 0.7836141055920806, 0.7444004591192654, 0.7901884694206294, 0.7928170412352795, 0.7816650785152917, 0.28363203313843144, 0.5141646090758931, 0.23646339841752118, 0.35478267355591286, 0.529118486321964, 0.2610157931284821, 0.3246873203985038, 0.25147127174869144, 0.21079097369240085, 0.6777365310710092, 0.6718859967556581, 0.6679732812135701, 0.6793241047785701, 0.6262092311038372, 0.6569902466752731, 0.6421146137177569, 0.6993377235914555, 0.5870520868268785, 0.8516089061529835, 0.8405644418542122, 0.8703093961801943, 0.8581446215778371, 0.8653111991508835, 0.8722091969684203, 0.8736602978965082, 0.8643631802363246, 0.8642237917458468, 0.14078984950738127, 0.1449383211804297, 0.14798074345503354, 0.15645645381862905, 0.17578794542783593, 0.15003177627678776, 0.13508896902066714, 0.14483654017517567, 0.11681222560943239, 0.6284348806514222, 0.14880521184710793, 0.6055185601872337, 0.3902470735005682, 0.7219422170995983, 0.28172106161396215, 0.5317442504548422, 0.6416090761833029, 0.3560384901541106, 0.7185209073856702, 0.7441342029688738, 0.6844283966244586, 0.6162567045112788, 0.6874679321390538, 0.7049906360189644, 0.5385228025831135, 0.6243952363101266, 0.7334378228961669, 0.5096683227634544, 0.5573780759114187, 0.5437673906989438, 0.5628365025292746, 0.6119103603313193, 0.2702845251328946, 0.5407019689287733, 0.5777275825210214, 0.6615230663715965, 0.20351586683196798, 0.21469768169124448, 0.23442835323041078, 0.2579842616531388, 0.1939700450651387, 0.23509257715367393, 0.21277558474510472, 0.19619297978094974, 0.2004094900520591, 0.24424006826144273, 0.23871665476543769, 0.24348657616774583, 0.19209905300978336, 0.2425665280531203, 0.2189067006883494, 0.2191779853061696, 0.20473368959508786, 0.2472866216032047, 0.16527637571133413, 0.8957602933706125, 0.9105390349870984, 0.8882296467902577, 0.1991848547432905, 0.1988938401069188, 0.17800696576678543, 0.922258295592479, 0.15781116952907304, 0.9050526903417928, 0.21222115128834806, 0.8726161258616651, 0.9048293650706273, 0.16755408971929409, 0.16808888164137292, 0.21243352741899202, 0.15582311980024355, 0.658679895706622, 0.1972902829501556, 0.21890658995036227, 0.18818151100963565, 0.19224892398331206, 0.1834241498831568, 0.18566756007694107, 0.19523107606717416, 0.1938646960407464, 0.19097338177069578, 0.09549291987488817, 0.08481344230064547, 0.08403573528227404, 0.08680139138045628, 0.08693838718489366, 0.09851316558340062, 0.09536496116116155, 0.08947054730671933, 0.09012732203891882]}, "mutation_prompt": null}
{"id": "6ffe66c7-319a-4281-a498-6249955460bc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 6  # Adjusted population size for better exploration\n        self.F = 0.6  # Tuned scaling factor\n        self.CR = 0.85  # Tuned crossover probability\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15  # Increased for more local refinements\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies, p=[0.4, 0.4, 0.2])  # Adjusted strategy probabilities\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Improved Adaptive CoDE with Enhanced Exploration through Adaptive Strategy Selection and Tuned Parameters.", "configspace": "", "generation": 62, "fitness": 0.41927681432010894, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8544359714618662, 0.863413056367435, 0.8622620106849282, 0.8600455041109155, 0.8678903920962545, 0.867758903938119, 0.857273127824265, 0.8611774195686926, 0.8583064793106634, 0.6908484999065028, 0.7399695218236537, 0.7403562866257763, 0.7441280933026144, 0.7424455773222882, 0.7535229330187192, 0.7564583887955396, 0.7384739413347183, 0.7375415487357264, 0.17168544036582056, 0.10499659099696546, 0.14181304665891037, 0.12771842383918497, 0.12472796403743092, 0.13288460105921618, 0.13262625340987033, 0.14689369741842706, 0.5626873127210433, 0.1358006218517045, 0.11152251972687299, 0.1176019563921924, 0.1491094170046472, 0.1226205476340898, 0.09696763423442611, 0.13101067149740342, 0.12067193967731416, 0.12796697915150435, 0.9795830683297652, 0.9764813349165081, 0.9712477307991306, 0.9818486643480233, 0.9784885032607109, 0.9589366751818786, 0.9898987530054939, 0.9772817322444409, 0.9748525259177407, 0.5741408594117173, 0.5260524933245483, 0.5052550898013831, 0.5504013825348744, 0.5807687412699704, 0.5577485851701305, 0.5328026659813233, 0.5767977032220457, 0.6175555212147085, 0.8396027228536342, 0.773423055946807, 0.8209373700804827, 0.8335369577763694, 0.7952723486801907, 0.8153289017280869, 0.8460605878863069, 0.8283664252022639, 0.8122189707136176, 0.6009585265399149, 0.5056851338172212, 0.5195978638045271, 0.48215716968289213, 0.4770942747843854, 0.565399106624724, 0.562417099041638, 0.5511830053176581, 0.5479790685631516, 0.5088174761519413, 0.47189806675779, 0.5361144178009765, 0.6001235031616705, 0.556149340939519, 0.5458834993714469, 0.5517253476242915, 0.5171892105188687, 0.5685398724456066, 0.297450082989685, 0.32909125871785705, 0.29102839416628434, 0.13440686040619954, 0.2458086886208224, 0.24775313325368853, 0.2985735104406241, 0.2869500526518073, 0.3141349179414519, 0.37714704000926913, 0.4216391748240985, 0.43116264923966086, 0.41045468649001793, 0.465033435474543, 0.28752105270860495, 0.5549352605835527, 0.5044173224364568, 0.4937678157812848, 0.17069846542061073, 0.179890971951432, 0.1668604415811924, 0.33812757383507586, 0.22122738211944792, 0.36212051836189496, 0.20655284110558003, 0.12833953344174331, 0.12503791874759884, 0.36244901353538395, 0.3379565835906564, 0.3582382041681803, 0.38193511807907765, 0.3713703869501319, 0.37116536551750556, 0.3568985349697139, 0.32958216683298747, 0.3628507118243035, 0.7372930131082305, 0.7489956342388717, 0.7649128124997523, 0.741180235692436, 0.7687912261013933, 0.7573569923362347, 0.7470000542075407, 0.7541140135173139, 0.7722774409756378, 0.09990396574873228, 0.10919970528092404, 0.10942457483146295, 0.10935441716809857, 0.11573503213474046, 0.10067401942811616, 0.12656215438221985, 0.11623788461577056, 0.09636364189854973, 0.2007878191288085, 0.17476264583775958, 0.1416815567052001, 0.18056353427114424, 0.30050192429393274, 0.16376418753236976, 0.2670078445100731, 0.17312629774030752, 0.26588235429798923, 0.47501221591929343, 0.4399911383454125, 0.4914407189033667, 0.5030064498638718, 0.48068133086120013, 0.5207029060715741, 0.5323694946933183, 0.5536453099705179, 0.554936810849965, 0.3813267006874417, 0.3762430068111371, 0.3448491490076041, 0.32534617797576737, 0.308778890458271, 0.33110999835194965, 0.4220223170774582, 0.4311117361925213, 0.40876367450054596, 0.22089019420332456, 0.23910318590072455, 0.22277862906335177, 0.1905707204651882, 0.19896261074330746, 0.17210749896978372, 0.20779096725366708, 0.19512747955822574, 0.18314448798638172, 0.230573227895716, 0.6045105929166205, 0.21966681611527306, 0.48541622984605715, 0.2121905431988248, 0.42534746036058546, 0.6281948503225296, 0.22592312962904637, 0.4433641234496277, 0.861751562770666, 0.1497833632134581, 0.15282958012140369, 0.17422981573554608, 0.1953975385347987, 0.195218703341988, 0.14105059816904597, 0.1704445193955273, 0.871443527497368, 0.7609920974762282, 0.20885965269002504, 0.20722918226463172, 0.1633578762965977, 0.1649125620425853, 0.7830988957895458, 0.1361259964364726, 0.2101879117305796, 0.21063674761538564, 0.1884867297749666, 0.18695667400151428, 0.1723797001165125, 0.19480411034733258, 0.18880773805386053, 0.18451325779495598, 0.1752280111082518, 0.222284203655582, 0.1870893801645097, 0.08522705201888059, 0.0871380948206848, 0.07394818496160682, 0.08214551231072675, 0.10046584596276009, 0.07880266794225499, 0.08901610948191552, 0.07934098829952041, 0.07716004787826292]}, "mutation_prompt": null}
{"id": "bad70f7b-a7ef-4812-a479-351bae595f41", "solution": "import numpy as np\n\nclass DynamicAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.6  # Slight increase for exploration\n        self.CR = 0.95  # Slight increase for exploration\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15  # Slight increase for local refinement\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.global_search_probability = 0.05  # New feature for stochastic selection\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.global_search_probability:\n                    strategy = self.mutation_rand_1  # Increased global exploration\n                else:\n                    strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicAdaptiveCoDE", "description": "Dynamic Adaptive CoDE with Stochastic Selection for Enhanced Global Optimization.", "configspace": "", "generation": 63, "fitness": 0.5252981157017719, "feedback": "The algorithm DynamicAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8795945097362082, 0.8865873083205621, 0.8775842843453521, 0.8946025341522299, 0.882076168590158, 0.8886166496819393, 0.8818541559753603, 0.8845338907171517, 0.8822654740683061, 0.7846149876874142, 0.79283789470288, 0.783300553824617, 0.7773083140790615, 0.7796120322394557, 0.8004661553360808, 0.7863074731011187, 0.7941244410294105, 0.7923163789691493, 0.12878824042650372, 0.14591684114430337, 0.14021091254650309, 0.1520933158676666, 0.43185825804748734, 0.15490819699068548, 0.10399353939919564, 0.13208275473970166, 0.1377882317656629, 0.14143901582108465, 0.10702829160983152, 0.112789048055849, 0.12013676234394366, 0.10772662723718018, 0.1245840177560964, 0.11283694544886325, 0.1429209271676951, 0.10716773246289735, 0.9905099752187998, 0.9627043355593958, 0.9846595903324787, 0.987448240355284, 0.9666140849624071, 0.9792206774393746, 0.9759542885724025, 0.9935385731001715, 0.9847011794750453, 0.7090151159730416, 0.7202514112732554, 0.6731511533084829, 0.7010725327536135, 0.6880662821988854, 0.7070819033745606, 0.7073651245553041, 0.7138436694842638, 0.6936054692581219, 0.22787078235659042, 0.8878611809239743, 0.8610164868192669, 0.8981633541318985, 0.920226419366738, 0.8919859941922884, 0.875731681517398, 0.8848076974219035, 0.8589427180038789, 0.7135047506923695, 0.6745747699497512, 0.7011009331945366, 0.7487551610387468, 0.6951654296736756, 0.7261796290765404, 0.7265405307125166, 0.7308177916568717, 0.6852304910774896, 0.6635494127707806, 0.6736646582977495, 0.7247783188131443, 0.7653480778967656, 0.7182569662150512, 0.751964381953853, 0.6960292219010686, 0.680728093457533, 0.7568623631488316, 0.7024702453186511, 0.7113272304425551, 0.7307120304269072, 0.6414153265570729, 0.7200451844743496, 0.7098899015471397, 0.728930501794065, 0.7062139741894224, 0.7343414431342008, 0.7746183369735072, 0.7570289267228103, 0.7802635678609072, 0.7739247918032528, 0.7582451378882411, 0.7644099333518624, 0.7815833566731134, 0.7975214344234667, 0.7833654714184864, 0.376583590245235, 0.449647761963495, 0.5036150804540785, 0.6435906265019354, 0.6767246873074477, 0.5630376396401209, 0.4171813549162312, 0.5478001314113857, 0.3188256417701517, 0.6602108397008131, 0.6401712680296405, 0.6449186655635715, 0.6383811532716852, 0.6677854256792528, 0.6301014694866921, 0.6293539038464362, 0.6644473222260865, 0.6361344918533443, 0.8524491329572336, 0.8581405621832451, 0.8561254856159417, 0.8551445379557427, 0.8585838031084153, 0.8518854500365936, 0.8403962184289118, 0.8507603614447157, 0.8425801411890114, 0.10328283130462002, 0.09159276903947644, 0.14979256064188085, 0.17601754087155064, 0.4713649803939465, 0.1263299420073437, 0.124289228693364, 0.1458333993164611, 0.12431633566484923, 0.18122516384361065, 0.2987236494382042, 0.6754031984825448, 0.21352759692872003, 0.3857721204543574, 0.22206827888527536, 0.26441841742405403, 0.200115625644956, 0.2427320064274715, 0.6245910358958549, 0.6679708756795086, 0.5986296253141015, 0.6020538272926188, 0.6031374991195653, 0.6262658177769305, 0.6121721355478833, 0.5405746659382035, 0.6484124658803243, 0.4446985774836433, 0.42593021879156356, 0.5419412085873337, 0.5229950562712842, 0.5492964377004077, 0.5428342353166897, 0.5595088968504176, 0.5768373408375145, 0.5494000063062165, 0.1959357109414831, 0.19360219225968445, 0.1967856844840894, 0.20705923763177814, 0.20284389300387706, 0.21322206015546186, 0.19784417913493124, 0.20472146950506565, 0.22191178884121032, 0.19847946385862192, 0.6804569363512504, 0.21342680208517129, 0.6148365833502553, 0.18707548961938159, 0.205150161003523, 0.19083306161660452, 0.21217552016807062, 0.550732823369189, 0.9081818650815369, 0.1715635276793568, 0.15402356866902644, 0.8913047847928881, 0.19592397153837116, 0.1663658275551836, 0.8739012193463067, 0.19449327433552444, 0.8923229134667254, 0.8631760556189821, 0.21015612963900066, 0.16479020842963632, 0.16749396931494398, 0.15484614327045798, 0.8480924910124776, 0.15609871922703655, 0.21038581646835142, 0.20968894821371575, 0.1830880352051648, 0.18847445515756267, 0.17984083744379908, 0.19458076110151634, 0.19181146774602598, 0.19019779016290883, 0.19672028927292962, 0.18327412983446445, 0.18526049664459543, 0.08076154122314128, 0.07954799380885846, 0.08180742523795492, 0.08514003778635337, 0.08812368127637815, 0.0861775196268636, 0.07909123915368943, 0.08707197986882875, 0.08724793730865421]}, "mutation_prompt": null}
{"id": "6b3d4cd7-d6f5-4214-937f-148874dfe0d9", "solution": "import numpy as np\n\nclass SynergisticAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest,\n            self.mutation_best_2\n        ]\n        self.local_search_probability = 0.15\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-4\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_2(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        top = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        a, b = population[np.random.choice(top, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "SynergisticAdaptiveCoDE", "description": "Synergistic Adaptive CoDE blends strategic adaptation and intelligent reinitialization for enhanced optimization.", "configspace": "", "generation": 64, "fitness": 0.4181160423878599, "feedback": "The algorithm SynergisticAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.933201905274246, 0.945901355523128, 0.9496917116569155, 0.9440043280150792, 0.9525303300124504, 0.942295344488801, 0.9529522012476785, 0.9517826159953695, 0.9400483116008824, 0.9058110722318709, 0.8711693507831454, 0.8979485696091796, 0.8807718397895449, 0.8647940463143861, 0.9128369319856576, 0.8637101290349433, 0.907318065939007, 0.9196734624535596, 0.14510777299756172, 0.14092021167712376, 0.11929102051282969, 0.15770010956845815, 0.14941270494017245, 0.143357355144491, 0.12098302562249097, 0.14050051588963275, 0.1124977506233521, 0.11858305670558167, 0.134103982831849, 0.09387465799296912, 0.12706487343016504, 0.11565258779633592, 0.13611730173407466, 0.1515030165031256, 0.14770214944126003, 0.13079012082933628, 0.9808350363611817, 0.9833315858452046, 0.9805190185135534, 0.9806980143680378, 0.9931726482721683, 0.9816261606073967, 0.9869089366441506, 0.9839269276133653, 0.9885864063734666, 0.8225189641882645, 0.8489414487495277, 0.8348612265946638, 0.8371538272726045, 0.8336325098625583, 0.8396522894776124, 0.8381051454663696, 0.8500727351131487, 0.8122958758737296, 0.9533177461272047, 0.1970824127636296, 0.39063309602137597, 0.9270121782736565, 0.2160415549684137, 0.15525283905622633, 0.12863418361816314, 0.15327854604577262, 0.4084107894140304, 0.8524131134094493, 0.7167261490562218, 0.7367767944630232, 0.6457617399104769, 0.8310929864649316, 0.7216021959869355, 0.737126124320502, 0.7489449241789771, 0.7990134289427472, 0.1365287585396996, 0.697153174283587, 0.7515032308716185, 0.69853567883669, 0.6969362274965571, 0.13706021027557558, 0.7707268338196678, 0.5940971852904533, 0.6253115754901091, 0.24872337978695058, 0.24269020205171343, 0.11194688669721142, 0.1175386394555964, 0.2086263570734006, 0.07733072646607397, 0.17478114951781132, 0.4195730962793336, 0.06829337306533612, 0.2217526709773774, 0.19377912070248338, 0.24182021715883817, 0.18187850472364753, 0.1178137984490153, 0.20593999030043453, 0.1816591242287242, 0.17592139116569727, 0.24666694666960498, 0.09524052735403876, 0.10613703607106795, 0.27646446732852537, 0.3692838944743405, 0.44021141794569807, 0.1976517171823039, 0.4771119952406092, 0.49567964066907577, 0.3522843118020109, 0.18734055450545417, 0.5349151673837375, 0.4359866108725384, 0.4305481052685437, 0.49522966611716035, 0.41719936760928256, 0.10349829243505049, 0.4279864318854687, 0.40217932319324756, 0.7774147673818506, 0.7021505753687245, 0.7254455950547005, 0.717816128252554, 0.6266273182718539, 0.6368607722332784, 0.815833602768601, 0.6664513665550399, 0.727821186948987, 0.12249064175732272, 0.11769606321681025, 0.118680922087808, 0.08951745385771626, 0.09540968159016339, 0.1337630691401257, 0.11452248594453884, 0.11082354676719475, 0.13212337411624198, 0.2583509525736013, 0.25980828007455725, 0.15943116964117032, 0.24798868881783298, 0.26338664489569863, 0.17100827963263743, 0.26115831560067204, 0.21707396559538794, 0.2043841380846888, 0.27754693218354154, 0.4014485335836441, 0.4175721471730609, 0.26446387348796696, 0.4342102281552519, 0.41797857999061894, 0.558827684944035, 0.41080751738019705, 0.20798161236814072, 0.30139269999185414, 0.20418808237789987, 0.32432641257592854, 0.23023894890706464, 0.26385637697194597, 0.2525930056928972, 0.22583728260918534, 0.35596744659610635, 0.3490990861609917, 0.20836076435021356, 0.24476997551404467, 0.23025243212891344, 0.21391112420122915, 0.2279523235150296, 0.23517294137121048, 0.21834460565085978, 0.26301979300881195, 0.26821521197041953, 0.2053775752258623, 0.25436321459185207, 0.21143690639331458, 0.2317793470082582, 0.2135887390325535, 0.19136049641393216, 0.19544979371529814, 0.20901369040393603, 0.19599136291595853, 0.18875545395131788, 0.15849798837505036, 0.15425928921275867, 0.1723551426751816, 0.20150289673244726, 0.14812530418758996, 0.9497650848309367, 0.16996545075514025, 0.2056652822812468, 0.8670280928903346, 0.9607522274516307, 0.7748934670823067, 0.2123459667255756, 0.16916928944035736, 0.9397905029663138, 0.10508227203425391, 0.21385340426744948, 0.8940898042280278, 0.2054893977597626, 0.2090314585138835, 0.21631597504710387, 0.20255052304440269, 0.24499222192473147, 0.25394531996999725, 0.25674329781791116, 0.2475590780572443, 0.24345461519004485, 0.11019861586407498, 0.1477482025386656, 0.10246601214351103, 0.10181791039059895, 0.08809972241242792, 0.1012843469182606, 0.10480641650207578, 0.08828829255356718, 0.10454077082300717]}, "mutation_prompt": null}
{"id": "af1fff97-2104-4aa1-8fed-174298c38795", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.2  # Slight increase for more local exploration\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.reinit_factor = 0.3  # Increase reinitialization size\n        self.dynamic_pop_adjustment = True\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            if self.dynamic_pop_adjustment and evaluations > self.budget // 2:\n                self.population_size = int(self.population_size * 0.8)\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(self.reinit_factor * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDEPlus", "description": "EnhancedAdaptiveCoDEPlus: Improved adaptive mutation strategies with dynamic population adjustment and exploratory reinitialization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {}, "mutation_prompt": null}
{"id": "4de451a8-51d1-4a76-97bd-10e4da3584d3", "solution": "import numpy as np\n\nclass AdaptiveCoDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.strategy_weights = np.array([1.0, 1.0, 1.0])\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum())\n                strategy = self.mutation_strategies[strategy_idx]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n                    self.strategy_weights[strategy_idx] *= 1.1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "AdaptiveCoDEPlus", "description": "AdaptiveCoDEPlus: Further enhanced adaptive CoDE with dynamic strategy selection and improved local exploration for robust optimization.", "configspace": "", "generation": 66, "fitness": 0.4413270106200276, "feedback": "The algorithm AdaptiveCoDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9419669855930299, 0.9046849325677379, 0.9462756635392672, 0.9487993699659364, 0.8939932198593745, 0.9410485932872684, 0.9444006631039806, 0.9052173573262718, 0.9388370562220631, 0.8642854562606599, 0.8141533999327923, 0.8869078383314535, 0.8791929658199531, 0.8543802591397638, 0.882115715716077, 0.8828379111486571, 0.2540849815243399, 0.8376281591730498, 0.1470686587859893, 0.16792849841229562, 0.17534007202874768, 0.11249978300956931, 0.13060502866113421, 0.20515910632357048, 0.12342774936927559, 0.32309497046962776, 0.17453957146746546, 0.09230571987233127, 0.13025632975146095, 0.141344456393926, 0.13307720469248474, 0.10092927099989613, 0.10874095266556838, 0.0867156817203728, 0.09811955535051842, 0.1343753161609288, 0.9822599477857029, 0.8905906735479066, 0.9830376946413776, 0.9724171233386009, 0.8830602852101976, 0.9882500314009064, 0.9893798638956609, 0.8242647362284945, 0.9843778133549942, 0.8297983597579404, 0.4538542215038225, 0.6561402319342373, 0.432511088135473, 0.44797341040342564, 0.82431158456046, 0.8346549541204564, 0.44684329291048974, 0.8450055266650589, 0.2572716809155827, 0.8875291780273113, 0.2154316367593926, 0.21076867824736467, 0.8819199884581173, 0.7760244556043991, 0.2379458303252704, 0.8837899643806181, 0.7302672142427964, 0.8288953521962964, 0.18071972295663852, 0.1661498735013991, 0.7971563721987631, 0.8154908832981752, 0.8561143473759544, 0.13646806823707813, 0.14464349876812088, 0.8333016302430103, 0.1359234284248092, 0.15684694015745737, 0.8105527218578406, 0.8544918515845532, 0.18766004541892922, 0.8222517286406745, 0.8364483371559442, 0.16838745937273691, 0.8115179781703923, 0.30978617967795574, 0.11653046357350849, 0.709095886747122, 0.07521288913103763, 0.48444640159900987, 0.5253596708760213, 0.6777016783792933, 0.17864248158653462, 0.14639259203773614, 0.34655705690559957, 0.3134109273706054, 0.1972519150188874, 0.22899792469145297, 0.10604275466359558, 0.4091108260366352, 0.6388577075791821, 0.4091296337096134, 0.4282600500502719, 0.6481368410987103, 0.20101959846006157, 0.41625772209834067, 0.5714769434962845, 0.2759813847708672, 0.6055914066078599, 0.1846074583416505, 0.20941106095973616, 0.24684717306251747, 0.6995266075460667, 0.5065456025390968, 0.3773830997352565, 0.7734716781526718, 0.6237674233307933, 0.6201408896512279, 0.4291661982188758, 0.6167099348510627, 0.5493230808620329, 0.8822354637078441, 0.8471404420009772, 0.9155096235487427, 0.8149252590683791, 0.8528735543026418, 0.8841650885985135, 0.9053789457763821, 0.8581448756433125, 0.873369659051127, 0.06257042890893094, 0.16414807228530104, 0.08068463274287974, 0.1885736379150329, 0.48608358900832704, 0.13740673576303075, 0.11010490146463559, 0.16287243742911828, 0.0975649658349379, 0.17045150561865408, 0.21318637400684293, 0.136258957450484, 0.14844608073587806, 0.14481330287875316, 0.27749887741681545, 0.8426660083217594, 0.15177062630453997, 0.20813281809101258, 0.4937487977905164, 0.6626807939894194, 0.6427434211054612, 0.33222500554596146, 0.642096057245179, 0.654092027179688, 0.5672740205366946, 0.6283075517364414, 0.25031406961187275, 0.22800148188869096, 0.5103010635096428, 0.34143580659749084, 0.38324103632564943, 0.5044950032207061, 0.277910483887872, 0.22345285199042153, 0.513143713186885, 0.18206011582376957, 0.2681477027643412, 0.23589448369249777, 0.21751100935411272, 0.1652594158901447, 0.2360886252829878, 0.16484051156590662, 0.1850499819244943, 0.2452957461703953, 0.25388240624203173, 0.20351529213987618, 0.20649511616414762, 0.22739148241454754, 0.7083303912267979, 0.20417127731061468, 0.1795348843045551, 0.19970581479142024, 0.21655775356375528, 0.2010400017771713, 0.9487944216169072, 0.8354587597458514, 0.15376440805605673, 0.9546973210825498, 0.18755627535856978, 0.599840439680674, 0.14261228499871836, 0.16713450924951723, 0.1673349416259835, 0.9427171946329601, 0.2095922259569598, 0.21153230131625655, 0.1680046008185192, 0.16711931234371746, 0.16620309160126767, 0.21367840842560315, 0.21299724482730542, 0.10447227551634808, 0.2944571368026193, 0.22219370461955257, 0.18235835374181852, 0.44032027546753816, 0.18997867794465995, 0.1750941566317783, 0.22785272106080112, 0.1896001616152787, 0.1928737666835939, 0.08884278399338275, 0.09306022301829087, 0.0939101246887103, 0.0860462721697115, 0.09697926185268557, 0.0977657948076025, 0.08759189207340057, 0.09176711738587129, 0.09403048690904547]}, "mutation_prompt": null}
{"id": "874a48bf-cace-4627-8a24-e31830e7585a", "solution": "import numpy as np\n\nclass NovelAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.dynamic_parameter_adjustment(adaptation_counter)\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.stochastic_reinforcement(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def stochastic_reinforcement(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def dynamic_parameter_adjustment(self, adaptation_counter):\n        if adaptation_counter < 5:\n            self.adaptive_step_size = min(0.5, self.adaptive_step_size * 1.1)\n            self.F = min(0.9, self.F * 1.05)\n        else:\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * 0.9)\n            self.F = max(0.1, self.F * 0.95)", "name": "NovelAdaptiveCoDE", "description": "Novel Adaptive CoDE with Stochastic Diversity Reinforcement and Dynamic Parameter Adjustment for Enhanced Global Exploration.", "configspace": "", "generation": 67, "fitness": 0.4363097752445511, "feedback": "The algorithm NovelAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9348086439110916, 0.9298281045053381, 0.9325259347501713, 0.9314744953553171, 0.9350998350511867, 0.9312868077657047, 0.9215645516078103, 0.9277529318606311, 0.9218524757922683, 0.8496213537761236, 0.8665298845331451, 0.878075160433522, 0.8259693554294302, 0.8574208301418704, 0.8734999335582669, 0.8541576639209398, 0.8684960167056996, 0.8624510112476352, 0.15834921310471906, 0.658162530922584, 0.13559188393341648, 0.7651879245436428, 0.11855209056004534, 0.1454314982312167, 0.1443228771469076, 0.13145793325824218, 0.13240500428143898, 0.14180972759365573, 0.13050895946493857, 0.14177558230626597, 0.14165580530148636, 0.162485801839106, 0.11679164192185942, 0.12324642046510637, 0.10718649055415808, 0.1564714821150417, 0.9901128791996175, 0.991291444466859, 0.9829187107537822, 0.9770791144517413, 0.9813753628493078, 0.9815517623204095, 0.9632791192382936, 0.982778729149947, 0.9814590009267974, 0.8242930804168828, 0.7520309703634085, 0.5596448688705562, 0.8116850939105897, 0.4463936036147451, 0.5653784864425506, 0.4577251769566385, 0.7715924692378996, 0.6617302913220219, 0.21064121969016913, 0.9079001349081669, 0.22878024794466523, 0.9384132678303867, 0.9288384099761011, 0.9340785526376338, 0.905432882516029, 0.1780409765923252, 0.9409064753229085, 0.13399563257554348, 0.6098532235852172, 0.5742221244486019, 0.5668195456811801, 0.13391112146468875, 0.6638082428226728, 0.695132301652824, 0.677204117200735, 0.7469667821651212, 0.6308390856650608, 0.5783452533387884, 0.6180699573450295, 0.7059429856840247, 0.13529977216984101, 0.13554819041686916, 0.6713792956410662, 0.6614925940479874, 0.8271892060959054, 0.32264736946283123, 0.13074386521896797, 0.0764353228669955, 0.3581505672145002, 0.18376535833637697, 0.18097383380963816, 0.6847905920290196, 0.27733792812785796, 0.1861541098862196, 0.4670568560666113, 0.1979334914869172, 0.20810569455845918, 0.18099999913925613, 0.18967355592351476, 0.2660404355568289, 0.3657554866670908, 0.20753506865707494, 0.1406276327971493, 0.12125386140375882, 0.48912144835286986, 0.309609618579864, 0.39059272075898555, 0.467431463349419, 0.3337717592864913, 0.1994163951337089, 0.1435135720267282, 0.39490433346097586, 0.3374422553487829, 0.6209137160791536, 0.4113007721820585, 0.31069329493594333, 0.6090585627167003, 0.46170356221110165, 0.447771369977057, 0.3849296537478717, 0.2647622238666357, 0.8506398216101354, 0.702927931619496, 0.6079853483060402, 0.7731528055142928, 0.6832409889395821, 0.7600415739184451, 0.7998934704193703, 0.6840781968944851, 0.7416962502760052, 0.1847280665882436, 0.1323937300360809, 0.11702701475551769, 0.11685637981741459, 0.11796262747910424, 0.11811458860602919, 0.13274133838911462, 0.13371818959912996, 0.1159153425371856, 0.23102124876813346, 0.38824215216922886, 0.19281541426698146, 0.20509915843963078, 0.19915545524451517, 0.18377046241613038, 0.20429145647377278, 0.18436429511277197, 0.40457394946209, 0.3363293789391416, 0.384654349421098, 0.312801570863496, 0.4166191601380109, 0.471933147026687, 0.3149393023693112, 0.4442795262216076, 0.5283393813676422, 0.4774128523815383, 0.24180906691323056, 0.21575927808727924, 0.33284306373656314, 0.3351433522731232, 0.31087464598378234, 0.29421784953328, 0.3092228599719734, 0.37183409677714496, 0.16493144408333682, 0.24320805001329526, 0.2252195108212609, 0.25704168845091013, 0.2719933036394033, 0.2446949690440654, 0.2357468378447144, 0.30633990045142934, 0.2160166222519615, 0.2598309136197322, 0.18573023615485695, 0.2508395735410264, 0.24092716187135688, 0.19775647232017335, 0.1848664346517508, 0.1890019998948761, 0.18892074318793117, 0.2036254219038255, 0.2139275968079648, 0.17683124462793098, 0.12572189021793512, 0.20097905074133493, 0.928400346737008, 0.20068377577871366, 0.2000973348928512, 0.18649058160316767, 0.15850547222298106, 0.9470436815312262, 0.9306922852501094, 0.46838092517840724, 0.9373095721538282, 0.21130635736598402, 0.7756313491070579, 0.8322985459143494, 0.9348445957512288, 0.1308726569920634, 0.94037863252861, 0.21200601597832547, 0.2065298297067295, 0.20908266015896504, 0.20662418048362707, 0.20950744811980848, 0.21305481376973778, 0.26941966298358333, 0.21816612436944793, 0.22800059982297793, 0.1881633936987792, 0.0955172832005926, 0.0972257389953669, 0.09604322415381517, 0.11260899808351554, 0.10466693642936042, 0.07668258850346554, 0.0932679966236587, 0.11569926590379365]}, "mutation_prompt": null}
{"id": "7db14ade-e78f-4144-94d3-fc395096cb90", "solution": "import numpy as np\n\nclass QuantumInspiredCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest,\n            self.mutation_quantum_walk\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            \n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_quantum_walk(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        quantum_step = np.random.normal(0, 1, self.dim)\n        mutant = population[target_idx] + self.F * (best_individual - population[target_idx]) + quantum_step * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "QuantumInspiredCoDE", "description": "Quantum-Inspired Adaptive CoDE with Quantum Walks for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 68, "fitness": 0.48264619752004245, "feedback": "The algorithm QuantumInspiredCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8988599139914536, 0.8977041851069301, 0.9005513059439444, 0.905128080441262, 0.8907437087057027, 0.9012807349317575, 0.9032870044860447, 0.9021009929496951, 0.898241869238542, 0.8146974346066758, 0.817814841418005, 0.8122168715333473, 0.8092631497897048, 0.8015507881090117, 0.7842562605265626, 0.8282002309232565, 0.8229812506499885, 0.8125570264379369, 0.12108673596920527, 0.14982934997471364, 0.13570151526327479, 0.15402257254446594, 0.1210422754336219, 0.12291256139828144, 0.14354359499332436, 0.5046583298057148, 0.1373697517601209, 0.09534559186978808, 0.15069994936707176, 0.13550607541076642, 0.13592719469958048, 0.1330460993566388, 0.13316291567300964, 0.12672840625344028, 0.15209637732733516, 0.10613019693637726, 0.9764856358961153, 0.982154530895097, 0.9728847135268262, 0.9705558891778573, 0.9729451276500012, 0.9721727936061647, 0.9899887695736476, 0.9788803541411054, 0.9812431097077478, 0.7500897675777343, 0.7363259635028507, 0.7170392580893102, 0.742084044872056, 0.7342946701172377, 0.7308577737304491, 0.7124751837656649, 0.7442064488512985, 0.7041486113277413, 0.8951589813858657, 0.8743984164185252, 0.8735292436738014, 0.8949635553183984, 0.8818646581059839, 0.8860421406738306, 0.865419888755893, 0.8649917264908804, 0.8781693908584224, 0.5983472174725475, 0.1303364053145042, 0.6212232732020524, 0.6410297756365351, 0.6594283095531995, 0.6560365737970432, 0.618909859046956, 0.1336687355658196, 0.6584172928600516, 0.6242847933587495, 0.6401168964963433, 0.66485428761514, 0.6560091388024065, 0.6636764053895154, 0.6810259789568824, 0.6655035672427355, 0.6652478280356304, 0.6997874625924025, 0.4894820006430036, 0.6158257764923789, 0.5951263684703278, 0.4889083651179652, 0.6646838857013064, 0.5369613871530016, 0.622287806613766, 0.6586853372617906, 0.620268364262494, 0.6608368764434043, 0.3163250556565711, 0.632407736622868, 0.5961748777288811, 0.5120247304529859, 0.6953299068078937, 0.6647738463683437, 0.6930083768778026, 0.6706930840892106, 0.22877074421654053, 0.2983767252720724, 0.1134428454512697, 0.5767252806156011, 0.5588332381598049, 0.4948589570399754, 0.2706090357194473, 0.3560173934213333, 0.1642503457092862, 0.5579896024611517, 0.5809251075618695, 0.5405077326729928, 0.5619090986888576, 0.5492560656442336, 0.5624536317902777, 0.5536890344147988, 0.5223190561747382, 0.5253786638805804, 0.8368658348190988, 0.8307822833794178, 0.8335695363251574, 0.8406885070606854, 0.8468239057335089, 0.8196544229780961, 0.8383378575821727, 0.8209222953623085, 0.8255137654938733, 0.12303708146492787, 0.12516570128153814, 0.11054173890868879, 0.1383013861769843, 0.15145707792103513, 0.132226560576454, 0.12317878449178665, 0.14211483935230063, 0.1084983363126456, 0.23976808822810336, 0.14929261356998036, 0.5025753369870168, 0.19389256091002083, 0.18852589604680703, 0.1669926508694518, 0.19524306373003186, 0.1279293001218017, 0.1541199668343899, 0.6527164960004004, 0.6682982834940331, 0.6320837732090897, 0.634894798474444, 0.6138242590019871, 0.62358446042672, 0.5428776483623502, 0.7137310573971745, 0.6913124142394882, 0.41054876210224267, 0.4859195257670811, 0.4711875554315994, 0.30113703387733626, 0.3555845087562991, 0.512567566721781, 0.5401783966813956, 0.5512835218226657, 0.4870710796757618, 0.20562969779039608, 0.20812971100752142, 0.23441881346048143, 0.19591897959170035, 0.21544087316459382, 0.24431380125125257, 0.20417073345305692, 0.21879843028503754, 0.22292480142005766, 0.7264743901852939, 0.25102690082164525, 0.2057905998427677, 0.23268692894762322, 0.22297993358812218, 0.5498855364005202, 0.24584166575360378, 0.7143616328824277, 0.20731711102966754, 0.18525174153948643, 0.20383327387609018, 0.15365144821281063, 0.17704598117197567, 0.16872801406739268, 0.8798812456991825, 0.2491573221394564, 0.6399745329275266, 0.2078980546806164, 0.8722585698925924, 0.2111009458697104, 0.20843144635098576, 0.20643103622357972, 0.1688795884450488, 0.12630426023051144, 0.10490028796089901, 0.16545758042980252, 0.15544417962935675, 0.192703545377791, 0.1942620714953639, 0.18298261752833345, 0.22989144823487784, 0.20159938307899306, 0.18427839673720126, 0.2063284095412551, 0.19249466766916334, 0.1729714653175135, 0.08641756905973141, 0.0789507214913252, 0.08629829892084495, 0.07953456857828389, 0.0868976995474442, 0.085741650379352, 0.08408249581305027, 0.0934131823146006, 0.09553395494670935]}, "mutation_prompt": null}
{"id": "06df5e37-8694-41a5-8ba7-b18554fa6ae6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.dynamic_cr = self.CR\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                self.dynamic_cr = 1 - 0.5 * (fitness[i] - best_fitness) / np.ptp(fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.dynamic_cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE_v2", "description": "Enhanced diversity through dynamic crossover rates and adaptive mutation scaling for robust exploration-exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.5317771543710224, "feedback": "The algorithm EnhancedAdaptiveCoDE_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.32.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9087247586454097, 0.9085204303988715, 0.906109617677285, 0.8978029390054186, 0.904112933807509, 0.9037032413564502, 0.898674920955658, 0.9149357336240688, 0.9043816817847309, 0.8189996685519756, 0.8235801561482845, 0.826892489159575, 0.8115830028111717, 0.7910978597688838, 0.830638073579954, 0.7969011400621563, 0.8255479750799397, 0.8079193659308469, 0.15331118898821494, 0.23058218939605168, 0.14311653903900678, 0.19088878585992286, 0.14145208243806007, 0.14373749052321017, 0.16639155775637537, 0.13812524906742507, 0.12764472554914597, 0.12507260403192066, 0.13485792890014037, 0.14025254257155106, 0.114745037488582, 0.14456867462511325, 0.14036183146266756, 0.10486075949723384, 0.11804740738980435, 0.11083774052490802, 0.9896824323800346, 0.9695607028577011, 0.9874442381007463, 0.9807558754016636, 0.9829096746429073, 0.9877215478462813, 0.9689821125725661, 0.9729764409239322, 0.9895073349667233, 0.7951914559151493, 0.7935373375674085, 0.7913949345008839, 0.8091968591525318, 0.8115428871327872, 0.7856587676181082, 0.8026061930002939, 0.8152117104125929, 0.7942357082957385, 0.9054840639225901, 0.9010130691590967, 0.88470099723498, 0.9149332448041048, 0.21259473727459777, 0.9226725449785754, 0.8970231700031889, 0.9153742793649361, 0.9202067881933651, 0.7982801074806923, 0.7419239577754391, 0.6176177413453485, 0.6577463587080479, 0.6425633676053714, 0.1344187651182296, 0.6755869852707803, 0.7480864668802985, 0.7773210620519126, 0.7332350680690151, 0.13325732657065414, 0.7379526701651778, 0.7505742988019044, 0.7347725858666363, 0.695807787790259, 0.7671724734782416, 0.6786464959581413, 0.7536902215489458, 0.8205174901403932, 0.370355385740452, 0.6771442665934371, 0.8348265537375628, 0.8172877054779042, 0.30831712597969985, 0.832052473042276, 0.7647855277371661, 0.7096072203339058, 0.8586693494158508, 0.8495159303871895, 0.8699960347031084, 0.3292871064679712, 0.8625601948636652, 0.877253986371274, 0.8646550349720186, 0.8771431613048497, 0.18818560766160186, 0.4138852072560625, 0.19683756041897327, 0.13535337625713295, 0.40012303108097835, 0.569983901690238, 0.76525007145469, 0.184984048462852, 0.45037201654989045, 0.39708069862921636, 0.7258269603539087, 0.70782180968486, 0.702839028148232, 0.6906029484282242, 0.7116868146522708, 0.7154083555929559, 0.7148339089322939, 0.40990729534433945, 0.42562244805583493, 0.8667611637074069, 0.8788880477740375, 0.8763186506223809, 0.8703303310655097, 0.8865599293440236, 0.8814671079427012, 0.8715137576392658, 0.8797460464684734, 0.8527464839351102, 0.40102109981479783, 0.1099275033283762, 0.16267981256662767, 0.13413980063530595, 0.1196015279027346, 0.12764088464105572, 0.1250814985418639, 0.12551716962462756, 0.11358024292602709, 0.2181918094807762, 0.2788245453139271, 0.3321602179971894, 0.17198148124242174, 0.5875634196199688, 0.15234783512133765, 0.2399844310103637, 0.310564093106939, 0.2157057167851668, 0.6702717401959593, 0.5552411546926357, 0.5682201297145493, 0.7012637944429321, 0.5543249979330973, 0.5766120727818478, 0.5894926017224018, 0.6725323852085117, 0.6550050803346127, 0.5850700224065288, 0.479061528902474, 0.5415998336244968, 0.6043553960043551, 0.5164477069797808, 0.5555565126447497, 0.6338232889742654, 0.6669864660859947, 0.4131116825569525, 0.21558449941778912, 0.20957408171645775, 0.21215871241579942, 0.22728885277471267, 0.2189253696367479, 0.23350939752819078, 0.19018342036966962, 0.21544122392006726, 0.2205195797437014, 0.240808025182213, 0.24743222928308028, 0.194785972221988, 0.21042243673226735, 0.21830440256152694, 0.7664461556921778, 0.24632831520579002, 0.1973510862383917, 0.2222376224610637, 0.8997257441398061, 0.19976210339391087, 0.1528213639713586, 0.9085790280999728, 0.8727898347138513, 0.8567856679303807, 0.14192397603206297, 0.8625801784227871, 0.15485563827085858, 0.8774491000162556, 0.20610548951944874, 0.8814548781675879, 0.2012397605483105, 0.20820296494888169, 0.20851377689819783, 0.7920012341285874, 0.8695574103285235, 0.8788558740715073, 0.1785865929976047, 0.18468467029115931, 0.19616335742111812, 0.18979814174891751, 0.19058004327022648, 0.17625805802704486, 0.18940472826715982, 0.1770438846089839, 0.18255589867236444, 0.08779044642750411, 0.0993519666098327, 0.11175117779259014, 0.08979278753440323, 0.09827097596719903, 0.08987732926667413, 0.0924532617913828, 0.08793422346348001, 0.09090858182532424]}, "mutation_prompt": null}
{"id": "0df79c5f-7f20-4527-90e8-414c41dcc325", "solution": "import numpy as np\n\nclass DynamicAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.6\n        self.CR = 0.8\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicAdaptiveCoDE", "description": "Dynamic Adaptive CoDE with Swarm-Inspired Exploration for Enhanced Search Efficiency.", "configspace": "", "generation": 70, "fitness": 0.41689536577511915, "feedback": "The algorithm DynamicAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8687974895043977, 0.8651143709951702, 0.8722553459213889, 0.8728400014443182, 0.8702950420205551, 0.877452232045924, 0.8694612013391819, 0.869779369937938, 0.8729531818679453, 0.747726383720266, 0.756432745217894, 0.7779345917546625, 0.7738539838245194, 0.7365384472680128, 0.7557277288259832, 0.7667384817387001, 0.7732992915174034, 0.7557523085357885, 0.11691390209445474, 0.18714635349222297, 0.19427893997956813, 0.11758053555637527, 0.17165421412844428, 0.12977651764356302, 0.1586349563623235, 0.14233394797778798, 0.14776717742844014, 0.14429409677750804, 0.13643557647134907, 0.13702175000649186, 0.11159565719318121, 0.13180101051091864, 0.13623112584214958, 0.11574875490648462, 0.152890700892508, 0.13501300701928032, 0.97443632183166, 0.981077455336719, 0.9732790552669179, 0.9602627923037645, 0.9873124490246876, 0.9810425875911037, 0.9586581939715013, 0.9676118894740753, 0.9798606063882154, 0.5750674911784179, 0.5892180612730585, 0.5774416747456996, 0.5968249859289486, 0.5698025775339608, 0.6653139937848175, 0.5877311589166392, 0.5324171065042158, 0.6099594461586351, 0.8217056375486249, 0.8207003484707178, 0.8120338667523529, 0.8135059516718478, 0.8000300927204331, 0.8422843571869009, 0.7882920117781589, 0.8152494109405061, 0.809504026406411, 0.4919175359918172, 0.5313383956972441, 0.592893931549364, 0.4498536667188042, 0.5411212497978553, 0.3800675193280376, 0.445345998743667, 0.5241516588044509, 0.5743130274638126, 0.42627059827411595, 0.48826396000943106, 0.34350809283635386, 0.5369869174965658, 0.4227391913676489, 0.6048043665794903, 0.5373395723208357, 0.41496086694274115, 0.5101925777964269, 0.10660823609114745, 0.10068543432575572, 0.1672664857753292, 0.1207171249334682, 0.10045801849520286, 0.1326375251001295, 0.14581712723425333, 0.14538508663871785, 0.21039874919399248, 0.17286594532628807, 0.2443507567509713, 0.2861220375203345, 0.2162377631325212, 0.17856858441342904, 0.2952334217322933, 0.2521682743200576, 0.3307862187229176, 0.3819600803442459, 0.07553952313315804, 0.08068908002156272, 0.13172981017036256, 0.09350531236055448, 0.11850631174980042, 0.0979788062046335, 0.25396850032338214, 0.16272983429218568, 0.12522984541585158, 0.2612357721444811, 0.2406451335705857, 0.3129399345720394, 0.3287757312788996, 0.30962832665727236, 0.3726008783241753, 0.2354346177268838, 0.2499330673416571, 0.2853185046778228, 0.7438961963613211, 0.7213640292713682, 0.7295657542293118, 0.7010213096096756, 0.7300955765750257, 0.7512217376463024, 0.7307372190627573, 0.7569964136688869, 0.7687852723907063, 0.10077666615558334, 0.1019710636011889, 0.12122568959696167, 0.09832350719366956, 0.102395521520797, 0.11288595319839567, 0.10099577724358566, 0.10294771766137822, 0.09884183058212348, 0.2165976235133743, 0.13234783982947995, 0.2093669918676102, 0.12419578952712595, 0.135576714693038, 0.19852880002471107, 0.43101130545703403, 0.14501153198278194, 0.22004828145511113, 0.4769389937446855, 0.4850534549483225, 0.4963142891965775, 0.4698144313770286, 0.48858107638899684, 0.5103759106084232, 0.5220872438071189, 0.5280463321008204, 0.5322805698679037, 0.30572124280395563, 0.31439173304248025, 0.34761590607445103, 0.3375354993373547, 0.34780767570654403, 0.34321837323383175, 0.4341349023610749, 0.42019216308768215, 0.45256000408818753, 0.23260764387189214, 0.19219936587589626, 0.19529078977927883, 0.1965048369169171, 0.21687710489131073, 0.21541685404352862, 0.1931090074697691, 0.20577894751456682, 0.1925259783258363, 0.2109847704076543, 0.608235786647022, 0.48402422808541345, 0.19089296058417415, 0.2000443130424252, 0.48034647272400144, 0.6061266977535833, 0.22806062392856208, 0.5189360327513468, 0.18399302171494258, 0.8221828162231295, 0.17101347587937166, 0.8522343908613266, 0.19561148390226812, 0.8742110824455943, 0.825504182198801, 0.7858877748011309, 0.841573563185757, 0.8027809516564277, 0.7533161667059662, 0.7721738160682499, 0.20538684911392446, 0.2039670214370365, 0.7552629858975437, 0.16444018686681683, 0.20468339381144918, 0.8333209002922122, 0.17027741460463697, 0.19452036566663633, 0.18773669831758533, 0.17815394360044956, 0.2026023652776382, 0.18408745889609868, 0.18584193413300876, 0.17691503948994725, 0.1956266456668695, 0.08543590404579482, 0.09331571289037277, 0.096360125987344, 0.08383461936747283, 0.07687894316452493, 0.08961456831451364, 0.08318357481639982, 0.08488165231899125, 0.08380468731046387]}, "mutation_prompt": null}
{"id": "960a03fc-4265-49fb-8e3b-8bbeeb7905dc", "solution": "import numpy as np\n\nclass QuantumInspiredCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.entanglement_rate = 0.15\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n            if np.random.rand() < self.entanglement_rate:\n                self.quantum_entanglement(population, best_individual)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def quantum_entanglement(self, population, best_individual):\n        q_factor = np.random.uniform(-1, 1, self.dim)\n        for i in range(self.population_size):\n            if np.random.rand() < 0.5:\n                population[i] = (population[i] + best_individual) / 2 + q_factor * np.abs(population[i] - best_individual)\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)", "name": "QuantumInspiredCoDE", "description": "Quantum-Inspired Adaptive CoDE with Entanglement Strategy for Enhanced Exploration and Exploitation Balance", "configspace": "", "generation": 71, "fitness": 0.44064971390982316, "feedback": "The algorithm QuantumInspiredCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9256399287404171, 0.9236780143951525, 0.9258577802898784, 0.9202474803989088, 0.9112953500271255, 0.9236919617802283, 0.9283009360074321, 0.9181320471765398, 0.919988859618305, 0.820618008813215, 0.8242732471551715, 0.8157355174588168, 0.8493292929876699, 0.8411757762221547, 0.8257929534285272, 0.8354982727174406, 0.8507258936959565, 0.8424781323835215, 0.32737190493107826, 0.14637193293268813, 0.15768354797963025, 0.15900474908654705, 0.13379843638809252, 0.17005055890225484, 0.16859561494354547, 0.18143541362173776, 0.43130594391548593, 0.0893414447889227, 0.1038492513133118, 0.13437474438687425, 0.11489916475570405, 0.14217705919904255, 0.12134521955086985, 0.13304283180708754, 0.155009858251402, 0.10527237617544849, 0.984589658969341, 0.9883507182031519, 0.9813579283425845, 0.9634028020147638, 0.9660286840871838, 0.9741969640888057, 0.9686283660186531, 0.9626982219570739, 0.9791413363615287, 0.8032084777288596, 0.7894462126265097, 0.8002223002269441, 0.8028390092761083, 0.7968465661592992, 0.7870741236602274, 0.7570311582031926, 0.7945683100681318, 0.8115509179217801, 0.9292590903265103, 0.9306159314632863, 0.9427668442865097, 0.9345296166389497, 0.2773006505732667, 0.9353734832090674, 0.9137292457578218, 0.9162189693759736, 0.2358357424506492, 0.7060738631289067, 0.7125013805543075, 0.6599941417785387, 0.6855232914321423, 0.23547098916122688, 0.6017348048100712, 0.5643395727302059, 0.7197084513391503, 0.6075190874541148, 0.546550510402747, 0.7053642698710225, 0.1330238538941685, 0.7107574356864836, 0.7216167917380105, 0.6956229890431851, 0.13364880011594849, 0.7612535426041335, 0.5919093516146594, 0.1324723754377517, 0.17826077583028277, 0.3034462735112866, 0.13050562567091184, 0.04060609496162593, 0.08800723256826837, 0.0385379750345648, 0.1498237917769487, 0.09665280613727667, 0.16609962230517028, 0.3866846172828381, 0.23144751218753312, 0.11999588091914992, 0.10379070551443925, 0.14429062830475925, 0.18089323968893467, 0.2577383675411785, 0.2716656829658538, 0.0654222664213081, 0.13593882396463597, 0.3287869248190155, 0.10015068786001813, 0.16008563339335302, 0.2774875833109366, 0.16422455127921443, 0.19573973641565157, 0.16122159454886587, 0.2661962297328765, 0.41031968114761663, 0.3414896878590866, 0.3926942912105318, 0.47691457374188073, 0.3148659545020427, 0.277743485592315, 0.37298165948572926, 0.25035172318946497, 0.7544140207179841, 0.7837548147591737, 0.7142254841133664, 0.6675834368488378, 0.8371442996774773, 0.6633216963916566, 0.6974503440626783, 0.7897988732167844, 0.7370934963036371, 0.158777960310428, 0.11121509335070623, 0.12880932185047367, 0.15711655486104903, 0.12387516221518746, 0.14650385530294263, 0.15657177246769827, 0.08141217229902864, 0.16134036839162547, 0.7207675768842567, 0.22509724811233423, 0.2152230904106498, 0.26697770281424527, 0.42332855597985264, 0.27996033074663773, 0.8182439558206991, 0.2811679909123448, 0.23208116413349256, 0.6079868930372136, 0.7617078860724249, 0.6033785515372644, 0.5678058936340018, 0.7742276373853064, 0.28490854297424917, 0.5563624708006425, 0.5862548835238469, 0.5619861474897595, 0.23789975114311612, 0.28411182067573004, 0.3978706878530235, 0.234274341052794, 0.29476262275668497, 0.33271056196078685, 0.22764973063857552, 0.46358872467951806, 0.3382450605980182, 0.2157813346417191, 0.22680886189525595, 0.22856400066423166, 0.26709639648321704, 0.23537358190901758, 0.19886584575334754, 0.5753225431026929, 0.233178544704285, 0.20192564288204395, 0.19117211606425455, 0.22342169450006144, 0.2517720240851704, 0.2521325975107266, 0.2167932732641642, 0.21570807476977638, 0.20915996937783232, 0.4338230924746095, 0.2019883694036102, 0.18609260264459804, 0.157471003658762, 0.20082174611478865, 0.9307824984116173, 0.2001036140162371, 0.48744347915006847, 0.14256428072485927, 0.16224523892110987, 0.9390033486040932, 0.9202891527320294, 0.21207031526430042, 0.9190916731570191, 0.21009183601549553, 0.21088006257408054, 0.8853943437523922, 0.6646210275756466, 0.10455305344265176, 0.9153119559125168, 0.18466229042465743, 0.2036542939771424, 0.24239145144896257, 0.29229603259258063, 0.18656834647006948, 0.23952625765857538, 0.21054301862514913, 0.19537910974791006, 0.2168545358787849, 0.0982043167104315, 0.08204301024133398, 0.08448664205099488, 0.09894582855451939, 0.09732574491524282, 0.09563018830234904, 0.0668844694810179, 0.09750100364219583, 0.1003856571786984]}, "mutation_prompt": null}
{"id": "a0c7bc7b-4bb5-452c-970a-670ab9078e92", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.strategy_probabilities = np.array([0.33, 0.33, 0.34])\n        self.strategy_rewards = np.zeros(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.strategy_probabilities)\n                strategy = self.mutation_strategies[strategy_idx]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.strategy_rewards[strategy_idx] += 1  # Reward strategy\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.update_strategy_probabilities()\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def update_strategy_probabilities(self):\n        self.strategy_probabilities = self.strategy_rewards / np.sum(self.strategy_rewards)", "name": "EnhancedAdaptiveCoDE2", "description": "EnhancedAdaptiveCoDE2: Further refined Adaptive CoDE with Reinforcement Learning for Mutation Strategy Selection.", "configspace": "", "generation": 72, "fitness": 0.5357878430281717, "feedback": "The algorithm EnhancedAdaptiveCoDE2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.32.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9288495272142497, 0.9062923621055398, 0.9269258403323275, 0.9281782107787114, 0.9214124221853778, 0.9282555955901378, 0.933419555233507, 0.9243176446987248, 0.9336402723330549, 0.8535612826514057, 0.8369431589592007, 0.8658889096658727, 0.8359667136148066, 0.8515377721840767, 0.8658840907689243, 0.8618510927009737, 0.8620785633329141, 0.8630099207892946, 0.15567103624329248, 0.17683357974137048, 0.1431376929396918, 0.15553565215312481, 0.1803240977284517, 0.15761297823132758, 0.48378782334769244, 0.163923176248151, 0.17660804635475347, 0.13594369656365324, 0.1292757542930858, 0.13175846250524792, 0.11711458369030114, 0.1440800041738577, 0.14979388961319273, 0.13585437277049206, 0.1479637037791215, 0.1257699554927273, 0.9825922249916679, 0.9798488569778121, 0.983916990600264, 0.9691291059105063, 0.980332321644773, 0.9876151688330428, 0.9875856537491622, 0.977423894283076, 0.9797599982091594, 0.7793186459722806, 0.7726885628431762, 0.7627972775686926, 0.7815497943757822, 0.7686344484872173, 0.7737624079110367, 0.8018296884962015, 0.785232731485867, 0.7906018901878825, 0.941238072182776, 0.9335417528855104, 0.9115286340421898, 0.9371751584516682, 0.9007988282533437, 0.1934651805114972, 0.24047529660577227, 0.9057460952837618, 0.23586465168381088, 0.134565660902206, 0.6390187729049559, 0.7832939663447475, 0.800061775556497, 0.7383671357547946, 0.7576770568147538, 0.6764352358500187, 0.7942848153598889, 0.8700323129634957, 0.7724225049350475, 0.13415520929952163, 0.13390236282772805, 0.7606595861950765, 0.7592409855017324, 0.8347251205795216, 0.7572809333992808, 0.13351608566187767, 0.7814142909494712, 0.7108342029682422, 0.6615837555314226, 0.6523205952772775, 0.7352267222049718, 0.7129653591435399, 0.556050095077246, 0.8058635263995192, 0.7150757882488681, 0.7756448715412574, 0.7965523833965866, 0.7985728158003138, 0.7739861647382051, 0.7633392678448642, 0.7827177722635321, 0.8091481764989094, 0.8198116508948403, 0.7693281175942513, 0.8241574304510764, 0.36082283564803486, 0.22493172380308368, 0.443065835586158, 0.43987467989585705, 0.6177053801710874, 0.5942104088655361, 0.2811090698304364, 0.45231354366350174, 0.16585675430129976, 0.7321257857620909, 0.7059278439224257, 0.6762667047289053, 0.7345075539821511, 0.7165304509785075, 0.7470157820574623, 0.7343600744391772, 0.6711116526627234, 0.7196359176991677, 0.8773908378185413, 0.8872255964574441, 0.8845739056128668, 0.9056443648149118, 0.8738232600231854, 0.8900117713710762, 0.9018250112540649, 0.8855279693466044, 0.8908525659549867, 0.16165005864278337, 0.1381673945266011, 0.15753482269647845, 0.13112581801975287, 0.15011790052865204, 0.07978494431865568, 0.633292886097725, 0.6052986071020952, 0.11312024489904293, 0.23153738801220258, 0.23229295193555433, 0.42656158569631075, 0.5583945487286374, 0.19482670029863358, 0.437139730955024, 0.766526687707928, 0.4589977825391135, 0.4339440696098964, 0.7455536048543474, 0.7771582328947326, 0.5462684603292038, 0.7868611732622894, 0.732061341419972, 0.4813020993175594, 0.8004486805710261, 0.7589124022484315, 0.5450913368313051, 0.32045947839323696, 0.6681261627026811, 0.5357736959359797, 0.5208473474290898, 0.5553919762646791, 0.5645751993944882, 0.5273081813098176, 0.39957855582762636, 0.5738362829979764, 0.2234076922805639, 0.22842203801276417, 0.19988657930694775, 0.2194273250056623, 0.2240516138127021, 0.2115335392986437, 0.20880528132371878, 0.2562480053609648, 0.20606366517930697, 0.20362936790253816, 0.21523464339425613, 0.21540546666541427, 0.18536065210814834, 0.7505034526836533, 0.20340356683161476, 0.22045550223112964, 0.21685190852342773, 0.1980415867855302, 0.16459078834244778, 0.18684110584184788, 0.15279893835172753, 0.9277414929467855, 0.16972403530982305, 0.9320599218011332, 0.1421043041950103, 0.8625693930779206, 0.9304010014615269, 0.9196496301764442, 0.21179729500896527, 0.8978118719673887, 0.20286242427736922, 0.16736755388723545, 0.16748319398496792, 0.2118988954779205, 0.8792689014058054, 0.10515563684871465, 0.19610685016930562, 0.2130249279141746, 0.1872719142374919, 0.18197769199542413, 0.1875705720363311, 0.1838814091871097, 0.1841677403664257, 0.18538137867587345, 0.18169324431741873, 0.07972144061456476, 0.09979891807399055, 0.1011230368551953, 0.08911845978701272, 0.0913907107385743, 0.09332795221038193, 0.10104865166312504, 0.08613444353870214, 0.09677358457104723]}, "mutation_prompt": null}
{"id": "75760eb5-09a7-47b7-a009-4abc77e742be", "solution": "import numpy as np\n\nclass DynamicAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = np.random.uniform(0.4, 0.9)  # Dynamic adjustment of F\n        self.CR = np.random.uniform(0.8, 0.95)  # Dynamic adjustment of CR\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.adaptive_strategy_probabilities(fitness))\n                strategy = self.mutation_strategies[strategy_idx]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def adaptive_strategy_probabilities(self, fitness):\n        sorted_indices = np.argsort(fitness)\n        best_indices = sorted_indices[:len(sorted_indices) // 3]\n        probabilities = np.zeros(len(self.mutation_strategies))\n        probabilities[0] = 0.5 if len(np.intersect1d(best_indices, range(len(fitness) // 2))) > 0 else 0.2\n        probabilities[1] = 0.3\n        probabilities[2] = 1.0 - (probabilities[0] + probabilities[1])\n        return probabilities\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicAdaptiveCoDE", "description": "DynamicAdaptiveCoDE with Varying Strategy Probabilities for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 73, "fitness": 0.43212565484180626, "feedback": "The algorithm DynamicAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8406479730276863, 0.8719799598603415, 0.8642253245436426, 0.8511904435618285, 0.8846743199802416, 0.8662442768870338, 0.8436772214340114, 0.8716086063189574, 0.8598535133418521, 0.7016730710782462, 0.7753388036290738, 0.7522117133264212, 0.7334667104810857, 0.7708038375457696, 0.7223796379177347, 0.7251269431392402, 0.7691811884574503, 0.7222420641056086, 0.11216717661144304, 0.11451082777547439, 0.16071615330391376, 0.0982192810194571, 0.12700164997395624, 0.13402679238854676, 0.10284916485435147, 0.10001282716979443, 0.13122672751568132, 0.11832284571279339, 0.11546963906232888, 0.10731406230181695, 0.09703948426904863, 0.11876670421690616, 0.11465237331969913, 0.09373159909986994, 0.1094494933354565, 0.13263397150389078, 0.9915949616264633, 0.9933468729704813, 0.9715171704999745, 0.984454777964581, 0.9697102180118249, 0.9699239403142934, 0.9761013010843427, 0.9827736932974056, 0.9621799186152931, 0.5360572454478685, 0.6754759456416468, 0.47315038290080846, 0.5593557792564183, 0.671552483044848, 0.5525853298044241, 0.5852860502363575, 0.6191790042982468, 0.5283989218271825, 0.792138955148927, 0.8165355271535408, 0.7537139645501678, 0.8481947271841693, 0.8800290951287573, 0.8011342982647996, 0.849428281580076, 0.8428864137134724, 0.7731927639835017, 0.5984591657280723, 0.5969649219575643, 0.4283645775810728, 0.6111811404465464, 0.6951571747165699, 0.3333647780865895, 0.5455522121095936, 0.6059546138523592, 0.38005415105370755, 0.6090655910077043, 0.6451977904012753, 0.3751666126827601, 0.5857269838595733, 0.624802317644422, 0.44983747664294993, 0.5994701866776124, 0.640103027488008, 0.38204013133631287, 0.5311628806416256, 0.608556537154388, 0.17109366964438888, 0.45390534181491027, 0.6616647851709858, 0.10112723644293986, 0.4831673428701264, 0.6186024482414645, 0.1501961311745763, 0.5960168132236496, 0.668451731916802, 0.21607512881881863, 0.6115530311294132, 0.6901396012506497, 0.2667437805350684, 0.648237325896139, 0.7312306945995916, 0.31704626040781725, 0.24282323027733266, 0.1275508310337916, 0.06459637236898708, 0.39921403480725925, 0.5187911332519082, 0.13832167103290105, 0.19434262580331374, 0.42009144050354164, 0.08342011007020522, 0.38138782858114484, 0.5298021480339733, 0.27777296814024577, 0.4164171420502467, 0.5473648053207457, 0.29784462165453873, 0.38520957137870016, 0.5134422057353802, 0.20846598099299296, 0.7323460623586837, 0.8037270576817045, 0.7102944888609821, 0.7665743139790985, 0.8182749508426778, 0.6991141318916401, 0.7543946737024795, 0.8351352506187983, 0.7252907017540756, 0.10016544264755178, 0.1277930222292476, 0.10547220109437727, 0.0948868890863479, 0.10131858413155514, 0.08970217439279571, 0.0965440124833532, 0.1243607895488813, 0.10983155397192135, 0.16436865033188786, 0.20755075474543794, 0.13468015490186658, 0.18635836628449587, 0.23995705471123363, 0.1501015396287777, 0.1413837596075913, 0.17325447184751885, 0.13715932136054854, 0.42570942094727593, 0.5413260136790763, 0.4418138697752192, 0.46344021394970614, 0.5360814225223172, 0.46777974192947, 0.47166800032782963, 0.6039506779844909, 0.4703851823866908, 0.34109564741905474, 0.4422336497373117, 0.3097032922425944, 0.34385845110576196, 0.44743419107187044, 0.3058796892260952, 0.33650493652745306, 0.47279623922988034, 0.30817596064078334, 0.19496715860887226, 0.19189875755447272, 0.21760822697656135, 0.21421399502979488, 0.20743843902808212, 0.2030006854942369, 0.20027397210264175, 0.20973960257216062, 0.17705025689343457, 0.19135689549285306, 0.6452826510296686, 0.34420898597672345, 0.22027700942823125, 0.2126229094485318, 0.2146231575673926, 0.20581648437793532, 0.19841477722523293, 0.2683445515245694, 0.16369646077424782, 0.14969694380636034, 0.2046396358555833, 0.7398217712065855, 0.19402223762224113, 0.7792407522619045, 0.29866183872480656, 0.8324195437648897, 0.7313199574093794, 0.20877810194472646, 0.16778224182678514, 0.7535743616253079, 0.19611969704933074, 0.4521690218997628, 0.7592395578790094, 0.20929344675738304, 0.21138261277321402, 0.639383239749554, 0.18347887652743367, 0.19140114263091867, 0.18918861761696515, 0.18686991637543993, 0.18545590018996694, 0.1848009645025832, 0.17612359766231167, 0.1674544888234497, 0.18076875236391676, 0.08750558399851582, 0.0926173069941737, 0.09270066242714381, 0.07419817594702749, 0.08332041257882972, 0.09055605980930304, 0.08265364452422241, 0.0858871532260258, 0.08307655410726422]}, "mutation_prompt": null}
{"id": "5eb096f6-2a32-4160-8f36-0c8daa3e3d26", "solution": "import numpy as np\n\nclass AugmentedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = np.random.uniform(0.4, 0.9)  # Self-adaptive F\n        self.CR = np.random.uniform(0.7, 1.0)  # Self-adaptive CR\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.F = np.random.uniform(0.4, 0.9)  # Update F adaptively\n            self.CR = np.random.uniform(0.7, 1.0)  # Update CR adaptively\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "AugmentedAdaptiveCoDE", "description": "AugmentedAdaptiveCoDE with Self-Adaptive Parameters and Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 74, "fitness": 0.45228073859941553, "feedback": "The algorithm AugmentedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8551752364971464, 0.8815013927234814, 0.8702243900714028, 0.8727233168489377, 0.8854903787672863, 0.8605139390520754, 0.8709186865689307, 0.8642832365488455, 0.8762221110010133, 0.7552174132222788, 0.7582357996337307, 0.7518829578949087, 0.7373952033155862, 0.7420389331338182, 0.7765075338067585, 0.7477669515088681, 0.7545753885744635, 0.7734753337571603, 0.12574305776178896, 0.1283685619749847, 0.12769992549426457, 0.11989026386205148, 0.11359839433431895, 0.1378991814481063, 0.20459849915851902, 0.2457204043858796, 0.11251032269313177, 0.1309749355599219, 0.12905627468673642, 0.13413492362523138, 0.14472093047868895, 0.09842346067260621, 0.10881944552381972, 0.1244950616111089, 0.10892853751737563, 0.1395421737572542, 0.9933179730093206, 0.9919582114597048, 0.9751300021287881, 0.9713175530139754, 0.9952320535966458, 0.9907119884433828, 0.9762568401265778, 0.9935226703922084, 0.98763718345827, 0.6113634261435288, 0.6399161699244711, 0.5889986411880739, 0.6195745317879826, 0.5907336517659778, 0.6281304413122376, 0.6492139947163739, 0.6251189520689, 0.6064549386772538, 0.8377656511310961, 0.8351186920412776, 0.8619488303290245, 0.8430292834569982, 0.8655616987251111, 0.8551351859337413, 0.8387341230920362, 0.8252168098419875, 0.8435601551497338, 0.6019847241609099, 0.5718197172799091, 0.5980762798823278, 0.5746707229587941, 0.5855914177574986, 0.5747957490742862, 0.5629984572157634, 0.6007182231439874, 0.602666203727066, 0.6108707405972289, 0.5961828626017149, 0.5816824372477554, 0.6350690671537012, 0.6458593303582874, 0.6394583692301052, 0.5367968685348588, 0.6323613908095016, 0.5600149124903416, 0.4352083210185922, 0.48475643146992575, 0.5097455213609872, 0.4405657471859844, 0.39927490926200193, 0.5035477255118415, 0.526291166825235, 0.4186871091917934, 0.5388841352514988, 0.5542074150244528, 0.5476229388992104, 0.5436520546704253, 0.48550101249416233, 0.4746232772313187, 0.5331675403858076, 0.5598485341973909, 0.58354960381158, 0.6499163587937455, 0.12538787684561736, 0.24192836565223697, 0.3085225974622554, 0.345040567243069, 0.26858966254075045, 0.2616583852956469, 0.238811042364804, 0.22171836639707654, 0.15138595141681677, 0.43424913130593235, 0.39006164547513933, 0.4051223310873199, 0.43116883360733627, 0.4471962267363834, 0.46758654292188107, 0.39499159199433076, 0.41005228549849604, 0.4411726970274594, 0.7742953385812746, 0.7588389033877847, 0.768516828464546, 0.7768356278122756, 0.7697812557312036, 0.7788617515584714, 0.7847947632030868, 0.7802521977424018, 0.7700649535535002, 0.11273567686369224, 0.09046904345010531, 0.08845770315208379, 0.10551726123299487, 0.09598418668327724, 0.11370279526046756, 0.12703678995023016, 0.1207003905602243, 0.10041545395730678, 0.1868971700058445, 0.15020512687970133, 0.15349536130609798, 0.17528760775014562, 0.13797425349669812, 0.14068572014080216, 0.1797738356550992, 0.12286083277263227, 0.3657483507968191, 0.5647944541455135, 0.5161238765384387, 0.4880450621690162, 0.49868620485631654, 0.49689482951336417, 0.5012689191012696, 0.6065426534517011, 0.5085730688139902, 0.5676965022787757, 0.3838229782997631, 0.38072161074448363, 0.41017239633471747, 0.4089888330335357, 0.325838160026625, 0.42610177717956643, 0.33646245332628477, 0.3734042405602721, 0.41168028275203716, 0.21041372704350847, 0.1957986903021548, 0.21734946510247077, 0.217012158220254, 0.22973485298965257, 0.19691943340827167, 0.18644207196005946, 0.21649372390310984, 0.20305094303492643, 0.23423972137486349, 0.2355279543557165, 0.5120261281467702, 0.22021760780326627, 0.5459261916043043, 0.23323421477436612, 0.21490514491663237, 0.22468319124115754, 0.48199033598343943, 0.18132698386062962, 0.8830312537533404, 0.18124692676069898, 0.18339166190686473, 0.8957502382943303, 0.8574714521048856, 0.7641396423343987, 0.16470560118845023, 0.16803673072794922, 0.208189276460104, 0.16907058861076874, 0.8100233320747292, 0.5306121630272582, 0.20945606615941492, 0.396801620801849, 0.7045817797251294, 0.2119207895768882, 0.21169528448807873, 0.18469374690595697, 0.1823328457481953, 0.18043813709594791, 0.18869268077883983, 0.18684891659773117, 0.184676521063185, 0.19830992823160054, 0.18615475135159987, 0.17501965110698914, 0.07938624354439339, 0.07925890637027044, 0.08924742367063809, 0.08398681234518912, 0.0859909635036149, 0.09007445379257784, 0.0989699117690892, 0.09107942838758043, 0.0888101960455342]}, "mutation_prompt": null}
{"id": "6b85761a-4b91-45e8-abc9-d1e55c84182b", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        perturbation = np.random.normal(0, local_step_size, self.dim)\n        neighbors = candidate + perturbation\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Gaussian Perturbation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 75, "fitness": 0.5301980311977302, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9159922520670037, 0.9161912369095011, 0.9233748804059545, 0.9179956566426334, 0.9140972064200377, 0.9125283013748393, 0.9109915835239245, 0.9186719739756807, 0.9174577433967871, 0.8329510342044475, 0.8287238747060429, 0.8378898291573217, 0.8373198447316678, 0.8151313897578771, 0.8327294025961585, 0.8122179285047544, 0.8353930714622649, 0.8369118729585677, 0.6833050720925551, 0.1839885263704384, 0.1347150283224675, 0.14911558307342299, 0.12960339218304784, 0.18061049766542214, 0.1364811443113284, 0.166172754558936, 0.15706655925655288, 0.09540476997364389, 0.1330504113765144, 0.10941351865327031, 0.13840733906080838, 0.1145542767425366, 0.10692650540828585, 0.13443871605677815, 0.11735394758518991, 0.12983152140600962, 0.9812250598336396, 0.9913711903573187, 0.981036468636492, 0.9710444025100674, 0.9731297892842294, 0.9693008790399474, 0.981068173920649, 0.9694762379484355, 0.9880096060625563, 0.76983844171518, 0.7648327091544249, 0.7596828350975398, 0.7847369308348682, 0.7635392877610028, 0.7703521949523956, 0.7420926584889423, 0.7690223205585179, 0.7708924484254723, 0.9045476644973, 0.9129537032502705, 0.895833031227757, 0.213953321807829, 0.9132573183853276, 0.9197330275235783, 0.9066179117895103, 0.9055803170630555, 0.9068016151497776, 0.7609247144626554, 0.7732435744112275, 0.6611933451871039, 0.7105418766671194, 0.6810896587808837, 0.7638865351795476, 0.7760741465505028, 0.7903722520915561, 0.7376508140379605, 0.7218971645046587, 0.7188040478071416, 0.6570405962263918, 0.7101924241631037, 0.6587045950921392, 0.6292516790902262, 0.7143305632514294, 0.7718589877284323, 0.7091406349891776, 0.3517516557263639, 0.38627166489038833, 0.13596855741912572, 0.7007446729613067, 0.6391928879228547, 0.6854251042052102, 0.538990415037452, 0.7225656796866029, 0.6046691493948753, 0.7999790329554807, 0.7593977868479911, 0.7507811604603889, 0.7734184674722866, 0.7457497148181854, 0.7818852966239727, 0.795150040713622, 0.7704420278128923, 0.7944072878505808, 0.491026542463347, 0.22786170142242312, 0.2752588800978867, 0.6735701085652754, 0.24368645691319024, 0.4458904532563669, 0.4968424335799887, 0.45984548807996406, 0.4800988667399877, 0.697644312881175, 0.6448224675928382, 0.6219475918001314, 0.7007503250759277, 0.6783123278904013, 0.6759603803814452, 0.6810353590612952, 0.6153079187178835, 0.5460650013176787, 0.8708630879866449, 0.871886667933131, 0.8867874050465931, 0.854333872191155, 0.8737963593662734, 0.8777873249125339, 0.8798247141309212, 0.8736143507280534, 0.8727774100812149, 0.12721634898862555, 0.1492965459950374, 0.1254672471874665, 0.11662032539814104, 0.13613790016634708, 0.14831215762326555, 0.1301614579551359, 0.11481185850173448, 0.15023278371174642, 0.26994197041512025, 0.27854130279164924, 0.195559242469574, 0.6446502443799631, 0.1701907479031879, 0.1664285378910314, 0.19697004353385217, 0.14392139061270537, 0.25576042602427873, 0.732777887258994, 0.6366845329506445, 0.6034023646256732, 0.6012091928294414, 0.5417985024026274, 0.7295449787923705, 0.6316477954843794, 0.7663616558890184, 0.7279462844675848, 0.6489896349502652, 0.6118521692078558, 0.5958158591335427, 0.5099750704295194, 0.5351211656860775, 0.5240494479021929, 0.6868642120093152, 0.6220472062725567, 0.535160337049128, 0.2119317598302478, 0.2318030283716246, 0.206126365546219, 0.21041329754745952, 0.2248943908379345, 0.2290153242810119, 0.21503481418637704, 0.19834446630334146, 0.2271832839712169, 0.2443104834427997, 0.20843941677906863, 0.20619573363169597, 0.19661730576129077, 0.22075162413105953, 0.23209531614183143, 0.21892025383210711, 0.22091597548715003, 0.19865089408524195, 0.18546643382890238, 0.15749476768067616, 0.20096138853515322, 0.9221907711342231, 0.1998139668969382, 0.16995357402495315, 0.918673579039982, 0.15839101202265282, 0.9337149014651329, 0.9274364682317081, 0.21297205414685727, 0.21007742133334872, 0.9118388285364674, 0.2128355463161039, 0.16819962294990531, 0.8964617466845244, 0.8827610480293513, 0.8993392176788424, 0.17490667836553653, 0.18641373919019766, 0.18722394086763583, 0.19146380363214388, 0.18183594185903307, 0.20184127987006406, 0.2103097646767903, 0.18396996973365842, 0.19579238362544027, 0.09044192664377348, 0.09704010206106484, 0.09362374590678135, 0.08681575311981982, 0.09816202767891213, 0.12531810690130296, 0.10855225676948443, 0.0953998692568061, 0.08444432355451592]}, "mutation_prompt": null}
{"id": "f0919715-b70f-4373-923c-b4df11a5e369", "solution": "import numpy as np\n\nclass ImprovedAdaptiveMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest,\n            self.mutation_rand_to_best_1\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_rand_to_best_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (best_individual - a) + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "ImprovedAdaptiveMetaheuristic", "description": "Adaptive Metaheuristic with Hybrid Mutation Strategies and Dynamic Learning to Improve Exploration and Exploitation.", "configspace": "", "generation": 76, "fitness": 0.5413376335833211, "feedback": "The algorithm ImprovedAdaptiveMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9189150572299407, 0.9224756014808722, 0.9243584490445224, 0.9231361988033048, 0.9227590545130029, 0.9223007684294895, 0.9183809488732945, 0.92030771600945, 0.9220625135536321, 0.8303400230129045, 0.8478066700429875, 0.8458970931688519, 0.8478109298030182, 0.8414190870593528, 0.8560855565777188, 0.8458534479119484, 0.8466217784480868, 0.8422862059816677, 0.17390614761711565, 0.15062987463445876, 0.17334931459936775, 0.1401021025778415, 0.14554817982110524, 0.6285639981723746, 0.6817450264473354, 0.6178678367574686, 0.1337003833095134, 0.12364388639747426, 0.11736451276034643, 0.12359687402776143, 0.12857903566083295, 0.1359661120630299, 0.11421881916886867, 0.1518617613466564, 0.14843534359409516, 0.1603606689919499, 0.9877005213078758, 0.9794229420551003, 0.9747365450663036, 0.965997496983274, 0.9789829385243249, 0.9738580410103878, 0.9608806712218031, 0.9776304794072148, 0.9926985481894204, 0.7891307572090591, 0.8040721795445077, 0.787277342239582, 0.8032297356683974, 0.7889215971750512, 0.7983293047749598, 0.807262805411703, 0.7842234166236677, 0.796024795213431, 0.9177169260201159, 0.9234542046266824, 0.9131402709096483, 0.9194775750498108, 0.9177120821063528, 0.9141365851303465, 0.28853403925399357, 0.9061456232766965, 0.9227424960563541, 0.7368374500475474, 0.6620281069147136, 0.7119256669380212, 0.8271840703717653, 0.1352918627081917, 0.6802053187937795, 0.7428691154170179, 0.7516824394050199, 0.7192773394231582, 0.7183110800479126, 0.742878627955696, 0.7495557890817051, 0.7068342511351422, 0.7408394579535824, 0.8200209398325252, 0.7852111349208486, 0.7465083580240772, 0.7417844284047391, 0.2043632188774539, 0.7120748759647634, 0.48717834803056137, 0.7188328016589898, 0.7107001671177475, 0.6196961711291477, 0.6825289112562216, 0.6620151938391416, 0.7691792075255722, 0.7851376795359154, 0.783381824458493, 0.7959266151895467, 0.7635038268916648, 0.6106362571533246, 0.7809597680665197, 0.7821435638714412, 0.677653355305972, 0.5823472565196955, 0.2861281099359554, 0.2137706677921999, 0.17854832698839396, 0.4242102056887528, 0.5378741524574124, 0.6117789981820108, 0.16031362223932333, 0.4700827724287593, 0.36512935166696403, 0.6894527933352282, 0.6902422202409493, 0.7057644363389921, 0.6914324950985509, 0.6432002280766876, 0.7016028548572075, 0.6308101373607937, 0.6935814164924087, 0.6078697678451569, 0.878509762946925, 0.8829857376884491, 0.8736573708950073, 0.8843887717400322, 0.882666715005015, 0.861904447007918, 0.8934037608036772, 0.8679094215729355, 0.8756876168598668, 0.15430815199565406, 0.15841374815703457, 0.17697866050138544, 0.17351574799461045, 0.152401549646907, 0.1693786026976173, 0.12810170208328087, 0.17325845025253528, 0.11309769789802582, 0.5932762756063199, 0.2660201670418032, 0.5729072331781004, 0.5014950358355852, 0.3689713847913576, 0.21698776534207365, 0.28746924027320764, 0.1999693270956442, 0.4117628231749646, 0.7474150163864159, 0.7480566961619908, 0.6451240478147396, 0.7130537380926634, 0.7702269320238035, 0.7341203551552897, 0.7804387751567226, 0.7317704824537665, 0.7854673385846493, 0.2438484233858872, 0.5586044253907037, 0.3241322002763355, 0.6445850421150465, 0.3603677743530479, 0.5563008002788365, 0.6935890568525664, 0.6676599020412093, 0.6284703433103871, 0.2339310680900779, 0.1923163260555928, 0.2153983153503779, 0.213995012794297, 0.21667707072290088, 0.20617867536644896, 0.23497396299388806, 0.21288761716970783, 0.23475080981835217, 0.2070013196303827, 0.22186003586140368, 0.22019713434074706, 0.24329127804330009, 0.19749179343155576, 0.22467494832899404, 0.7473376885356207, 0.7263283336415904, 0.21945717798041553, 0.18715661661826588, 0.17334912955172987, 0.14833660520771597, 0.9216072430342467, 0.19942640730808148, 0.5582676952992864, 0.16033116740969144, 0.1687012935970188, 0.8722808899598733, 0.9206223837115892, 0.2125753335677404, 0.4972496302662316, 0.21077222302536247, 0.8891814841711569, 0.8759447410064942, 0.21171805340991412, 0.1669384030030011, 0.21304819685518372, 0.18475876058411456, 0.2108629790833333, 0.18252532719243952, 0.19784977830780992, 0.20176473849576237, 0.19112687717088706, 0.18730685649086187, 0.20540241922656055, 0.20179251504716733, 0.08581990079423663, 0.12185315646409633, 0.08860684980517275, 0.09947003401993493, 0.09558671995145396, 0.09584905068702121, 0.09360198207669146, 0.10638377803660881, 0.09845861274389811]}, "mutation_prompt": null}
{"id": "deb6994f-c7da-4142-9b29-61b3b8290c8f", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.quantum_amplitude = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.quantum_crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def quantum_crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        quantum_shift = self.quantum_amplitude * np.random.uniform(-1.0, 1.0, self.dim)\n        trial = np.where(cross_points, mutant, target) + quantum_shift\n        return np.clip(trial, self.lower_bound, self.upper_bound)\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "QuantumInspiredAdaptiveCoDE", "description": "Quantum-Inspired Adaptive CoDE leverages quantum principles and dynamic parameter tuning for enhanced exploration-exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.2769683212472096, "feedback": "The algorithm QuantumInspiredAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.47018427820984077, 0.48851599190924655, 0.4903912947091438, 0.4958420039102872, 0.47066338460660473, 0.5006912616029335, 0.5014105053956746, 0.5219625162060463, 0.48818847024511014, 0.05278660325234796, 0.07693714410188246, 0.15044092278080334, 0.04749921854503503, 0.07334075220081271, 0.07120917904789348, 0.06671736965156361, 0.08454260609940378, 0.11490142505526946, 0.12544104231806008, 0.13571369538010603, 0.1499839003424821, 0.17795283358515768, 0.1400362177070269, 0.12712749981455929, 0.11550471388959593, 0.1239649796494332, 0.13869861318559984, 0.12489963459135234, 0.11102033987175797, 0.11132324896334556, 0.13016037620847332, 0.11688087870330599, 0.10312927620343437, 0.09775380377252041, 0.13451924724676678, 0.10520552360875246, 0.9536750880095362, 0.9184082841837224, 0.9569394569646665, 0.9501953455764963, 0.9727844301112248, 0.9518719353505974, 0.9543384453373802, 0.9679754884184717, 0.9736967044242603, 0.34845993765729577, 0.33423721212052215, 0.3380792866500958, 0.3650774813637837, 0.3479775970132135, 0.3508184315763856, 0.3560460979771741, 0.3353232812348862, 0.3583019457183779, 0.8275357533785577, 0.7634261558684111, 0.8335535656929592, 0.8660280379234909, 0.851388786659839, 0.8677454827630786, 0.39810446738793204, 0.8335323837917852, 0.8890882080860264, 0.2332742021017924, 0.229097550783243, 0.231510237952686, 0.2033304956403411, 0.21527864893236193, 0.21150740347944463, 0.19639895160356224, 0.2436155140923275, 0.18596342610973393, 0.21699948978785, 0.20921489891706035, 0.19169522803708217, 0.19887821250234738, 0.22384464646834246, 0.12921360496599177, 0.24168769962558123, 0.24546850643597606, 0.22720218287961147, 0.10340435853789187, 0.09233404512004784, 0.052275881579236905, 0.07089467454073617, 0.08430621186705178, 0.05217888388686409, 0.050135510779574566, 0.08040056592797573, 0.031131785899761955, 0.1894382941247802, 0.1293126222337605, 0.14718363187611305, 0.1004076751632953, 0.09109242949114538, 0.11991052880995445, 0.14455870503041424, 0.1085774399869166, 0.18073608526466778, 9.999999999998899e-05, 9.999999999998899e-05, 0.03276118861005528, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011610754110880084, 0.00572098135564536, 0.023080521407818022, 0.0020432167709228954, 0.13951176778908958, 0.13515961386868736, 0.13874620899239964, 0.1414667996776694, 0.1384975362519124, 0.13386335293307927, 0.1289958390326187, 0.1430273549448644, 0.14925284154623109, 0.4647517221169264, 0.4572270215876437, 0.4447102946574858, 0.49659261533965093, 0.43437512949078516, 0.4310283908218687, 0.4465464074364821, 0.46216508810916146, 0.4353033772123409, 0.1121402175725863, 0.13368058479045253, 0.13571664956596108, 0.1430766991214132, 0.12988641866884754, 0.11742236905409864, 0.12347972969130894, 0.12237188235097951, 0.15958288195357362, 0.306416475527145, 0.24164846927463435, 0.2831371902687885, 0.1849368139383074, 0.2829951697080001, 0.2201540161052995, 0.2013022891459847, 0.2022812485055071, 0.2736586452579788, 0.3180710330361606, 0.3240986412829554, 0.32075788163627317, 0.319847748622734, 0.32356062664226704, 0.3236296384508882, 0.3169563623944318, 0.3372638348124428, 0.3170322066878103, 0.2546302009384641, 0.27223443907826905, 0.2585579989584659, 0.26338606153960475, 0.24138334574829312, 0.26261790794898543, 0.25607678923022426, 0.2600584325335741, 0.25158712533594974, 0.2333585061839638, 0.2067477765570297, 0.2214076759602206, 0.22251776844448978, 0.21784976406425638, 0.21502333610106983, 0.21878691319464794, 0.2144004749312447, 0.21616420979823348, 0.20671941562952656, 0.20094280834797829, 0.23712520602103626, 0.20555841052296842, 0.2188034264100026, 0.22200128491543059, 0.21411369853970985, 0.23986875931093954, 0.315946480822878, 0.18601119940143762, 0.7842215385857796, 0.19823755672852772, 0.7401208163383979, 0.19984834186479916, 0.1992146303584008, 0.14192522934441199, 0.6235526795878807, 0.7583157253109128, 0.7052409402267457, 0.211809282978083, 0.6582743997606877, 0.6692901148901003, 0.155799567567819, 0.15426206682822374, 0.21312188803387155, 0.10442648255804776, 0.6786167777375967, 0.1843540152918911, 0.18022907112918496, 0.18300209888847963, 0.17949510508732003, 0.18710595862483093, 0.1839237757368296, 0.1917613302240866, 0.1748464451818118, 0.17899222218976085, 0.09513512851415251, 0.0877386250024128, 0.08989023886887948, 0.0964260663820884, 0.09307425008645265, 0.08820339453389425, 0.09114749643886022, 0.10007494983968312, 0.08654038639887607]}, "mutation_prompt": null}
{"id": "8b7d1270-d157-47af-a7aa-f40a01421ad7", "solution": "import numpy as np\n\nclass StochasticHybridCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15  # Adjusted local search probability\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.stochastic_perturbation(trial)  # Added stochastic perturbation\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def stochastic_perturbation(self, individual):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)  # Added stochastic perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)", "name": "StochasticHybridCoDE", "description": "StochasticHybridCoDE: Hybridization of Enhanced CoDE with Stochastic Perturbation for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 78, "fitness": 0.25079778610163656, "feedback": "The algorithm StochasticHybridCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.45357810553801137, 0.45060211554474194, 0.48279134783526556, 0.4731072627502294, 0.47899688145949393, 0.46945801139767196, 0.45964506260746063, 0.4466111916381911, 0.48042123141378057, 0.06601603965584324, 0.05618836439189001, 0.05442525124442332, 0.06965846060493674, 0.082285710683079, 0.05030417575394419, 0.05449083648033315, 0.10834941014396715, 0.03356904982223319, 0.12762775666872972, 0.12629174811649624, 0.13027429047814054, 0.12700644900935132, 0.14262793677727204, 0.12470132052708871, 0.11600012332548848, 0.11934351766435469, 0.12406631919472677, 0.11769673118558, 0.09991919123904192, 0.10515291748082511, 0.11258493335925146, 0.09329096012288851, 0.10978147933943005, 0.09881289201397903, 0.09528613282635434, 0.09751499764293636, 0.944080409713694, 0.9528618363192777, 0.9438861718659937, 0.9489841840644364, 0.9469040221466648, 0.9233430457922988, 0.9626846483814138, 0.9466543099688303, 0.949241684043499, 0.2838637295266998, 0.282901379775063, 0.29169780540817924, 0.3183498654745215, 0.2944702193481732, 0.3130856960386428, 0.30640496922893656, 0.3010127471276425, 0.3001518083955148, 0.3800145479862592, 0.8325782347903596, 0.37142474957392824, 0.37339007637414057, 0.39057804304513566, 0.6674152338207973, 0.6433688469280121, 0.7818370877880395, 0.7548094589027543, 0.1761464704082948, 0.19768989391618585, 0.19850592604468142, 0.1290632134245201, 0.1774698198116541, 0.1877740402822884, 0.1675940674629799, 0.17158980014810077, 0.18435945749124893, 0.2004554580860627, 0.20652668809308206, 0.20071677746833583, 0.18133579138894085, 0.17899064065054604, 0.17319140847352643, 0.19020180596644554, 0.18730877521217015, 0.19361286581597115, 0.10282623159803606, 0.03941383181154301, 0.1095984340890247, 0.00955515249754002, 0.0250227011228773, 0.045723612344777176, 0.006602012840644655, 0.051274924042397974, 0.020999775521322372, 0.15370787722032897, 0.15181727078372165, 0.1886379662939548, 0.09674739687871403, 0.16684353560718646, 0.11665452998545645, 0.18292109583794125, 0.14680594199409702, 0.14984502312658754, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12800322260295693, 0.12375932416934976, 0.11188745106779296, 0.12968398916862767, 0.11367372773540174, 0.1310231338610347, 0.1293601776995058, 0.12053683574311158, 0.11537779069476872, 0.4235954679630962, 0.4213414080532917, 0.4494536536211462, 0.41336493430823384, 0.4112993677013691, 0.4323706513404172, 0.4266495773638813, 0.43547908985628714, 0.4479778184388499, 0.13842179830878265, 0.10944716068062299, 0.11478471860778339, 0.10496442926757477, 0.10704702378834996, 0.12223306455137395, 0.12445658488747702, 0.1286960948164444, 0.1310901604141771, 0.17154183939485212, 0.14704164797782526, 0.21521745755458255, 0.16551462210875711, 0.25337092910218084, 0.18958442734155678, 0.2082798177538835, 0.1644974917326586, 0.22271609563915507, 0.3004765861848686, 0.29477368000853676, 0.3209947942420288, 0.2987559950885872, 0.2878154151693757, 0.308688487844463, 0.30916848396185437, 0.3102802649559824, 0.2972737492781454, 0.23443551536368423, 0.24594420879862822, 0.2674879013394398, 0.23824570186195704, 0.2413019311526372, 0.2404847363285869, 0.24863736998270625, 0.24151532414562005, 0.26140447551449075, 0.23010452007426607, 0.21826364598051473, 0.21738397707825596, 0.2726546293074087, 0.22365071103478618, 0.2591125770325421, 0.2300279179460082, 0.19021978882128088, 0.22290720864316427, 0.20749684109619337, 0.2513958773755368, 0.25472603458722576, 0.27258778071227385, 0.22770286661743766, 0.20228865758721148, 0.24948664164218015, 0.2289969312711616, 0.22588021056670227, 0.18640040752949372, 0.6962706151290747, 0.1534550927957613, 0.6403511676793278, 0.6412145859242091, 0.19781700559433546, 0.16645853864057114, 0.12525534050196652, 0.1844563472714572, 0.6143167471809976, 0.210269019727802, 0.6084163500295792, 0.2093128302991175, 0.16775902961251066, 0.15473757185517312, 0.6851676864578358, 0.5605911787107769, 0.21081419163465942, 0.19642379186710457, 0.16995556428495961, 0.18018056988893183, 0.18114870631834312, 0.1995225246062874, 0.18727004719414775, 0.17998232989479734, 0.18176246146704733, 0.19375977988370618, 0.10283877134416575, 0.08780794102553313, 0.09337606261687847, 0.11098309625184555, 0.08866413542861662, 0.10970920496435899, 0.08969404598381503, 0.09281316232260939, 0.08414824061526449]}, "mutation_prompt": null}
{"id": "04c8247a-bb33-4840-a4dc-248ac1ad13ac", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.successful_strategies = np.zeros(len(self.mutation_strategies))  # Track strategy success rates\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic selection of mutation strategy based on past success\n                strategy_idx = self.select_mutation_strategy()\n                strategy = self.mutation_strategies[strategy_idx]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                        self.successful_strategies[strategy_idx] += 1  # Mark strategy as successful\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def select_mutation_strategy(self):\n        # Use a probability distribution based on past success\n        total_success = np.sum(self.successful_strategies)\n        if total_success == 0:\n            return np.random.choice(len(self.mutation_strategies))\n        probabilities = self.successful_strategies / total_success\n        return np.random.choice(len(self.mutation_strategies), p=probabilities)\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Enhanced Diversity and Adaptive Learning Differential Evolution with Dynamic Strategy Selection for Superior Global Optimization.", "configspace": "", "generation": 79, "fitness": 0.4183708948879688, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9531095699669704, 0.9022518482639692, 0.9081546795347925, 0.951245325768962, 0.948038452295302, 0.9093068626695184, 0.951215836564375, 0.9474074545253853, 0.9453497469804668, 0.8878629897111798, 0.37304554113151045, 0.8190754541933671, 0.2122788776036344, 0.19118205238453445, 0.4565086496935945, 0.8951573573958133, 0.13012169407016427, 0.8672313466139553, 0.15634975554675834, 0.15869012990204356, 0.414114594450532, 0.11383783420413585, 0.09756814781563428, 0.4705383416768546, 0.14871923898510653, 0.15617749098085387, 0.33243969621831415, 0.12425994846913202, 0.12218476721637583, 0.12350830685427461, 0.12277245903898781, 0.1233414479031224, 0.12620501260103678, 0.09715109143333533, 0.11800632471306582, 0.1281947713827205, 0.989794672346786, 0.9932494465110561, 0.9904507502457025, 0.9843349864233178, 0.9849070038265735, 0.8850171316938681, 0.9873846284668856, 0.9875238830269093, 0.7891809235837829, 0.5160293522904542, 0.8490151604430072, 0.3807080214792261, 0.48398291838893615, 0.15351564620730662, 0.40886230618730757, 0.4558348752639252, 0.2930590365913457, 0.8122362245010044, 0.9405527383468676, 0.9468437479454426, 0.23017160439458828, 0.2815581719559155, 0.28069308143346017, 0.19484369969913595, 0.809150735701637, 0.1254276403133373, 0.17900653330597815, 0.26322299774274405, 0.15281258530162722, 0.16471514163725698, 0.7454033345392483, 0.16875635883409434, 0.8189268739565728, 0.832366083678139, 0.8168524686548779, 0.8047946664855996, 0.3139304973392214, 0.20889241383627288, 0.2089184511719493, 0.8168025243128032, 0.15044217782762315, 0.2075308695383663, 0.1552800364370036, 0.17870410202166165, 0.30153103379900803, 0.4188736489184004, 0.6603290872996468, 0.42811228230912446, 0.7006082645275222, 0.7284072073447058, 0.31571578493287333, 0.25064249289023, 0.2110446351511619, 0.31127868529027514, 0.864112718807642, 0.3315126222850143, 0.3241233885418032, 0.7910846067526114, 0.1549267047017049, 0.7916223011077574, 0.2924515481685689, 0.5975717402204809, 0.6912497754734857, 0.330986098565904, 0.5699980924618187, 0.4576919683816637, 0.16396727306648262, 0.6490685179548764, 0.28935116946596395, 0.2934456043307059, 0.3681017019454129, 0.09470294043109462, 0.29742525712925916, 0.7132972153698405, 0.6519149777248254, 0.631929677146127, 0.5925205172646435, 0.5953944163044642, 0.29218646355644096, 0.5568561344980134, 0.45672797527028275, 0.8966380635267422, 0.9064169994501431, 0.8763593970806206, 0.7173548506444464, 0.7285685694307238, 0.6909195352664226, 0.7739015045919275, 0.9167807481750513, 0.9082975417155885, 0.35977287099250166, 0.10692127948035468, 0.4480059623311816, 0.1437383433246634, 0.14967612844015044, 0.13546339541645414, 0.14109035570358341, 0.13240818402127952, 0.0954328022084926, 0.1460150718553458, 0.21265784300832924, 0.14395896802012798, 0.31813341255775873, 0.14804176414163195, 0.1748037225035709, 0.18415030627976037, 0.21893544286518662, 0.13432337501916503, 0.635523444100061, 0.23724601873754014, 0.3072032175881383, 0.8339434552584228, 0.6177584965758276, 0.372549218592527, 0.41990849812004616, 0.44558497917252593, 0.33308762899010114, 0.5415674206454197, 0.19237974539870428, 0.4191679964498013, 0.19530437443262483, 0.518119293139941, 0.19862943825692359, 0.2152281357916822, 0.2868483970647089, 0.1591545788768015, 0.28976891663260496, 0.22479444617268896, 0.23254829284891898, 0.23394942458510937, 0.22521662941890774, 0.21328817980239434, 0.237307382292683, 0.18593734489616898, 0.20674508354323629, 0.3672759591906726, 0.20959973039070834, 0.22814979704165295, 0.18948602650761937, 0.2339042154851303, 0.1927991390832312, 0.2258977106883352, 0.180331247806662, 0.19161759222099506, 0.16653277313485193, 0.12665923536691548, 0.14851568243599744, 0.9650633446163808, 0.21794280667341004, 0.16716589006617, 0.14287071280714847, 0.21296912983279792, 0.9619551725977413, 0.9476759986913778, 0.21119036179684292, 0.9302809964492644, 0.9415839822648204, 0.16582169023248594, 0.1566339562028365, 0.29091700546827737, 0.7716149012999969, 0.7955296005792434, 0.18401714439490013, 0.2868755962078401, 0.18412690492883566, 0.18231449473512418, 0.18227934507544608, 0.1878411051524057, 0.17692353629824098, 0.19414583947879904, 0.1911679705323287, 0.08798047081562632, 0.1668013818836973, 0.0923622822633301, 0.09722540589593298, 0.10120857499922509, 0.08703217158635979, 0.09404528117235422, 0.08742476979846381, 0.1617757541766458]}, "mutation_prompt": null}
{"id": "a605aca5-bbea-42db-bc10-0d851553af6d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest,\n            self.hybrid_mutation\n        ]\n        self.local_search_probability = 0.2\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def hybrid_mutation(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        gradient_direction = (a - b) / np.linalg.norm(a - b)\n        mutant = best_individual + self.F * (a - b) + 0.1 * gradient_direction\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Adaptive CoDE with Gradient-Inspired Hybrid Mutation and Enhanced Exploitation for Improved Convergence.", "configspace": "", "generation": 80, "fitness": 0.48807596934291053, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8878240950852078, 0.8864026338284607, 0.898303915268858, 0.899112509409286, 0.8864126938212014, 0.9007154335542243, 0.887033239218423, 0.8875875521941728, 0.9014448405013065, 0.7894091839066898, 0.8051091838490543, 0.8122849881205824, 0.7881224186037582, 0.805845844473188, 0.8215484886170977, 0.7991593267060695, 0.8180887044951568, 0.8080263450552162, 0.10883404201614666, 0.6760174196645747, 0.09706981413876836, 0.10932043753103937, 0.14905324292410482, 0.12011261317254707, 0.08982862517707779, 0.6745520078704502, 0.17677241634196472, 0.17716076317183582, 0.13499167924756983, 0.12666252596981542, 0.10797825694007301, 0.15416532743979972, 0.11041287113929288, 0.1824701608216014, 0.15156686979870881, 0.1321406719557835, 0.9882831498785066, 0.9823682730005909, 0.9807818399792457, 0.9861283573364761, 0.9883172883464119, 0.9758583242612071, 0.9860419158060298, 0.9875641149275304, 0.9823005882562889, 0.608550590084227, 0.6254881586936056, 0.6706028425287907, 0.6516807069376895, 0.6487209332447799, 0.6833861603822546, 0.600475662269526, 0.6274660728593409, 0.6892270290307755, 0.9163115517563418, 0.9159406293996809, 0.8812071596916663, 0.9120887641267373, 0.2134443911529771, 0.9005171084455704, 0.8895176973369676, 0.29065851863448644, 0.9112680452891294, 0.6840879312351404, 0.6498377367166599, 0.7148605701301799, 0.13329076887430402, 0.6707426326399055, 0.6869491372182803, 0.6561990714617483, 0.7172003219994347, 0.6514099560491021, 0.660498371564775, 0.13293671426080544, 0.6093465928153106, 0.7111990462382631, 0.5822382144058165, 0.6587162245200413, 0.6972160841450793, 0.711517522414369, 0.6987560766737078, 0.5995258093493756, 0.5782296531340452, 0.5580566015483281, 0.6242657347574956, 0.4145927013622901, 0.6307858849795159, 0.6050040614933466, 0.5486556986532568, 0.6773596964799025, 0.7098312613298519, 0.6290989806417406, 0.7517463119208952, 0.7015793954359613, 0.689706724269431, 0.6383991191220724, 0.7186966900837477, 0.7557334257545587, 0.7704922439658963, 0.1415370580724813, 0.226866416113348, 0.1125575599563241, 0.5084455919663884, 0.599200333705308, 0.34758619482437914, 0.12913209673684123, 0.2227324702140263, 0.29628326601022825, 0.5409421371312928, 0.5270804257191055, 0.5489540826585569, 0.5235811275634745, 0.5636975455228165, 0.5788661091655429, 0.44625093077672895, 0.43779427053324926, 0.5237681277176349, 0.8162875126428769, 0.8197892826752935, 0.8313772719769359, 0.8002857115776558, 0.8273489034126439, 0.7907075484129855, 0.8237539487205074, 0.8190364515078713, 0.8208163090500216, 0.1236534469340258, 0.1678096103231268, 0.12323244294232427, 0.11252728602165152, 0.11125163037668007, 0.12672302115957157, 0.1541375672651737, 0.13308981567650569, 0.12011707876994593, 0.1643670028992248, 0.17820779491141292, 0.25808304939862614, 0.6357567551304144, 0.673224910319018, 0.1350778477803144, 0.20367620038788292, 0.5481478969713288, 0.6147666687469007, 0.5173360999250509, 0.5728496760482348, 0.2764091136851269, 0.5513341814618882, 0.5538226725056805, 0.49987399480102945, 0.5208058975135675, 0.5773419812764145, 0.4954352911783658, 0.42182702831421137, 0.4458485684349949, 0.26595061919628094, 0.37835849961127854, 0.24387092331409232, 0.46898598216275933, 0.4819090203600219, 0.5154397296902524, 0.2465551893353739, 0.22480643798342714, 0.2187301185362921, 0.21568161293071875, 0.20048932706148803, 0.21600108754150893, 0.1867992790757964, 0.2622201248701399, 0.21540597724531863, 0.21469538208734118, 0.2460116860528958, 0.22194491392231497, 0.21680251832976216, 0.678680998001476, 0.20731598494791137, 0.22389089977244503, 0.21878689014673403, 0.24161573596201957, 0.24664616156430708, 0.9106100243075689, 0.9145410694148285, 0.1538684286023606, 0.9120990671232483, 0.20034475384677275, 0.19955635065259136, 0.9296801930171756, 0.1690073653952977, 0.9240638395395537, 0.913048262794062, 0.2121033218537265, 0.07349435361268064, 0.2096568172118396, 0.21241196853298994, 0.15550501009727946, 0.15568470773500598, 0.1674082763913468, 0.9130526437384661, 0.20235241064143272, 0.1819482379704611, 0.1845570550672554, 0.17883168307393338, 0.2001081172314847, 0.18825042062199426, 0.19024198027304806, 0.19793064406252348, 0.18543882674645662, 0.11764754830871338, 0.09338116557948828, 0.08256495733299885, 0.08907735041795917, 0.08136701956049985, 0.08226630099268528, 0.09327214536852424, 0.0758580303519899, 0.08967073204469922]}, "mutation_prompt": null}
{"id": "c7ebe9f6-ad68-4b0f-979a-60b360d37b86", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Improved Adaptive CoDE with Enhanced Diversity Maintenance for Robust Global and Local Exploration.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.13082243391408332, 0.14926882832655353, 0.4871502730920929, 0.1566818646751459, 0.13570242631640106, 0.617196753638718, 0.1434970705283406, 0.17547458408710936, 0.13928315457245588, 0.1189632854231788, 0.13000621709587412, 0.13249475508348774, 0.14874280185365985, 0.12753402335912323, 0.14136619935343897, 0.13437263489837425, 0.13224867351621183, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6838500505938747, 0.6374214476331126, 0.6777146197687898, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.10839248883327424, 0.14735438667347678, 0.17190016584136014, 0.10295122102213972, 0.13335029487955397, 0.15720729559937097, 0.13404918076899575, 0.12197132087737994, 0.14089908522209627, 0.6847240630975421, 0.8064795999398799, 0.33169013459262564, 0.30914131438775505, 0.16953977388728259, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.7034778980630669, 0.7097195853213218, 0.7274573919572764, 0.7146626855679129, 0.6997498948705058, 0.6792506696181246, 0.5455138719437629, 0.759666167706329, 0.6360804614621964, 0.5546263845368586, 0.5628789544136292, 0.5889206638705538, 0.5923266609197938, 0.2594499454960548, 0.47691450874840047, 0.6778095954785703, 0.5714513874489102, 0.6741277609996407, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496757575, 0.24954120677673663, 0.2089355077776709, 0.7127353020253682, 0.20214899961642407, 0.2207334733772448, 0.20164636749791687, 0.7843193504840147, 0.2427273571520273, 0.18651505573874283, 0.18745256279014155, 0.20030504180354325, 0.9151272172316909, 0.20079593464574463, 0.920504483371455, 0.9091934308991853, 0.15783294821268368, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559195, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "7bf8bce0-5a6a-40dd-8d5f-037608453fd5", "solution": "import numpy as np\n\nclass DynamicCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.dynamic_factor = 1.2\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            if adaptation_counter < 5:\n                self.adaptive_step_size *= self.dynamic_factor\n            else:\n                self.adaptive_step_size /= self.dynamic_factor\n\n            self.adaptive_step_size = np.clip(self.adaptive_step_size, 0.01, 0.5)\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicCoDE", "description": "DynamicCoDE: Dynamically Adjusted Adaptive CoDE with Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 82, "fitness": 0.5442637789960151, "feedback": "The algorithm DynamicCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9150113278383212, 0.9113065840802308, 0.9207422012816808, 0.9093407917438634, 0.9126092364733581, 0.9256843931868617, 0.9094945803515757, 0.9129799160670884, 0.9202860759526145, 0.8112360768749464, 0.8291870476636571, 0.8460647467583284, 0.8174573884218592, 0.8445543985337259, 0.8489152746692294, 0.8279258367146088, 0.8433853574464466, 0.8375898114265907, 0.17006373871399105, 0.17574771379190424, 0.1670826711000576, 0.15638324162261907, 0.17159471162676054, 0.17241424291441543, 0.16671394834517372, 0.25214686754285, 0.1529880344793021, 0.1380240869836351, 0.1492193846603963, 0.11119433168906523, 0.1367976448269166, 0.12945622982255012, 0.15275727647692205, 0.12970207924275878, 0.11969408778628388, 0.13465147169002234, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745407924933989, 0.9828961041443951, 0.977639260258256, 0.9684123185711848, 0.982778729149947, 0.9814459544822531, 0.7784366253136894, 0.770207435109114, 0.7649097476860283, 0.769645013094838, 0.7731193650043351, 0.7641139625691872, 0.769544246255272, 0.7658865084485394, 0.7987066599785151, 0.9070772949660094, 0.8868556190317575, 0.9290752788767999, 0.21437266358259066, 0.9238116132341893, 0.902030123892462, 0.9055471950665807, 0.23554862900527318, 0.23675224998995514, 0.7539154105658384, 0.812992954535119, 0.7015358042359555, 0.8022494255388053, 0.690965284658994, 0.7292609433614674, 0.7431917184966319, 0.7115247051399167, 0.7436550732987262, 0.6664076076992244, 0.5670889532441289, 0.681817668209391, 0.6371513567420168, 0.7706946591096204, 0.744981257219635, 0.7696724046450264, 0.6855290137111636, 0.7055114868619539, 0.7223267444065398, 0.5428368798081302, 0.6544403418852954, 0.6996300904528647, 0.7079179239862212, 0.7505223288595229, 0.7405868935697659, 0.7596386400010078, 0.6718496545126742, 0.7883959297742318, 0.7802594494489652, 0.7760167164538099, 0.7903203065372759, 0.6821463744879743, 0.7296461268032887, 0.8143268129671013, 0.7749687472016142, 0.6479752198957422, 0.13848145435339032, 0.49225202611279373, 0.6993621266380173, 0.2938771599969856, 0.6522779052178015, 0.605719417401304, 0.23695049277841884, 0.16641823148249424, 0.42751286318579995, 0.6173664031141962, 0.6811486026180069, 0.6645234701732108, 0.6828216000795947, 0.6784912900416786, 0.703437879849294, 0.6532509162980817, 0.598180061734467, 0.6656631696494895, 0.8691803503409193, 0.8694979305571637, 0.8601481602162058, 0.8760136416081716, 0.8578147643010359, 0.8758911534285573, 0.8748895201749489, 0.8684091947966298, 0.8695827051466036, 0.11338064089033417, 0.1420832620089867, 0.6089319193159917, 0.12834739687789476, 0.15265135951907993, 0.14306072774277978, 0.11940418040432921, 0.12142362504588378, 0.13637714041536297, 0.20777022277662283, 0.5749734407545679, 0.5581536732373078, 0.33936172639637185, 0.6918813475524521, 0.23484034243714436, 0.20571440438258448, 0.2764166133358881, 0.6113272441175821, 0.7104825141186643, 0.69371037206871, 0.7303391360998523, 0.7276051563951409, 0.7345139692041582, 0.6897765386089855, 0.6346872723169998, 0.7648796570153791, 0.7059248013681634, 0.619914784947931, 0.4521277257984029, 0.501229283511546, 0.5596329785145804, 0.544944987884484, 0.5886256777630539, 0.5109732218417653, 0.4012947143449179, 0.668685869085684, 0.21210189185306905, 0.20130112615067897, 0.23266752283938086, 0.23676314342489646, 0.21911915976045726, 0.23543570858769725, 0.22111998044704828, 0.21455746573868306, 0.222571670249895, 0.20742564809167674, 0.20803703537430007, 0.22229148673872046, 0.22187984739512667, 0.2073480679575117, 0.2102991618753598, 0.21978393678279295, 0.22274133203331103, 0.22045392867259717, 0.18616026403202723, 0.18743628446264915, 0.20024785566795544, 0.9113359688823153, 0.20085192422203546, 0.9252546864359943, 0.14219889363716554, 0.15824240464242811, 0.9274653387545533, 0.9168154637618023, 0.8567275142552591, 0.9248178384179595, 0.20898331357729572, 0.21078544967662216, 0.9068325909399394, 0.8806893426121103, 0.884194273624296, 0.9017129593279767, 0.18265360419371268, 0.19886080712605847, 0.1840452929475861, 0.20926728576373954, 0.19400991471802986, 0.18623762810343314, 0.20147910471276986, 0.17787286672363645, 0.19011030994385636, 0.11835210985097999, 0.11857001971995018, 0.08551422989816126, 0.08954399660557233, 0.08780990670555455, 0.09232648553139389, 0.0935451719207796, 0.09625914590293938, 0.0959026665930014]}, "mutation_prompt": null}
{"id": "df200518-509d-4216-a7bd-c7305838286b", "solution": "import numpy as np\n\nclass DynamicDEwithAdaptiveLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 4 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size * (1 + np.random.normal(0, self.learning_rate))\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicDEwithAdaptiveLearning", "description": "Dynamic Differential Evolution with Adaptive Learning Rates and Enhanced Local Search for Improved Convergence.", "configspace": "", "generation": 83, "fitness": 0.5195068868151191, "feedback": "The algorithm DynamicDEwithAdaptiveLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9132067915942135, 0.9147855585959801, 0.9154483538099295, 0.9087180363362284, 0.9048679259553458, 0.9231187628928051, 0.9137268713026727, 0.916626284250806, 0.919427549213703, 0.8242657702410683, 0.824443542958387, 0.8224873206465254, 0.8185352097104676, 0.8316878983816984, 0.844887672811721, 0.8297835606559228, 0.8219922377187112, 0.8321910336912617, 0.1655335168637646, 0.17302193434209145, 0.6097648371123513, 0.11889369114820891, 0.44165789935226096, 0.15041138608458515, 0.14812535062507015, 0.14553682318789962, 0.1594598739620302, 0.10611601049582498, 0.1542752021415298, 0.17758408691605387, 0.12722747482305696, 0.1384112839545889, 0.1572173222543124, 0.15540616907363858, 0.12846256603288675, 0.215553047821476, 0.9886678514695418, 0.9734784413116496, 0.9712058418192013, 0.9855350178775886, 0.9659262645913858, 0.9691315783449319, 0.9889358519788903, 0.9753178688154874, 0.9875963433023733, 0.7563107099444031, 0.7441113246301301, 0.7563541876570237, 0.765571563849865, 0.7713215798091159, 0.763973756202843, 0.7636745751095224, 0.7540441557980897, 0.7528004567097606, 0.8601581757652546, 0.855288529968665, 0.9087905296987538, 0.9140246406970653, 0.2138405654853638, 0.27958893892456504, 0.900611181322499, 0.8898021552843396, 0.914489902223947, 0.7567051378949372, 0.650547561750045, 0.7416673949669838, 0.688227883157499, 0.7685168241437614, 0.782953436191962, 0.13391913047139004, 0.1390610295927447, 0.13579344638956858, 0.13428914244669887, 0.631132517409084, 0.6681438761994518, 0.6019704776978618, 0.7517853736504572, 0.5996724170660128, 0.6293390888761768, 0.6815458564171599, 0.7350330691763185, 0.6880006618056488, 0.7055085256838285, 0.6915872791765829, 0.7107108572378911, 0.6066259010940446, 0.658366317113832, 0.7090242533280272, 0.7299577042373497, 0.652889783149656, 0.7496348888054538, 0.7459937172052388, 0.7709713214944516, 0.6962289924621843, 0.6857139127645451, 0.39410426949573696, 0.7737044627233775, 0.799872502566181, 0.7765079884924488, 0.13454831063328743, 0.15078008150665123, 0.2730921750189721, 0.579097935126422, 0.3532806357638383, 0.5928619878834425, 0.1507336487942661, 0.40595857305152017, 0.6846871924222886, 0.65937519282134, 0.6493227571376962, 0.6403678416812699, 0.6450324952297228, 0.6833809906951885, 0.6361796048307748, 0.6657021612573677, 0.6354268921818693, 0.5995816956060311, 0.8723316204338959, 0.8585701264537464, 0.856615177369309, 0.8492082866736592, 0.8632821559794079, 0.8642052119886751, 0.8734890707186865, 0.8688769746845333, 0.8767731043094482, 0.13356312380491253, 0.1266114271227069, 0.14517645054174355, 0.12083820838660309, 0.1568084716537429, 0.13419077727408169, 0.1399995112464517, 0.1308602829609865, 0.13776755631385929, 0.18400875424108787, 0.44730754581022625, 0.5755698564564555, 0.39368204431729537, 0.7015926063678413, 0.7105911825930009, 0.2659243050774096, 0.49230155856187585, 0.3020658959170649, 0.70063835745367, 0.6973500856421768, 0.5212479031574002, 0.7246916888424465, 0.6942987193738211, 0.7247938937352456, 0.7321153472809829, 0.6113697195773371, 0.29333934187271116, 0.25548550474120324, 0.5581421944180978, 0.6122044123518038, 0.515852800364835, 0.25571074889099377, 0.21532388664225377, 0.5544061404876971, 0.2398653653698335, 0.6489193639891271, 0.23489541937645753, 0.2253053340293547, 0.25578667673531075, 0.21928814250233575, 0.22388094773346268, 0.19152774706094322, 0.26535551479530717, 0.22160764947792333, 0.20535240378477382, 0.2222691230286108, 0.191271324545762, 0.19851529165667625, 0.20161707877535573, 0.21618264469209314, 0.2255560582899191, 0.21786952373808888, 0.2224665680225788, 0.20717656343381408, 0.18804413173235657, 0.19783497348213108, 0.1540738298298513, 0.9114168336563672, 0.19920281117645733, 0.19810848862207564, 0.9267328643382005, 0.16752983556740453, 0.9118129762461575, 0.9216199354566198, 0.21301107774213546, 0.8779599367570712, 0.21078824588470846, 0.21089063914354633, 0.884627621159931, 0.5870563002060778, 0.9039040240733149, 0.9058902186839222, 0.19583224248239517, 0.20104277606959864, 0.17606807602510421, 0.19883642746509977, 0.2010935931914105, 0.18517099407074777, 0.2061489934756915, 0.1940422869530285, 0.21721403762238356, 0.09519922181566909, 0.0904205937961926, 0.08883479227660696, 0.10172456095214133, 0.09031385109528434, 0.09589959258731706, 0.09183663267202624, 0.09709629955084798, 0.09378904354887507]}, "mutation_prompt": null}
{"id": "d32be55b-383b-4cc5-8a84-c21d342de0d5", "solution": "import numpy as np\n\nclass QuantumInspiredCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.quantum_superposition_strength = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.quantum_superposition(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def quantum_superposition(self, population):\n        for i in range(self.population_size):\n            superposition = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            population[i] = population[i] + self.quantum_superposition_strength * (superposition - population[i])\n            population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)", "name": "QuantumInspiredCoDE", "description": "Quantum-Inspired Adaptive CoDE with Enhanced Search Space Exploration using Quantum Superposition Principles for Diverse Solution Discovery.", "configspace": "", "generation": 84, "fitness": 0.5590768457208783, "feedback": "The algorithm QuantumInspiredCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.13279940716504302, 0.1492688282837995, 0.17648957497932172, 0.15668186460335598, 0.13570242628793616, 0.617196753638718, 0.1375942596416797, 0.17547458401533877, 0.1381635242411714, 0.11896328538233902, 0.1272374413703805, 0.13398979555132406, 0.14874280172768917, 0.12753402329668884, 0.14713352640421984, 0.1341765874822295, 0.11219389597349871, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6768124044928846, 0.6364677100749887, 0.6521455257203934, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.10839248883052077, 0.14735438663590705, 0.17190016580079515, 0.10295122101149279, 0.13335029484029493, 0.1572072954659266, 0.1340491807462746, 0.12197132087022367, 0.14089908519288474, 0.6847240630975421, 0.8064795999398799, 0.331674070964065, 0.309140269525392, 0.1695391852026058, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.5743029074684284, 0.5850901459250701, 0.6324394410874461, 0.599885621698617, 0.6083717232345855, 0.5928215812622502, 0.5460421137180939, 0.6550853264200598, 0.6077645055120594, 0.5453987778646231, 0.5127348402391236, 0.5333598173019557, 0.5738117166550779, 0.2594499454960548, 0.4759325878110229, 0.5711557234510447, 0.5661542101761468, 0.5682486953923783, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.2044381049549534, 0.24954120676303093, 0.20893550777284375, 0.7127353020253682, 0.2021489996104998, 0.2207334733589289, 0.20164636749707932, 0.7843193504840147, 0.2427273571261137, 0.18651505573820382, 0.18745256278976508, 0.2003050418028819, 0.9151272172316909, 0.20079593464500722, 0.920504483371455, 0.9091934308991853, 0.15783294821228233, 0.9313882926224516, 0.9108915658636829, 0.21103743357480165, 0.9241725503416365, 0.20897100887536613, 0.21079014528087314, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "2b47aa09-9b15-421a-9ed8-f692629ada20", "solution": "import numpy as np\n\nclass HybridDynamicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.dynamic_population = False\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            if self.dynamic_population and evaluations % 50 == 0:  # Dynamically adjust population size\n                self.population_size = min(self.population_size + 1, 50 + self.dim * 10)\n                if np.random.rand() < 0.2:\n                    population = np.append(population, [np.random.uniform(self.lower_bound, self.upper_bound, self.dim)], axis=0)\n                    fitness = np.append(fitness, func(population[-1]))\n                    evaluations += 1\n\n            for i in range(len(population)):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(len(population), 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(len(population), 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * len(population)))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(len(population), 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(len(population), size=int(0.2 * len(population)), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "HybridDynamicDE", "description": "Hybrid Differential Evolution with Dynamic Population and Adaptive Local Search for Enhanced Convergence.", "configspace": "", "generation": 85, "fitness": 0.5659799771222236, "feedback": "The algorithm HybridDynamicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.13082243391408332, 0.14926882832655353, 0.4871502730920929, 0.1566818646751459, 0.13570242631640106, 0.617196753638718, 0.1434970705283406, 0.17547458408710936, 0.13928315457245588, 0.1189632854231788, 0.13000621709587412, 0.13249475508348774, 0.14874280185365985, 0.12753402335912323, 0.14136619935343897, 0.13437263489837425, 0.13224867351621183, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6838500505938747, 0.6374214476331126, 0.6777146197687898, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.10839248883327424, 0.14735438667347678, 0.17190016584136014, 0.10295122102213972, 0.13335029487955397, 0.15720729559937097, 0.13404918076899575, 0.12197132087737994, 0.14089908522209627, 0.6847240630975421, 0.8064795999398799, 0.33169013459262564, 0.30914131438775505, 0.16953977388728259, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.7034778980630669, 0.7097195853213218, 0.7274573919572764, 0.7146626855679129, 0.6997498948705058, 0.6792506696181246, 0.5455138719437629, 0.759666167706329, 0.6360804614621964, 0.5546263845368586, 0.5628789544136292, 0.5889206638705538, 0.5923266609197938, 0.2594499454960548, 0.47691450874840047, 0.6778095954785703, 0.5714513874489102, 0.6741277609996407, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496757575, 0.24954120677673663, 0.2089355077776709, 0.7127353020253682, 0.20214899961642407, 0.2207334733772448, 0.20164636749791687, 0.7843193504840147, 0.2427273571520273, 0.18651505573874283, 0.18745256279014155, 0.20030504180354325, 0.9151272172316909, 0.20079593464574463, 0.920504483371455, 0.9091934308991853, 0.15783294821268368, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559195, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "a0e39906-8c15-4895-9191-c49e2a0817f2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.dynamic_diversity_factor = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            current_diversity = self.calculate_diversity(population)\n            if current_diversity < self.diversity_threshold:\n                self.reinitialize_population(population)\n            else:\n                self.dynamic_diversity_factor = min(1.0, self.dynamic_diversity_factor * 1.1)\n\n            if np.random.rand() < self.dynamic_diversity_factor:\n                self.dynamic_selection(population, fitness)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n    \n    def dynamic_selection(self, population, fitness):\n        worst_indices = np.argsort(fitness)[-int(0.1 * self.population_size):]\n        for idx in worst_indices:\n            if np.random.rand() < 0.5:\n                population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "EnhancedAdaptiveCoDE with Dynamic Diversity-Based Selection and Adaptive Local Refinement.", "configspace": "", "generation": 86, "fitness": 0.5170202333860776, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9117819820276211, 0.9179379940073581, 0.9183845041193296, 0.908633800144417, 0.9116213399658719, 0.9137951663239365, 0.9131119552145215, 0.9136585502230021, 0.9182827753187914, 0.8302451372019338, 0.8196474468891275, 0.8357641143917847, 0.829210476354681, 0.8255569741537826, 0.8294142404266437, 0.8261291758875766, 0.8274128617589673, 0.8349367776582691, 0.16884262261602057, 0.13075144918568748, 0.1773265768135901, 0.16457999454266103, 0.14330329969693134, 0.16813626266098525, 0.17327932004677782, 0.1371771766072889, 0.7543007722145223, 0.1337823244004408, 0.1035061734200261, 0.13871440098839505, 0.1127321827073069, 0.11585710737711274, 0.12514085203731118, 0.1487557711943147, 0.13237490188834267, 0.12332731845176037, 0.984589658969341, 0.9883507182031519, 0.9870081417371372, 0.9631609865280284, 0.9692284674225856, 0.9765303615707681, 0.9696514595592767, 0.9578477217883047, 0.9816785182589158, 0.737012745904122, 0.7470489137840538, 0.7569139009842827, 0.7449861168600082, 0.7226770270074205, 0.7354636869269049, 0.7448051840642571, 0.739532672827806, 0.7584199193226863, 0.8762518215953198, 0.9252753768983664, 0.8792983544638155, 0.8911949710642895, 0.21356729531218932, 0.913492129674579, 0.9150175139498501, 0.9120995791635974, 0.9060824196952079, 0.25201551705740177, 0.6638400464910609, 0.6708534461010325, 0.6704211713378081, 0.6522598572037639, 0.41144145020683087, 0.6702219362102332, 0.6654517919401961, 0.6595904335736995, 0.6303545854932291, 0.6360573211252216, 0.13463310640425719, 0.645951398425203, 0.6984289083331413, 0.678329532244067, 0.6374766063108213, 0.7313848151054332, 0.6810910845229554, 0.7281473499502216, 0.6896988942339655, 0.517676679647713, 0.6878469355397232, 0.6486677650077259, 0.7168277985949, 0.7333598426425232, 0.6847608239093271, 0.5271866435982697, 0.7697774357318602, 0.7508875005411758, 0.7328303677188047, 0.754183598508007, 0.7343472646913421, 0.7645478425677266, 0.7739464277579409, 0.7579713915876339, 0.7512075317809837, 0.11625623767631821, 0.1148839515927399, 0.5394911642828237, 0.3671246745543978, 0.517088811908866, 0.28315350378523363, 0.2752177599923764, 0.1814532779194391, 0.32821428442952016, 0.6543797472859282, 0.6646351989181636, 0.663822498461025, 0.6618607730942362, 0.6370718696093969, 0.6790737697893037, 0.619327496816622, 0.6481029822492036, 0.6645136510022052, 0.8337551399445571, 0.856885238783337, 0.8695084783046283, 0.8704155087430531, 0.8543627596087437, 0.8531998540928705, 0.871159908795716, 0.8518508664872522, 0.8589150333685973, 0.12356697510933567, 0.13614997864157252, 0.12249041924545745, 0.12613331839786057, 0.12570618692016977, 0.15066435351503715, 0.1477038326611111, 0.07954123570516913, 0.1294524616704652, 0.16450281482273876, 0.21066582973495585, 0.5899288866232566, 0.2523751031031968, 0.549545135849338, 0.17585645714079112, 0.5368490789720839, 0.23363377754618686, 0.23194388480209638, 0.5246022558643562, 0.7198558238963185, 0.6210424086605443, 0.5370857509776374, 0.625803464491431, 0.6924296787523938, 0.5629731534905722, 0.5715947231741871, 0.6019016418840867, 0.41545765991074946, 0.439987204918981, 0.3533780603795261, 0.5872901281671001, 0.31981021057218795, 0.6103878237652606, 0.26936547457029947, 0.5451265101734956, 0.5634152136006633, 0.19962356669089443, 0.2060288917219878, 0.2058692351032423, 0.191417538363431, 0.21605641362566397, 0.2170319827984668, 0.19793839508830868, 0.20035865049390955, 0.21896086178324436, 0.20351373827944375, 0.21179459674639867, 0.7249439610965616, 0.7971397980146544, 0.2181281693768352, 0.20862388017776734, 0.20360198568025567, 0.7869461640512886, 0.22807163289751387, 0.18515379712072577, 0.15739299146292474, 0.20025236966986903, 0.9183988008976518, 0.19995185084050415, 0.16313082232392884, 0.15741506514775905, 0.37527092436256193, 0.9187544682134475, 0.9080373605482043, 0.2118757752353705, 0.8921245332249003, 0.565844405422713, 0.21030011293233786, 0.8247991761634301, 0.16561314362779755, 0.398511727223381, 0.9343729485608804, 0.19311529378267922, 0.19555093297323622, 0.21624881236183968, 0.219172978027815, 0.19855592260389754, 0.2006908278534968, 0.1860736892311421, 0.17229353828667737, 0.21192507923112336, 0.08432512395289049, 0.09622943616673751, 0.09337780507708482, 0.09061222916454703, 0.09329638536469997, 0.09278270414703838, 0.09500582877644426, 0.09150951800636542, 0.09013866766005196]}, "mutation_prompt": null}
{"id": "a9a7f5e6-7cd5-41cf-a4a9-e20965f168d2", "solution": "import numpy as np\n\nclass AdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.2\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.F_adaptation_rate = 0.05\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.F = min(1.0, self.F + self.F_adaptation_rate * (0.1 if adaptation_counter < 5 else -0.1))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "AdaptiveCoDE", "description": "Adaptive CoDE with Adaptive Parameter Control and Enhanced Local Search for Improved Convergence.", "configspace": "", "generation": 87, "fitness": 0.4813975496339907, "feedback": "The algorithm AdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.908428092873388, 0.9148793343313426, 0.9122704399607723, 0.908570683811621, 0.9076686906743504, 0.9162341397964917, 0.9072412492228183, 0.9163703088402635, 0.9124708636295695, 0.8311120580017187, 0.839777077388782, 0.8397461552159898, 0.8297196220601568, 0.8408046970503117, 0.8415210803925246, 0.7969423997898445, 0.8448843130708332, 0.8335443780054684, 0.14548286685707512, 0.45349607183672846, 0.14325037746736557, 0.17400051438053166, 0.17651269067396935, 0.15320791264998312, 0.17842762140517265, 0.15461085533996577, 0.6865058746000599, 0.1278623686540995, 0.11273873550606517, 0.12056396457636309, 0.15758919813892514, 0.1097391392028092, 0.13280440781177927, 0.14677080364367157, 0.13520055398008157, 0.15294800367661443, 0.9785982727895249, 0.982895894640517, 0.9735758300168071, 0.9855988389290297, 0.9775035027301773, 0.969999415568594, 0.9718867653232284, 0.970167928123816, 0.9787619791396751, 0.7748140865530642, 0.7877275345372364, 0.7585047653500083, 0.7827581073157532, 0.7821990265849526, 0.820884530926393, 0.7182496475493007, 0.8030599823400338, 0.7831761893566634, 0.9140594669249142, 0.391257496929147, 0.8900633613554889, 0.9122329034119737, 0.2790039433574414, 0.2788587200056801, 0.9040075886513698, 0.23626988414507677, 0.9217679631651106, 0.7381891443908906, 0.699254067924639, 0.6408759245251229, 0.6457953614569139, 0.6267759472976484, 0.13287991824820167, 0.7014397170329285, 0.6727164872592822, 0.6865505026162995, 0.6975777772996368, 0.6951930354186431, 0.6915032074243781, 0.6501701338237775, 0.7854070762496782, 0.6394077553700499, 0.13200208561595828, 0.6685733765256476, 0.7151613402108788, 0.21670065964691254, 0.3078686155805499, 0.5319989980875437, 0.16889583603861125, 0.17818601267616263, 0.7364161667723008, 0.7308487147761848, 0.6024571783054369, 0.7352088769863006, 0.6913922468419835, 0.7001435323290088, 0.7856072632233049, 0.13149954118055307, 0.6923857167107932, 0.6627290494273431, 0.7540235139335596, 0.2409818182803991, 0.8018822971448121, 0.416518605929485, 0.2920074434038109, 0.24242705245941554, 0.36270152030506575, 0.4516511043601765, 0.3674710463174061, 0.12887315645167674, 0.16516115057932734, 0.21953646744519506, 0.4033130344622555, 0.4166385757178046, 0.631891051338068, 0.43448811856458913, 0.33508637247973005, 0.4036147340706706, 0.5536424929335275, 0.4346013849390016, 0.39108813479971827, 0.8664941169165582, 0.8675252386036848, 0.8624864699237932, 0.7888333004644728, 0.8299961756588708, 0.7480879329104024, 0.8534594770383798, 0.8070118017719923, 0.7637451182122391, 0.14942622474479017, 0.1203868549990118, 0.12175062219620636, 0.15470909018750223, 0.77480182354959, 0.7366935446696744, 0.11939244324849374, 0.15619811823904906, 0.12560725266333106, 0.18752494492452176, 0.4459503399620893, 0.2250274332580552, 0.2169181955861571, 0.26603029390327715, 0.14916791917703598, 0.4581763898114104, 0.2652949580593714, 0.2451704461359332, 0.4687377605285046, 0.5012105626021919, 0.4787711156437774, 0.578374603695027, 0.6116739351035568, 0.6556826317574325, 0.5164825295408877, 0.4496583774020527, 0.5487862070198433, 0.4483600043757153, 0.3543786398412514, 0.3408341605746762, 0.26796256092487514, 0.3898886495517181, 0.3639967791976001, 0.40112282263289045, 0.36379323419828047, 0.37887154878154783, 0.22742874137165825, 0.22942447261837184, 0.2327332427899702, 0.2060848464679872, 0.26393247867875635, 0.2739214890698852, 0.24133973152502564, 0.2629043355761195, 0.2452846602662746, 0.20463037981789411, 0.24562581220689195, 0.19190234780925808, 0.190139171079155, 0.18988888021291572, 0.19886411102767398, 0.21987712369814916, 0.19255153441602502, 0.2051092800426787, 0.18558104363142536, 0.18674088786786414, 0.14770591558484703, 0.9330870674302623, 0.19994308897344237, 0.9136360671299456, 0.1870904975367692, 0.16854497726813644, 0.17062255840212492, 0.9020774469544035, 0.21259967551603243, 0.9036448044125767, 0.8867392950759495, 0.2121603871183868, 0.8886920159199312, 0.15593624610118406, 0.1044441199766174, 0.909983380291121, 0.20660944617381627, 0.2005686248187657, 0.20408914768964792, 0.22077589002075793, 0.23882737857237613, 0.23422299188500828, 0.2267158457977464, 0.22805894165687912, 0.23560093478247002, 0.10871608155990597, 0.14714799870395434, 0.1557488142468466, 0.12345377605678709, 0.10715949638126243, 0.1035984545234081, 0.1054754643933149, 0.09344191615809394, 0.09514324003975982]}, "mutation_prompt": null}
{"id": "75e70726-8a12-40fd-8c36-89885b2f2b26", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.quantum_initialization()\n\n    def quantum_initialization(self):\n        # Quantum superposition-based population initialization\n        self.population = (np.random.rand(self.population_size, self.dim) * 2 - 1) * (self.upper_bound - self.lower_bound) / 2\n\n    def __call__(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        best_idx = np.argmin(fitness)\n        best_individual = self.population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(self.population, best_individual, i, fitness)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(self.population) < self.diversity_threshold:\n                self.iterative_diversity_boost(self.population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def iterative_diversity_boost(self, population):\n        # Boosts diversity iteratively by randomly perturbing a portion of the population\n        indices_to_boost = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n        for idx in indices_to_boost:\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n            population[idx] = np.clip(population[idx] + perturbation, self.lower_bound, self.upper_bound)", "name": "QuantumInspiredAdaptiveCoDE", "description": "Quantum-Inspired Adaptive CoDE introduces quantum superposition-based initialization and an iterative diversity boost mechanism for enhanced exploration.", "configspace": "", "generation": 88, "fitness": 0.5642420187792999, "feedback": "The algorithm QuantumInspiredAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9105798302263084, 0.9141054614874764, 0.9243878926844054, 0.9135191115308045, 0.9078221156586693, 0.9220870599626664, 0.919213133027396, 0.9089525020351529, 0.9161959928004061, 0.8301911331561247, 0.8144505960183047, 0.8365161619424567, 0.8209216459958543, 0.8299764493102356, 0.8480575659485987, 0.8322304646565688, 0.8397772623793783, 0.8340455748810017, 0.5771411812616585, 0.13497664058908487, 0.16291045703118756, 0.17648957515839303, 0.15668186467622147, 0.15027370721142763, 0.6171967536366152, 0.1375942596709323, 0.1754745840862093, 0.1347467710458835, 0.13625724714993737, 0.1341758099322462, 0.13774657815827518, 0.16168084431460372, 0.12753402335920416, 0.15289746400096138, 0.13417658752693318, 0.11892341629935177, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640690491, 0.7938965047996775, 0.7401365364682045, 0.7747890158094339, 0.7905944618041643, 0.7747505656234089, 0.793066190126179, 0.7671695033336258, 0.7953118874271008, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273162, 0.8196916268584283, 0.7158481821310111, 0.6827654306121018, 0.71705987938937, 0.7417145331212509, 0.6962882741210412, 0.6781859122638947, 0.7566522423822795, 0.7357742358207608, 0.5286137577020384, 0.6784826379649731, 0.8023174503321369, 0.7773124623874879, 0.6637054952790935, 0.6929230238760222, 0.6708095409485344, 0.7746810905800096, 0.7259150805104032, 0.7023440876189727, 0.6500216671590413, 0.7119129209015124, 0.616638337573363, 0.711099432129517, 0.7400375748142625, 0.6780015466916449, 0.7257360655690821, 0.8089674282247906, 0.7507515598521647, 0.7853658121054199, 0.41308714208402875, 0.7711855398017746, 0.7582508403769819, 0.8202996577801867, 0.77967159136626, 0.7463883051783637, 0.3423085961633392, 0.38691131757454345, 0.5563813985740613, 0.6428654498600813, 0.6783384181670904, 0.5279311426805606, 0.1919957277287161, 0.18071472344821193, 0.19336631291465933, 0.6838791527397323, 0.6374148705233484, 0.6829420209912747, 0.7119003802576718, 0.6805595455309715, 0.6812042555846841, 0.6795807844214452, 0.6829131452965191, 0.6753800179179517, 0.8624903184738975, 0.8756732221693699, 0.8742072805753371, 0.8775039685189805, 0.8816951625569918, 0.8695963432714708, 0.8904207267572231, 0.8816208413542588, 0.8722996962421604, 0.10839248883338493, 0.14735438667273648, 0.17190016584027812, 0.1029512210219673, 0.13335029487868122, 0.15720729559867397, 0.1340491807698656, 0.12197132087736118, 0.14089908522244132, 0.6847240630981868, 0.8064795999399474, 0.33169012258367203, 0.3091412990628718, 0.16953977143217802, 0.42020581881857066, 0.464206584034198, 0.788733197564384, 0.6293798853376993, 0.6106536052340186, 0.7134946132852856, 0.7204118100946719, 0.7067066167947202, 0.6956901688108905, 0.6837132466351576, 0.5455058717433587, 0.7601125495538958, 0.6349747039663375, 0.5548418651367975, 0.5632202810355524, 0.5723118601571557, 0.5916968187100764, 0.25944994551425005, 0.4769071510713536, 0.6708420446584686, 0.5713393047481428, 0.6726328091009416, 0.22330643476674972, 0.23607339650927273, 0.23320110638282643, 0.23001428188186424, 0.21788431344224723, 0.19755015912710883, 0.21290987927437655, 0.21619732749063492, 0.21608816623847993, 0.20443810496733528, 0.24954120677688163, 0.20893550777752445, 0.7127353020429423, 0.20214899961610777, 0.22073347337693516, 0.20164636749788767, 0.7843193504863357, 0.24272735715199978, 0.18651505573874017, 0.18745256279012967, 0.20030504180353337, 0.9151272172316923, 0.2007959346457444, 0.920504483371455, 0.9091934308991838, 0.15783294821265803, 0.9313882926224516, 0.9108915658636835, 0.21103743357524174, 0.9241725503416369, 0.20897100887559072, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410688, 0.19247028814135525, 0.20455412310516308, 0.18955948632615272, 0.20926728576373954, 0.18794618065823143, 0.17800173671556274, 0.21406032978105338, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789477216, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "759d38ff-d25f-4d3b-af8f-9f38f877221e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20 + dim * 5\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.CR = 0.8 + 0.2 * np.random.rand()  # Adaptive crossover rate\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n            # Dynamic population resizing\n            if adaptation_counter > 10:\n                self.population_size = max(self.initial_population_size, int(self.population_size * 0.9))\n            else:\n                self.population_size = min(self.initial_population_size * 2, int(self.population_size * 1.1))\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDEPlus", "description": "EnhancedAdaptiveCoDEPlus introduces adaptive crossover rates and dynamic population resizing for improved exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 45').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 45')", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {}, "mutation_prompt": null}
{"id": "4fb08988-277f-46f2-a8b0-8661ee3169a5", "solution": "import numpy as np\n\nclass AdaptiveCoDEWithHierarchicalMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.05:\n                    strategy = self.mutation_hierarchical(population, best_individual, i, fitness)\n                else:\n                    strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_hierarchical(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        top_half_idx = sorted_indices[:self.population_size // 2]\n        a, b = population[np.random.choice(top_half_idx, 2, replace=False)]\n        mutant = a + self.F * (b - best_individual)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "AdaptiveCoDEWithHierarchicalMutation", "description": "Adaptive CoDE with Hierarchical Mutation Strategy for Enhanced Exploration and Convergence.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.ndarray' object is not callable\").", "error": "TypeError(\"'numpy.ndarray' object is not callable\")", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {}, "mutation_prompt": null}
{"id": "a6fe9071-d22e-4aa2-a8f7-303142deb495", "solution": "import numpy as np\n\nclass DynamicAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.exploration_weight = 0.7  # New parameter for dynamic adaptation\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n            self.exploration_weight = max(0.3, min(0.9, self.exploration_weight * 0.99))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.exploration_weight * self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "DynamicAdaptiveCoDE", "description": "Dynamic Adaptive CoDE with Self-Adjusting Strategies for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 91, "fitness": 0.4996891972047194, "feedback": "The algorithm DynamicAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.925187255443209, 0.9258661009150534, 0.9301447615690889, 0.9245275940598713, 0.9245334817905098, 0.9325591916902553, 0.9317125738250689, 0.9232331294371937, 0.9297755395339224, 0.8478995542527937, 0.862784588033529, 0.8584568159657778, 0.843830311822769, 0.8535972005660835, 0.8441133731687016, 0.8334553552091294, 0.8346395352938167, 0.846449909875364, 0.13805697781949422, 0.17259407879587674, 0.15741628192265744, 0.15753141596818954, 0.14957984206092134, 0.15028196286176554, 0.17363759654676014, 0.14636567815754065, 0.12697341149441166, 0.12055382662099179, 0.13494362684882777, 0.10506894393656985, 0.1337095683168349, 0.11541552811740252, 0.108498014561633, 0.11451306803522188, 0.1567158482341594, 0.12890269200545712, 0.9891072282453949, 0.9912833447207536, 0.9890632322721931, 0.9819447351301717, 0.9531358169152346, 0.9592771965553716, 0.9561411391436039, 0.9808379991568347, 0.9872682970774411, 0.8290132200893967, 0.8322655940021334, 0.8051447329975409, 0.8302713714355225, 0.8117280973606038, 0.7928190128991146, 0.8257450619288697, 0.8177684860567814, 0.8036507530676813, 0.874826632044495, 0.396361530035488, 0.9189285564618783, 0.9337222246713119, 0.9229748446583858, 0.9372563550768599, 0.9267633288408935, 0.17852228401887382, 0.9324947307662059, 0.6460613327973209, 0.7311110657645614, 0.6632667336537024, 0.27269968472083495, 0.7745690192317647, 0.73715853607124, 0.7348915120346404, 0.1321905217946605, 0.7429182146446778, 0.7160420506622465, 0.13514292880334255, 0.6249703020613186, 0.7141797266789696, 0.7080071523008856, 0.8041684665516697, 0.7119721877799707, 0.6982812418174786, 0.6621804319045106, 0.7254498745102649, 0.76811641525717, 0.18889070046223078, 0.6897522756300684, 0.13086796892769292, 0.7571849357676287, 0.24442749354681537, 0.6830138210263266, 0.3792037854153204, 0.770693750097226, 0.3385759383531175, 0.780908255528407, 0.25572491163040345, 0.7745993586959983, 0.36860273460179194, 0.8404205217370664, 0.8222641008073216, 0.7860532715597691, 0.39102689000683066, 0.30454220113315456, 0.35661139631790306, 0.6650796908329173, 0.43400838848736567, 0.49579486442402854, 0.29282588463623804, 0.36428313313584026, 0.37086206159486423, 0.61808513154579, 0.5336448018034384, 0.645330954480599, 0.742340445576108, 0.6448522602056657, 0.32203229867886385, 0.5708591587567513, 0.5282402389005566, 0.3768236426164854, 0.8754384555481074, 0.8869353088400761, 0.8659627829503106, 0.8901350265132364, 0.8819955535057705, 0.8309482986432347, 0.8249102544327415, 0.8834701910421567, 0.9021828023323054, 0.1256076815754814, 0.1503959878519059, 0.16652606842363749, 0.14888078442558095, 0.12617160570977137, 0.15838328503584942, 0.12953914800267552, 0.13859417777003913, 0.12389772665904908, 0.5575368544426703, 0.2569469077587264, 0.1958561329359979, 0.29676883443464963, 0.38180291699171676, 0.21667556444805303, 0.2684488987503094, 0.4676460356569384, 0.27083324160210187, 0.547772235225751, 0.31085799968449424, 0.29381380344054564, 0.614572901485298, 0.630025877605137, 0.7659361147727503, 0.5530563622102473, 0.7285860870454638, 0.6207528584604924, 0.38911612207543655, 0.3301303648331183, 0.3314312624552753, 0.4945542788480949, 0.567094623379694, 0.3456369561652518, 0.6101460334674611, 0.5588867551579634, 0.7139845411711969, 0.2597526864024877, 0.20674288957608655, 0.23244535989996806, 0.20355856392538163, 0.22203784504307622, 0.2042488390859829, 0.19932993690240908, 0.2270901091656944, 0.24418110981684038, 0.19651597601982818, 0.17360698166832478, 0.18418269006557753, 0.2103640466278902, 0.2147325523467043, 0.22070354461599195, 0.2047026734486017, 0.24316694559469265, 0.7243825901364895, 0.17663425309609737, 0.1865713156151677, 0.14865882247876583, 0.9152232793715873, 0.2005199378659519, 0.2002480570248275, 0.14214764082503972, 0.15824236471734243, 0.9387892255203192, 0.9346091709696999, 0.21251718998505276, 0.8776320470202112, 0.3767506849398503, 0.21106856396910578, 0.8867975234150922, 0.16778091699893594, 0.10507025699920536, 0.9238164825211518, 0.18123395618710114, 0.18256457700415318, 0.18218941780929765, 0.22454945902827206, 0.18598972312846695, 0.18546438529714337, 0.1937197012412335, 0.19902281371814912, 0.18427581711872631, 0.09116607731062576, 0.08600963220702906, 0.09753600425826625, 0.08956751984082423, 0.09059684997453299, 0.09841695472264889, 0.1040513455965193, 0.10482786043036918, 0.09437061755613774]}, "mutation_prompt": null}
{"id": "48d87651-4db0-4686-b1b3-ce602de730df", "solution": "import numpy as np\n\nclass HybridizedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.15\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.stochastic_tunneling_factor = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if np.random.rand() < np.exp(self.stochastic_tunneling_factor * (fitness[i] - trial_fitness)):\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n                        if trial_fitness < best_fitness:\n                            best_individual = trial\n                            best_fitness = trial_fitness\n                            adaptation_counter = 0\n                        else:\n                            adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "HybridizedAdaptiveCoDE", "description": "Hybridized Adaptive CoDE with Stochastic Tunneling and Diversity-Inspired Reinitialization to Enhance Global Search.", "configspace": "", "generation": 92, "fitness": 0.5324486609820741, "feedback": "The algorithm HybridizedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.912063922875067, 0.9172306440750458, 0.9039496069129405, 0.9183536745284041, 0.9078880350421707, 0.9017318501904303, 0.9180872808495081, 0.9028348066609814, 0.9169926677393563, 0.8385766429092132, 0.8293223158035445, 0.8349967930401968, 0.8427528878360829, 0.8293126623665794, 0.8296268983064616, 0.845085901959671, 0.8352218963841138, 0.8282706515360007, 0.1399642585356874, 0.15889402095043448, 0.159694512484157, 0.6332367401216772, 0.14593015791034303, 0.15086727663247634, 0.5355976836558088, 0.1485682624918503, 0.17169717206034507, 0.14309646495131823, 0.1213498991527967, 0.10545991513591546, 0.16821721989837202, 0.11964664172357131, 0.11728446391055569, 0.116965552232281, 0.11491238308755325, 0.11115293019400108, 0.9822075399435115, 0.9561370576886378, 0.98374742772431, 0.9881552017462536, 0.9737285944715, 0.9738307544054081, 0.9280140007685724, 0.9747509202441171, 0.9716741668953566, 0.7675453259037575, 0.7337597240589202, 0.760459008532226, 0.7644052869711834, 0.7438311348410801, 0.7712996047875795, 0.7743054070848961, 0.7430560330088158, 0.7567250656216573, 0.8960437452994807, 0.9168339252033512, 0.8979647719877035, 0.9077808349302252, 0.8981693642850328, 0.9182162792993059, 0.8882503219654454, 0.8948314491611253, 0.8910623523475981, 0.6998633039780138, 0.6590310558379449, 0.6402278711291197, 0.6673863801824201, 0.6721162911569174, 0.7110818639573926, 0.7410421220274988, 0.7476321282679779, 0.8033781631267902, 0.6302590604858846, 0.7441560476054696, 0.6564306551651499, 0.6981744384976859, 0.6141951135187893, 0.5991185424236616, 0.8060518514949033, 0.6828606863968255, 0.7790418961878389, 0.6435375824564933, 0.6453290734877088, 0.6563201980724472, 0.6997018083126668, 0.6386650245535748, 0.624667033374082, 0.7358849537510266, 0.6451095445877919, 0.6516371871959594, 0.7919528815588782, 0.7606165289459654, 0.7664444255072871, 0.43571334494954794, 0.732206930326003, 0.7589781801262606, 0.8024949150723194, 0.8005671594698867, 0.7776519766498837, 0.12004461848828107, 0.22731240314044776, 0.4637564783468069, 0.6280471352159908, 0.6491879218639358, 0.25589928459558864, 0.3998931265090925, 0.21893144088649086, 0.3261188414771131, 0.6498966982679553, 0.6694947530984022, 0.6602070344379624, 0.6591473121727434, 0.6945496468490806, 0.6528586552268425, 0.5704562343551155, 0.6485013142119436, 0.606916758565063, 0.8680552722460038, 0.8647476105539411, 0.8635177777854585, 0.8679239310412584, 0.8652958132564387, 0.8730128591125158, 0.8714497829078478, 0.8737164813499004, 0.864911028347578, 0.11077424703803518, 0.1127252886418808, 0.12130994648264537, 0.14013298611284786, 0.12278810589900435, 0.15667813903660333, 0.13711897150683072, 0.11978458449533269, 0.13225458504071863, 0.5735969267168972, 0.2023027469850609, 0.3893512017341797, 0.6127657780082661, 0.6172809577722843, 0.6279677019110728, 0.31331378475159055, 0.28652955063544105, 0.47494400236711276, 0.7147794060157853, 0.5737768028502983, 0.691782266601963, 0.6202905221658285, 0.701948793596472, 0.6919924440020168, 0.7299005665772356, 0.7299834152502218, 0.7387757156089085, 0.5764329281476235, 0.4967368161928951, 0.5611104407308805, 0.345668904773615, 0.6006109126868306, 0.526242612121508, 0.46872259433001084, 0.5084355033747476, 0.4985308651899377, 0.23289979741217914, 0.20889394734551137, 0.23300167048390918, 0.22206366124973242, 0.2090795098978807, 0.2104967764444461, 0.24120758444779267, 0.23438091564392682, 0.2533871951656175, 0.22413312256435736, 0.20188541211221334, 0.20450761784302285, 0.19730906244689372, 0.24851501991793645, 0.19011283467802442, 0.18854887406537058, 0.23727978164037, 0.21887753171996815, 0.25705835859682125, 0.1648441896005416, 0.15311334961586143, 0.9281212082806146, 0.20019542340905994, 0.19940029787153357, 0.1861638581852817, 0.1679259221042979, 0.21212252291434985, 0.9053043837934764, 0.2127216090607058, 0.9028289411584013, 0.9132397840413913, 0.11253541602346795, 0.8781211816443849, 0.2121521911478269, 0.20885634519531548, 0.8687407387663435, 0.19151569980427985, 0.1947141554523233, 0.18081718606539254, 0.17807540595785942, 0.19845882427490524, 0.20351733354934565, 0.20695940405900015, 0.1945017669411282, 0.18400261325826872, 0.089118875826247, 0.08811142433135499, 0.09175326017723529, 0.09264332448890178, 0.10509094583736933, 0.08765003062644627, 0.09774584885189519, 0.09758042487808449, 0.09429076843671469]}, "mutation_prompt": null}
{"id": "101ccc7b-83f3-4c4a-8657-303afe063a61", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.diversity_reintroduction_rate = 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reintroduce_diversity(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reintroduce_diversity(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(self.diversity_reintroduction_rate * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDEPlus", "description": "EnhancedAdaptiveCoDE+ with Strategic Diversity Reintroduction and Adaptive Parameter Controls for Improved Convergence.", "configspace": "", "generation": 93, "fitness": 0.5659799771222236, "feedback": "The algorithm EnhancedAdaptiveCoDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.13082243391408332, 0.14926882832655353, 0.4871502730920929, 0.1566818646751459, 0.13570242631640106, 0.617196753638718, 0.1434970705283406, 0.17547458408710936, 0.13928315457245588, 0.1189632854231788, 0.13000621709587412, 0.13249475508348774, 0.14874280185365985, 0.12753402335912323, 0.14136619935343897, 0.13437263489837425, 0.13224867351621183, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6838500505938747, 0.6374214476331126, 0.6777146197687898, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.10839248883327424, 0.14735438667347678, 0.17190016584136014, 0.10295122102213972, 0.13335029487955397, 0.15720729559937097, 0.13404918076899575, 0.12197132087737994, 0.14089908522209627, 0.6847240630975421, 0.8064795999398799, 0.33169013459262564, 0.30914131438775505, 0.16953977388728259, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.7034778980630669, 0.7097195853213218, 0.7274573919572764, 0.7146626855679129, 0.6997498948705058, 0.6792506696181246, 0.5455138719437629, 0.759666167706329, 0.6360804614621964, 0.5546263845368586, 0.5628789544136292, 0.5889206638705538, 0.5923266609197938, 0.2594499454960548, 0.47691450874840047, 0.6778095954785703, 0.5714513874489102, 0.6741277609996407, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496757575, 0.24954120677673663, 0.2089355077776709, 0.7127353020253682, 0.20214899961642407, 0.2207334733772448, 0.20164636749791687, 0.7843193504840147, 0.2427273571520273, 0.18651505573874283, 0.18745256279014155, 0.20030504180354325, 0.9151272172316909, 0.20079593464574463, 0.920504483371455, 0.9091934308991853, 0.15783294821268368, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559195, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "8c8b1a77-2288-4552-97be-803bf339932e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.12\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.crossover_probability_decay = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.1 if adaptation_counter < 5 else 0.9))\n            self.CR = max(0.1, self.CR * self.crossover_probability_decay)\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDEPlus", "description": "Enhanced CoDE with Synergistic Exploration-Exploitation Dynamics and Adaptive Parameter Fine-tuning.", "configspace": "", "generation": 94, "fitness": 0.36749764386468825, "feedback": "The algorithm EnhancedAdaptiveCoDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9055661827085477, 0.9109220140916979, 0.8910946591984761, 0.8874610666680836, 0.908331729905875, 0.8987999523915793, 0.9022995830697541, 0.9065032083854111, 0.8973107693117147, 0.7982019230785691, 0.7975314311666549, 0.809939940746314, 0.797151891742305, 0.8145751602184996, 0.7857548871449657, 0.789531337075529, 0.7896370113794257, 0.8022892717726429, 0.5327694924526065, 0.16812893345624802, 0.5119378304467532, 0.42968238980845597, 0.5332705808269969, 0.4444427648539795, 0.6369804794005949, 0.17260466992163515, 0.46123495110236457, 0.1215088865014462, 0.14778792323293488, 0.1592159372635522, 0.15018960735228026, 0.14883428829078615, 0.16577288930142764, 0.2396953482423616, 0.17021144306117242, 0.13782137554769636, 0.9898436678627428, 0.991291444466859, 0.9724137718528624, 0.9862141217127902, 0.980310413424276, 0.9714566790789616, 0.9716968647980696, 0.974257757509971, 0.9513437485683826, 0.5601202429211738, 0.5211571056145159, 0.49047129160865777, 0.5621980825348076, 0.5462289455637857, 0.5408292563106378, 0.4696867990031557, 0.48347229362422284, 0.490021679438008, 0.8754738257836208, 0.8869890454702987, 0.8546726423185284, 0.8726574606295882, 0.8952596660087895, 0.8548883149379068, 0.8568999403341202, 0.8419099064611989, 0.8411442198654937, 0.2723091409527427, 0.19343777818978047, 0.238570916577741, 0.17752494606037306, 0.26624344434139857, 0.17296440183328088, 0.23203669198735233, 0.19640813194411644, 0.25505558262870054, 0.22292073489224928, 0.12753568646679636, 0.2154149048113122, 0.1822189092081079, 0.22504653293082888, 0.21461104911192475, 0.31943338060488446, 0.2493452161269487, 0.20240979908270817, 0.05783335083764851, 0.08975098826774153, 0.07896672177808794, 0.024081042388525042, 0.00012027056128738334, 0.012898943779508731, 0.02697289135713765, 0.11472828178585404, 0.03052074360458734, 0.09106504672038462, 0.09902621383386723, 0.13656593440053444, 0.20141030864215625, 0.03328663955891731, 0.062242069633242525, 0.1210063703205626, 0.15804492991468322, 0.14435743148402413, 0.028105544760945067, 0.032035756166923224, 0.06452904718791919, 0.08784368281979882, 0.08814098497541456, 0.07020335308687387, 0.07145491369312296, 0.12990567115570995, 0.15709598480459808, 0.21429750672283276, 0.18327450421075442, 0.20579146783146007, 0.17709785965313418, 0.22185810674383633, 0.17527337104968288, 0.18784806083787076, 0.1321138838879593, 0.20026571566183382, 0.5385503725389621, 0.6209209400176671, 0.5846015245237572, 0.5639827236935413, 0.5523774634169678, 0.565073161848386, 0.5943434228395239, 0.5660589319132014, 0.588380935557709, 0.12403196904182567, 0.14364459712844257, 0.13086762116978, 0.14614560698218826, 0.10625939706136256, 0.12955295389760668, 0.13265391744852062, 0.11904818607585543, 0.12546421471510982, 0.15047076625331723, 0.14620346246405147, 0.15759239177699913, 0.15227736470571107, 0.1452915912267606, 0.13741063354081395, 0.1842767829710582, 0.19282737097856095, 0.16314059607777887, 0.45097547468175303, 0.4385346281167689, 0.4616017269659587, 0.46159332457889723, 0.46733794672369, 0.47977064986201357, 0.3705506174385409, 0.5255213013548117, 0.45866975567532986, 0.2806982162826087, 0.2674473170824666, 0.3653819415654699, 0.28244126321410634, 0.3170102953262667, 0.3149434681648886, 0.3309327210261206, 0.3626074444791296, 0.25286176318273557, 0.22337415782454573, 0.22248971122705363, 0.20410793709343922, 0.20414150563696087, 0.19978251257722446, 0.20961039334977927, 0.22226192312337012, 0.2103870048909281, 0.22056080145691692, 0.47783506600283554, 0.23653983211042084, 0.19426568263725386, 0.3097201114435608, 0.5741840229767399, 0.6548499956606637, 0.5886752045556484, 0.24388783535524672, 0.6371620211664881, 0.8508208759899463, 0.20850371741914808, 0.185481195005188, 0.912895867467028, 0.19881027666780626, 0.1995143614333026, 0.1771320732306102, 0.15785126452750153, 0.1761850338781007, 0.6398110888209436, 0.21175145336859114, 0.2098443718013795, 0.5514937187070923, 0.7155531741491723, 0.16653257642641672, 0.21229111768038522, 0.10497787121218483, 0.7507321149255677, 0.1797272256891208, 0.19886080712605847, 0.18604122602154516, 0.17918063911053417, 0.18922618277127634, 0.1838010505753136, 0.19200134690801973, 0.18462126498719966, 0.1987936775685737, 0.11207401250507842, 0.084998439416622, 0.08838204585405451, 0.09244222209050146, 0.08672838693000884, 0.09396610797550253, 0.08739752777363285, 0.09414857377093155, 0.10135186961878484]}, "mutation_prompt": null}
{"id": "1b3f554d-531d-4394-890a-46fb83911edb", "solution": "import numpy as np\n\nclass DynamicMutationCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_probabilities = np.array([0.4, 0.4, 0.2])\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.mutation_probabilities)\n                strategy = self.mutation_strategies[strategy_idx]\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                        self.update_mutation_probabilities(success=True, strategy_idx=strategy_idx)\n                    else:\n                        adaptation_counter += 1\n                        self.update_mutation_probabilities(success=False, strategy_idx=strategy_idx)\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def update_mutation_probabilities(self, success, strategy_idx):\n        if success:\n            self.mutation_probabilities[strategy_idx] += 0.1\n        else:\n            self.mutation_probabilities[strategy_idx] -= 0.05\n        self.mutation_probabilities = np.clip(self.mutation_probabilities, 0.05, 0.9)\n        self.mutation_probabilities /= np.sum(self.mutation_probabilities)", "name": "DynamicMutationCoDE", "description": "DynamicMutationCoDE introduces dynamic mutation strategies with adaptive probabilities for improved exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.48989322592721124, "feedback": "The algorithm DynamicMutationCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.8764159932106246, 0.8664991980928208, 0.8641881426094044, 0.869838746507188, 0.8786805702325251, 0.8719412324858534, 0.8588205376281441, 0.8767240840074003, 0.8695352118530986, 0.7677895767456677, 0.744479022704092, 0.7486524711853368, 0.7386494219618256, 0.7465063200035067, 0.7551330053896014, 0.7488773088809644, 0.7519592991712116, 0.7439616149272319, 0.1030089656802089, 0.13130737790499858, 0.16405451822826655, 0.11514851503357482, 0.15485018237847614, 0.1624719262865134, 0.11738974780304601, 0.13539453824009728, 0.11958689285313573, 0.1417846398679431, 0.10573487618439581, 0.11292915076648657, 0.61000469197801, 0.13188527730602617, 0.11505006240870241, 0.13786946408056522, 0.12558771336696462, 0.12863012301541132, 0.985493882086628, 0.9914450869838757, 0.973700397565672, 0.9599824853685697, 0.9886304925427052, 0.9882758039190606, 0.9879330543386929, 0.9779260297495019, 0.9870167819829916, 0.7716153184584338, 0.794277805733629, 0.7915017966995681, 0.7318206416181631, 0.7664430532778789, 0.76192985434073, 0.7882479250047997, 0.7546125666356163, 0.7954051414472686, 0.8275271977432844, 0.8650832362421839, 0.8572890841573911, 0.8430997978467061, 0.8216709453521086, 0.8207520332359751, 0.8517809388400717, 0.8394729656913819, 0.1777367357897952, 0.7254821211444518, 0.5304278069711714, 0.582476843718795, 0.5334650371192118, 0.6203057770293192, 0.551018261701602, 0.6339962592716463, 0.6600162849135789, 0.6565270714283544, 0.1319666524047518, 0.5980656426096451, 0.6029583055400775, 0.6941340671330886, 0.6560191505593258, 0.667803013947502, 0.6640125992444328, 0.6823696254154841, 0.6744412857961533, 0.5460152771202245, 0.6079502045404079, 0.5019925339971708, 0.6158849036057013, 0.5905679204944065, 0.5305011096574808, 0.6109444343192734, 0.5479156492074939, 0.5676580850116668, 0.6519114930518504, 0.6595201994576735, 0.5980767687956574, 0.674557944531798, 0.6310123272473509, 0.5403613176149847, 0.7219060134821003, 0.6856956178634162, 0.7335091380151257, 0.08618676512271761, 0.1479419958044046, 0.17867510502512107, 0.2534113266489414, 0.3846833707766486, 0.3714648592607067, 0.3204809212962769, 0.34400542910317555, 0.19396303006203852, 0.4599450262938971, 0.4320924744069028, 0.47992315158109466, 0.4550436157670521, 0.5473763339854476, 0.49703293429970397, 0.4841194166068564, 0.46384287359585574, 0.44534650796509145, 0.7818258391302269, 0.8022730532939008, 0.8161567187757186, 0.8058106498246718, 0.7858036073479436, 0.8350677637371093, 0.793581678712837, 0.8088291163435273, 0.8437335186701681, 0.12502377244032958, 0.12518295776290034, 0.15498699795716697, 0.13772699407808764, 0.11876848852999888, 0.11202922139894622, 0.1157829320491941, 0.10064401709082937, 0.1119946468083759, 0.4309236504973889, 0.41857371073660377, 0.3001659634963718, 0.18044468114686407, 0.6357385422688637, 0.22873700157341514, 0.17652270830621508, 0.19139295942685142, 0.4096062637843346, 0.515042734683105, 0.5652584831987149, 0.5580009815498556, 0.5356193553315418, 0.5195995272419061, 0.5224351782754526, 0.5004985069728881, 0.5667325661076517, 0.5403200848115737, 0.3664830680576593, 0.3969164895493965, 0.43230169838246546, 0.4379278301197914, 0.40669711307473966, 0.4819463028284122, 0.4412884780146422, 0.4602653736455542, 0.42314037281479, 0.20586177845115405, 0.20438911515744562, 0.1970702615793124, 0.1993180513742161, 0.18177717194967158, 0.20815953569139733, 0.21469138014060518, 0.2329499945456508, 0.20023863838514422, 0.20099660593318325, 0.22036977000126623, 0.24314970346163822, 0.650419124745601, 0.6403851618803226, 0.23159468937809302, 0.2910535343139653, 0.21278352135052125, 0.20602143748688395, 0.9187459484536681, 0.8863822823015233, 0.15320344397422014, 0.8758761290856123, 0.8191414638738901, 0.19848357504429137, 0.8588467570941833, 0.16841813325235377, 0.8547757730301713, 0.8542796543380594, 0.20843279410345228, 0.20926737041351617, 0.8350047526486126, 0.8893948262728409, 0.16874602600237398, 0.8343710958939273, 0.12571210686783485, 0.21129428335498068, 0.20276155396887274, 0.1948310212307286, 0.198207128255803, 0.18905678793548308, 0.18467919669843091, 0.18204260877754563, 0.17563243649820182, 0.18667728932102667, 0.19190524568155698, 0.09015774198950788, 0.0893191084607643, 0.08945868371648502, 0.07743055159025314, 0.0767427012332329, 0.08479049462573784, 0.08648318716867454, 0.07915646622191219, 0.08918375002655143]}, "mutation_prompt": null}
{"id": "002d543a-dfd1-42a7-bd08-aeb31b9d18ba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Improved Adaptive CoDE with Enhanced Diversity Maintenance for Robust Global and Local Exploration.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9105798302263151, 0.9141054614874701, 0.924387892684406, 0.9135191115307851, 0.9078221156586789, 0.922087059962655, 0.9192131330273936, 0.9089525020351407, 0.9161959928004023, 0.8301911331621108, 0.814450596009725, 0.8365161619428452, 0.8209216459941577, 0.8299764493069033, 0.8480575659499788, 0.832230464656111, 0.8397772623790287, 0.8340455748869665, 0.5771411812624994, 0.13082243391408332, 0.14926882832655353, 0.4871502730920929, 0.1566818646751459, 0.13570242631640106, 0.617196753638718, 0.1434970705283406, 0.17547458408710936, 0.13928315457245588, 0.1189632854231788, 0.13000621709587412, 0.13249475508348774, 0.14874280185365985, 0.12753402335912323, 0.14136619935343897, 0.13437263489837425, 0.13224867351621183, 0.9901128791996175, 0.991291444466859, 0.980243384882362, 0.9745408270623441, 0.9828961041443951, 0.977639260258256, 0.9684129198151669, 0.982778729149947, 0.9814459544822531, 0.7607429640685528, 0.7938965047998695, 0.7401365364684565, 0.7747890158103798, 0.7905944618036389, 0.7747505656229973, 0.7930661901263134, 0.7671695033332803, 0.7953118874256477, 0.9087329246632255, 0.9116417944872156, 0.9152241430947853, 0.8976554942185271, 0.9242652373429475, 0.928660283759528, 0.8955989432356625, 0.9146095961377916, 0.9135340366496525, 0.8110642408273272, 0.8196916268585402, 0.7158481821320726, 0.6827654305934676, 0.7170598793907864, 0.7417145331212774, 0.6962882741355858, 0.678185912293175, 0.7566522423781521, 0.7357742358198442, 0.528613757705982, 0.6784826379643211, 0.8023174503323081, 0.7773124623866855, 0.6637054952763756, 0.6929230238744655, 0.6708095409432557, 0.7746810905797253, 0.7259150805167836, 0.702344087546432, 0.6500216672214174, 0.7119129209053825, 0.6166383376495783, 0.7110994320918945, 0.7400375748268935, 0.6780015466843087, 0.7257360655489227, 0.8089674281924436, 0.7507515598382359, 0.7853658121056972, 0.4130871420900928, 0.7711855398016534, 0.7582508403812696, 0.8202996577542795, 0.7796715913604397, 0.7463883051442147, 0.34230859620898635, 0.3869113175638448, 0.5563813983610415, 0.6428654498617979, 0.678338418078118, 0.5279311434449215, 0.1919957277287604, 0.18071472344979012, 0.1933663129259774, 0.6838500505938747, 0.6374214476331126, 0.6777146197687898, 0.7119003474274168, 0.680559516228008, 0.6812047379030773, 0.6795807708066074, 0.6829130892559356, 0.6753799473068842, 0.8624903185132274, 0.8756732221805262, 0.8742072805523258, 0.8775039685688747, 0.8816951625299926, 0.8695963432611935, 0.8904207267511006, 0.8816208414585023, 0.8722996962376217, 0.10839248883327424, 0.14735438667347678, 0.17190016584136014, 0.10295122102213972, 0.13335029487955397, 0.15720729559937097, 0.13404918076899575, 0.12197132087737994, 0.14089908522209627, 0.6847240630975421, 0.8064795999398799, 0.33169013459262564, 0.30914131438775505, 0.16953977388728259, 0.420205818818434, 0.464206584033666, 0.7887331975643844, 0.629379885337752, 0.7034778980630669, 0.7097195853213218, 0.7274573919572764, 0.7146626855679129, 0.6997498948705058, 0.6792506696181246, 0.5455138719437629, 0.759666167706329, 0.6360804614621964, 0.5546263845368586, 0.5628789544136292, 0.5889206638705538, 0.5923266609197938, 0.2594499454960548, 0.47691450874840047, 0.6778095954785703, 0.5714513874489102, 0.6741277609996407, 0.2233064347667495, 0.23607339650927694, 0.23320110638282665, 0.2300142818817651, 0.217884313442247, 0.19755015912709606, 0.21290987927437743, 0.2161973274906348, 0.2160881662384866, 0.20443810496757575, 0.24954120677673663, 0.2089355077776709, 0.7127353020253682, 0.20214899961642407, 0.2207334733772448, 0.20164636749791687, 0.7843193504840147, 0.2427273571520273, 0.18651505573874283, 0.18745256279014155, 0.20030504180354325, 0.9151272172316909, 0.20079593464574463, 0.920504483371455, 0.9091934308991853, 0.15783294821268368, 0.9313882926224516, 0.9108915658636829, 0.21103743357524174, 0.9241725503416365, 0.20897100887559195, 0.21079014528108553, 0.8925662951964496, 0.8655748292586329, 0.890849157014255, 0.8995390514410689, 0.19247028814135125, 0.20455412310519272, 0.18955948632615272, 0.20926728576373954, 0.18794618065823154, 0.17800173671556274, 0.2140603297810535, 0.17170312304168656, 0.21193153416147703, 0.08944003933199096, 0.09195019969195095, 0.09588531049823357, 0.09455692798662618, 0.09473038615231621, 0.09154603471130618, 0.0889050196297414, 0.09311481789487475, 0.09470571397611638]}, "mutation_prompt": null}
{"id": "a97af059-e6c3-4cbc-a6a4-b239678c8969", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.quantum_prob = 0.03\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.quantum_prob:\n                    population[i] = self.quantum_operator(population[i])\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def quantum_operator(self, individual):\n        return np.clip(individual + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)", "name": "AdaptiveQuantumInspiredCoDE", "description": "Adaptive Quantum-Inspired CoDE introduces quantum-based diversity enhancements and adaptive parameter tuning.", "configspace": "", "generation": 97, "fitness": 0.4929912502471192, "feedback": "The algorithm AdaptiveQuantumInspiredCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9104959622967919, 0.9173584064673836, 0.9040360864266155, 0.9030479029688196, 0.9151267124984872, 0.9129748430747782, 0.9150579467515884, 0.9110404799816485, 0.9075745116511789, 0.8168757635674991, 0.8203854034102893, 0.8150498937854898, 0.8194891847281196, 0.8171290227943713, 0.7864076724776524, 0.7928475053522137, 0.8268429897434657, 0.7968325047880415, 0.1449476070050294, 0.1442570687556114, 0.14503388545211127, 0.6226830485364265, 0.13526923977748406, 0.14945711586693955, 0.15399954139575545, 0.5472720331718658, 0.16152600643435655, 0.13731324454690874, 0.13304148598165633, 0.11155165354324004, 0.1351472545749529, 0.10384734689279373, 0.13510324383511363, 0.11748215296743036, 0.1725269164837886, 0.1528985377584533, 0.985198299621353, 0.9489928400538685, 0.9842994780033957, 0.9661221507549752, 0.9550041497359694, 0.9826850115981645, 0.9770046275650699, 0.9902849101113322, 0.975227970477503, 0.7377860583157703, 0.7248127997211194, 0.536063819696696, 0.7244528128841907, 0.730048550771345, 0.5990879258689699, 0.6387273885017979, 0.7357539792595382, 0.5081033386445071, 0.8892383707463359, 0.9106336951795598, 0.1403213963247032, 0.9001227956007447, 0.9081734583029362, 0.9163995868902747, 0.8950663023407951, 0.889967355563287, 0.899075365714943, 0.6602783107373987, 0.71667943970621, 0.7001621367982389, 0.13464340582307033, 0.7495007355381489, 0.6273792969831702, 0.6548306831530548, 0.7608836414039313, 0.7480713941246302, 0.6296832265877672, 0.6688710399968893, 0.5559992629770295, 0.6628404315910534, 0.13357316893883076, 0.6760793546652322, 0.721605179757653, 0.649441427945467, 0.677327278076528, 0.6927039181215504, 0.5396442852394431, 0.2874942206112181, 0.6868116920028985, 0.5672767728062196, 0.28397393103271773, 0.6888795628927358, 0.233984863682433, 0.5612343743044566, 0.7336201303824187, 0.7104116752695406, 0.6382484394919374, 0.6825685924748746, 0.7265364377777191, 0.5707806217042768, 0.7576727524995387, 0.772631811435172, 0.6682101630422235, 0.3813459178780153, 0.13389959000432372, 0.09141720917806795, 0.5653438580111458, 0.5323828817121956, 0.33003063546158284, 0.1875216461015985, 0.22306315921351216, 0.11804862404347682, 0.4373701516769838, 0.5248824390125131, 0.3884295535093165, 0.585778086331681, 0.6279661955021474, 0.5137637432949879, 0.5597653116254906, 0.5419035328157316, 0.41990816793405306, 0.8520364726245141, 0.8721018607050489, 0.844877902380387, 0.824951896684418, 0.8468993079991809, 0.7961010690137209, 0.8492686809408319, 0.8447555079438667, 0.834875301021531, 0.15532869112389747, 0.14997784137381298, 0.6030513444024503, 0.14165826885507538, 0.11525808834367146, 0.16933166078324902, 0.1144636610667672, 0.14669675468152088, 0.1327830085601832, 0.4816967592073075, 0.1917147603542424, 0.2926956178457696, 0.7237970419107558, 0.27522672120505753, 0.5179541347453333, 0.3886566059375215, 0.2558684254101192, 0.18480754844687697, 0.6863214342722057, 0.5327161896278232, 0.5114390914301126, 0.5627771916632576, 0.6478240705635173, 0.5342876722064118, 0.7151297918916489, 0.6322785704390496, 0.5033209665194355, 0.39721939463773015, 0.4199387187388778, 0.46111595826212426, 0.4714032866916843, 0.3793200391558813, 0.2788938187507074, 0.5432734850718535, 0.6009927094831179, 0.3980891931439863, 0.2169732406575562, 0.21747028812509106, 0.2291884331300409, 0.23328315440173986, 0.20972798120128577, 0.21142904880278224, 0.20192970647817765, 0.2209752622003578, 0.20698317180217674, 0.24287386368088348, 0.20526899498911066, 0.19565406401481178, 0.243290681194683, 0.2045939884322242, 0.18236234974536303, 0.24526033416900495, 0.8235213806892095, 0.19643004696796984, 0.14762539525157936, 0.18563209272973813, 0.1535983637882351, 0.893437643308025, 0.19935613703678745, 0.9085117382968383, 0.18691439357895812, 0.9026473672138279, 0.2130006653485914, 0.8983462850414322, 0.2122131989722168, 0.901871131888847, 0.21046449898579977, 0.16787354487332928, 0.8871581478513293, 0.210356567500131, 0.12696093049159207, 0.1675044927865159, 0.18841642681249926, 0.18986937803956305, 0.18711978015895347, 0.20828910167835324, 0.17807477493064994, 0.17391416950898042, 0.19887499365556316, 0.17884629586583234, 0.17646276781779147, 0.089704892017899, 0.09247572676626625, 0.10060495047582574, 0.0936205055826389, 0.09204701673028126, 0.09160232599144436, 0.0938191511764902, 0.08078086298611686, 0.09378285456381896]}, "mutation_prompt": null}
{"id": "722f89b0-9070-405e-b65a-624992c5be0d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_current_to_pbest\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n        self.dynamic_strategy_prob = [1/3, 1/3, 1/3]  # Dynamic strategy probabilities\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies, p=self.dynamic_strategy_prob)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                        # Increase probability of successful strategy\n                        chosen_strategy_idx = self.mutation_strategies.index(strategy)\n                        self.dynamic_strategy_prob[chosen_strategy_idx] += 0.1\n                        self.dynamic_strategy_prob = np.clip(self.dynamic_strategy_prob, 0, 1)\n                        self.dynamic_strategy_prob /= np.sum(self.dynamic_strategy_prob) # Re-normalize\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_current_to_pbest(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        p_best_idx = sorted_indices[:max(1, int(self.p_best_rate * self.population_size))]\n        p_best = population[np.random.choice(p_best_idx)]\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[target_idx] + self.F * (p_best - population[target_idx]) + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)  # Changed reinitialization rate\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Adaptive Differential Evolution with Dynamic Strategy Selection and Enhanced Diversity Reinitialization.", "configspace": "", "generation": 98, "fitness": 0.547031469196302, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.32.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9327511355325913, 0.919865121106594, 0.9294978240001021, 0.9254038901982635, 0.9301969895541718, 0.9378686186705674, 0.933743902537258, 0.9397568358989407, 0.9360450697485685, 0.8722710908020711, 0.8427383550564526, 0.8827735848286322, 0.8790506311462472, 0.8613553825048011, 0.871695579149987, 0.8633640084796648, 0.8709643013635141, 0.8648699715730348, 0.11583115833081048, 0.16932910417648095, 0.16704803737161256, 0.12602424798992506, 0.1517000804497347, 0.14841263527629855, 0.17156101183368577, 0.6349197252616843, 0.17252307090562813, 0.10989876725767866, 0.15321491650413477, 0.1398920602137117, 0.10810620033621621, 0.11304443634879968, 0.1480529282318519, 0.16728707567038126, 0.13108746845039554, 0.1347987016010651, 0.9883141537590012, 0.978968843845414, 0.9821176475870634, 0.9799364052232062, 0.9905308183726047, 0.9876151688330428, 0.9856739006303903, 0.9838316510699698, 0.9691279459895198, 0.8098257873285611, 0.8157520999070231, 0.7966712460988297, 0.8130892375570413, 0.7935517462796967, 0.8200751389608276, 0.8401709257052089, 0.8011400659913315, 0.8076690693431985, 0.3845555340312974, 0.9263245324011914, 0.9237698287594518, 0.2804937925507536, 0.21374585591375495, 0.2746615109283186, 0.9158572644598457, 0.9384066002689893, 0.8640710253902586, 0.808191130901592, 0.7319909716221491, 0.8243441018094771, 0.8084788844851338, 0.7805727617661526, 0.8113382422241474, 0.8091335471125658, 0.771513885026801, 0.8027021386408557, 0.7629337449004936, 0.8047200718998702, 0.7453526216448362, 0.8289800224858322, 0.8007256218451968, 0.83005298246652, 0.8360223073653212, 0.8112683363564179, 0.8346659444328385, 0.7693930859028153, 0.16184084242698793, 0.7544355209689801, 0.804085805435435, 0.7824532314719713, 0.7077044165952262, 0.7731400070199592, 0.7874583809713863, 0.7672397502301198, 0.8358374181036637, 0.8321527799443372, 0.7744333751434551, 0.8233833771741045, 0.8220524636575421, 0.7595786776385012, 0.806695447609475, 0.844959863731128, 0.8195560720133516, 0.2820455912237777, 0.48997904395723246, 0.154250732578323, 0.6386792337404751, 0.7813547276807151, 0.6087387859088639, 0.37473357782621275, 0.571050281482999, 0.18328271155187414, 0.7591791752033835, 0.6295273307567771, 0.4150807313490912, 0.7285829696298267, 0.49938060189306854, 0.5566748437719964, 0.05819733754429435, 0.78294393323571, 0.7486988777659078, 0.8953768897223265, 0.8636670796171482, 0.8881341582834195, 0.8926526253747986, 0.8980174252543152, 0.8980820198884703, 0.9105546756252105, 0.885858019548118, 0.8965427244288559, 0.14567025133197564, 0.137493602725552, 0.10833354096764014, 0.10245847991286905, 0.16091109852518526, 0.7853443525504978, 0.16803051396664448, 0.10363223854671455, 0.1524632740018831, 0.693277098627801, 0.16673830671391077, 0.647339034877196, 0.6179438718806053, 0.5351111360817358, 0.6604345967657947, 0.794553025387076, 0.2581743053891177, 0.14451988836513807, 0.5009481243226136, 0.6669466184379589, 0.7679565742372021, 0.5832809679838719, 0.5797439413457057, 0.5391892171985342, 0.5049834185440784, 0.5503048068045386, 0.6999594258152677, 0.27072985328107413, 0.5558311266043888, 0.4883572735991871, 0.35899942925021944, 0.4129831103425744, 0.5210087083463051, 0.32775316014357514, 0.3907051992705346, 0.5326429469732442, 0.2081240640897125, 0.20475291736987, 0.20520022820410078, 0.2335592654284977, 0.22157072394117006, 0.2447241726988646, 0.21245435752492348, 0.2514859234816287, 0.22587879287318424, 0.22391706331572336, 0.21332088279877393, 0.20743538964854435, 0.22446293255709393, 0.19576505664808974, 0.20934600926679137, 0.21041839475225677, 0.7278557264490934, 0.19130156425560407, 0.9144743629335398, 0.929176697976421, 0.15329882941238682, 0.9363346983569327, 0.19935775573008108, 0.1983639271952099, 0.14251535567978357, 0.9027722399799069, 0.20975930804793164, 0.92756204162147, 0.2127583434572039, 0.9162910636842518, 0.9092498162571252, 0.2109681866702201, 0.16638357584267816, 0.2136871571460982, 0.7006813836305628, 0.21256402094908322, 0.18622148276704342, 0.18887296082301486, 0.20805156532221514, 0.19742559167826612, 0.19641199426889677, 0.19262034379126858, 0.18255841689439367, 0.18948536895812695, 0.1968058747622754, 0.09428870501182862, 0.09273215038932359, 0.0942802444715366, 0.10216590638017564, 0.10866547059097353, 0.10405230837137658, 0.09441997695002369, 0.08913879664642266, 0.0945297859158698]}, "mutation_prompt": null}
{"id": "2c05e6ea-7840-405e-ba60-c3a666cb5960", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim * 5\n        self.F = 0.5\n        self.CR = 0.9\n        self.p_best_rate = 0.2\n        self.mutation_strategies = [\n            self.mutation_rand_1,\n            self.mutation_best_1,\n            self.mutation_rank_based\n        ]\n        self.local_search_probability = 0.1\n        self.adaptive_step_size = 0.1\n        self.diversity_threshold = 1e-5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n        adaptation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                mutant = strategy(population, best_individual, i, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                        adaptation_counter = 0\n                    else:\n                        adaptation_counter += 1\n\n                if np.random.rand() < self.local_search_probability:\n                    local_candidate, local_fitness = self.local_search(trial, func)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.adaptive_step_size = max(0.01, self.adaptive_step_size * (1.05 if adaptation_counter < 5 else 0.95))\n\n            if self.calculate_diversity(population) < self.diversity_threshold:\n                self.reinitialize_population(population)\n\n        return best_individual, best_fitness\n\n    def mutation_rand_1(self, population, best_individual, target_idx, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_best_1(self, population, best_individual, target_idx, fitness):\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = best_individual + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def mutation_rank_based(self, population, best_individual, target_idx, fitness):\n        sorted_indices = np.argsort(fitness)\n        rank_weights = np.linspace(1, 0.1, self.population_size)\n        rank_weights /= rank_weights.sum()\n        selected_idx = np.random.choice(sorted_indices, p=rank_weights)\n        a, b = population[np.random.choice(self.population_size, 2, replace=False)]\n        mutant = population[selected_idx] + self.F * (a - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, candidate, func):\n        local_step_size = self.adaptive_step_size * (0.5 + 0.5 * np.random.rand())\n        neighbors = candidate + local_step_size * np.random.uniform(-1.0, 1.0, self.dim)\n        neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n        local_fitness = func(neighbors)\n        return neighbors, local_fitness\n\n    def calculate_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def reinitialize_population(self, population):\n        indices_to_reinitialize = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n        for idx in indices_to_reinitialize:\n            population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)", "name": "EnhancedAdaptiveCoDE", "description": "Adaptive CoDE with stochastic rank-based mutation and dynamic local search adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.5164959730781175, "feedback": "The algorithm EnhancedAdaptiveCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.31.", "error": "", "parent_id": "5a434fdc-cfdb-4d06-97df-44cf4be1eb55", "metadata": {"aucs": [0.9088315648207188, 0.9040720652494941, 0.9041908456743039, 0.9041188802503841, 0.905276401042601, 0.9094000883484313, 0.913273755375295, 0.9117640618847647, 0.9027801590975468, 0.8411190125113164, 0.8377781783840708, 0.8372597415816911, 0.8408167129614936, 0.8370694990043999, 0.8350443334910508, 0.835964400073256, 0.8379160903400003, 0.8413683100278486, 0.13176956632922265, 0.14058686798602726, 0.47748456362588365, 0.5910724408614589, 0.13415378321369353, 0.17055144694178093, 0.1624112867895614, 0.1739853461839268, 0.1457933704334955, 0.19579161335058715, 0.15531886761787972, 0.11021411797449676, 0.13984230550375765, 0.1612852193166665, 0.16510369733329266, 0.14781474101018488, 0.4996282916408845, 0.11320442831248712, 0.987509370594168, 0.9915384313209468, 0.9843670202884621, 0.9791396469435943, 0.960833015649313, 0.9881734739466831, 0.9834446484191373, 0.9647262588442281, 0.9873742842996462, 0.7290989720130172, 0.7207906473052339, 0.7582579485123765, 0.7782680185044885, 0.7345176373990578, 0.7491168651966751, 0.7419466604227853, 0.7643357569390737, 0.7525201581924101, 0.9090624999389405, 0.9084242817718027, 0.9126627037679353, 0.920198105377593, 0.28121159265189344, 0.8818296996140592, 0.8848873620304102, 0.9002265328667779, 0.9081515644221412, 0.69677759494178, 0.7003839178553077, 0.7035999247486664, 0.6771457179374649, 0.7565847033905453, 0.7040044110085896, 0.13216881996140584, 0.13277186114847883, 0.7299976434204738, 0.13465547282498247, 0.6185599814150022, 0.6911534947037339, 0.7023874138698594, 0.7030842722964898, 0.13135331857533106, 0.6335859880509422, 0.732301471402, 0.6930634377128742, 0.10906558851154291, 0.734308097554994, 0.7098223068499917, 0.7407728359146207, 0.29533274612170446, 0.6453666386283413, 0.6739555647866624, 0.7106595652184498, 0.6705685267961368, 0.7809787869576265, 0.7115548309429525, 0.7839438566632648, 0.7610266999678325, 0.7109974078715514, 0.7778507411763307, 0.7862807305541648, 0.8077482957904777, 0.7677004692097319, 0.43719211978297035, 0.1319137105093542, 0.18493482218519475, 0.6673505640612114, 0.6572548811016541, 0.6736055097970273, 0.17207538929483157, 0.16074886450289028, 0.19248401457950115, 0.6484183726747175, 0.6403964171226011, 0.6518640401894295, 0.6172901150328716, 0.6700017973932335, 0.6281059971256073, 0.6543109281371159, 0.6478976406804293, 0.6063388252162442, 0.8672131578493705, 0.863662859929455, 0.8618987607048498, 0.8742056292856578, 0.8605174524131167, 0.863251684804414, 0.8709854964777478, 0.8622525509301047, 0.862418218638193, 0.14665654264454608, 0.16952025270879423, 0.12355231577907977, 0.14784109666064815, 0.12766890260379038, 0.10293533655879439, 0.13348266786699892, 0.16411060429975155, 0.5466901088631452, 0.24446633911637095, 0.25662400328841006, 0.33676045782103636, 0.1931090690179923, 0.2294662039431994, 0.21285767184652282, 0.24699887740670845, 0.5325598006335615, 0.23621486169940864, 0.5857764655406377, 0.5845911919557298, 0.647117142907736, 0.4893704260890148, 0.5368830211165372, 0.701620804802499, 0.7274694619871278, 0.7308421059936419, 0.7302735411053124, 0.3339606666209486, 0.5874461848095973, 0.3054074032079289, 0.4240138287308658, 0.2302284638430908, 0.6389835695034327, 0.628819293304554, 0.5897018979399264, 0.3922815674201502, 0.21484762895128318, 0.21667637091573144, 0.22159607458165953, 0.20737503013121117, 0.224048029813116, 0.22198692198382564, 0.24591452361602428, 0.22852690358952432, 0.21677347378442202, 0.2331889117325744, 0.18759155362787971, 0.24733442244471948, 0.753105567242087, 0.23538947400519994, 0.2248453995985128, 0.2411269168088105, 0.22549370841837113, 0.23895492435896826, 0.9104262813338766, 0.9222892665911656, 0.1532205547769201, 0.1693442038595624, 0.19836568576459945, 0.16551786753389297, 0.14246760339494435, 0.18622931899620498, 0.9043646084851498, 0.9055166976645783, 0.2123815486435947, 0.8855336970683756, 0.8944434997718951, 0.612694657426123, 0.15627875488877885, 0.10466643845162693, 0.8684303921535415, 0.16766426710767246, 0.18704017727727662, 0.19371372052245928, 0.19837025150917975, 0.19038792337026944, 0.183371133058446, 0.17887154300248398, 0.19878446050193976, 0.1730396594032403, 0.20105489812593036, 0.10956871584588856, 0.08705058056827508, 0.09178513029562985, 0.08864371223573142, 0.0966394837670339, 0.08981862904790872, 0.09384572629877752, 0.09108958188125948, 0.08236936203081857]}, "mutation_prompt": null}
