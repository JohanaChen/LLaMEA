{"id": "fc5f085c-f69d-4dcd-b681-9d3d52df1a23", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic Sampling for diverse and efficient search.", "configspace": "", "generation": 0, "fitness": 0.261332256345072, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "ccbee97a-8853-47d6-9183-d2165199be8a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic Sampling for diverse and efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fc5f085c-f69d-4dcd-b681-9d3d52df1a23", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "d396fbb8-23b8-4951-aaed-aed5adad5d84", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.dynamic_population = True  # Allow dynamic population resizing\n        self.shrink_factor = 0.95  # Shrink population over time\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            if self.dynamic_population:\n                self.resize_population()\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n\n    def resize_population(self):\n        new_size = max(4, int(self.population_size * self.shrink_factor))\n        if new_size < self.population_size:\n            # Reduce the population size\n            best_indices = np.argsort(self.fitness)[:new_size]\n            self.population = self.population[best_indices]\n            self.fitness = self.fitness[best_indices]\n        self.population_size = new_size", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Control and Stochastic Sampling for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.19175712707333614, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "fc5f085c-f69d-4dcd-b681-9d3d52df1a23", "metadata": {"aucs": [0.570798464130224, 0.3329387227920739, 0.28591666664607285, 0.4400618966189712, 0.33356062188258806, 0.32207596456412557, 0.2956844282914448, 0.3485675987844622, 0.33946443107901225, 0.15999467775852294, 0.1272891700196831, 0.02815145658664664, 0.40397810765233244, 0.23666923307363563, 0.19829587054359332, 0.18139074859464988, 0.01851007259570303, 0.04726491800742294, 0.11068039472899649, 0.09174154674502022, 0.14720905190712041, 0.1282006328630143, 0.08117811242851058, 0.12903830376630743, 0.11690169579010601, 0.10157240903047038, 0.1360352376026145, 0.0984954796236871, 0.08973644341448139, 0.10959242423788185, 0.09024409043588244, 0.07729262485998056, 0.09567320778535426, 0.10124878767296341, 0.06365501953931885, 0.03922623991071561, 0.954985044334296, 0.9752688739096087, 0.9686926609413028, 0.9508190134037758, 0.9523493939508255, 0.9829348331631653, 0.93849353928093, 0.9482737635186269, 0.9655465225262002, 0.22417179415978872, 0.12700736088793962, 0.11868916112984429, 0.1578006439320736, 0.15540514017161766, 0.11748421486360949, 0.1152777469797216, 0.08706065922924267, 0.11343411923883484, 0.32357687037307536, 0.22459067378642739, 0.2056137818447068, 0.23369394584073822, 0.2669132526250412, 0.1555312178829127, 0.23253988368203904, 0.23219453797058986, 0.23885250485898357, 0.14225260295786846, 9.999999999998899e-05, 0.12457518764027087, 0.1452999332967696, 0.13952235488783649, 0.12466517633997187, 0.1263480983745341, 0.0447894313133369, 0.13416112541594916, 0.030754253832124934, 0.03960981262516983, 0.08805698687834396, 0.06005892106813371, 0.09229687345666404, 0.11052213900010266, 0.10400019985367837, 0.2603150211127231, 0.12005055178778834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007593394843666279, 0.11468545724634693, 0.0715229678715017, 0.15897222698941804, 0.09218951637288186, 0.09760548826070359, 0.046324837902636085, 0.12717247781268493, 0.11345118829693657, 0.13217527887940395, 0.007635512849632153, 9.999999999998899e-05, 9.999999999998899e-05, 0.10218683291889974, 0.10800331458799428, 9.999999999998899e-05, 9.999999999998899e-05, 0.04941048486359345, 9.999999999998899e-05, 0.08749864559417564, 0.08481303594389988, 0.029388617653720917, 0.07479326814967502, 0.0957657600597468, 0.16762955685223968, 0.1579053114663439, 0.04581412779995131, 0.08150323599695453, 0.594665861932717, 0.39499682265784586, 0.47036547429633846, 0.31556938445485994, 0.40465998106269985, 0.34586451805100094, 0.2972804806338155, 0.5325249841246233, 0.32703864261970816, 0.09405700876336687, 0.06992746308035713, 0.10268691734253066, 0.09854991654906864, 0.06693899731735087, 0.0802774242976404, 0.10417089780440258, 0.06623370169989906, 0.1014382602268552, 0.11833548809233108, 0.10905440236891262, 0.14040030973022843, 0.1502982786714343, 0.16400348144058385, 0.11490640147402442, 0.10181455519740179, 0.11114039397351083, 0.13047935964620316, 0.28727860161578056, 0.27346391217686605, 0.25646053761584797, 0.3319581970716112, 0.15797319752984118, 0.23250784966201543, 0.2660159099271324, 0.23681780868071423, 0.2939552486106868, 0.2765419245377314, 0.17859507589917012, 0.1540407759474589, 0.17803942782397186, 0.20367623199445184, 0.11145298426231243, 0.2712919116905239, 0.2766490084566231, 0.2244768169485457, 0.16620889555495866, 0.18474226329938115, 0.17802293311620432, 0.177789693620521, 0.1952573763996136, 0.16114238433296046, 0.17380239986453327, 0.1706828841167839, 0.16391801942308282, 0.21153009761394603, 0.19029150082486523, 0.19124769563725386, 0.1928252973348017, 0.16015118845459497, 0.1771980270470751, 0.17855258732445922, 0.1743424068139009, 0.2268498471456034, 0.16817662398414868, 0.12457050199863628, 0.12317826324867565, 0.16592526181744938, 0.16657895402507472, 0.18571401330465986, 0.16407381759080475, 0.12833621764313063, 0.6564857149313572, 0.32059922563902477, 0.19859720014573912, 0.17272984509851264, 0.15882899294470498, 0.1648351720630371, 0.2756391152923604, 0.2072023070921355, 0.19737807694435394, 0.2041105172613994, 0.18251555466450942, 0.1772378551955508, 0.1800768993490015, 0.16714195663742792, 0.15632688402322004, 0.1681535187681058, 0.1755590372799889, 0.175621103902735, 0.1764518330101673, 0.08261249945589477, 0.07329223354284908, 0.046894769324347774, 0.052879087517003986, 0.05049686067761594, 0.07779825865133205, 0.05729818945444709, 0.0757717590714665, 0.07876588490042413]}, "mutation_prompt": null}
{"id": "da6a3bee-b2cb-4e99-90c6-e83219c12040", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic Sampling for diverse and efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fc5f085c-f69d-4dcd-b681-9d3d52df1a23", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "d0f6faf7-5fd7-48de-9c07-8552a300c276", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with global best guidance\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + 0.1 * (best_solution - x0)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Parameters and Global Best Guidance for enhanced convergence and robustness.", "configspace": "", "generation": 4, "fitness": 0.3220463372387134, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "fc5f085c-f69d-4dcd-b681-9d3d52df1a23", "metadata": {"aucs": [0.6851075102426706, 0.7532175431409871, 0.7392624291752254, 0.7377369205692792, 0.7476108329311282, 0.7402227693563384, 0.7103381616069204, 0.7445296075300905, 0.7635086007084968, 0.5627868150176534, 0.5404155002014581, 0.5315446536144739, 0.5263752473524886, 0.5330631059445976, 0.5795461563257895, 0.5114984588349065, 0.578053671453782, 0.5346842378198766, 0.1113532340993375, 0.11792837008460288, 0.11557521123181791, 0.10947047315757263, 0.0944477361115229, 0.11716848356860299, 0.12267071790792305, 0.13009424608016884, 0.103097164981937, 0.09702912724715862, 0.08634356457865777, 0.09285192811406628, 0.09337678531331695, 0.09315671441735851, 0.0844247676439025, 0.10333944739255896, 0.08538131409766525, 0.09597308550174022, 0.969568223458472, 0.9816784916952453, 0.8735102450789123, 0.9421129494494391, 0.9146903128300801, 0.9516249593071389, 0.9456352359326214, 0.9556716825536167, 0.9697120592900065, 0.34421776469387977, 0.4089571731375383, 0.36687143490845053, 0.33848854905685144, 0.3805806877999298, 0.3849375316560115, 0.3617377115939716, 0.39098720278985033, 0.4044122704134331, 0.6297644718879688, 0.6596944930778124, 0.6367913248260826, 0.6554121921705233, 0.6787896362009715, 0.6874982511564799, 0.5805615255141263, 0.6208925791382689, 0.7145974472512192, 0.28310212193220585, 0.30540628126682745, 0.29098113876168585, 0.2565518409185713, 0.27559235547994654, 0.2767267222145037, 0.26805221493185705, 0.3310284952261585, 0.32376272637036196, 0.23718635329336368, 0.3849957636840191, 0.28807462216487223, 0.2772794888842951, 0.28942096066468903, 0.28875559493150416, 0.22196313513833488, 0.2809583517664882, 0.2743260601657671, 0.16919594600474053, 0.26868432509366036, 0.2160166320202278, 0.18002238649696378, 0.22103670621476135, 0.27023692150902345, 0.16524396264160535, 0.23506554297798632, 0.2593492106151909, 0.2663363935639085, 0.4352396743666457, 0.39194425845198944, 0.2787332195326869, 0.3692944786742932, 0.37664361030846927, 0.3501307601363861, 0.4338962233085092, 0.37879811396275065, 0.0609933649247163, 0.07195112261497927, 0.08138413024123181, 0.1036706424782482, 0.11129242539326811, 0.07869415991445461, 0.05710903442615689, 0.11111107970404521, 0.082431731208915, 0.17785646703807234, 0.2226858220047072, 0.22125495805706108, 0.19933837191477988, 0.23434976670028695, 0.24284610876040447, 0.18510682366893394, 0.2135541772026851, 0.23524349333823025, 0.5454895357715882, 0.5832427942796059, 0.5534747730901897, 0.5210936332017102, 0.6018864479426823, 0.6072027041820528, 0.5342454868517318, 0.5783309798999479, 0.5980282258149496, 0.10292773005838296, 0.08987353188049585, 0.0839656814763694, 0.1050546180189531, 0.09688993299862791, 0.08982812997993683, 0.08337397553836834, 0.10427355153324147, 0.099061271467899, 0.1525878686492368, 0.13657617658377452, 0.14204317391071486, 0.15966213013133201, 0.1342028446052631, 0.1388933183762867, 0.14180342236686538, 0.14182528799521243, 0.13461741886916156, 0.3051610163534545, 0.31481219021841467, 0.3308926049317713, 0.3014239386222385, 0.32892065202190757, 0.3315407857624879, 0.33984294196568565, 0.3619554948769814, 0.34868626609499687, 0.22549724989251607, 0.25273637730457865, 0.2517632883981009, 0.24531877969960303, 0.23597379952530317, 0.26853129649091245, 0.24932209102224756, 0.24960932649710943, 0.26858314807650263, 0.18118495443592575, 0.16897481378326118, 0.17565078131753875, 0.20036504878293604, 0.18726913101820375, 0.19010896247334763, 0.19116131476588538, 0.1721666934155297, 0.19859107000825094, 0.1838430046852192, 0.2635067450713108, 0.1987154150684547, 0.195076170600058, 0.19536961981554302, 0.1793113678689684, 0.1853525599147643, 0.1841202539765463, 0.20515537949907736, 0.6471724802574477, 0.444054247926027, 0.5901006538105974, 0.1750616453549112, 0.39826941831408136, 0.1607463203995414, 0.5650629213498988, 0.595434707564668, 0.1806630856842828, 0.6423300496210693, 0.6147192696504922, 0.1966515141382501, 0.31914199328472526, 0.18614634336273417, 0.1850740464612003, 0.20316995493488454, 0.7567643341555979, 0.1878325388994263, 0.18338943905264782, 0.20836253944522343, 0.18529087443500547, 0.18783663450480648, 0.18991056744030743, 0.18417496042561454, 0.18469271116584451, 0.17770879767734749, 0.19346262173475037, 0.07932855033227715, 0.07274817675586309, 0.0648107959502946, 0.06852952664678191, 0.07705551652830689, 0.0710633568352731, 0.07006230319165829, 0.07324949054066876, 0.08150000250796985]}, "mutation_prompt": null}
{"id": "309216bb-1e9d-47ad-a0f2-9063c3efd243", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with global best guidance\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + 0.1 * (best_solution - x0)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Parameters and Global Best Guidance for enhanced convergence and robustness.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0f6faf7-5fd7-48de-9c07-8552a300c276", "metadata": {"aucs": [0.6851075102426706, 0.7532175431409871, 0.7392624291752254, 0.7377369205692792, 0.7476108329311282, 0.7402227693563384, 0.7103381616069204, 0.7445296075300905, 0.7635086007084968, 0.5627868150176534, 0.5404155002014581, 0.5315446536144739, 0.5263752473524886, 0.5330631059445976, 0.5795461563257895, 0.5114984588349065, 0.578053671453782, 0.5346842378198766, 0.1113532340993375, 0.11792837008460288, 0.11557521123181791, 0.10947047315757263, 0.0944477361115229, 0.11716848356860299, 0.12267071790792305, 0.13009424608016884, 0.103097164981937, 0.09702912724715862, 0.08634356457865777, 0.09285192811406628, 0.09337678531331695, 0.09315671441735851, 0.0844247676439025, 0.10333944739255896, 0.08538131409766525, 0.09597308550174022, 0.969568223458472, 0.9816784916952453, 0.8735102450789123, 0.9421129494494391, 0.9146903128300801, 0.9516249593071389, 0.9456352359326214, 0.9556716825536167, 0.9697120592900065, 0.34421776469387977, 0.4089571731375383, 0.36687143490845053, 0.33848854905685144, 0.3805806877999298, 0.3849375316560115, 0.3617377115939716, 0.39098720278985033, 0.4044122704134331, 0.6297644718879688, 0.6596944930778124, 0.6367913248260826, 0.6554121921705233, 0.6787896362009715, 0.6874982511564799, 0.5805615255141263, 0.6208925791382689, 0.7145974472512192, 0.28310212193220585, 0.30540628126682745, 0.29098113876168585, 0.2565518409185713, 0.27559235547994654, 0.2767267222145037, 0.26805221493185705, 0.3310284952261585, 0.32376272637036196, 0.23718635329336368, 0.3849957636840191, 0.28807462216487223, 0.2772794888842951, 0.28942096066468903, 0.28875559493150416, 0.22196313513833488, 0.2809583517664882, 0.2743260601657671, 0.16919594600474053, 0.26868432509366036, 0.2160166320202278, 0.18002238649696378, 0.22103670621476135, 0.27023692150902345, 0.16524396264160535, 0.23506554297798632, 0.2593492106151909, 0.2663363935639085, 0.4352396743666457, 0.39194425845198944, 0.2787332195326869, 0.3692944786742932, 0.37664361030846927, 0.3501307601363861, 0.4338962233085092, 0.37879811396275065, 0.0609933649247163, 0.07195112261497927, 0.08138413024123181, 0.1036706424782482, 0.11129242539326811, 0.07869415991445461, 0.05710903442615689, 0.11111107970404521, 0.082431731208915, 0.17785646703807234, 0.2226858220047072, 0.22125495805706108, 0.19933837191477988, 0.23434976670028695, 0.24284610876040447, 0.18510682366893394, 0.2135541772026851, 0.23524349333823025, 0.5454895357715882, 0.5832427942796059, 0.5534747730901897, 0.5210936332017102, 0.6018864479426823, 0.6072027041820528, 0.5342454868517318, 0.5783309798999479, 0.5980282258149496, 0.10292773005838296, 0.08987353188049585, 0.0839656814763694, 0.1050546180189531, 0.09688993299862791, 0.08982812997993683, 0.08337397553836834, 0.10427355153324147, 0.099061271467899, 0.1525878686492368, 0.13657617658377452, 0.14204317391071486, 0.15966213013133201, 0.1342028446052631, 0.1388933183762867, 0.14180342236686538, 0.14182528799521243, 0.13461741886916156, 0.3051610163534545, 0.31481219021841467, 0.3308926049317713, 0.3014239386222385, 0.32892065202190757, 0.3315407857624879, 0.33984294196568565, 0.3619554948769814, 0.34868626609499687, 0.22549724989251607, 0.25273637730457865, 0.2517632883981009, 0.24531877969960303, 0.23597379952530317, 0.26853129649091245, 0.24932209102224756, 0.24960932649710943, 0.26858314807650263, 0.18118495443592575, 0.16897481378326118, 0.17565078131753875, 0.20036504878293604, 0.18726913101820375, 0.19010896247334763, 0.19116131476588538, 0.1721666934155297, 0.19859107000825094, 0.1838430046852192, 0.2635067450713108, 0.1987154150684547, 0.195076170600058, 0.19536961981554302, 0.1793113678689684, 0.1853525599147643, 0.1841202539765463, 0.20515537949907736, 0.6471724802574477, 0.444054247926027, 0.5901006538105974, 0.1750616453549112, 0.39826941831408136, 0.1607463203995414, 0.5650629213498988, 0.595434707564668, 0.1806630856842828, 0.6423300496210693, 0.6147192696504922, 0.1966515141382501, 0.31914199328472526, 0.18614634336273417, 0.1850740464612003, 0.20316995493488454, 0.7567643341555979, 0.1878325388994263, 0.18338943905264782, 0.20836253944522343, 0.18529087443500547, 0.18783663450480648, 0.18991056744030743, 0.18417496042561454, 0.18469271116584451, 0.17770879767734749, 0.19346262173475037, 0.07932855033227715, 0.07274817675586309, 0.0648107959502946, 0.06852952664678191, 0.07705551652830689, 0.0710633568352731, 0.07006230319165829, 0.07324949054066876, 0.08150000250796985]}, "mutation_prompt": null}
{"id": "6708030b-f93d-4af3-bacc-f222aea8c2f6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with global best guidance\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + 0.1 * (best_solution - x0)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Parameters and Global Best Guidance for enhanced convergence and robustness.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0f6faf7-5fd7-48de-9c07-8552a300c276", "metadata": {"aucs": [0.6851075102426706, 0.7532175431409871, 0.7392624291752254, 0.7377369205692792, 0.7476108329311282, 0.7402227693563384, 0.7103381616069204, 0.7445296075300905, 0.7635086007084968, 0.5627868150176534, 0.5404155002014581, 0.5315446536144739, 0.5263752473524886, 0.5330631059445976, 0.5795461563257895, 0.5114984588349065, 0.578053671453782, 0.5346842378198766, 0.1113532340993375, 0.11792837008460288, 0.11557521123181791, 0.10947047315757263, 0.0944477361115229, 0.11716848356860299, 0.12267071790792305, 0.13009424608016884, 0.103097164981937, 0.09702912724715862, 0.08634356457865777, 0.09285192811406628, 0.09337678531331695, 0.09315671441735851, 0.0844247676439025, 0.10333944739255896, 0.08538131409766525, 0.09597308550174022, 0.969568223458472, 0.9816784916952453, 0.8735102450789123, 0.9421129494494391, 0.9146903128300801, 0.9516249593071389, 0.9456352359326214, 0.9556716825536167, 0.9697120592900065, 0.34421776469387977, 0.4089571731375383, 0.36687143490845053, 0.33848854905685144, 0.3805806877999298, 0.3849375316560115, 0.3617377115939716, 0.39098720278985033, 0.4044122704134331, 0.6297644718879688, 0.6596944930778124, 0.6367913248260826, 0.6554121921705233, 0.6787896362009715, 0.6874982511564799, 0.5805615255141263, 0.6208925791382689, 0.7145974472512192, 0.28310212193220585, 0.30540628126682745, 0.29098113876168585, 0.2565518409185713, 0.27559235547994654, 0.2767267222145037, 0.26805221493185705, 0.3310284952261585, 0.32376272637036196, 0.23718635329336368, 0.3849957636840191, 0.28807462216487223, 0.2772794888842951, 0.28942096066468903, 0.28875559493150416, 0.22196313513833488, 0.2809583517664882, 0.2743260601657671, 0.16919594600474053, 0.26868432509366036, 0.2160166320202278, 0.18002238649696378, 0.22103670621476135, 0.27023692150902345, 0.16524396264160535, 0.23506554297798632, 0.2593492106151909, 0.2663363935639085, 0.4352396743666457, 0.39194425845198944, 0.2787332195326869, 0.3692944786742932, 0.37664361030846927, 0.3501307601363861, 0.4338962233085092, 0.37879811396275065, 0.0609933649247163, 0.07195112261497927, 0.08138413024123181, 0.1036706424782482, 0.11129242539326811, 0.07869415991445461, 0.05710903442615689, 0.11111107970404521, 0.082431731208915, 0.17785646703807234, 0.2226858220047072, 0.22125495805706108, 0.19933837191477988, 0.23434976670028695, 0.24284610876040447, 0.18510682366893394, 0.2135541772026851, 0.23524349333823025, 0.5454895357715882, 0.5832427942796059, 0.5534747730901897, 0.5210936332017102, 0.6018864479426823, 0.6072027041820528, 0.5342454868517318, 0.5783309798999479, 0.5980282258149496, 0.10292773005838296, 0.08987353188049585, 0.0839656814763694, 0.1050546180189531, 0.09688993299862791, 0.08982812997993683, 0.08337397553836834, 0.10427355153324147, 0.099061271467899, 0.1525878686492368, 0.13657617658377452, 0.14204317391071486, 0.15966213013133201, 0.1342028446052631, 0.1388933183762867, 0.14180342236686538, 0.14182528799521243, 0.13461741886916156, 0.3051610163534545, 0.31481219021841467, 0.3308926049317713, 0.3014239386222385, 0.32892065202190757, 0.3315407857624879, 0.33984294196568565, 0.3619554948769814, 0.34868626609499687, 0.22549724989251607, 0.25273637730457865, 0.2517632883981009, 0.24531877969960303, 0.23597379952530317, 0.26853129649091245, 0.24932209102224756, 0.24960932649710943, 0.26858314807650263, 0.18118495443592575, 0.16897481378326118, 0.17565078131753875, 0.20036504878293604, 0.18726913101820375, 0.19010896247334763, 0.19116131476588538, 0.1721666934155297, 0.19859107000825094, 0.1838430046852192, 0.2635067450713108, 0.1987154150684547, 0.195076170600058, 0.19536961981554302, 0.1793113678689684, 0.1853525599147643, 0.1841202539765463, 0.20515537949907736, 0.6471724802574477, 0.444054247926027, 0.5901006538105974, 0.1750616453549112, 0.39826941831408136, 0.1607463203995414, 0.5650629213498988, 0.595434707564668, 0.1806630856842828, 0.6423300496210693, 0.6147192696504922, 0.1966515141382501, 0.31914199328472526, 0.18614634336273417, 0.1850740464612003, 0.20316995493488454, 0.7567643341555979, 0.1878325388994263, 0.18338943905264782, 0.20836253944522343, 0.18529087443500547, 0.18783663450480648, 0.18991056744030743, 0.18417496042561454, 0.18469271116584451, 0.17770879767734749, 0.19346262173475037, 0.07932855033227715, 0.07274817675586309, 0.0648107959502946, 0.06852952664678191, 0.07705551652830689, 0.0710633568352731, 0.07006230319165829, 0.07324949054066876, 0.08150000250796985]}, "mutation_prompt": null}
{"id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 7, "fitness": 0.43839131272011495, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "d0f6faf7-5fd7-48de-9c07-8552a300c276", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "f5b0f8c9-9e50-4d27-aeca-414df302a666", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "e236fe5b-8680-4e7c-85c1-18413b5b8e87", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 6 + int(self.dim * np.log(self.dim)))  # Slightly increased population size\n        self.mutation_factor = 0.4 + np.random.rand(self.population_size) * 0.6  # Broad range of mutation factor\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Adjusted crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with stochastic local search\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * (best_solution - x0)  # Increased perturbation scale\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive scaling\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Stochastic Local Search and Adaptive Scaling for Robust Convergence.", "configspace": "", "generation": 9, "fitness": 0.4325727566862, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.31.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9042116463020393, 0.9208006788207301, 0.9297028762452165, 0.906549454606307, 0.9294124691416897, 0.9134365937249316, 0.911568288442813, 0.9146466943248177, 0.9347031030928284, 0.8476774522853461, 0.8892660764491781, 0.8681583604211385, 0.8370264048186533, 0.8631786212667327, 0.8748634798291685, 0.8274671813787056, 0.8947734407119483, 0.8591298917517847, 0.16475306386497246, 0.17306742840223432, 0.15876333789299368, 0.16692532110029878, 0.6746726407185119, 0.16898808693615208, 0.16246669629483856, 0.15896719198601783, 0.7807598457349952, 0.22349767711326052, 0.13181921907610594, 0.1537677822011596, 0.1473319468662727, 0.14142632467787064, 0.149646636350786, 0.14779897157546307, 0.17217217461298984, 0.12084363812096743, 0.9804939950810744, 0.9762276678406024, 0.9728900262182633, 0.970221043507869, 0.9743754828722673, 0.9780920808109087, 0.9663829426609322, 0.9730504289058725, 0.9913920330564379, 0.655440115076914, 0.7236784949045265, 0.7062474287660703, 0.7069356144852373, 0.7072027189483079, 0.7874989846515645, 0.7226562043568858, 0.7793062997399832, 0.8136068050498202, 0.7283509769967922, 0.9148977791703115, 0.8721687873324585, 0.8323820154908315, 0.8637024365004837, 0.8649387015106278, 0.8167031894161166, 0.24173068817056287, 0.8934230609126983, 0.48432956470857313, 0.5899432681864638, 0.5751421140413004, 0.5176982881479228, 0.6371041331058231, 0.6134138239619997, 0.5417405897789354, 0.19196823765829885, 0.5789203056423552, 0.009802881093252891, 0.20419224251880264, 0.24969900446718774, 0.5255581365072075, 0.5334047415261476, 0.7438051993898158, 0.4398630088768173, 0.5240649611066954, 0.36994195310578715, 0.1356116441787204, 0.18221417995310396, 0.06982840097742005, 0.06729630642416373, 0.1972400814159977, 0.14208114807777805, 0.1510125828703418, 0.18058719812968227, 0.14670452338379292, 0.17236371593647204, 0.12617380051454952, 0.17557677703990815, 0.14591563199363866, 0.15196080326611094, 0.24815997632547648, 0.1832912369440639, 0.1248412217122179, 0.2460367179143924, 0.07979024916975308, 0.055707804184621845, 0.07430158348832483, 0.22177721345378076, 0.23294995704606514, 0.22256248990293803, 0.209555984755056, 0.12545502176127865, 0.08805253206701946, 0.2285415019152155, 0.2669961012310277, 0.33175981178880143, 0.2771040133258297, 0.2907790872803834, 0.3427358649739073, 0.22605361937273516, 0.3424155739261343, 0.30353262396651304, 0.6240641337789183, 0.6761434557508386, 0.6529580126899078, 0.6347155241344358, 0.7120339673182869, 0.6947385521396607, 0.6569152859158534, 0.7427139057656347, 0.6919247453454345, 0.1117644175280833, 0.11484034819782285, 0.12573184580900965, 0.09882702432132395, 0.10588033695544785, 0.12559042027669343, 0.09609846219053109, 0.11373087227430645, 0.104617617081053, 0.1613087857658333, 0.17734397766837973, 0.1624605559816782, 0.512631418180274, 0.2226122327661596, 0.17549634038563477, 0.14979049600283068, 0.2700602858039637, 0.16722940266428, 0.570503333044938, 0.7207812476439613, 0.5257459428321873, 0.5209085427631643, 0.7059817988863448, 0.6579526536376357, 0.5401160854987272, 0.6226149807059622, 0.5818607216283285, 0.2705095244008796, 0.3045064410330116, 0.38734816308160425, 0.3365976944711955, 0.4434470460519463, 0.4225941086178129, 0.42960458877430896, 0.431955373617696, 0.546190540774426, 0.1844231404761204, 0.216631209401268, 0.18610478246823636, 0.17974401324162192, 0.18360575121384415, 0.19387530023148203, 0.20019759659402048, 0.1782382974194714, 0.20573812264029612, 0.6903550513632329, 0.24134093111471844, 0.7934602048856888, 0.7080503680207708, 0.6258985440095746, 0.5796760720672833, 0.19656287327147248, 0.8350429814839252, 0.71970505639928, 0.15314853065502199, 0.16487414873163775, 0.9059733378665693, 0.8348227660308455, 0.1786841186184862, 0.16852861391657137, 0.8184796755441941, 0.7631288817643139, 0.9055106659221314, 0.19839031226342174, 0.15521628319772152, 0.8086429610248318, 0.8024141996932408, 0.16596876638548075, 0.2095364818117431, 0.7670001244112452, 0.11317573693029004, 0.1569941543458082, 0.19515968483238544, 0.17647665143226898, 0.1838787716323369, 0.18341078313898684, 0.18257029834926075, 0.18006718434389601, 0.18557245290903435, 0.20200761771005626, 0.18968279940446053, 0.07282305015218205, 0.09594158599992042, 0.07461679649849395, 0.09046155290020885, 0.07850561586868154, 0.08432592338417999, 0.07320023011732191, 0.08141035506540595, 0.0792266908429099]}, "mutation_prompt": null}
{"id": "0430bb23-b750-47eb-95fc-20e250d9f916", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "24525586-3aab-4da7-89ac-982677efc4b1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.laplace(size=self.dim) * 0.1 * (best_solution - x0)  # Laplace perturbation for diversification\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size incorporating Local Search Intensification and Self-Adaptive Strategies for Enhanced Global Optimization.", "configspace": "", "generation": 11, "fitness": 0.437217041229836, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8971565196655908, 0.9169821264405318, 0.9137855373759479, 0.9035780266420408, 0.9169362747100716, 0.9312050614576058, 0.9015633526378051, 0.9222066266476794, 0.933997492372808, 0.8354295865272658, 9.999999999998899e-05, 9.999999999998899e-05, 0.8569654130052067, 0.8799133092836906, 0.874427978681414, 0.843164821613507, 0.8965476303636812, 0.8731570846348633, 0.4551742360071739, 0.7913950371215204, 0.1647344959889866, 0.2165823860930538, 0.1309938555925806, 0.5285119697082543, 0.11544980447417963, 0.6402856635409753, 0.15809635595373295, 0.12522190319716087, 0.13176514627393954, 0.17728327466995164, 0.39211289565818863, 0.11782924437982878, 0.12998729114853436, 0.15667523862258714, 0.14858222569266677, 0.11234770201081046, 0.9826036991278074, 0.9752375596436134, 0.9602305467189015, 0.9783542070973164, 0.9692247282902591, 0.9775054328481773, 0.9713015849876228, 0.9821511732019444, 0.9614146408874298, 0.7530248446702054, 0.8064856964965563, 0.7835287687237377, 0.7481278754990005, 0.7548100908783734, 0.6529878051582276, 0.7238775549971499, 0.7185697404309694, 0.7474543484778458, 0.8608181903079611, 0.8927776111528454, 0.8874989698894729, 0.8377525408309372, 0.8989256831695006, 0.8896940408183038, 0.8585342186160266, 0.9102143957900622, 0.880067091305079, 0.7180368159845059, 0.1361279745810975, 0.21225872812799007, 0.6718073911317265, 0.13393704413293306, 0.2636774398909243, 0.6406645040170724, 0.7437844762719483, 0.38674173057268535, 0.010030569848810567, 0.30748552286450626, 0.20228795110371878, 0.6709910857327842, 0.6950350793162409, 0.6784675162529534, 0.6393239746972794, 0.733584610821506, 0.6314003817854625, 0.17278753371807432, 0.26550907760715514, 0.2376381127560978, 0.17027540860962997, 0.028508088842914003, 0.14964615772655165, 0.22332253704864102, 0.09602137167352143, 0.27979208942428313, 0.1864364980055031, 0.21646952020639953, 0.2871240652204472, 0.16679006854635392, 0.14977066643058334, 0.15171735006520448, 0.18188245245239465, 0.39461146125059776, 0.11991727932640939, 0.09077162716764142, 0.3156555611959321, 0.09003404753764477, 0.15945851789503906, 0.28118943353968684, 0.20291877635986344, 0.19927515004676888, 0.13771108717375025, 0.15733286422365322, 0.333297893015829, 0.3838528166620385, 0.3353863801228425, 0.30535346091590176, 0.3815498085185437, 0.36079694841894705, 0.2994814217276165, 0.3554848765962325, 0.34049041365978994, 0.6453913985666042, 0.7592401754006597, 0.7133075069025574, 0.7058155004767386, 0.6675176831411213, 0.8156759315328495, 0.7608675598516808, 0.7282409726437011, 0.7674964502185762, 0.11978099628485361, 0.11119553870325305, 0.10995346742361722, 0.10182689669981704, 0.12574876018182457, 0.12176007129349331, 0.09337265322432609, 0.11769142206997618, 0.10531371756543717, 0.6064260662450636, 0.160371332728662, 0.14369630754603435, 0.3903473035978332, 0.2835768772636388, 0.16989652078367457, 0.25328397879183306, 0.47057008665973976, 0.14832874307098864, 0.6413513135051447, 0.21051494036707774, 0.5579729002505689, 0.5746132760999612, 0.7478107602581126, 0.7588829292782328, 0.6636416244523864, 0.6176454613904878, 0.5976008096595072, 0.4278381280122461, 0.5445442353680429, 0.5102602321084914, 0.336647253342647, 0.511417250514064, 0.446177908745775, 0.4840827088516272, 0.5588081801917688, 0.5671311873304886, 0.19467458442291685, 0.18589857572372126, 0.21072150167540815, 0.17266408894350438, 0.19816742740080795, 0.19444494560874914, 0.2349860923940068, 0.1885549497727651, 0.20581975606473435, 0.2444994992599907, 0.2197593513999736, 0.2168327058245042, 0.24477849360867043, 0.21319371665846343, 0.24062568104723325, 0.23249187039929198, 0.6430066503447297, 0.2064879811996957, 0.17111320428626442, 0.1959613062766099, 0.1646376837273963, 0.8765648795484616, 0.8618686136733964, 0.8959178112989751, 0.8735790008682738, 0.17105470617558405, 0.9082323079270753, 0.8670225332564703, 0.16930529154522012, 0.16889752953175918, 0.7684797933478731, 0.8711093640136066, 0.20949427364893602, 0.2113186046690425, 0.2138982854039847, 0.1677102491677137, 0.17936202581731997, 0.1661783034683687, 0.1910765960115992, 0.18313010869706847, 0.19448041200345867, 0.18589004589514857, 0.18848077794721096, 0.19778449943478638, 0.18051208947077468, 0.08910481725651698, 0.08682211155117658, 0.09293796877019433, 0.07207701041094627, 0.07677695028992892, 0.08773085136486647, 0.09032862802403929, 0.08940105165363421, 0.0820760998347616]}, "mutation_prompt": null}
{"id": "2b26087f-8500-4882-84fc-644f5fc9ea67", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "7289e9d4-f263-495f-a51c-81bd564545bf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "ef632906-02e0-4a0a-884b-4bb1e4547e64", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * ((x1 - x2) + (x3 - x4)) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategies and Local Search Variability for Optimized Exploration-Exploitation.", "configspace": "", "generation": 14, "fitness": 0.3113730546980494, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.7788421554100365, 0.8479224930431606, 0.8633478047224582, 0.813354144357147, 0.8726394619237876, 0.8846218548089606, 0.819773784355667, 0.865081426610012, 0.8772884473504065, 0.6640527407413368, 0.7656046950744512, 0.7703918620423124, 0.6591170694326255, 0.7985400659433428, 0.7553535399479059, 0.6515744029729349, 0.7718638139774208, 0.7891097912296342, 0.10457820530835393, 0.11648698989535367, 0.11601402196786381, 0.08659459927025037, 0.10705527124693415, 0.13432241101899833, 0.0945711431175208, 0.09956053034781764, 0.10739708367566858, 0.09260429288213601, 0.10235907549731038, 0.1081474793282321, 0.09441211005770078, 0.09592827375625546, 0.11227811600478521, 0.09623145571080471, 0.11450934317429728, 0.10256018960950497, 0.9919224542630973, 0.9686427239953223, 0.9756203546406242, 0.9831909283296563, 0.9616522087692156, 0.9868919580337742, 0.9847278305218301, 0.9813163444350252, 0.9810568319852861, 0.4141592625162597, 0.6075112266388727, 0.6411247576166278, 0.3958154127008382, 0.6381797212459608, 0.5471334935815916, 0.43719260965339, 0.6231549616854131, 0.6149334332914513, 0.5681993568623983, 0.6634945253221045, 0.7053754422357089, 0.6146367226611474, 0.7808731347732781, 0.7143461692701898, 0.5854328982641082, 0.8269957833720171, 0.6846677665867684, 0.21921406047965875, 0.3769278860893911, 0.2759119068986674, 0.19891697548605203, 0.37668467598588107, 0.3747931728758086, 0.26008245299305466, 0.3613227838755161, 0.3303544935950996, 0.18716694928090183, 0.05460311099234316, 0.2494027051525589, 0.30591064917459065, 0.427258790527678, 0.3277545572954611, 0.1900485803631219, 0.43988205443397044, 0.34044481580154595, 0.012693812643961744, 0.023699415217306008, 0.07091697755099735, 0.0068186550779594235, 0.04229060939043339, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489751807066476, 0.051582116857394666, 0.06692390660516434, 0.08528812708063793, 0.07161851527373042, 0.049360564166889165, 0.094337061051178, 0.11097981704708959, 0.06715217872461798, 0.06044749159292351, 0.06904221519453568, 9.999999999998899e-05, 0.031694430211869795, 0.011991919618972835, 0.029269214972073132, 0.011019660626084393, 9.999999999998899e-05, 9.999999999998899e-05, 0.0383852106135506, 9.999999999998899e-05, 0.042034933523990015, 0.22000103849268127, 0.1776557766767366, 0.16593776373665114, 0.1962966268625259, 0.1710953595484903, 0.13229251288296107, 0.19973767038333845, 0.16069182480097044, 0.49776129871536945, 0.5577483157695626, 0.5528370667114796, 0.5108069412581704, 0.5816616379692351, 0.5523112731047057, 0.5186700310950997, 0.5787550132953055, 0.5972398192524382, 0.09110455116712068, 0.09662554028846693, 0.08200383170944092, 0.07827008322592033, 0.08360394762408307, 0.08172764699593826, 0.11251683202040952, 0.10191545458283058, 0.0989601034463542, 0.1565842935781322, 0.1372985836645506, 0.1582261662723331, 0.21525324249535305, 0.17666327619755973, 0.12521646700862055, 0.14335888297119692, 0.14076142973718508, 0.24972122278537334, 0.276115888970894, 0.3654185361912129, 0.35961793377585916, 0.2783379143161051, 0.38691579542741206, 0.3147880636136198, 0.2977064235806741, 0.45575202064363696, 0.4058554214193071, 0.1990725742916235, 0.26702355874620887, 0.2333530047943999, 0.1900929819015006, 0.24618488244230052, 0.25304859151618386, 0.24504310395903284, 0.3231024596259755, 0.25868734467343946, 0.19353981070261317, 0.18135040196688113, 0.1821541146205249, 0.1821838148622269, 0.18398062251894698, 0.1902288837792243, 0.16618870359937377, 0.2036779066999802, 0.1767597089137245, 0.18562818174073548, 0.19153727529423126, 0.1970306142990509, 0.17995317492465934, 0.1748863143211007, 0.18230945463446768, 0.1734178538187231, 0.2046600955166018, 0.1861719114839646, 0.18738791755278705, 0.8215440396678371, 0.8062353326405458, 0.1498494481970567, 0.17420578611112814, 0.15223338404304554, 0.15617010473940263, 0.3494776753902731, 0.1589412611556329, 0.1613839122280376, 0.2032835054738953, 0.18338740004347587, 0.21645405913190674, 0.6145559068116111, 0.19056921552198902, 0.21068757090648926, 0.1976215676093046, 0.2123982815423947, 0.18691703865399556, 0.18004394827925174, 0.17723008025216802, 0.18330680427056745, 0.18696129627761204, 0.1859459087772548, 0.18850621192107286, 0.21335582824740718, 0.1840330078381015, 0.062019012823591235, 0.07017984587958603, 0.07573412788566514, 0.0683890083266091, 0.07447099721925754, 0.07527958132870483, 0.06799892099434346, 0.07047486858808805, 0.08419665705690316]}, "mutation_prompt": null}
{"id": "088f9bfa-bf16-4046-b0a9-65ad400c8336", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "d4cd79c2-0f9d-461c-b560-f92bb405bf1a", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 6 + int(self.dim * np.log(self.dim)))  # Slightly larger population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.6  # Broader range for mutation factor to increase diversity\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Adjusted crossover rate for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with enhanced local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - self.population[i])\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Enhanced Local Search and Population Diversity Balance for improved exploration-exploitation.", "configspace": "", "generation": 16, "fitness": 0.3668255573568974, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8766099657576543, 0.9174289187239086, 0.9120593589173523, 0.8727608473215993, 0.9044121803411344, 0.9024583736372198, 0.908614238239801, 0.9089668966025846, 0.9182006731275324, 0.7772951902936327, 0.8511040309119791, 0.8375957669639822, 0.7843090694124926, 0.8324361044382402, 0.8480318602865894, 0.7905334966527535, 0.8644176621916155, 0.8567401904033534, 0.14260967161400184, 0.1792793504127076, 0.4365592945278639, 0.21212503342172562, 0.1676032015349498, 0.11749355176024567, 0.5454419887784809, 0.16397827153734001, 0.21471961068022416, 0.24512816412369887, 0.1293715039784762, 0.13508437619176383, 0.1860361024413818, 0.1302595622019218, 0.4800123608213327, 0.1515484035682928, 0.47652622059343885, 0.12456076469195754, 0.9399986545173554, 0.9628331695796694, 0.9711820373682584, 0.9758998930067216, 0.990756784666076, 0.9777278409771141, 0.9554917202180676, 0.9463405415701039, 0.9910230817506125, 0.6607590855562169, 0.7427705920811665, 0.6203004890158492, 0.6278759493898789, 0.7522952561842907, 0.7388769847100528, 0.7076587048874841, 0.7565621242670199, 0.7373449793955787, 0.7893348331150307, 0.7760015270859587, 0.8339437015544783, 0.9038366511688455, 0.2119004955964936, 0.8693894814873853, 0.8253103686111725, 0.29094048880567525, 0.8267249015487452, 0.3445667323996269, 0.5054162386303171, 0.46049442698043264, 0.39270679456827395, 0.4902707591115051, 0.5095630170321551, 0.4192598681075915, 0.17403177484252041, 0.47156379435120543, 0.13541015023240865, 0.32650254102168663, 0.365034738885901, 0.4010165879794244, 0.5510219410177466, 0.456305332724143, 0.14800179031495175, 0.4358249980793656, 0.3802256374316497, 0.036167188260018523, 0.04939759170373892, 0.05167254470880511, 0.041665598689004435, 0.017736513900408313, 0.02835345930631683, 0.008699623565823655, 0.03705653232101125, 0.001005134561558041, 0.09172642429215228, 0.05621385039012161, 0.10560347624354838, 0.11583888414831378, 0.10514953067262578, 0.08855892219385475, 0.15749541991336868, 0.0857951054084447, 0.12683425040317997, 0.044686282448559544, 9.999999999998899e-05, 0.03012393638903743, 9.999999999998899e-05, 0.01950989762375588, 0.0029004829473938676, 9.999999999998899e-05, 9.999999999998899e-05, 0.06349721625943894, 0.18846344531381287, 0.18228460009494785, 0.2091485106617087, 0.19737686754927708, 0.2173324888098126, 0.22996471716249767, 0.19049625811286408, 0.18823139072320272, 0.17044924415737628, 0.5715648032627808, 0.6052388966443507, 0.5894150374666791, 0.6030621786826114, 0.6556316698741309, 0.6130596889858915, 0.6100304226756534, 0.6586965196640981, 0.6498007648679408, 0.10201075027360562, 0.09594078454695265, 0.12286968838698142, 0.09642581109454074, 0.10630559559282193, 0.09806972548336057, 0.10463212846848624, 0.10798874793431823, 0.11780801019663012, 0.13790133020148299, 0.1433145197854495, 0.15453522708440437, 0.18136809983222735, 0.15368252421664597, 0.15775567888790287, 0.2059679553073358, 0.10916569051474256, 0.1770472058780126, 0.41738275326457785, 0.5621450609738412, 0.571622368753206, 0.38787033082727496, 0.6065676416944705, 0.597496048230677, 0.49888395474112046, 0.705322724106179, 0.6551489754221143, 0.2633525312864141, 0.2721115673805763, 0.2264704489497793, 0.24191847492995955, 0.3227738069086836, 0.39363998602418016, 0.3570563909867691, 0.4197384484489034, 0.41443177818757126, 0.18392266746477637, 0.20329149884438857, 0.22536309471043425, 0.19591036373927617, 0.18765717381916613, 0.1829015266323346, 0.18675952833209808, 0.18250167704404874, 0.20566962235980213, 0.26078250514513757, 0.3541674545962964, 0.5161035865839229, 0.18073936853765316, 0.2681182314762295, 0.34141176354970737, 0.18458642999580022, 0.23833819416926239, 0.2107677552251478, 0.16424094331155725, 0.1948501567669899, 0.1633824423154272, 0.18416351792772168, 0.19150199414590485, 0.17817699780075524, 0.18287853121213282, 0.9015901872025928, 0.8584435269213961, 0.20598802631714141, 0.1681272325307589, 0.2088870762367253, 0.16621545507779534, 0.7123826019326418, 0.20982336216050423, 0.2803099309771395, 0.2089859605381279, 0.15618848352056047, 0.18718694958793936, 0.1824645989649828, 0.18158745432225198, 0.1821148524898314, 0.21168074977098028, 0.17520261380313606, 0.18027374550895658, 0.18902562644238796, 0.2006290872891313, 0.07893977279077191, 0.0816084953208529, 0.07927305913980398, 0.10222618926689231, 0.09017006824222573, 0.06547170453619433, 0.08957552107023681, 0.08860169257035411, 0.087491484059806]}, "mutation_prompt": null}
{"id": "97cf5b0b-33f8-4ec2-b43e-27bfa98db23a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "784eeef5-547e-4459-af23-a148a6e28877", "solution": "import numpy as np\n\nclass RefinedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.4 + np.random.rand(self.population_size) * 0.6  # Adjusted mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Adjusted crossover rate range\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * (best_solution - x0)  # Enhanced perturbation\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "RefinedAdaptiveDifferentialEvolution", "description": "A refined Adaptive Differential Evolution with self-adaptive parameters and enhanced diversity through perturbation control for improved exploration.", "configspace": "", "generation": 18, "fitness": 0.3830461921200893, "feedback": "The algorithm RefinedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.30.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8940052407534685, 0.9421841377517732, 0.9354908503785763, 0.9024353568495534, 0.938554024929296, 0.9400846386404571, 0.9251210952758596, 0.9426994025312554, 0.9351892270533414, 0.7657517158547155, 0.8982367070875816, 0.8877576938798623, 0.8444005402738792, 0.8813159267254568, 0.9096541311932751, 0.019366282388224354, 0.899802268371644, 0.8837369701500903, 0.1672677882195761, 0.1422003959086955, 0.17145902815268765, 0.13617934749616722, 0.11119121090266748, 0.6117511522232532, 0.5788483271651124, 0.1293721884122191, 0.13799545158674043, 0.13219776515870252, 0.14712584573692622, 0.5348766615453254, 0.14934041148311028, 0.1788293814029488, 0.15382410831356141, 0.1373587064867805, 0.1558043106899507, 0.1500299591751003, 0.978631502462025, 0.9641933288121208, 0.9688059202100697, 0.947863687460608, 0.9641924222574249, 0.9658655062636912, 0.9531121649908321, 0.979214847789298, 0.07479526696043581, 0.7666639767686817, 0.8142006384492936, 0.7660242664298778, 0.7202386627450317, 0.7681592148389699, 0.794069827497933, 0.7787778671382374, 0.7609546961521263, 0.6516199169711945, 0.871226938087651, 0.2123166355433782, 0.8958710615371313, 0.8719516895258862, 0.9440262343466431, 0.21292690457284724, 0.7996871341129806, 0.36543611755016514, 0.2293087994651396, 0.5756090389424959, 0.16737148625167297, 0.23375271732976521, 0.579313583931947, 0.16776404810241297, 0.13564190084806937, 0.5732964934712395, 0.18425847899267211, 0.7590718513628614, 0.12482558947921718, 0.15580167640809173, 0.1924635857233199, 0.5988729521819303, 0.7921160852329621, 0.21098407229378457, 0.5314775359728281, 0.7544663991394458, 0.20756138951165393, 0.1124992516929122, 0.05382285085184724, 0.2047012622397283, 0.11557587898233523, 0.16535451278828261, 0.14302778235713232, 0.07072638607031512, 9.999999999998899e-05, 0.07610124134004814, 0.2451238666402361, 0.09992851219152965, 0.10750900516886608, 0.17840937402074308, 0.09195861030092034, 0.1638417325575594, 0.1755706167401171, 0.2656810317289081, 0.27120633862942445, 0.07714337980433794, 0.16059973786639403, 0.09079744187433392, 0.10742096190717854, 0.2117262641605131, 0.2645802609038638, 0.13479637666744237, 0.3159242047927674, 0.13838623521375104, 0.2891040078197987, 0.33256594873824064, 0.3466560793281799, 0.28765440795355546, 0.3508190974873525, 0.3348858048632426, 0.2428716627622053, 0.32764278216193865, 0.28842608443552575, 0.5929039191180996, 0.7531510668332821, 0.7226905078110855, 0.6672299829112662, 0.7480609586669638, 0.7856145779024211, 0.7008232341895797, 0.7426701873913463, 0.6838264163057766, 0.11459454183854811, 0.11763539379366106, 0.12763931215945123, 0.09887896525837625, 0.13477710369659146, 0.11243026901297126, 0.11083480576939042, 0.12563127390576267, 0.10171735432658346, 0.15153208087699188, 0.19423862313087714, 0.18500280073166664, 0.15158265544982064, 0.2316409947864917, 0.15300896500470096, 0.11664614959241626, 0.1587889383117368, 0.1768029486089303, 0.4769046316992176, 0.6905693044906107, 0.5388958998628292, 0.6513715130350863, 0.7889455104484588, 0.7217263272646842, 0.6535851274501328, 0.3698010393545008, 0.7528247623471591, 0.3691668054966972, 0.31308599185926667, 0.30517678542676074, 0.36334630356777087, 0.33317361922955546, 0.5818413490774305, 0.4424816472091012, 0.653035188471573, 0.5386054461377883, 0.19180683339648408, 0.19691253425404343, 0.20787196246729356, 0.1976176625227406, 0.19733212097666342, 0.2231250995400601, 0.2119033604752174, 0.205442312321788, 0.19480175859032267, 0.21463213030896833, 0.18329020703535248, 0.254510159197079, 0.20920737696266456, 0.23451462197520145, 0.23696685556949082, 0.19329371939969775, 0.24561615492618472, 0.6804741597492541, 0.18590822952863517, 0.16601174402110375, 0.1597421907753156, 0.1759740076239854, 0.8823395886236465, 0.8308588282448625, 0.16954867082161984, 0.17075991312871686, 0.16181085119884175, 0.1088154364265651, 0.163290328529336, 0.16107130724137864, 0.12537462418891865, 0.21161996057539356, 0.20875588469700013, 0.21073678694321396, 0.20358589346606404, 0.12724037120008547, 0.20390805877124363, 0.1934105459132337, 0.18807156015728965, 0.19267648085194844, 0.18037599729154696, 0.20442339535538967, 0.16838534920571124, 0.18419749277318664, 0.17451857556257, 0.09071550747257695, 0.0906953246296156, 0.07966624689918822, 0.07248086148261446, 0.08180513070433171, 0.08565566291272408, 0.08062662305871404, 0.09401673152988077, 0.08533166934550773]}, "mutation_prompt": null}
{"id": "4f3c0ba2-dd84-4edb-9ae1-899837f20894", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "257cee63-05c4-4f03-aade-bb41f720914a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "059a3635-be17-454a-875e-81aae7e4ee83", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))\n        self.scaling_factor = np.random.rand(self.population_size) * 0.9  # Adaptive scaling factor\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Broad crossover adaptability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Stochastic Mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.normal(0, 0.1, self.dim) * (best_solution - x0)\n                mutant_vector = x0 + self.scaling_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with enhanced adaptability\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Scaling Factor and Stochastic Mutation for Improved Global Search Capability.", "configspace": "", "generation": 21, "fitness": 0.22926688197073794, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9399935570263378, 0.3544370470192897, 0.2592835494823281, 0.910209235158667, 0.39850464909687944, 0.3399060098607861, 0.9427516597462731, 0.4054682047055289, 0.13930847407797697, 0.32369386642454023, 9.999999999998899e-05, 0.0775316708824022, 0.2702734467937423, 9.999999999998899e-05, 0.15579992517171926, 0.8979461330469505, 9.999999999998899e-05, 0.2080082882423261, 0.09433789694705941, 0.09405157246225193, 0.08695644519059553, 0.6250342042235532, 0.05042615389151395, 0.05595027923203455, 0.13021054930733733, 0.09640328503158146, 0.11309344574997504, 0.16678722097050647, 0.06487607795094263, 0.09522173970021852, 0.11089984883425963, 0.06423423122021554, 0.11804418021003871, 0.169733183817948, 0.06411865302567099, 0.16136659318373403, 0.9617406522807205, 0.10121421533081831, 0.40553863637512766, 0.949113749495066, 0.3569372240314287, 0.07633474533849294, 0.9586821002191437, 0.9796589658635971, 0.410855197898892, 0.5952024861862367, 0.07767445260705241, 0.06145263857606664, 0.3105896309546752, 0.26293243892007223, 0.034459853658259654, 0.34060198144119236, 0.14068613341420533, 0.0807186613593478, 0.2274660459944322, 0.17764011278368785, 0.21056625448830624, 0.9075982114044887, 0.16193530928457545, 0.10694761052771862, 0.2293981338879224, 0.17868765460243285, 0.06384174607678328, 0.1796498125218401, 9.999999999998899e-05, 9.999999999998899e-05, 0.14422604790920868, 0.16064766254638685, 0.1423475390351132, 0.15333909199486662, 0.18151311378873292, 0.031436614646144556, 0.4849391012863389, 0.15918646211962928, 0.1311448648269008, 0.13801777548293626, 0.08010934375280199, 0.1409740040889481, 0.17969598801297126, 0.18180787950349997, 0.1325661634800026, 0.202815639030554, 9.999999999998899e-05, 9.999999999998899e-05, 0.07415570363449697, 9.999999999998899e-05, 9.999999999998899e-05, 0.10432699656848798, 9.999999999998899e-05, 9.999999999998899e-05, 0.3336120814952592, 0.18802431348792525, 0.07165121890439563, 0.16632791680456815, 0.12427980060652155, 0.08093117927641069, 0.2536081692891481, 0.05232859145114577, 0.11761108452518088, 0.12332720754005, 9.999999999998899e-05, 0.10790082197943252, 0.2098222515307281, 9.999999999998899e-05, 9.999999999998899e-05, 0.3137541054889642, 0.07876480344546566, 0.16900837125788093, 0.3611567603502649, 0.07296607268524147, 0.021211097607558127, 0.32290437454337084, 0.04211380827378275, 0.059417448307685694, 0.29919602244430765, 0.2316518502795376, 0.24528038140142272, 0.7686072426282043, 0.2728783841454929, 0.4127431367128438, 0.39456962191048983, 0.2400323932741285, 0.4583746220288495, 0.6537426888948079, 0.29546127836666203, 0.25376969110610337, 0.15205179884589015, 0.07019100226583619, 0.11613685366387838, 0.1324401000936143, 0.08426906964948344, 0.1346466187196802, 0.13188864616721507, 0.11571537268657683, 0.13252093515998353, 0.6297912471208928, 0.18614934786046966, 0.22741342682297028, 0.18426581544140397, 0.1656304530202164, 0.15487439837170636, 0.23875069292293039, 0.4106190696642895, 0.22811375452592664, 0.6769598455523033, 0.2688280098639332, 0.25216687420042894, 0.4920183868986002, 0.3016640041126316, 0.25709169061570514, 0.5929075298076764, 0.22786854913135646, 0.3218404056878953, 0.3890746704240333, 0.1695005007534326, 0.2892543239637717, 0.5537537338810659, 0.3036279867230395, 0.24743629380648013, 0.5086844938761284, 0.17729228460591662, 0.21237902556147015, 0.20720763043671941, 0.22408537967019215, 0.19650341161866003, 0.20611655227691705, 0.24421421341256278, 0.18093237079365887, 0.20022690258196973, 0.21191418254191008, 0.2221320515743086, 0.23017260958478492, 0.2571805292365412, 0.19883105695809433, 0.2267665747374954, 0.17269712520415947, 0.1799589702245039, 0.2174725646732355, 0.2059145119858713, 0.2532307305846584, 0.20659188713023158, 0.17480295926270006, 0.18606922429330475, 0.16492931054617588, 0.16618429478394214, 0.16667792869098008, 0.1660649422007816, 0.16904130344959067, 0.16951257430574374, 0.21350253604823577, 0.22730016728566171, 0.4909986215952772, 0.7661406553384451, 0.32555688613634093, 0.1668361137708505, 0.1863489589307631, 0.17298280286567913, 0.16952930595822513, 0.1811485012578462, 0.19194158534089, 0.1779670201963912, 0.18448395578068755, 0.19022699831947998, 0.1880058425816784, 0.19116612337787964, 0.1856812465940929, 0.19195716205066815, 0.07574402958899118, 0.08971155438969036, 0.099166966180394, 0.09446911698088167, 0.10344185395982963, 0.10642888030874242, 0.0824149850143513, 0.06559972625636168, 0.1049811873829174]}, "mutation_prompt": null}
{"id": "09313731-b8e0-4af3-a1d8-6221e1110fe2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "bf7c8585-efd7-4c20-acfc-52576f4ca09f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "7727cbee-25a8-4a7c-93da-fe86981d184a", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.6 + np.random.rand(self.population_size) * 0.4  # Adjusted to improve exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with enhanced diversity\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * (best_solution - x0)  # Increased perturbation for diversity\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with enhanced rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Parameters and Incremented Diversity for Robust Solution Exploration.", "configspace": "", "generation": 24, "fitness": 0.40325150758461925, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.30.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8839560985504658, 0.9336362172401506, 0.921725809777352, 0.9096819662994965, 0.9261227650628168, 0.9345137448945275, 0.910570151341318, 0.9198199337471415, 0.9246523333094199, 0.8222283979369018, 0.8245826638360569, 0.859351505879324, 0.8175027784327706, 0.8774358153532774, 0.8679029855861885, 0.8149052830163785, 0.865731664344619, 0.8932292618073187, 0.41692382360542835, 0.142157237275351, 0.17215170387607193, 0.179689415501194, 0.665268845868533, 0.7209858981462952, 0.15474762790512453, 0.1761745420664369, 0.6641841338161867, 0.169437512897462, 0.1406632914360394, 0.15670914087879595, 0.15362922843454907, 0.15694955193236126, 0.14834409208873844, 0.3696358349742712, 0.1530685737715377, 0.3684108424927718, 0.9815843567898849, 0.966142055061352, 0.9796239802596954, 0.980163159174243, 0.9815940272989776, 0.9799834652808739, 0.9683004651254229, 0.9767511216417346, 0.9935824012107363, 0.6930725700513856, 0.7547389579457284, 0.7500797305170605, 0.7224002028842769, 0.7857935711535232, 0.7796356856807964, 0.713833407722329, 0.7979213572077248, 0.7192113471762069, 0.746851042138685, 0.7929337962538827, 0.8306345135457515, 0.8486100087527632, 0.8745714177667341, 0.8469804954926229, 0.17849591372383222, 0.8513100514833771, 0.7747987670556746, 0.4106667807577514, 0.16974152124391562, 0.42872891695072357, 0.4548865607911342, 0.4821094437725838, 0.5076029382985141, 0.49449243738283477, 0.5799625808983371, 0.5825653838164151, 0.022836796360813927, 0.1318818024580647, 0.3246676409365411, 0.4742442765197534, 0.6329915100800526, 0.5077446171955526, 0.35876590604226855, 0.22608554678614945, 0.4703553555392235, 0.07353567782977555, 0.15219254098445234, 0.13187046026325955, 0.06779157206259356, 0.15958829871116287, 0.14443332206632298, 0.0740959921470683, 0.24276424271391028, 0.12402697193635015, 0.17701040625673592, 0.1817404867631479, 0.13063297986266775, 0.1910049446527512, 0.21849695322841178, 0.15540541052942913, 0.12165128771665545, 0.15311987661587168, 0.11401058320324631, 0.050242739283513416, 0.07406089551635264, 0.046050760267386304, 0.11894222889738626, 0.16414663049905198, 0.12590526652785994, 0.06257349359762499, 0.12971880471161235, 0.1284681661704522, 0.23941532327392623, 0.35649843540599746, 0.26566734714046425, 0.006591385364355884, 0.2927007681745476, 0.2308928142218789, 0.19995492498668976, 0.26114727851899744, 0.21046411032478685, 0.6249421609975823, 0.6471607190348945, 0.6548832439960437, 0.6091429036391259, 0.6679525447676021, 0.6575695152122704, 0.6481651052870648, 0.7032067577361443, 0.6530018850821022, 0.11013510360177681, 0.15502281303515797, 0.12052637997303295, 0.08250255126026917, 0.10935708237050734, 0.12370140638623162, 0.09393474711154137, 0.11562705150698716, 0.09068093787687104, 0.2778723459784578, 0.2764902316006681, 0.14811314079243998, 0.153382798650467, 0.23977269167776571, 0.2719858963068905, 0.21954642044267192, 0.3198423723427024, 0.18900870030120953, 0.4565894697984302, 0.5084290693505855, 0.5054388770813132, 0.5216608951271832, 0.5820374060970762, 0.5819864616520827, 0.594204197052116, 0.7612878134578952, 0.737748490102758, 0.2778190430573212, 0.40561181283786796, 0.3380193046262371, 0.3608315419472973, 0.3250054483135776, 0.4006552028523792, 0.4156655994377776, 0.4606013773252492, 0.3812152359113139, 0.19066002166277662, 0.20070226153628812, 0.20728994573410098, 0.16686775289524225, 0.20360082136059077, 0.19529124812105625, 0.18149352620580306, 0.20760107364434188, 0.20007933747644713, 0.4441022753747821, 0.24003132142301187, 0.22127106474801939, 0.6361439984627648, 0.6392421701831248, 0.5991160369914981, 0.2410111915086991, 0.8322382500740882, 0.7294179685641835, 0.16754375535912058, 0.8880540034200779, 0.18628655729280286, 0.16212401745120475, 0.1638488544871438, 0.8926488755338354, 0.15996581993637715, 0.170728195488151, 0.19537199494605217, 0.12751416387733427, 0.16645278077953496, 0.16695250004893059, 0.16263794115726593, 0.21032414608187888, 0.21015859344904997, 0.2081863840508935, 0.19928168710424177, 0.16536749629091652, 0.1960191902113947, 0.18320758607533327, 0.18865384938049, 0.1981078801821976, 0.19170418903010844, 0.19178540850619108, 0.18518115234291022, 0.17774430986766032, 0.18553955763879582, 0.09204351457674387, 0.0768630940140198, 0.09510858726594562, 0.08972501652564879, 0.07821802724944771, 0.09142892445838147, 0.0744336022531612, 0.08531128260340104, 0.07988574234209322]}, "mutation_prompt": null}
{"id": "7c165b23-02be-4488-b7c6-111e63e0c2dd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "40c66936-c406-4676-8bb3-8fe50a1fc402", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "7497bf29-bf54-4974-a1d5-1f3a60756885", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with stochastic perturbation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * (best_solution - x0) * np.random.rand(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Stochastic Perturbation and Dimensional Mutation Scaling for improved convergence dynamics.", "configspace": "", "generation": 27, "fitness": 0.4148421307883823, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.30.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8955027750730559, 0.9353394317579224, 0.9170842549304942, 0.9024106543150735, 0.9267557675938858, 0.9363596553698557, 0.9045017537419809, 0.9262966883165545, 0.9364701831969797, 0.8262325696153914, 0.8363358376279014, 0.8666403182299, 0.8249023937630691, 0.8284381031777519, 0.8616037626468084, 0.8394227527482662, 0.8952948649487756, 0.8581275627911494, 0.15435848375401096, 0.09370063304966969, 0.5896133201335139, 0.1428285578025934, 0.07428629286617705, 0.4331082682207702, 0.16890387378588145, 0.14654098972534557, 0.7250890953987463, 0.13672840117569396, 0.11447760002602303, 0.13661307529060052, 0.14679022177969314, 0.1254052658503626, 0.1338773404871918, 0.13657671793106785, 0.12568792897500425, 0.15110867380249116, 0.9857176741839756, 0.966468404073601, 0.9570499748118835, 0.9740142933357954, 0.9838641421737718, 0.09870079831054934, 0.96424284501235, 0.9596398278880539, 0.9699902755729706, 0.769127414463525, 0.7732982693691799, 0.7810776139246378, 0.15204248471182724, 0.8064091572962833, 0.8069909023671085, 0.7332359771791277, 0.8358649943504171, 0.7544158257439219, 0.9147803248020959, 0.8729742344813817, 0.22855239999472365, 0.8891451974786047, 0.22068987205184043, 0.3814554520333592, 0.8392046015323423, 0.24133154770233978, 0.23334450139285123, 0.711053021867809, 0.7189456994786293, 0.7462477080180017, 0.6932050343359105, 0.1307914192230153, 0.6238372592892474, 0.6649918442557691, 0.7949716365703463, 0.6998036343773643, 0.6863002969829377, 0.18701095447696947, 0.016675356900389127, 0.6159695046535187, 0.2198349896738887, 0.35172409716224295, 0.7347942982653353, 0.27669677023808403, 0.20919433170642066, 0.22474492838133375, 0.12859264450751762, 0.4092720728389333, 0.18743064636707174, 0.3080414542133425, 0.14798107715280961, 0.28137851999808183, 0.37951874925381546, 0.20156303409565934, 0.2048583528359459, 0.34942345481838233, 0.2237519164060905, 0.0718854367446129, 0.12771490973237765, 0.30759272557921313, 0.23885383379775094, 0.17367114125579397, 0.17848008819109495, 0.1127737395145807, 0.4109605501032042, 0.13305466382576925, 0.1829872536049707, 0.33166960712544846, 0.2131490454696755, 0.17639717295761181, 0.1736806716102175, 0.2091517859792008, 0.3305192987733805, 0.42276838338682143, 0.3577211646915106, 0.2904264109680075, 0.42336275369636533, 0.39511989063026953, 0.28486911311141516, 0.3822228117998826, 0.050199614911311086, 0.7098998852290712, 0.7006200026515674, 0.7557323765431991, 0.7276747877061369, 0.7873617233142558, 0.752058241922277, 0.7080738645466218, 0.7562327518290622, 0.7260689859420468, 0.14614257543650433, 0.10965057412918289, 0.09317015246362226, 0.12811469404325804, 0.12478698585267756, 0.09287210851296768, 0.11118481761075161, 0.11740936047178652, 0.14643630894873239, 0.14102896967543788, 0.20437087725534198, 0.2369196568729035, 0.1599932756209066, 0.2750977177270676, 0.16450343282913837, 0.4420958508573143, 0.16666520753428649, 0.18492022657820684, 0.5829127587038649, 0.502968569151578, 0.5838143909992912, 0.5926930670863606, 0.45302431368117024, 0.5466486636304082, 0.6380784185418349, 0.590128905026527, 0.7717422819803079, 0.3304908386622445, 0.5079856555111559, 0.2417372653874691, 0.40903204268236004, 0.5683775239259836, 0.43242525856789993, 0.5024486577811775, 0.5498739402722226, 0.6671382418991059, 0.20279671319992199, 0.22342821105084487, 0.20443102076878505, 0.19275977051020432, 0.2100982571398875, 0.21116360581386284, 0.21029950431364974, 0.2066636865141528, 0.1946128965490972, 0.5770088552304617, 0.24109685057339847, 0.2455901974094027, 0.22614073827628922, 0.218065162731089, 0.19679354460893306, 0.24663200295461551, 0.21114150787150054, 0.22517332228739362, 0.9244136964018517, 0.9270614143488134, 0.18832595347349912, 0.16290425051723045, 0.18502777429617412, 0.8699497268901804, 0.8908440807184523, 0.1727264243504767, 0.2060094145582867, 0.892940718170097, 0.16938348975549156, 0.16722649877941875, 0.2098776885670327, 0.1664403396897698, 0.2113020711695036, 0.1940014271927839, 0.2101914041836721, 0.2093280211455113, 0.18234926367052395, 0.1878377614131691, 0.18679127465801793, 0.20293035076513366, 0.18946273286852588, 0.17962475845304693, 0.1770055226380577, 0.18565520051241413, 0.18899984564328565, 0.07921138431223174, 0.07293874305670489, 0.08045273258991203, 0.07086083019231504, 0.0922441323448584, 0.09155754782560233, 0.07924726465227327, 0.08427156397589641, 0.07712304116805246]}, "mutation_prompt": null}
{"id": "a95e5c22-aa61-43ff-94c3-af795eacd9a7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(np.sqrt(self.dim * np.log(self.dim))))  # Improved dynamic population size\n        self.mutation_factor = np.random.rand(self.population_size) * 0.6 + 0.3  # Adaptive mutation factor with wider range\n        self.crossover_rate = np.random.rand(self.population_size) * 0.3 + 0.7  # Adaptive crossover rate with narrower range\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with dynamic strategy\n                strategy_selector = np.random.rand()\n                if strategy_selector < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    x0, x1, x2 = self.population[indices]\n                    perturbation = np.random.randn(self.dim) * 0.05 * (best_solution - x0)\n                else:\n                    indices = np.random.choice(self.population_size, 5, replace=False)\n                    x0, x1, x2, x3, x4 = self.population[indices]\n                    perturbation = np.random.randn(self.dim) * 0.05 * (best_solution - x0)\n                    x0 = x0 + self.mutation_factor[i] * (x1 - x2) + self.mutation_factor[i] * (x3 - x4)\n\n                mutant_vector = x0 + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Strategy Selection and Adaptive Parameter Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 28, "fitness": 0.09220744054259179, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.12.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.25949064857164195, 0.2859109394443644, 0.1978017328295293, 0.11742553889776719, 0.10268547050006782, 0.12394428288391646, 0.17285382975853902, 0.2760611533708035, 0.31950969812551955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02874161992541191, 0.006402309259301964, 0.042592152351937695, 0.052004654745664625, 0.11208099477635147, 0.11415820950257616, 0.09316246335383727, 0.08080309968777599, 0.10717648891628928, 0.04346610873589052, 9.999999999998899e-05, 0.022825882613778603, 0.013357448641307057, 0.010500135438393787, 0.07546564063849148, 0.06795508240525128, 0.0014941179495179258, 0.029488963018539094, 0.34193625407132366, 0.09978522919518051, 0.06079424713220938, 0.982575945905874, 0.07921305346446139, 0.09759357305645422, 0.9911947762870773, 0.24137683540670674, 0.09077990086055232, 0.18166975136803765, 9.999999999998899e-05, 9.999999999998899e-05, 0.054267435372032935, 0.07518606501673897, 0.06986205503314036, 0.053414640029588956, 0.008494756679975346, 0.03553774831992029, 0.08958971517194714, 0.03824923035064953, 0.11651787181025597, 0.11891471121761044, 0.15738899394934147, 0.033596975726880696, 0.13460317603190342, 0.17056188146208806, 0.05845764195662195, 0.15523929364247802, 9.999999999998899e-05, 0.029264659402366333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04779100865843433, 9.999999999998899e-05, 0.03664907015636509, 0.13800029507591693, 9.999999999998899e-05, 0.0742514219671575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016638235013815783, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04044971898312155, 0.09551950954266464, 9.999999999998899e-05, 0.08046603901629024, 9.999999999998899e-05, 0.019855591661551042, 0.0378004895087779, 0.029047277948908046, 0.10894331467199059, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20489041609151204, 0.16069647839349366, 0.3114628623847484, 0.31052037887706496, 0.18770735025951701, 0.1623504130467932, 0.22137608767109518, 0.11782050216213424, 0.14623401049479745, 0.054492935242183016, 0.05872685603456684, 0.02712671815751566, 0.04536785375447361, 0.006915507766803941, 0.048418564271815234, 0.023487789859741537, 9.999999999998899e-05, 0.06878577919678541, 0.1917119091512013, 0.054266289006756785, 0.11412238094938454, 0.07668599693728573, 0.07616104098945142, 0.08189548947855652, 0.2027339265339232, 0.12517966051546048, 0.12070100381637117, 0.1119859357324674, 0.15295769554664929, 0.14098110302542843, 0.15362501595103406, 0.2241941019569561, 0.1513366620343053, 0.14894897174832145, 0.1932418977597915, 0.12821685529025584, 0.08487342074597781, 0.07222752122273413, 0.06498445117626561, 0.14269206599244788, 0.07249776714941347, 0.10282685839175487, 0.05567685209788964, 0.07993273092431541, 0.1485461974123622, 0.1614559898068203, 0.1342055824259858, 0.19076581827550576, 0.15006064404677677, 0.11097969624355941, 0.21850679445465426, 0.14668802698015648, 0.14149331104301432, 0.16351136037312664, 0.15574733182306155, 0.17719986626043627, 9.999999999998899e-05, 0.15242922924693358, 9.999999999998899e-05, 0.1755824977201561, 9.999999999998899e-05, 0.16742068939909982, 0.1715964755956686, 0.11271970485667826, 0.2805404407184142, 0.09817817955451424, 0.10227092469399124, 0.16056027266130823, 0.14560593665266042, 0.07922285642929205, 0.13153133009446372, 0.12559259247832655, 0.02206135024396061, 0.1506912613512852, 0.07245810475304693, 0.07990317917792344, 0.1607207694617918, 0.18523704286131726, 0.06616162671060177, 0.10796656594433152, 0.11279158827234281, 0.16575367693649368, 0.15898855041168958, 0.13897575081892044, 0.1332127018067225, 0.147535108406058, 0.14026068081669418, 0.13689299720258863, 0.13996482725266401, 0.15483770772785488, 0.029354703715151143, 0.035090427148747994, 0.06702966877635241, 0.07127178632956566, 0.048308627801481596, 0.05474702374717566, 0.05102874341387209, 0.07899036159660466, 0.0686854110093027]}, "mutation_prompt": null}
{"id": "8344acae-1bcf-4c1a-8622-e78710d36122", "solution": "import numpy as np\nimport skfuzzy as fuzz\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.best_fitness = np.inf\n\n    def fuzzy_control(self, fitness):\n        # Fuzzy logic control for mutation and crossover rates\n        rates = np.linspace(0, 1, self.population_size)\n        low = fuzz.trimf(rates, [0, 0, 0.5])\n        medium = fuzz.trimf(rates, [0, 0.5, 1])\n        high = fuzz.trimf(rates, [0.5, 1, 1])\n        membership = fuzz.interp_membership(rates, high, fitness)\n        return membership * 0.9 + (1 - membership) * 0.1  # Fuzzy membership to influence rate\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        self.best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                mutation_factor = self.fuzzy_control(self.fitness[i])\n                crossover_rate = self.fuzzy_control(self.fitness[i])\n\n                # Mutation with fuzzy controlled perturbation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + mutation_factor * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with fuzzy controlled rate\n                trial_vector = np.where(np.random.rand(self.dim) < crossover_rate, mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using Fuzzy Logic Based Control for Adaptive Parameter Tuning and Balanced Exploration-Exploitation.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'skfuzzy'\").", "error": "ModuleNotFoundError(\"No module named 'skfuzzy'\")", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {}, "mutation_prompt": null}
{"id": "2ad5c38d-e293-4fc8-920b-c5beaed6fe2d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            reduced_population_size = max(4, int(self.population_size * (1 - (self.eval_count / self.budget)**2)))  # Nonlinear reduction\n            for i in range(reduced_population_size):\n                if self.eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.05 * (best_solution - x0)  # Tightened local search\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation and crossover strategies enhanced by a nonlinear population reduction scheme.", "configspace": "", "generation": 30, "fitness": 0.3990003554243263, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8884315026362888, 0.9034027368400102, 0.9303502582010034, 0.8785039202693167, 0.9275350127271241, 0.9016316998321878, 0.8774120556815777, 0.9239023818467521, 0.9098066537177982, 0.7781980056482798, 0.7853102902813044, 0.8184680741799075, 0.7458005129620711, 0.8604127600599374, 0.8166852001282416, 0.8034609608994218, 0.8363328212152794, 0.8559120625641221, 0.134715685440722, 0.15996995619093302, 0.26697742055802876, 0.15762719676207548, 0.46324329237262296, 0.1147402281991563, 0.15469714675827761, 0.15073416412589757, 0.15050959165195177, 0.11813607745651211, 0.11262645735074861, 0.16244341569022402, 0.13198234251314422, 0.1447348480623788, 0.15827629909690366, 0.12350284563789649, 0.14263440051910226, 0.138021523557466, 0.979726625917376, 0.9706328313856301, 0.9773595003171203, 0.9657699965039496, 0.9873484715188666, 0.9665836439750675, 0.9854001725963617, 0.9862012727859029, 0.9934167279392476, 0.6440746698066937, 0.5424408044199069, 0.6851336032031687, 0.6477887516877844, 0.6468141365891236, 0.7405241148006512, 0.6119930421100548, 0.4892801302324835, 0.6706704413509313, 0.8839359899520822, 0.8000441308238956, 0.8407035952912862, 0.8306143535566275, 0.835101508545324, 0.9116363427590197, 0.8764740015101181, 0.8759742303314305, 0.8387880931904338, 0.4115297201899658, 0.5863190949045842, 0.17600506130260352, 0.42457434760022916, 0.20180879291306209, 0.13673489760804602, 0.5366521906452033, 0.3721687574736837, 0.7428289118196688, 0.010046479711743772, 0.28366970632584776, 0.2315335242622305, 0.3968123801587716, 0.7320545067676274, 0.5148774574927089, 0.5480005198666138, 0.13388480740376085, 0.30820495405656434, 0.21980577049597494, 0.1252182362526828, 0.21004881204205117, 0.23128119599361951, 0.24409753639846732, 0.08588733035293916, 0.16558658144049365, 0.27753085988218984, 0.19990129939219548, 0.25305429213331765, 0.1867124430481304, 0.08881235190777426, 0.25371054045860275, 0.2224735803586695, 0.24831992228171995, 0.15618340515356122, 0.22597585955831434, 0.3341785813441678, 9.999999999998899e-05, 0.06093158052015457, 0.06495462473440927, 0.2486853525766345, 0.18409739578890882, 0.20744030049116302, 0.10077993662087248, 0.3588404608185849, 0.11824896897293724, 0.31002578445216866, 0.369528021303387, 0.3486505373630846, 0.42086520740051214, 0.3138124243878083, 0.37529591252459504, 0.32058865444931994, 0.2718520671950331, 0.3405690379113454, 0.6702086983794482, 0.7094584310239589, 0.7106566160554884, 0.6543743292889397, 0.6456112356774133, 0.7162749092221519, 0.7375917471871554, 0.7950678357792389, 0.7336037390509429, 0.12236547689007493, 0.10979365364901295, 0.13230421947589, 0.12021610362295776, 0.10392387424102545, 0.13403864917792796, 0.12123045413497435, 0.16431972642000803, 0.10462414451948698, 0.14649480219908984, 0.3709437403889281, 0.18981463743670157, 0.2058981186640957, 0.13045859727103182, 0.16657979721910865, 0.6115976587686166, 0.6036167328062104, 0.2388342812724823, 0.3814587311966312, 0.41301574157215815, 0.5008464548679001, 0.42262183012734056, 0.36593341288479164, 0.4773982426287713, 0.4990188713602681, 0.5328195900686934, 0.5596984610064212, 0.3519859828494981, 0.41180162084921756, 0.385313017661437, 0.33097730659143665, 0.24949831259807675, 0.32826929826330287, 0.33592660692923304, 0.3766861310813554, 0.40036478674065945, 0.20135563873340923, 0.17750420083040785, 0.1786042180756966, 0.17949207600470451, 0.19287026079187686, 0.17044368310066715, 0.20896540027266397, 0.19791018292933982, 0.19796731308715976, 0.24807488719165016, 0.7800643583695314, 0.21720367226183668, 0.20980504227150654, 0.24310591594829656, 0.7829223001614518, 0.22705368288997319, 0.21095672635896567, 0.21599960112282723, 0.8721104630575196, 0.9297783671741733, 0.18598997315632937, 0.870235060600898, 0.18842655931985663, 0.1630424301384562, 0.15610060302808848, 0.14166954294361367, 0.16486174079309057, 0.12791387224994655, 0.8365811974670582, 0.1680722963588267, 0.12470923688622493, 0.16005368499723094, 0.20946166707529534, 0.210055917313535, 0.3392272166962146, 0.1050249519208648, 0.18714705165162315, 0.1818293729239081, 0.19733260777849548, 0.17099794350673803, 0.19169831328604037, 0.1834763135001497, 0.19286842048328567, 0.19573521229676594, 0.18979042474892804, 0.08089990273796144, 0.09719144371568544, 0.07319539064626823, 0.07007400062577618, 0.07734551153778157, 0.0761225167352888, 0.07532469370675932, 0.08603682696604797, 0.08654831288433484]}, "mutation_prompt": null}
{"id": "59d10e91-8610-470c-826d-d1ff69772e14", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 6 + int(self.dim * np.log(self.dim)))  # Slightly increased population size\n        self.mutation_factor = 0.4 + np.random.rand(self.population_size) * 0.6  # Adjusted mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Adjusted crossover rate range\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with enhanced local search\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * (best_solution - x0)  # Increased perturbation factor\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Population and Adaptive Parameters for Improved Convergence.", "configspace": "", "generation": 31, "fitness": 0.4325727566862, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.31.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9042116463020393, 0.9208006788207301, 0.9297028762452165, 0.906549454606307, 0.9294124691416897, 0.9134365937249316, 0.911568288442813, 0.9146466943248177, 0.9347031030928284, 0.8476774522853461, 0.8892660764491781, 0.8681583604211385, 0.8370264048186533, 0.8631786212667327, 0.8748634798291685, 0.8274671813787056, 0.8947734407119483, 0.8591298917517847, 0.16475306386497246, 0.17306742840223432, 0.15876333789299368, 0.16692532110029878, 0.6746726407185119, 0.16898808693615208, 0.16246669629483856, 0.15896719198601783, 0.7807598457349952, 0.22349767711326052, 0.13181921907610594, 0.1537677822011596, 0.1473319468662727, 0.14142632467787064, 0.149646636350786, 0.14779897157546307, 0.17217217461298984, 0.12084363812096743, 0.9804939950810744, 0.9762276678406024, 0.9728900262182633, 0.970221043507869, 0.9743754828722673, 0.9780920808109087, 0.9663829426609322, 0.9730504289058725, 0.9913920330564379, 0.655440115076914, 0.7236784949045265, 0.7062474287660703, 0.7069356144852373, 0.7072027189483079, 0.7874989846515645, 0.7226562043568858, 0.7793062997399832, 0.8136068050498202, 0.7283509769967922, 0.9148977791703115, 0.8721687873324585, 0.8323820154908315, 0.8637024365004837, 0.8649387015106278, 0.8167031894161166, 0.24173068817056287, 0.8934230609126983, 0.48432956470857313, 0.5899432681864638, 0.5751421140413004, 0.5176982881479228, 0.6371041331058231, 0.6134138239619997, 0.5417405897789354, 0.19196823765829885, 0.5789203056423552, 0.009802881093252891, 0.20419224251880264, 0.24969900446718774, 0.5255581365072075, 0.5334047415261476, 0.7438051993898158, 0.4398630088768173, 0.5240649611066954, 0.36994195310578715, 0.1356116441787204, 0.18221417995310396, 0.06982840097742005, 0.06729630642416373, 0.1972400814159977, 0.14208114807777805, 0.1510125828703418, 0.18058719812968227, 0.14670452338379292, 0.17236371593647204, 0.12617380051454952, 0.17557677703990815, 0.14591563199363866, 0.15196080326611094, 0.24815997632547648, 0.1832912369440639, 0.1248412217122179, 0.2460367179143924, 0.07979024916975308, 0.055707804184621845, 0.07430158348832483, 0.22177721345378076, 0.23294995704606514, 0.22256248990293803, 0.209555984755056, 0.12545502176127865, 0.08805253206701946, 0.2285415019152155, 0.2669961012310277, 0.33175981178880143, 0.2771040133258297, 0.2907790872803834, 0.3427358649739073, 0.22605361937273516, 0.3424155739261343, 0.30353262396651304, 0.6240641337789183, 0.6761434557508386, 0.6529580126899078, 0.6347155241344358, 0.7120339673182869, 0.6947385521396607, 0.6569152859158534, 0.7427139057656347, 0.6919247453454345, 0.1117644175280833, 0.11484034819782285, 0.12573184580900965, 0.09882702432132395, 0.10588033695544785, 0.12559042027669343, 0.09609846219053109, 0.11373087227430645, 0.104617617081053, 0.1613087857658333, 0.17734397766837973, 0.1624605559816782, 0.512631418180274, 0.2226122327661596, 0.17549634038563477, 0.14979049600283068, 0.2700602858039637, 0.16722940266428, 0.570503333044938, 0.7207812476439613, 0.5257459428321873, 0.5209085427631643, 0.7059817988863448, 0.6579526536376357, 0.5401160854987272, 0.6226149807059622, 0.5818607216283285, 0.2705095244008796, 0.3045064410330116, 0.38734816308160425, 0.3365976944711955, 0.4434470460519463, 0.4225941086178129, 0.42960458877430896, 0.431955373617696, 0.546190540774426, 0.1844231404761204, 0.216631209401268, 0.18610478246823636, 0.17974401324162192, 0.18360575121384415, 0.19387530023148203, 0.20019759659402048, 0.1782382974194714, 0.20573812264029612, 0.6903550513632329, 0.24134093111471844, 0.7934602048856888, 0.7080503680207708, 0.6258985440095746, 0.5796760720672833, 0.19656287327147248, 0.8350429814839252, 0.71970505639928, 0.15314853065502199, 0.16487414873163775, 0.9059733378665693, 0.8348227660308455, 0.1786841186184862, 0.16852861391657137, 0.8184796755441941, 0.7631288817643139, 0.9055106659221314, 0.19839031226342174, 0.15521628319772152, 0.8086429610248318, 0.8024141996932408, 0.16596876638548075, 0.2095364818117431, 0.7670001244112452, 0.11317573693029004, 0.1569941543458082, 0.19515968483238544, 0.17647665143226898, 0.1838787716323369, 0.18341078313898684, 0.18257029834926075, 0.18006718434389601, 0.18557245290903435, 0.20200761771005626, 0.18968279940446053, 0.07282305015218205, 0.09594158599992042, 0.07461679649849395, 0.09046155290020885, 0.07850561586868154, 0.08432592338417999, 0.07320023011732191, 0.08141035506540595, 0.0792266908429099]}, "mutation_prompt": null}
{"id": "2d08dd10-f497-4561-84f9-3c10e1982878", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.learning_rate = 0.01  # Adaptive learning rate for mutation factor adjustment\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification and adaptive learning\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n                        # Adaptive learning to adjust mutation factor\n                        self.mutation_factor[i] = max(0.1, self.mutation_factor[i] * (1 + self.learning_rate))\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Size, Local Search Intensification, and Adaptive Learning for Balanced Exploration-Exploitation.", "configspace": "", "generation": 32, "fitness": 0.42733215833297405, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8983924297920078, 0.913926986147352, 0.9268384615941307, 0.9054104032203802, 0.9141806467593804, 0.9335137357941248, 0.9029592538875498, 0.93761108210047, 0.9305540155463946, 0.8171250182056863, 0.08053340194749559, 0.833962679120957, 0.8515186599136602, 0.852012432722638, 0.8751767775590222, 0.834398309948348, 0.891930687791316, 0.8818902120556944, 0.1637586132538279, 0.5490077592748204, 0.09726184088218981, 0.6000700273235171, 0.5301399550420174, 0.6697399955061458, 0.2861152860666082, 0.16772175373939913, 0.6112872212472593, 0.13800920084003943, 0.1525337519327189, 0.13180319409646513, 0.16261100030638753, 0.1423387236571374, 0.41254032288207576, 0.13533071662439766, 0.17802810540388203, 0.14976726556487352, 0.9870366677621274, 0.9472766039870606, 0.9758636464156203, 0.055545954744294024, 0.9818110269804899, 0.9566937559436073, 0.9518654381097514, 0.9713477759517175, 0.9637000979124574, 0.7414245461634343, 0.8049951385041079, 0.7484176570344007, 0.7561077300742095, 0.7855671879520107, 0.749171447997431, 0.7584391521764374, 0.7945093720961234, 0.8128115390646655, 0.8286182791443798, 0.39767323944734256, 0.8798622932035871, 0.8457126284664463, 0.914982066774192, 0.848763623334939, 0.8375829543804978, 0.8698676279259052, 0.866544528087415, 0.6056073106726527, 0.6075771338551428, 0.545649157434712, 0.5589220781016437, 0.6222762578819016, 0.6319511489306766, 0.6271191493097923, 0.49737287248878304, 0.5541410150278586, 0.010196830905250698, 0.5620189844066441, 0.5422433572995378, 0.594113646088271, 0.6190060633849264, 0.6597109366618721, 0.48015744563169704, 0.6313580003854475, 0.4626470126380967, 0.18703467868269197, 0.19661438586046331, 0.17730326732444823, 0.16781796313338748, 0.24622897035347235, 0.18615449706387288, 0.15497686601608363, 0.2922806830473582, 0.15190423676589437, 0.2612336422443009, 0.1334208265951733, 0.2032152579848927, 0.1441162634673201, 0.25356746282518816, 0.08004388677357488, 0.24130223067048095, 0.3004071546391821, 0.24100794221531285, 0.1211491692701302, 0.19075691278801865, 0.10947369465659706, 0.11752392876591455, 0.21106764827161373, 0.15256731353601394, 0.16374454067301925, 0.18649508076658128, 0.18251681956364252, 0.2705928147351947, 0.3495609296922685, 0.32964410518815157, 0.2790719228393609, 0.39317197242850965, 0.32066797973728633, 0.26781202837952434, 0.30687816289749903, 0.28662136753409084, 0.6753761272831509, 0.7260683827853309, 0.7022792247899017, 0.6827773580355943, 0.6779034889260606, 0.6956534232951981, 0.6959086978676146, 0.7812997466308684, 0.722042574840355, 0.10013305106284409, 0.07915438065755676, 0.12630461687437766, 0.13960153750136983, 0.11967487277267519, 0.11221971466544034, 0.13019662130968646, 0.13064921132399954, 0.12785745538355264, 0.1681812133956524, 0.365357868922227, 0.1592925588153823, 0.17106055279274712, 0.1632781037285711, 0.2180144644111568, 0.21324472401101824, 0.17357572340431637, 0.13305712753010301, 0.5362842526568166, 0.6931682584773888, 0.6361591150398405, 0.5112312325928452, 0.7073574706189624, 0.6509577353726834, 0.571260665303776, 0.753431219596282, 0.6978218354912247, 0.29976784174868965, 0.27299578508984246, 0.42966451318763177, 0.46333435208040175, 0.46839407712589587, 0.1940245385897995, 0.41187791307823995, 0.5565013363280203, 0.42956669697698524, 0.1773586697473193, 0.1872119657000928, 0.18564407604774003, 0.2104022899761665, 0.18232801643031993, 0.19580621993000003, 0.19213625156907632, 0.18730203442057114, 0.229563601801963, 0.2140035020560036, 0.4987889396795425, 0.6493643993206831, 0.237267627710828, 0.7104246531409371, 0.24227940850769136, 0.21358262091416746, 0.6955657284568215, 0.7402365064064266, 0.16550751307995382, 0.19900435403184003, 0.152862508754678, 0.19350716314387106, 0.1640580525295272, 0.16730540295336815, 0.20447694612431666, 0.1716559289226054, 0.21194197006792947, 0.7885149630148284, 0.16939476907378925, 0.8735601280272468, 0.8156728704542576, 0.16657230115182498, 0.21089509133680462, 0.20335627214105467, 0.19444778993990097, 0.1863823570632549, 0.21159098694996847, 0.17826694900683326, 0.19215027404082508, 0.18019222296187676, 0.1782967564125989, 0.1914134938807921, 0.19000747534115847, 0.18555700548340215, 0.1940354166780427, 0.08372748567489674, 0.08140765759782553, 0.07743082705101456, 0.09638245445613924, 0.08884192880495079, 0.08817193805563095, 0.07388677358785811, 0.09463287766747996, 0.09320220439518379]}, "mutation_prompt": null}
{"id": "25c972a1-ff7c-4044-b45a-b3eff83cc6a7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.stochastic_bias = 0.1\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification and stochastic perceptual bias\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perceptual_bias = self.stochastic_bias * np.random.uniform(-1, 1, self.dim)\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0 + perceptual_bias)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Stochastic Perceptual Bias for Diverse Exploration and Intensified Exploitation.", "configspace": "", "generation": 33, "fitness": 0.3472175339638639, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.715182594037913, 0.7515277245800516, 0.7555611389891866, 0.719295729054307, 0.7538086109807989, 0.7265134243589799, 0.7194121343523137, 0.7316411962849373, 0.751800028196795, 0.3467015451683747, 0.3656825540791566, 0.31565894466115707, 0.3696307691225593, 0.3690924435794648, 0.3757623536385447, 0.3267944372970545, 0.39213787994724414, 0.356942203766352, 0.25320192644655404, 0.17747343725572595, 0.16228297972094297, 0.15353731482987043, 0.35620452825867477, 0.11766568297677837, 0.27959612085170404, 0.11224182089486145, 0.16631396775525498, 0.1147068939708712, 0.14119550201503772, 0.13519074055998204, 0.1302474806233198, 0.14671104837464066, 0.1388818807440486, 0.170660614277244, 0.1332170555681067, 0.11438010753984074, 0.9942910041513017, 0.9423302581735507, 0.957768220133364, 0.8941030594092072, 0.9513363637383518, 0.9233885291197492, 0.932113686641643, 0.9675616571933, 0.9530957656474298, 0.5126964208986512, 0.5471201749692827, 0.5200427851948395, 0.5012452354866481, 0.5250048015869521, 0.5287797259653271, 0.4670897898912737, 0.532851858315532, 0.5564248481867182, 0.8557055768495871, 0.9001674123409327, 0.9219590809620093, 0.9184419246836575, 0.8972693508223494, 0.2133081935550536, 0.8948898980575867, 0.8964272903664625, 0.878950595106888, 0.3870087871936774, 0.1375850828963503, 0.36548991958140953, 0.13228413221042468, 0.3676202430602171, 0.3956690651949045, 0.13221159994818021, 0.39633003114623333, 0.40199156183106544, 0.3482302281757754, 0.3972749438803681, 0.39226215273146514, 0.1317254521713861, 0.4298240999598274, 0.3772568038954027, 0.4125874542830761, 0.32918837796583456, 0.38752037952519536, 0.14236383715957346, 0.23597575637449508, 0.18928249070143455, 0.12962924414945942, 0.05303419632963491, 0.14054453782925624, 0.12864055525648688, 0.19015567835196856, 0.03214913696819799, 0.2531377768100037, 0.23530189188169648, 0.2218855987120567, 0.1557337206403958, 0.19963594939597495, 0.15969280884788262, 0.21428484490901656, 0.22596060206439628, 0.25474603912155325, 0.06289272355821196, 0.14347865265615534, 0.0505296910828833, 0.06208677396471052, 0.10366691165887221, 0.14667438255097554, 0.09974893255416573, 0.08614817647532069, 0.12656825841814645, 0.22003224246201725, 0.21673055507604044, 0.23032297951447522, 0.2256595056182572, 0.23417463755489443, 0.24647822514254603, 0.23541648980971364, 0.24544930817327326, 0.24152913031459866, 0.558214349371487, 0.5712824698644037, 0.567882497577195, 0.5883929480957827, 0.5750357176283472, 0.5846961038998204, 0.5422512315091734, 0.5910785981729312, 0.5506928140800724, 0.13027452065647172, 0.17653871714246616, 0.14861788414082644, 0.13126253476341831, 0.12757361425692015, 0.1228729742585436, 0.1439552919010737, 0.1257374037759813, 0.16547970585541116, 0.2776724437036452, 0.2763566501774478, 0.385277136170577, 0.2119322308840288, 0.20976233456415605, 0.21219996008551711, 0.23659451142697285, 0.1639648227965712, 0.1738301481135428, 0.3887829805289189, 0.4070274121950095, 0.42086097069886563, 0.39298038205824337, 0.4216445757790733, 0.42769259795980197, 0.41465691369113145, 0.4438253640285169, 0.41454155378035107, 0.3085374628352361, 0.3458076732419564, 0.3384013594158275, 0.3305148017197459, 0.3122038829042114, 0.33613355604508366, 0.346590957911467, 0.3453315403979933, 0.34000875008974474, 0.200956693082057, 0.19621081158314047, 0.199216489594627, 0.22344104080949223, 0.21905739591637152, 0.23662782252723036, 0.19862118847484767, 0.17302938570605475, 0.21893916630971477, 0.23685608450670292, 0.21597521987281454, 0.492537078808607, 0.3880942834806328, 0.22530817353075372, 0.5810662617094332, 0.46996928652517467, 0.22012109029264215, 0.2420218246593877, 0.18189853733348715, 0.17161622699333257, 0.9066963367181532, 0.16897157462768375, 0.19555486939178457, 0.9173449725969272, 0.17066887470482017, 0.9091182507274546, 0.18471950924910796, 0.12791747314820023, 0.16837837871161443, 0.1674445331962514, 0.8936479801385945, 0.210850102117087, 0.9079271083914767, 0.21395871448696957, 0.21371446998865706, 0.167963991311471, 0.17672713892612812, 0.18394257750994425, 0.17505680449943506, 0.19381256546467052, 0.17164461606611658, 0.2004721144312862, 0.18172073692924884, 0.19789456221417467, 0.1904485721814283, 0.07554777110288491, 0.07956525778908996, 0.08049538424802627, 0.07468787877780414, 0.08305122498589335, 0.08287847551642735, 0.08069870151198388, 0.0912710426536758, 0.08463748006384597]}, "mutation_prompt": null}
{"id": "9e97a171-08b7-4957-bc3b-8cf8d9d0d1c1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "32d6d46e-37e6-4183-ae58-091ec360465b", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = np.full(self.population_size, 0.7)  # Fixed mutation factor for better stability\n        self.crossover_rate = 0.9 + np.random.rand(self.population_size) * 0.1  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with random selection enhancement\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection with diversity preservation\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n                elif np.random.rand() < 0.05:  # Introduce a small chance to replace with slightly worse solutions\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Strategies and Dynamic Parameter Tuning for Robust Performance Across Diverse Functions.", "configspace": "", "generation": 35, "fitness": 0.3804523189277385, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.31.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9233660443088582, 0.9263885756323464, 0.9254996809787128, 0.9011976361264687, 0.9166244508144935, 0.9206054784811708, 0.90620856383006, 0.9083693386266308, 0.9115492088588687, 0.8227925074711293, 0.8474680921929797, 0.0433794922051044, 9.999999999998899e-05, 0.8654598518438308, 0.799590832913647, 0.8527616541019775, 0.8479543254763889, 0.8635475879367973, 0.15334743609201906, 0.13283162735034382, 0.1139964810110845, 0.12520826967702792, 0.1319424263946335, 0.15076706726382438, 0.11231223851955785, 0.1244607973359203, 0.14282154349546106, 0.12660874874624573, 0.1486596009267127, 0.12272589857112015, 0.1208366368866709, 0.13060963565259587, 0.11059906394591601, 0.11392590923346724, 0.11110329696267962, 0.13932524362954424, 0.9492171206423872, 0.9827236489319806, 0.9443379280965265, 0.9513270344107719, 0.9867581567786172, 0.9248232270755304, 0.9582858724326735, 0.9439405991313203, 0.0989978945893728, 0.7443530742726283, 0.7497787196346803, 0.7275215874230287, 0.704286297820747, 0.7471944908915111, 0.7418430899691029, 0.7752547519907268, 0.8239408029168134, 0.7844374533740485, 0.880706844380611, 0.4717432852517467, 0.8807726197331067, 0.9071185791982075, 0.7153673077880949, 0.9017289952334587, 0.8917482309641144, 0.8993997389120073, 0.8642596943010944, 0.5410495311410606, 0.6367053773576812, 0.29586612670101375, 0.34661923910139714, 0.21814064165994074, 0.13449266822008443, 0.19043728745528565, 0.18273298160043172, 0.6867497971568681, 0.38572872008542536, 0.010039986969343051, 0.2296150507307776, 0.795747447056638, 0.7308504720854327, 0.30428116039417963, 0.19820798318390576, 0.23170200279208952, 0.19682149157665774, 0.1000785393067537, 0.06740820905240019, 0.14602642323481874, 0.06836602161431815, 0.05489125443019316, 0.027855299418186763, 0.041312510985136774, 0.12289400758256541, 0.12694165468073793, 0.11484475645190473, 0.13794488467922328, 0.13909963439124295, 0.11348731198009776, 0.10328482719475485, 0.1000406352386517, 0.0855486789880977, 0.13335447311407755, 0.10842365054125913, 0.05341209346580711, 0.07399067078913668, 0.08539579581970536, 0.15560755745044863, 0.15348664514982224, 0.18329088538525817, 0.08895256287173126, 0.23052648253839325, 0.16364820068740393, 0.30823810009460983, 0.3134192137791638, 0.25794277828008894, 0.344627635709289, 0.2759608448721306, 0.23069188355880388, 0.2544905652756705, 0.2657693592028163, 0.29549934262879973, 0.6770655035480612, 0.6363286509466792, 0.6095429583220249, 0.5438967024816324, 0.6273260964074276, 0.6488851336382224, 0.6727951255633341, 0.6389313521171016, 0.6706309201669707, 0.07447913452672528, 0.1217355690972608, 0.09123013194495944, 0.1430590069867188, 0.09911794895176318, 0.0957109147957943, 0.0928956012268114, 0.08956546863184545, 0.0975551415130318, 0.15495903688202362, 0.14865635309097036, 0.3093032696649216, 0.1354476954153333, 0.16499893616901207, 0.15071179300961535, 0.1442614834721313, 0.7663058098772088, 0.11006231049313886, 0.7057923152022704, 0.5811746098550286, 0.6414912987294845, 0.6685028663320901, 0.6079493533325249, 0.5961225982252465, 0.5378812857666486, 0.625172541376451, 0.6561909852865078, 0.4710025074820142, 0.24890328587431942, 0.2563662396269316, 0.3383203901719032, 0.41106162374132504, 0.4672120092745363, 0.4702519641562676, 0.5034040297098474, 0.3565374251784046, 0.22690180170964713, 0.21769566756155623, 0.23380334484226628, 0.19617691190981146, 0.23932801666549264, 0.2013222759047717, 0.19893068321993856, 0.18892314374389485, 0.18772853345289564, 0.3600096689299076, 0.20093363461500757, 0.24571122500620746, 0.2218621624184698, 0.1952817384140373, 0.31375662465196275, 0.2185650776785818, 0.24487954370999931, 0.5721606630982665, 0.9170658250626663, 0.9312186476060518, 0.16516831891890038, 0.1478282932806142, 0.13030842410885957, 0.19724540445349337, 0.17006933771928712, 0.1168172928742428, 0.17105503054760351, 0.807481608735777, 0.15576176425716926, 0.8302969162161251, 0.8632166877795308, 0.8839980514467078, 0.20929102885606754, 0.1288390954348383, 0.19850175264601744, 0.2129242446381412, 0.17242822011220982, 0.19427632229537395, 0.1790764153167964, 0.18983284835664482, 0.19014900903768617, 0.17860291083129576, 0.17360608615935924, 0.1660564576406952, 0.1781224236574368, 0.07689368887311321, 0.08670621293344827, 0.07263498360593168, 0.0704064446186794, 0.07166613126768895, 0.07970549550693962, 0.07979515415762561, 0.07579104619942956, 0.0927435720929276]}, "mutation_prompt": null}
{"id": "e600c5e7-6cad-4d21-8a9c-92dc368a38f6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "e5cd2bee-70a5-4d7d-b5d5-c279b8f45a9b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "b0e816ef-d098-4270-b70c-09004dd332b9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = np.clip(0.4 + np.random.rand(self.population_size) * 0.6, 0.4, 0.9)  # Self-adaptive mutation factor\n        self.crossover_rate = np.clip(0.7 + np.random.rand(self.population_size) * 0.3, 0.7, 1.0)  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with intelligent adaptive perturbation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * np.exp(-0.5 * (self.fitness[i] - best_fitness))\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Intelligent Adaptive Parameters for enhanced global and local search balance.", "configspace": "", "generation": 38, "fitness": 0.24826393435993632, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.48773805733612474, 0.45380032214192545, 0.4830272023842187, 0.43272326320330323, 0.4453275759965948, 0.4774575487233963, 0.44110673876610695, 0.4764739522750927, 0.42929943233979373, 0.2289636409390745, 0.24677789421451057, 0.2113695634016316, 0.24387593636483784, 0.2413406430305668, 0.21177542101521385, 0.20307525997223452, 0.17188012367295147, 0.24581879633427783, 0.16706099675476327, 0.156350483883818, 0.1631623463078542, 0.15689097603926816, 0.15892683225755022, 0.14243458539138887, 0.15622283427275963, 0.16354669066527405, 0.1541229791510903, 0.13876950101348806, 0.12710580093781065, 0.054504724938519766, 0.13641342942987755, 0.1402068849502679, 0.11640345281529685, 0.14258224238821204, 0.12787067520826367, 0.14368549052674173, 0.9786001839658454, 0.9725452623399355, 0.9753294584313082, 0.9228502959641317, 0.9725380522829907, 0.9361301544533832, 0.94589965964451, 0.985725717964041, 0.9069372505668661, 0.29196962880056576, 0.29624556529905954, 0.3206746421190856, 0.28578342340687746, 0.308558074897224, 0.2890127106806464, 0.28019968786950944, 0.3042968735150967, 0.32085819213759526, 0.34876736138887277, 0.38758008452175585, 0.344743766001375, 0.3279334744872583, 0.35298437735009325, 0.37973300188465486, 0.33332461060610463, 0.3649772965183836, 0.6470113196068845, 0.1666189445562557, 0.1756177446299707, 0.1923123963182789, 0.1831392113364343, 0.12948092488296692, 0.1739500027717792, 0.1720438215592086, 0.16931890662643878, 0.13078093987584216, 0.12143390484390437, 0.1956309160337748, 0.1821166130805607, 0.20349604649072994, 0.1973797829489503, 0.15024240806310174, 0.19338719088737932, 0.17591196506468154, 0.17767921840256162, 0.1252995505859783, 0.004663096156413804, 0.0824984497568414, 0.11580379771333849, 0.16913772518147585, 0.014624305395007475, 0.14493433991027393, 0.046348790002298634, 0.14008539353824323, 0.19871564061443614, 0.12692419190873716, 0.14114143559572623, 0.1626237142822371, 0.14741204286559673, 0.12116377180612148, 0.2016980158072994, 0.21324319050778562, 0.24654388990080212, 0.06261954522525992, 0.16583828542499846, 0.0382154631708016, 0.12967358140806207, 0.09354059180913232, 0.08716022150373814, 0.09799883571472001, 0.13757032268665514, 0.11537735591985676, 0.12520131232248222, 0.11375939451752204, 0.1385147375541379, 0.14826248507119344, 0.15497682101372556, 0.09463066895945249, 0.14366839150906596, 0.13131991173106783, 0.13487266489688932, 0.3966756527418971, 0.4233814535165503, 0.41661984539014707, 0.39027412724028565, 0.41265333214653466, 0.41336520451934056, 0.400501830534967, 0.4349244261540053, 0.40370557615009195, 0.13540776763387752, 0.13482188117795868, 0.10761275647372637, 0.11643104730164211, 0.13265959135090832, 0.09356341804771928, 0.10325576186024832, 0.11444786478128499, 0.12660852588232552, 0.18407710063420402, 0.2824303322796078, 0.17666125872982208, 0.1663389239720111, 0.20143776588927842, 0.13998567720722588, 0.21887763627540957, 0.2895391465670062, 0.17688651504186315, 0.2936608632738954, 0.2898777567105768, 0.29692533980817837, 0.2941619601325337, 0.29490851168190324, 0.2892373165882136, 0.2925778443767779, 0.2853432652082799, 0.28882335709919105, 0.21232055475096, 0.23283083161545715, 0.21132250996473878, 0.21417825261321488, 0.2303608059659462, 0.2558314780055898, 0.23207211410749595, 0.22863309994953773, 0.24182485228124395, 0.18028594653483343, 0.20639414189525118, 0.1942333610766206, 0.19058122857826387, 0.19324997921304188, 0.2123895141601545, 0.17457811091012843, 0.21709660751032223, 0.19325818064802092, 0.22023034182618773, 0.23134710061762964, 0.229783941731886, 0.1998994632643718, 0.22466479781789706, 0.28361560144675446, 0.1977500294926403, 0.2185995959529814, 0.2568851548080344, 0.15654347393138013, 0.1864056919533491, 0.6146063486554294, 0.19412174210130984, 0.16996427974570416, 0.19549367845699905, 0.19039167561596637, 0.16708082179346095, 0.6507127275546428, 0.5507484706044818, 0.21011674595277197, 0.4690399732283509, 0.2001504843794445, 0.15454220673333674, 0.21138703749301224, 0.2126583578631045, 0.2123233584907399, 0.2126460676740527, 0.17273186404935237, 0.2003547021906812, 0.19744982612145923, 0.19130012049589018, 0.21531294210763474, 0.1812608300537627, 0.17953712127080235, 0.18479276413246326, 0.19864065249939256, 0.08426475153214918, 0.08423522359863433, 0.09260535201407727, 0.09963221139584966, 0.08059871389952877, 0.08222637202318983, 0.07907638502789327, 0.0852378660139087, 0.08803545388499556]}, "mutation_prompt": null}
{"id": "e690a02f-36db-4a48-8a8e-f60dc6c48aff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "573d628c-ab32-46e4-afd4-abce4a71b870", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "c52e73d8-7820-45cc-9dd3-ed8b1c01f7bf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "716718a2-07f9-4741-a55c-9f867b3831b7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 5 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.4 + np.random.rand(self.population_size) * 0.6  # Broader mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Broader crossover rate range\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with dynamic local intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.15 * (best_solution - x0)  # Increased perturbation\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate and elitism\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection with elitism\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Self-Adaptive Strategies and Dynamic Intensification Mechanism for Efficient Global and Local Search.", "configspace": "", "generation": 42, "fitness": 0.4234993255359696, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.911264475564379, 0.8716687282988972, 0.9396612772488022, 0.9033319413404047, 0.6240488601141543, 0.9379359797247754, 0.9120160774474885, 0.9402469035319247, 0.9391793435968109, 0.8381777830352093, 0.779936606240138, 0.8756762615101754, 0.857219190851379, 0.8980947002601172, 0.8869993344195678, 0.8675553520017789, 0.9011743089431423, 0.8959041260921087, 0.5095942098059343, 0.16901390618630918, 0.6934330083235397, 0.5917691966266175, 0.15209517757355606, 0.5336300101258404, 0.4500939626504836, 0.17555647377368588, 0.7531912688083431, 0.15458508217447142, 0.1615584041251077, 0.1276782780347132, 0.16636796105859142, 0.15549678043000226, 0.12021358110752112, 0.14968304414678857, 0.14078699126386907, 0.167891767026339, 0.9838058013266239, 0.9694671177416156, 0.9725961899910069, 0.9692387617672585, 0.9647802631028122, 0.9670655404819047, 0.9835329544688592, 0.9829405410083849, 0.9629665417690197, 0.7818675198812189, 0.6083636224562758, 0.7897389080387806, 0.7669207306295505, 0.8559527771766778, 0.7652542061868455, 0.7529073029406428, 0.6221598325627973, 0.7925073654665784, 0.8146780927269315, 0.9197787517093075, 0.8730587828156395, 0.9035309701060645, 0.38118424485164526, 0.19309812577941887, 0.8278965398062749, 0.9271354588700695, 0.23285238288330123, 0.613574993332948, 0.24398180185822316, 0.1998174780798183, 0.5657242387678642, 0.19905280762500754, 0.6999989211418522, 0.5926179179371891, 0.7141759806616288, 0.29795554876269603, 0.022824080031259686, 0.22963547286163288, 0.5320645340267043, 0.6464462672929503, 0.6226349633631993, 0.7340233038408875, 0.44924910150804664, 0.15311425717896143, 0.1802502164239571, 0.11037257235110176, 0.09313109924853413, 0.08650704529763775, 0.13356747618471232, 0.34304801326689727, 0.08145803232695303, 0.1879768961148559, 0.262251246225503, 0.1473768613375761, 0.07298049718381439, 0.16719106860433297, 0.21891663213565526, 0.16124145163236792, 0.22496693391945288, 0.16987249090774348, 0.19478455091726787, 0.2725830466267106, 0.21443340658094034, 0.055725167780326434, 0.13161021776558102, 0.10157383592852076, 0.11144270021844527, 0.23794264456172454, 0.08897875331960092, 0.14330453282057842, 0.17771875111812674, 0.13922185528678965, 0.29446540695976475, 0.32060475311128933, 0.33178223380687144, 0.2725093584648227, 0.39560227524176916, 0.31192924646611353, 0.28522244149678067, 0.31939859768048007, 0.32726668440871176, 0.6844987740929902, 0.7179961117115271, 0.6933471914854172, 0.6697313886919609, 0.7509880037023637, 0.6661231081383231, 0.6927944436962947, 0.7344338449288377, 0.795573968428052, 0.09672543721141524, 0.1336924985677158, 0.11537314383042663, 0.11157499358014122, 0.11727990272718303, 0.11378681414749447, 0.08804383716277875, 0.13112323724992148, 0.12093215853859851, 0.18942945493466723, 0.18308704944411347, 0.21504073718527428, 0.17020568005262282, 0.27312635985986333, 0.179114504081747, 0.15170590806320228, 0.35358621043067184, 0.25123736114829287, 0.49741657624777835, 0.5192325139019986, 0.3952454880243569, 0.5551618997726449, 0.7840131359698163, 0.6452752337274192, 0.5413252610286139, 0.6342183555555674, 0.7237672439900644, 0.43636750713651595, 0.6037360680594404, 0.5425272285754088, 0.32252664522950003, 0.5712419265380202, 0.44999101521081086, 0.515770962574188, 0.550452504803094, 0.4632442609787658, 0.17165917777870365, 0.2004003768389535, 0.20600637123173315, 0.1973101831787255, 0.2152217073807532, 0.19096309819220525, 0.21624151785923906, 0.19167564368974288, 0.1999870285073736, 0.21334041627356448, 0.8326998828706907, 0.5798204635966513, 0.6667057907129139, 0.36482718412657933, 0.6081331624000132, 0.24427651712573695, 0.2501843147953643, 0.7806070205311132, 0.21061017539422078, 0.19927946789610174, 0.18708478052216737, 0.9164075391352507, 0.1636537202588153, 0.16444059168829206, 0.8702557988429975, 0.19724482657677422, 0.1399759704809994, 0.11336158526022222, 0.1697998148572678, 0.2061474352253717, 0.1666190902670458, 0.8144411680326338, 0.20973032930293434, 0.20963873369160135, 0.2091137480803016, 0.8260428141150784, 0.193906690089644, 0.17811574017809761, 0.18308943272574785, 0.18239028124969103, 0.1800591159583268, 0.18703987183380433, 0.19985840850727254, 0.1703540218250087, 0.18066594504194688, 0.08015377302395499, 0.08570334476455899, 0.08683510994151233, 0.0871355830519186, 0.08944071792522723, 0.08290722743775003, 0.08256815205479329, 0.08456993676616364, 0.08097722425833165]}, "mutation_prompt": null}
{"id": "92038805-03f1-4526-a1c3-13e646d8f651", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "534eac86-d158-4285-aef7-3ab4302ed47d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 5 + int(self.dim * np.log(self.dim)))  # Dynamic population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Self-adaptive mutation factor\n        self.crossover_rate = 0.8 + np.random.rand(self.population_size) * 0.2  # Self-adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with local search intensification\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.1 * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Size and Local Search Intensification for improved exploitation-exploration balance.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.9071979993370288, 0.9308328854048237, 0.9311221163642268, 0.9058155833428774, 0.921731543170365, 0.932156980968529, 0.910375437013408, 0.8800595462001667, 0.9230746612058716, 0.836036541857204, 0.8582591617873322, 0.8772725616733302, 0.838755099966976, 0.8687965662639763, 0.8713270171149301, 0.8538222672776985, 0.882938632445374, 0.8710862121172657, 0.45984189619318205, 0.6071787424385355, 0.11603678533260486, 0.4466882324581004, 0.17179229712102895, 0.5987175154121259, 0.1657395358972783, 0.16970468390499827, 0.1495993867379002, 0.15189329591847112, 0.14665185810211645, 0.13894560300360403, 0.15583814419540298, 0.14977455949627205, 0.15446588007947415, 0.1485561026722837, 0.1285912408913359, 0.1597806434545158, 0.9748208689878125, 0.957725498399412, 0.9746623879673428, 0.9669105883097797, 0.9778196154054294, 0.9415617065789192, 0.9766726183552632, 0.952936992990384, 0.976884338801959, 0.7715594688478455, 0.7931276754897636, 0.8147501787193975, 0.7176325796161639, 0.7174242671871893, 0.780715556124113, 0.7585760157206689, 0.7618583207172229, 0.6179723823123222, 0.8835637097681674, 0.9391357930407529, 0.8645818281756156, 0.8785589839964938, 0.9106935269735559, 0.9136870252969077, 0.8832328655378341, 0.17376587295959411, 0.9112490390946442, 0.6354006957637326, 0.1655241908290076, 0.13473790509434436, 0.6494625338054566, 0.1649568496592283, 0.7226024351775808, 0.707520735238183, 0.20957635996232238, 0.70173067600108, 0.010151788581156174, 0.149761482158573, 0.20014692466669315, 0.6843259732442544, 0.8127173352836952, 0.2891230877342317, 0.6118957130317941, 0.23160296310049588, 0.24626513867892885, 0.19645068425312295, 0.10754691892066404, 0.255157765059833, 0.10964095606121105, 0.19882830074881142, 0.21616677507089677, 0.287745717786726, 0.4539668440135721, 0.27615960802322015, 0.3158208620584424, 0.19885419221017675, 0.2646985647378526, 0.2006577645414983, 0.17357216926696584, 0.20319645118742735, 0.3115823754676016, 0.2829584933588888, 0.318239923018266, 9.999999999998899e-05, 0.18709435048462297, 0.14105841039418376, 0.13755353567479356, 0.08034393201917933, 0.19753764130729135, 0.11659966286891998, 0.24439898330692666, 0.11637194267800754, 0.3410363292093057, 0.33982613214967383, 0.36199534841034653, 0.2967343340076042, 0.38491736627275264, 0.34296282091306984, 0.2713080149460638, 0.3802091001154073, 0.37220287801672325, 0.6678804734743312, 0.8463561234807442, 0.7345822825304966, 0.6968224260460951, 0.7218933272839236, 0.7115802937491659, 0.6915244486793759, 0.7607719679426981, 0.7992601198593217, 0.7086202949947052, 0.13241727423479077, 0.10729384414562992, 0.10984375241438105, 0.13130683787280528, 0.1362876736329086, 0.15085638239608457, 0.14273725740014975, 0.12047017043547037, 0.20448489634352485, 0.3666835939321442, 0.15015810479556602, 0.30359355007693656, 0.31589220283235653, 0.17500846391099711, 0.2071859149195947, 0.1953957964252253, 0.2906516216819397, 0.6153771140963703, 0.5934405658304907, 0.6064512275075803, 0.6244631458545746, 0.3583385563813243, 0.7253451807490228, 0.5888517310255907, 0.7635811068110305, 0.6288324092365697, 0.36402482215664145, 0.5289783356305181, 0.49222108284065935, 0.3262188127183172, 0.21639556097439927, 0.24150120642540263, 0.3965137857470813, 0.6602088158609212, 0.5720092475384386, 0.22932634361919058, 0.18761794474818305, 0.19416328843749753, 0.18928816233713663, 0.196995797949981, 0.19725540186892954, 0.19297607692326424, 0.18221084642800578, 0.20268106225051064, 0.21816536345852666, 0.7444265224550929, 0.580189121101229, 0.2064959226452705, 0.23539475792191533, 0.779454780935963, 0.6096574850145464, 0.18921625643227158, 0.22405238243169834, 0.8847165645920734, 0.9342967757202731, 0.8944434852864096, 0.16687789775490725, 0.915028835311916, 0.16893964053474297, 0.15639160027394372, 0.8429040406839743, 0.20660486867936656, 0.12787369504098045, 0.1694422290154871, 0.2098066031711605, 0.8921878837340447, 0.4430627484938281, 0.21041266914819434, 0.2039284606721603, 0.21337627404241544, 0.21384482953393458, 0.1899499474212204, 0.19000083471631624, 0.18865071410858536, 0.1499754665880637, 0.18733120805643622, 0.18022691861106466, 0.1883638381402054, 0.1931893599704806, 0.180668026625044, 0.07869471896818392, 0.08135747613969668, 0.07741854544852034, 0.07846027126590815, 0.08347511069863145, 0.0861996457244788, 0.07270245575869672, 0.08877706610300917, 0.07752866290897598]}, "mutation_prompt": null}
{"id": "294e9389-b0e5-4203-93fb-8e752c633d77", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 6 + int(self.dim * np.log(self.dim)))  # Slightly increased population size\n        self.mutation_factor = 0.4 + np.random.rand(self.population_size) * 0.6  # Wider range for mutation factor\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Wider range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with randomized local search\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * np.random.rand() * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Randomized Local Search and Adaptive Parameters for Robust Global Optimization.", "configspace": "", "generation": 45, "fitness": 0.4398972124612697, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "2293262d-2f01-4a63-9c95-fc9207790fc5", "metadata": {"aucs": [0.8962861910568224, 0.9234332697724653, 0.9282870990157953, 0.8979817934919099, 0.9377644169287862, 0.930648911016939, 0.9041382146156348, 0.920732872425808, 0.9315621249014248, 0.8370285545419068, 0.8844696057851783, 0.8801032457058396, 0.8195183298915301, 0.8791569935060592, 0.8817730105523484, 0.8482357786686603, 0.875041184766015, 0.8452614433263665, 0.5532101837507548, 0.15440472222739865, 0.6242450568167751, 0.6969992969392, 0.17171197032835295, 0.17930616891270545, 0.32072247887955563, 0.14571563856138636, 0.1711579990595674, 0.13287902738268076, 0.14471701647610535, 0.1601170138681589, 0.4235283315989553, 0.6441311723830063, 0.17150997971186466, 0.14731836205586768, 0.1533893351197525, 0.16816905934876702, 0.9730564459801526, 0.9724202810541239, 0.988960574531336, 0.9872248139752459, 0.9553076930448086, 0.9824535724759942, 0.9749006130038409, 0.9796722868261473, 0.9436854664211685, 0.7544237687591409, 0.7856514797786837, 0.7853208756293704, 0.7293553791093268, 0.6888166838597887, 0.7962681345095293, 0.746013009424428, 0.791237726874145, 0.7075844339468808, 0.8408808572956379, 0.8847373143160032, 0.38448896890937356, 0.8420995622537841, 0.914381283061826, 0.19186570693296778, 0.8664483405593848, 0.8802934754873232, 0.903599285709338, 0.5629103542172013, 0.5704703621063211, 0.13331876498885487, 0.4811296055467027, 0.6677155982000165, 0.6587149797336732, 0.5223490927260308, 0.21699541947554313, 0.1665786340921659, 0.5131685448635724, 0.6937284611841682, 0.13338295749210283, 0.5541770628616006, 0.17317335321084648, 0.13007452446183398, 0.5309814667133474, 0.5649053629298209, 0.1335463275634574, 9.999999999998899e-05, 0.32483727396523654, 0.10595042200807148, 0.13521844235827452, 0.2607267070993021, 0.31672637083994026, 0.253538517561371, 0.24818943913521707, 0.20316004222376183, 0.2161642756552573, 0.34637290202866333, 0.2366819905540376, 0.2310274164164684, 0.22488418601025983, 0.1666696070262167, 0.3309626985518176, 0.2646719256576948, 0.10337758784270645, 0.13858920335229574, 0.09054181262635463, 0.22529448537733765, 0.14153731010510606, 0.3458767482112628, 0.2273623984069144, 0.2102630434399263, 0.16328741641880118, 0.32587991879062506, 0.30954586477325696, 0.38204343370998295, 0.35705076826368853, 0.3020105021264521, 0.3497396254948826, 0.378315642187675, 0.24790586727034347, 0.34382761459001554, 0.3348078248824534, 0.6838569982302168, 0.7123492384898908, 0.705108216168739, 0.6808035747357875, 0.7048311220139677, 0.7034344587395867, 0.690486666211479, 0.7506256583274044, 0.759079942121403, 0.1175052417194643, 0.12716035287220473, 0.09091648916332984, 0.13840874486057986, 0.10953562284441887, 0.1356864827519143, 0.0993603874648945, 0.12721582233604045, 0.10356963668280295, 0.3919031761905518, 0.1426910570365728, 0.1815993315490878, 0.1825101673245635, 0.4450642583012203, 0.1776246404292855, 0.15113843603293675, 0.6560460005901292, 0.17485734277633436, 0.5105609082721962, 0.5996303902200597, 0.7287247532848662, 0.5543374771114837, 0.6798852799391202, 0.6020944199598934, 0.6339416226312802, 0.5777856549129892, 0.6011452625835219, 0.38513647625376546, 0.493565130483095, 0.463969700640845, 0.3590324129720094, 0.4642923725590328, 0.43184674577808047, 0.3588490569924099, 0.6130754845525929, 0.5266194009357956, 0.1751046633388944, 0.18718225115665765, 0.19196395324591897, 0.23629564470948128, 0.19915460231649862, 0.23651469813122605, 0.19230633941475384, 0.2034514628945877, 0.19715041574370673, 0.21814857574097435, 0.7592734289206173, 0.24412123473757696, 0.7224657335695918, 0.214754951231223, 0.5287599721023521, 0.21856771660524832, 0.2379225212487882, 0.7832243807574308, 0.17003543170300672, 0.17315570421097504, 0.7922141818967511, 0.9198863975412795, 0.17620426473458195, 0.1598224789178605, 0.1967715336757947, 0.7857083109660886, 0.8891642123400171, 0.21211422269790814, 0.16727761152862008, 0.16854815563364878, 0.7531191853188484, 0.16881579776038835, 0.20404212163435698, 0.83978335891715, 0.1568303155575722, 0.6834407264489039, 0.18523301501557754, 0.18230063726721624, 0.18039826957188, 0.18812387145380471, 0.19458082102033225, 0.17587353249520188, 0.1977482477266499, 0.16904349500009375, 0.20724431359149487, 0.08424220866941434, 0.08620993480278194, 0.08182958912792271, 0.07964434367739415, 0.08343453676363222, 0.08451283520159902, 0.08624719015917692, 0.08751859199001921, 0.08619024025391842]}, "mutation_prompt": null}
{"id": "5e5a98a1-5e4c-48ae-beed-a71eda3e2ab2", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 6 + int(self.dim * np.log(self.dim)))  # Slightly increased population size\n        self.mutation_factor = 0.4 + np.random.rand(self.population_size) * 0.6  # Wider range for mutation factor\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Wider range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with randomized local search\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                perturbation = np.random.randn(self.dim) * 0.2 * np.random.rand() * (best_solution - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Randomized Local Search and Adaptive Parameters for Robust Global Optimization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "294e9389-b0e5-4203-93fb-8e752c633d77", "metadata": {"aucs": [0.8962861910568224, 0.9234332697724653, 0.9282870990157953, 0.8979817934919099, 0.9377644169287862, 0.930648911016939, 0.9041382146156348, 0.920732872425808, 0.9315621249014248, 0.8370285545419068, 0.8844696057851783, 0.8801032457058396, 0.8195183298915301, 0.8791569935060592, 0.8817730105523484, 0.8482357786686603, 0.875041184766015, 0.8452614433263665, 0.5532101837507548, 0.15440472222739865, 0.6242450568167751, 0.6969992969392, 0.17171197032835295, 0.17930616891270545, 0.32072247887955563, 0.14571563856138636, 0.1711579990595674, 0.13287902738268076, 0.14471701647610535, 0.1601170138681589, 0.4235283315989553, 0.6441311723830063, 0.17150997971186466, 0.14731836205586768, 0.1533893351197525, 0.16816905934876702, 0.9730564459801526, 0.9724202810541239, 0.988960574531336, 0.9872248139752459, 0.9553076930448086, 0.9824535724759942, 0.9749006130038409, 0.9796722868261473, 0.9436854664211685, 0.7544237687591409, 0.7856514797786837, 0.7853208756293704, 0.7293553791093268, 0.6888166838597887, 0.7962681345095293, 0.746013009424428, 0.791237726874145, 0.7075844339468808, 0.8408808572956379, 0.8847373143160032, 0.38448896890937356, 0.8420995622537841, 0.914381283061826, 0.19186570693296778, 0.8664483405593848, 0.8802934754873232, 0.903599285709338, 0.5629103542172013, 0.5704703621063211, 0.13331876498885487, 0.4811296055467027, 0.6677155982000165, 0.6587149797336732, 0.5223490927260308, 0.21699541947554313, 0.1665786340921659, 0.5131685448635724, 0.6937284611841682, 0.13338295749210283, 0.5541770628616006, 0.17317335321084648, 0.13007452446183398, 0.5309814667133474, 0.5649053629298209, 0.1335463275634574, 9.999999999998899e-05, 0.32483727396523654, 0.10595042200807148, 0.13521844235827452, 0.2607267070993021, 0.31672637083994026, 0.253538517561371, 0.24818943913521707, 0.20316004222376183, 0.2161642756552573, 0.34637290202866333, 0.2366819905540376, 0.2310274164164684, 0.22488418601025983, 0.1666696070262167, 0.3309626985518176, 0.2646719256576948, 0.10337758784270645, 0.13858920335229574, 0.09054181262635463, 0.22529448537733765, 0.14153731010510606, 0.3458767482112628, 0.2273623984069144, 0.2102630434399263, 0.16328741641880118, 0.32587991879062506, 0.30954586477325696, 0.38204343370998295, 0.35705076826368853, 0.3020105021264521, 0.3497396254948826, 0.378315642187675, 0.24790586727034347, 0.34382761459001554, 0.3348078248824534, 0.6838569982302168, 0.7123492384898908, 0.705108216168739, 0.6808035747357875, 0.7048311220139677, 0.7034344587395867, 0.690486666211479, 0.7506256583274044, 0.759079942121403, 0.1175052417194643, 0.12716035287220473, 0.09091648916332984, 0.13840874486057986, 0.10953562284441887, 0.1356864827519143, 0.0993603874648945, 0.12721582233604045, 0.10356963668280295, 0.3919031761905518, 0.1426910570365728, 0.1815993315490878, 0.1825101673245635, 0.4450642583012203, 0.1776246404292855, 0.15113843603293675, 0.6560460005901292, 0.17485734277633436, 0.5105609082721962, 0.5996303902200597, 0.7287247532848662, 0.5543374771114837, 0.6798852799391202, 0.6020944199598934, 0.6339416226312802, 0.5777856549129892, 0.6011452625835219, 0.38513647625376546, 0.493565130483095, 0.463969700640845, 0.3590324129720094, 0.4642923725590328, 0.43184674577808047, 0.3588490569924099, 0.6130754845525929, 0.5266194009357956, 0.1751046633388944, 0.18718225115665765, 0.19196395324591897, 0.23629564470948128, 0.19915460231649862, 0.23651469813122605, 0.19230633941475384, 0.2034514628945877, 0.19715041574370673, 0.21814857574097435, 0.7592734289206173, 0.24412123473757696, 0.7224657335695918, 0.214754951231223, 0.5287599721023521, 0.21856771660524832, 0.2379225212487882, 0.7832243807574308, 0.17003543170300672, 0.17315570421097504, 0.7922141818967511, 0.9198863975412795, 0.17620426473458195, 0.1598224789178605, 0.1967715336757947, 0.7857083109660886, 0.8891642123400171, 0.21211422269790814, 0.16727761152862008, 0.16854815563364878, 0.7531191853188484, 0.16881579776038835, 0.20404212163435698, 0.83978335891715, 0.1568303155575722, 0.6834407264489039, 0.18523301501557754, 0.18230063726721624, 0.18039826957188, 0.18812387145380471, 0.19458082102033225, 0.17587353249520188, 0.1977482477266499, 0.16904349500009375, 0.20724431359149487, 0.08424220866941434, 0.08620993480278194, 0.08182958912792271, 0.07964434367739415, 0.08343453676363222, 0.08451283520159902, 0.08624719015917692, 0.08751859199001921, 0.08619024025391842]}, "mutation_prompt": null}
{"id": "a128df0e-8017-472d-8c39-d268f2058f9d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, 6 + int(self.dim * np.log(self.dim)))  # Slightly increased population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.5  # Adjusted mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.3  # Wide range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            # Adaptive population size based on budget\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with gradient-inspired local search\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                gradient = np.random.randn(self.dim) * 0.1 * (x0 - best_solution)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                # Crossover with self-adaptive rate\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Population Size and Gradient-Inspired Local Search.", "configspace": "", "generation": 47, "fitness": 0.4409990304373408, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "294e9389-b0e5-4203-93fb-8e752c633d77", "metadata": {"aucs": [0.8846226690470782, 0.9138707365767811, 0.9099856512088196, 0.8850506385286165, 0.9152955567338965, 0.9122542674033075, 0.8973469163810547, 0.9295693505022272, 0.9222434643454268, 0.8166443169668491, 0.8515654819697135, 0.8527476060612204, 0.8223329550786442, 0.8483836753988887, 0.8669126247859311, 0.8179926500067028, 0.8645349438636916, 0.8369416682599922, 0.3910410509940154, 0.5256487150416078, 0.18266679817458187, 0.5488462720074698, 0.4488633683522829, 0.5771075763292883, 0.4436993005794624, 0.5286486185919759, 0.5640527297995641, 0.16758388255066492, 0.3929106278334672, 0.13195710168176522, 0.15657911266380253, 0.177533024351619, 0.15276835601851413, 0.1647716474430646, 0.14698738788010102, 0.46288267105829506, 0.9773611605671196, 0.9861248323914875, 0.9752584532731514, 0.9922814228669622, 0.9837489537401944, 0.9826693254411372, 0.9879943526706522, 0.9776794742381223, 0.9849797879274174, 0.7479917980707621, 0.7881141677459169, 0.751094712045768, 0.6925779292810832, 0.7836239761935854, 0.7660476636954605, 0.6913359011639979, 0.67462633479185, 0.6683799355807423, 0.754262664764288, 0.8694119287739377, 0.9079742274953073, 0.8493308118530782, 0.211457892999263, 0.859012205248724, 0.8523947259051767, 0.9127133436746565, 0.8340088337520686, 0.510913100518444, 0.5377953517240497, 0.7249053858668519, 0.5748439896675629, 0.6131343467107822, 0.6927810181375305, 0.5370390802347134, 0.6164015834148495, 0.5149888330829525, 0.48222962146335924, 0.44329654226053083, 0.022033776162335705, 0.5519086708504954, 0.7288244038404941, 0.1339539899594172, 0.5393535325593604, 0.5374155909292575, 0.2736732751121711, 0.1260757494776863, 0.20872872698393785, 0.14193235741041155, 0.15180045710407664, 0.13824373744253915, 0.15924433478985123, 0.12099844512617097, 0.28109060878151937, 0.20194522184191832, 0.203001788731475, 0.2682418186219565, 0.17060467053780848, 0.19458192323237122, 0.22008239805672203, 0.198081951292025, 0.16883993081272108, 0.20799761624596524, 0.12663578066438264, 0.09636547781193983, 0.07713067535488882, 0.05433330012215032, 0.18712782088941926, 0.1473978237361021, 0.18588287179562912, 0.11436665163990745, 0.19634040723828494, 0.13742102051690364, 0.27646527319324987, 0.30755367225571106, 0.316584632606856, 0.29529791475603784, 0.3115809223370968, 0.335814386941362, 0.2704305009493514, 0.294711042754076, 0.2646513692112671, 0.6344168311317342, 0.6942779902844792, 0.6655900653399744, 0.6573118357556069, 0.6803974175083647, 0.7040379616415042, 0.6459460147001818, 0.7180821269911943, 0.7273249133464568, 0.12132722637806292, 0.10046514986748845, 0.10380342987308577, 0.08579838213340296, 0.12144768464981304, 0.10216119267544543, 0.09668704388722837, 0.11247429632561523, 0.11030570685595031, 0.16702608026406285, 0.17469471001687598, 0.30329461582100004, 0.5735389946300791, 0.17958634555412623, 0.15995742195630414, 0.1846084109269639, 0.20174905836015944, 0.13680240917566988, 0.5218256338777005, 0.6152031037053364, 0.6157494879839288, 0.5190939701904684, 0.5717952969801394, 0.6623051629907812, 0.6057965815166898, 0.7303399157009919, 0.691738144159378, 0.3636251695936831, 0.3747598049800651, 0.3435661141272618, 0.3951763233858676, 0.40495966154384366, 0.3619361463273232, 0.41172958935290827, 0.5860609125727934, 0.4360879440384894, 0.17957779922715889, 0.20185450118584203, 0.20349944271349807, 0.20487934148259612, 0.19026041558384077, 0.2094872014814414, 0.198319562109616, 0.19415249290946512, 0.19547449867242228, 0.6709191724907655, 0.23470777620818106, 0.45325749583463093, 0.4436766092688291, 0.6474873487804439, 0.5715820454416884, 0.5035079320098241, 0.6248070931574294, 0.5232818453222661, 0.19982925117639794, 0.18540278236215046, 0.17773715112606003, 0.18731406226526293, 0.1769930980526755, 0.16226214488472435, 0.168892328109852, 0.9092090052230037, 0.9047741516651814, 0.20835409254527226, 0.8505227885551427, 0.1671119794074606, 0.20473585855144005, 0.7647040981497046, 0.207667158562708, 0.8823468995987618, 0.166297363373906, 0.8470508743221629, 0.1857410418808737, 0.18151642614756747, 0.18290406174360752, 0.1833816386748418, 0.21668251822913787, 0.18693232814310645, 0.19384364478146254, 0.22439883602665323, 0.1847896515225208, 0.08424549187567232, 0.09074145746170303, 0.08115293407315116, 0.07854267808707593, 0.08060483509375571, 0.08678130499916448, 0.08511450979726742, 0.08137132797667113, 0.08187034267985527]}, "mutation_prompt": null}
{"id": "89f4ad85-4df4-4d7a-ab1e-6d0384728b0a", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 7 + int(self.dim * np.log(self.dim)))  # Adjusted population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Narrowed mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.4  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                gradient = np.random.randn(self.dim) * 0.15 * (x0 - best_solution)  # Slightly increased gradient influence\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Gradient-Inspired Exploration and Budget-Aware Variability.", "configspace": "", "generation": 48, "fitness": 0.45233697704839876, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.31.", "error": "", "parent_id": "a128df0e-8017-472d-8c39-d268f2058f9d", "metadata": {"aucs": [0.9145752154423313, 0.9333357663702485, 0.9238607574024407, 0.9240117195169676, 0.9259792718506562, 0.9293016869562493, 0.9164482974883345, 0.9168987608849106, 0.9221871109532239, 0.857952304536715, 0.8829323581084728, 0.8790062890896541, 0.8600995328492835, 0.8922264272078636, 0.8522669856067333, 0.8626400504137447, 0.8622417207058637, 0.8656763035230838, 0.14472882049844538, 0.1589385789474772, 0.155243359030793, 0.11925629383204339, 0.630475704065851, 0.17227667702333782, 0.5394096758744772, 0.1643875546421446, 0.135542036036303, 0.1306939307944991, 0.1153796324009756, 0.5548310666788232, 0.1354638813828184, 0.1372658761330997, 0.1627762267054066, 0.14765259789728902, 0.12641587333123916, 0.13041071244949376, 0.9805826566316859, 0.9551714252355056, 0.9697793876495134, 0.9658688117064125, 0.9899364425730826, 0.9685540507768771, 0.9593637446737794, 0.9584439391945754, 0.976097779511699, 0.7740561760343667, 0.7653163103496419, 0.8152696094319116, 0.7690679894142124, 0.5450925023958493, 0.7636583197526339, 0.7291289032752717, 0.5188566284874983, 0.7068997407320816, 0.8410925774273039, 0.2546845366634689, 0.3393691647248409, 0.8964595414489216, 0.9055737456272893, 0.8975940316335292, 0.8782412147036782, 0.5053367422783914, 0.8797195904115555, 0.5631298192445021, 0.5205073869241151, 0.17085579869575396, 0.7186489225980318, 0.1448383611618974, 0.6793849106322136, 0.19831763039151518, 0.7474766450285173, 0.6786557140972427, 0.6278645046330581, 0.1866667406768645, 0.2264787424172683, 0.6574283862148524, 0.6658441766539918, 0.23006709991772056, 0.36828374444399536, 0.19450144769036726, 0.202065371324882, 0.2123037179383851, 0.19771045496924833, 0.15508026610751768, 0.19072467191744014, 0.15903136244365323, 0.18471275425948674, 0.264550795068051, 0.3257397921087253, 0.301260752100866, 0.24159721455418726, 0.3295153553299164, 0.1836658102355473, 0.27740615484858155, 0.2203565914533745, 0.15130762658119767, 0.23681118162589931, 0.350517281492864, 0.13579675796432655, 0.22782667829422032, 0.11850405147279908, 0.295656307887733, 0.08294581817823032, 0.19003094327336068, 0.29410413806693714, 0.11238978693006607, 0.1870309096365841, 0.15207537481223554, 0.33379400774271917, 0.3117296564589028, 0.2914693240244026, 0.3398015545811529, 0.2837011251264725, 0.32925336794364124, 0.3344481634332508, 0.3504249116866053, 0.23288508035179234, 0.7292174075728058, 0.7629675337609481, 0.7330156013736273, 0.701538119246859, 0.7855687111366433, 0.7452005415513836, 0.7122367646187799, 0.6827087768340059, 0.7193491828521856, 0.11671922001112633, 0.0993676594065741, 0.10195365246711541, 0.11983197993916406, 0.13067508431152985, 0.11542585233424019, 0.10838278937449886, 0.09839162443167115, 0.13897590730408915, 0.14394359494654985, 0.4808906301553477, 0.13049976031964527, 0.14285712110221827, 0.2192374423992176, 0.2172039328010692, 0.6379147596870773, 0.23225692338045634, 0.12820909184589968, 0.6332559555792929, 0.7741287781318682, 0.6607136712578249, 0.6383913550245917, 0.7337721819949525, 0.721633474375486, 0.6785261154113261, 0.7423074557768226, 0.7203148220153885, 0.44570201970631285, 0.5868422766581737, 0.42146565119373813, 0.4558351696358339, 0.4928269599561509, 0.2879262592292038, 0.5422552594596788, 0.6582615123017972, 0.4860135983635593, 0.20415422694980512, 0.19670611046405928, 0.19747000248251856, 0.20416750243210857, 0.1925349227294817, 0.20516700864004078, 0.18936165787053305, 0.18994800674475731, 0.23399185911525333, 0.4121551285003323, 0.24702212345774488, 0.5895732033531862, 0.8013843323154008, 0.7844789952462554, 0.24451174631783168, 0.5176040250873999, 0.24583458511080192, 0.24836372512958083, 0.19674447144607055, 0.9267272108418136, 0.16747035269055266, 0.8890490852535237, 0.9141903944915706, 0.8500902607811047, 0.8980310799022181, 0.9194816196328754, 0.1857557636823819, 0.8811641239816566, 0.8769135356677054, 0.8747699332355379, 0.8836850290567425, 0.15447655180307973, 0.8084968156725141, 0.10526824147725711, 0.21279345453821574, 0.15591718734585824, 0.18028501163356925, 0.18773862127485885, 0.18682626648248424, 0.1763291144061475, 0.2023319730490265, 0.17823761254904424, 0.19288053902472302, 0.18970706365864043, 0.1703480129439906, 0.07569777698173275, 0.0679125837098683, 0.09010341752778295, 0.0832629787324004, 0.09328167064610648, 0.08164194224016941, 0.08877888263895473, 0.09195548122570085, 0.08812187602039101]}, "mutation_prompt": null}
{"id": "89d55076-f767-4e37-a7e7-67db05593991", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 7 + int(self.dim * np.log(self.dim)))  # Adjusted population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Narrowed mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.4  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                gradient = np.random.randn(self.dim) * 0.15 * (x0 - best_solution)  # Slightly increased gradient influence\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Gradient-Inspired Exploration and Budget-Aware Variability.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89f4ad85-4df4-4d7a-ab1e-6d0384728b0a", "metadata": {"aucs": [0.9145752154423313, 0.9333357663702485, 0.9238607574024407, 0.9240117195169676, 0.9259792718506562, 0.9293016869562493, 0.9164482974883345, 0.9168987608849106, 0.9221871109532239, 0.857952304536715, 0.8829323581084728, 0.8790062890896541, 0.8600995328492835, 0.8922264272078636, 0.8522669856067333, 0.8626400504137447, 0.8622417207058637, 0.8656763035230838, 0.14472882049844538, 0.1589385789474772, 0.155243359030793, 0.11925629383204339, 0.630475704065851, 0.17227667702333782, 0.5394096758744772, 0.1643875546421446, 0.135542036036303, 0.1306939307944991, 0.1153796324009756, 0.5548310666788232, 0.1354638813828184, 0.1372658761330997, 0.1627762267054066, 0.14765259789728902, 0.12641587333123916, 0.13041071244949376, 0.9805826566316859, 0.9551714252355056, 0.9697793876495134, 0.9658688117064125, 0.9899364425730826, 0.9685540507768771, 0.9593637446737794, 0.9584439391945754, 0.976097779511699, 0.7740561760343667, 0.7653163103496419, 0.8152696094319116, 0.7690679894142124, 0.5450925023958493, 0.7636583197526339, 0.7291289032752717, 0.5188566284874983, 0.7068997407320816, 0.8410925774273039, 0.2546845366634689, 0.3393691647248409, 0.8964595414489216, 0.9055737456272893, 0.8975940316335292, 0.8782412147036782, 0.5053367422783914, 0.8797195904115555, 0.5631298192445021, 0.5205073869241151, 0.17085579869575396, 0.7186489225980318, 0.1448383611618974, 0.6793849106322136, 0.19831763039151518, 0.7474766450285173, 0.6786557140972427, 0.6278645046330581, 0.1866667406768645, 0.2264787424172683, 0.6574283862148524, 0.6658441766539918, 0.23006709991772056, 0.36828374444399536, 0.19450144769036726, 0.202065371324882, 0.2123037179383851, 0.19771045496924833, 0.15508026610751768, 0.19072467191744014, 0.15903136244365323, 0.18471275425948674, 0.264550795068051, 0.3257397921087253, 0.301260752100866, 0.24159721455418726, 0.3295153553299164, 0.1836658102355473, 0.27740615484858155, 0.2203565914533745, 0.15130762658119767, 0.23681118162589931, 0.350517281492864, 0.13579675796432655, 0.22782667829422032, 0.11850405147279908, 0.295656307887733, 0.08294581817823032, 0.19003094327336068, 0.29410413806693714, 0.11238978693006607, 0.1870309096365841, 0.15207537481223554, 0.33379400774271917, 0.3117296564589028, 0.2914693240244026, 0.3398015545811529, 0.2837011251264725, 0.32925336794364124, 0.3344481634332508, 0.3504249116866053, 0.23288508035179234, 0.7292174075728058, 0.7629675337609481, 0.7330156013736273, 0.701538119246859, 0.7855687111366433, 0.7452005415513836, 0.7122367646187799, 0.6827087768340059, 0.7193491828521856, 0.11671922001112633, 0.0993676594065741, 0.10195365246711541, 0.11983197993916406, 0.13067508431152985, 0.11542585233424019, 0.10838278937449886, 0.09839162443167115, 0.13897590730408915, 0.14394359494654985, 0.4808906301553477, 0.13049976031964527, 0.14285712110221827, 0.2192374423992176, 0.2172039328010692, 0.6379147596870773, 0.23225692338045634, 0.12820909184589968, 0.6332559555792929, 0.7741287781318682, 0.6607136712578249, 0.6383913550245917, 0.7337721819949525, 0.721633474375486, 0.6785261154113261, 0.7423074557768226, 0.7203148220153885, 0.44570201970631285, 0.5868422766581737, 0.42146565119373813, 0.4558351696358339, 0.4928269599561509, 0.2879262592292038, 0.5422552594596788, 0.6582615123017972, 0.4860135983635593, 0.20415422694980512, 0.19670611046405928, 0.19747000248251856, 0.20416750243210857, 0.1925349227294817, 0.20516700864004078, 0.18936165787053305, 0.18994800674475731, 0.23399185911525333, 0.4121551285003323, 0.24702212345774488, 0.5895732033531862, 0.8013843323154008, 0.7844789952462554, 0.24451174631783168, 0.5176040250873999, 0.24583458511080192, 0.24836372512958083, 0.19674447144607055, 0.9267272108418136, 0.16747035269055266, 0.8890490852535237, 0.9141903944915706, 0.8500902607811047, 0.8980310799022181, 0.9194816196328754, 0.1857557636823819, 0.8811641239816566, 0.8769135356677054, 0.8747699332355379, 0.8836850290567425, 0.15447655180307973, 0.8084968156725141, 0.10526824147725711, 0.21279345453821574, 0.15591718734585824, 0.18028501163356925, 0.18773862127485885, 0.18682626648248424, 0.1763291144061475, 0.2023319730490265, 0.17823761254904424, 0.19288053902472302, 0.18970706365864043, 0.1703480129439906, 0.07569777698173275, 0.0679125837098683, 0.09010341752778295, 0.0832629787324004, 0.09328167064610648, 0.08164194224016941, 0.08877888263895473, 0.09195548122570085, 0.08812187602039101]}, "mutation_prompt": null}
{"id": "27553f4d-377a-4347-805d-759ab292e7f1", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 7 + int(self.dim * np.log(self.dim)))  # Adjusted population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Narrowed mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.4  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                gradient = np.random.randn(self.dim) * 0.15 * (x0 - best_solution)  # Slightly increased gradient influence\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Gradient-Inspired Exploration and Budget-Aware Variability.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89f4ad85-4df4-4d7a-ab1e-6d0384728b0a", "metadata": {"aucs": [0.9145752154423313, 0.9333357663702485, 0.9238607574024407, 0.9240117195169676, 0.9259792718506562, 0.9293016869562493, 0.9164482974883345, 0.9168987608849106, 0.9221871109532239, 0.857952304536715, 0.8829323581084728, 0.8790062890896541, 0.8600995328492835, 0.8922264272078636, 0.8522669856067333, 0.8626400504137447, 0.8622417207058637, 0.8656763035230838, 0.14472882049844538, 0.1589385789474772, 0.155243359030793, 0.11925629383204339, 0.630475704065851, 0.17227667702333782, 0.5394096758744772, 0.1643875546421446, 0.135542036036303, 0.1306939307944991, 0.1153796324009756, 0.5548310666788232, 0.1354638813828184, 0.1372658761330997, 0.1627762267054066, 0.14765259789728902, 0.12641587333123916, 0.13041071244949376, 0.9805826566316859, 0.9551714252355056, 0.9697793876495134, 0.9658688117064125, 0.9899364425730826, 0.9685540507768771, 0.9593637446737794, 0.9584439391945754, 0.976097779511699, 0.7740561760343667, 0.7653163103496419, 0.8152696094319116, 0.7690679894142124, 0.5450925023958493, 0.7636583197526339, 0.7291289032752717, 0.5188566284874983, 0.7068997407320816, 0.8410925774273039, 0.2546845366634689, 0.3393691647248409, 0.8964595414489216, 0.9055737456272893, 0.8975940316335292, 0.8782412147036782, 0.5053367422783914, 0.8797195904115555, 0.5631298192445021, 0.5205073869241151, 0.17085579869575396, 0.7186489225980318, 0.1448383611618974, 0.6793849106322136, 0.19831763039151518, 0.7474766450285173, 0.6786557140972427, 0.6278645046330581, 0.1866667406768645, 0.2264787424172683, 0.6574283862148524, 0.6658441766539918, 0.23006709991772056, 0.36828374444399536, 0.19450144769036726, 0.202065371324882, 0.2123037179383851, 0.19771045496924833, 0.15508026610751768, 0.19072467191744014, 0.15903136244365323, 0.18471275425948674, 0.264550795068051, 0.3257397921087253, 0.301260752100866, 0.24159721455418726, 0.3295153553299164, 0.1836658102355473, 0.27740615484858155, 0.2203565914533745, 0.15130762658119767, 0.23681118162589931, 0.350517281492864, 0.13579675796432655, 0.22782667829422032, 0.11850405147279908, 0.295656307887733, 0.08294581817823032, 0.19003094327336068, 0.29410413806693714, 0.11238978693006607, 0.1870309096365841, 0.15207537481223554, 0.33379400774271917, 0.3117296564589028, 0.2914693240244026, 0.3398015545811529, 0.2837011251264725, 0.32925336794364124, 0.3344481634332508, 0.3504249116866053, 0.23288508035179234, 0.7292174075728058, 0.7629675337609481, 0.7330156013736273, 0.701538119246859, 0.7855687111366433, 0.7452005415513836, 0.7122367646187799, 0.6827087768340059, 0.7193491828521856, 0.11671922001112633, 0.0993676594065741, 0.10195365246711541, 0.11983197993916406, 0.13067508431152985, 0.11542585233424019, 0.10838278937449886, 0.09839162443167115, 0.13897590730408915, 0.14394359494654985, 0.4808906301553477, 0.13049976031964527, 0.14285712110221827, 0.2192374423992176, 0.2172039328010692, 0.6379147596870773, 0.23225692338045634, 0.12820909184589968, 0.6332559555792929, 0.7741287781318682, 0.6607136712578249, 0.6383913550245917, 0.7337721819949525, 0.721633474375486, 0.6785261154113261, 0.7423074557768226, 0.7203148220153885, 0.44570201970631285, 0.5868422766581737, 0.42146565119373813, 0.4558351696358339, 0.4928269599561509, 0.2879262592292038, 0.5422552594596788, 0.6582615123017972, 0.4860135983635593, 0.20415422694980512, 0.19670611046405928, 0.19747000248251856, 0.20416750243210857, 0.1925349227294817, 0.20516700864004078, 0.18936165787053305, 0.18994800674475731, 0.23399185911525333, 0.4121551285003323, 0.24702212345774488, 0.5895732033531862, 0.8013843323154008, 0.7844789952462554, 0.24451174631783168, 0.5176040250873999, 0.24583458511080192, 0.24836372512958083, 0.19674447144607055, 0.9267272108418136, 0.16747035269055266, 0.8890490852535237, 0.9141903944915706, 0.8500902607811047, 0.8980310799022181, 0.9194816196328754, 0.1857557636823819, 0.8811641239816566, 0.8769135356677054, 0.8747699332355379, 0.8836850290567425, 0.15447655180307973, 0.8084968156725141, 0.10526824147725711, 0.21279345453821574, 0.15591718734585824, 0.18028501163356925, 0.18773862127485885, 0.18682626648248424, 0.1763291144061475, 0.2023319730490265, 0.17823761254904424, 0.19288053902472302, 0.18970706365864043, 0.1703480129439906, 0.07569777698173275, 0.0679125837098683, 0.09010341752778295, 0.0832629787324004, 0.09328167064610648, 0.08164194224016941, 0.08877888263895473, 0.09195548122570085, 0.08812187602039101]}, "mutation_prompt": null}
{"id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 51, "fitness": 0.46062614241362526, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "89f4ad85-4df4-4d7a-ab1e-6d0384728b0a", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "aaa11aea-dcd1-40aa-aa7b-1f9f056125f7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "549f244b-8349-41eb-b7fa-a779b27bff61", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "b0b0cef9-c162-44b7-8dbd-50c94ce729ff", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "5a12f104-f88c-4327-965b-1344e7dbc3e7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "398ef604-36c3-4ba3-8fb8-39f557db5e4f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "6abc8596-6394-41dc-88cc-86aa30de8d07", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Adjusted mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.2  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.quantum_fluctuation = 0.05  # Quantum-like fluctuation parameter\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)\n                else:\n                    gradient = np.zeros(self.dim)\n\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector += self.quantum_fluctuation * np.random.randn(self.dim)  # Apply quantum fluctuation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Dynamic Adaptive Differential Evolution with Probabilistic Gradient Enhancement and Optimized Resource Utilization.", "configspace": "", "generation": 57, "fitness": 0.28386812513076315, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.5908591395980362, 0.5572706342286646, 0.5736246913857421, 0.5551823841615817, 0.5649294208635549, 0.5555529202843239, 0.5401604396653596, 0.5537517124861899, 0.5472780291675334, 0.194710111651763, 0.1984638884156672, 0.19884781509679128, 0.1875310699185634, 0.21711591514045792, 0.2286584640802808, 0.21659652789147377, 0.22357036072260061, 0.24553353561544933, 0.16704770845743278, 0.22945829961024167, 0.15131330884054517, 0.1438826276825843, 0.17598463378025864, 0.15722502565377927, 0.12150972240425417, 0.21199609595573654, 0.16696415282710808, 0.15827763738960332, 0.14555450069349352, 0.14545754067185568, 0.1326205325080977, 0.14056543880180505, 0.13786488481410797, 0.12603110775838744, 0.11273214405363252, 0.13550699302276448, 0.9664004651671172, 0.9581941298219996, 0.9680713135745579, 0.9612819623100417, 0.9549616881069456, 0.9687030232292145, 0.9789909826031046, 0.9708037310344735, 0.9471417295284745, 0.3551992567764096, 0.4059682885467102, 0.36242522650032216, 0.37766497667811094, 0.37201866212755674, 0.36355344296004133, 0.3652051666383329, 0.39978832299868905, 0.36841626263592975, 0.8208798946038537, 0.8205836174235478, 0.7126111496581706, 0.821709873637464, 0.7689800927087286, 0.8282735832831141, 0.7754410996961881, 0.666270451231226, 0.8308603129716374, 0.1923335785689283, 0.21513265731744158, 0.2243287445229869, 0.2044116546633582, 0.21084858975906806, 0.20178912603037757, 0.20271701317246826, 0.21426720061477678, 0.20186352461409407, 0.21058353109556693, 0.19860317964423646, 0.23428832206576, 0.21851398917758802, 0.20620711156739202, 0.19233320778395002, 0.22873786759636183, 0.2364105444607254, 0.1988823139444863, 0.1004622627593682, 0.07161480353602478, 0.04069664813405138, 0.04208667802212207, 0.07655068978129442, 0.08893095280907437, 0.0503694834296875, 0.08459757165709292, 0.05193423502926309, 0.13818834925761803, 0.11265108052258488, 0.13008573553346559, 0.11390325241905086, 0.16494229061079035, 0.11958361287923325, 0.16180058231412808, 0.11747109137300304, 0.1589769239905181, 0.01835425850760153, 9.999999999998899e-05, 0.0007615264689576628, 0.008376719790302745, 9.999999999998899e-05, 9.999999999998899e-05, 0.009987303774564915, 0.0013648027401595986, 9.999999999998899e-05, 0.14861025309956855, 0.1467694085386969, 0.14563131068851365, 0.14596276674796538, 0.14491795066728863, 0.1562535874967249, 0.138252515296584, 0.15095920886429137, 0.15362119249393147, 0.45865586649340717, 0.4855855907866059, 0.45199513275059455, 0.47636633694105857, 0.47930048883914156, 0.4656799086327741, 0.46832351271602957, 0.4682901825822037, 0.4675390416381311, 0.09916460209346711, 0.10356916100240143, 0.1066876155968206, 0.09607155106859333, 0.10650291649274246, 0.10668274962978341, 0.1322419770266, 0.13714476845653079, 0.11167288985276769, 0.144852541143497, 0.20314675097992885, 0.1777084292559068, 0.34075700897866323, 0.13629631726078295, 0.17886506356185417, 0.323493501079141, 0.17236468323914955, 0.1826589015935144, 0.31947712388043814, 0.32800819801552994, 0.327764377064494, 0.32479649336428607, 0.3404607284385891, 0.33454089490356254, 0.326173927316578, 0.34415623998199896, 0.3444320733471242, 0.26846246031304366, 0.26866756703948635, 0.2795074370140985, 0.2624552623728643, 0.24668152504607277, 0.2760337324132385, 0.26273610964755334, 0.2671358860985962, 0.25330452302211093, 0.2079937022983711, 0.18082940918817847, 0.18387095485488336, 0.20941745259077738, 0.2061033038313107, 0.22260083763362248, 0.1976833551261301, 0.2299592900348686, 0.22803429854802593, 0.21772805247364868, 0.349282381361411, 0.33203784560001226, 0.2914700295495688, 0.22131749427369118, 0.23177299274021657, 0.23422101583342114, 0.2628253756141212, 0.29218081085794567, 0.18496534958860145, 0.8249449742526942, 0.8283237173542928, 0.1690410854441281, 0.19187737916306868, 0.16617649029093406, 0.1692565174802768, 0.7236750326577226, 0.8409733036426754, 0.16836243032732778, 0.16916312868311956, 0.2052128735942076, 0.2050399129134296, 0.16849267624076458, 0.1657298150777886, 0.21072325417102633, 0.7691862880974287, 0.21292601105422304, 0.19277529617183686, 0.1818263180585281, 0.17612216070861086, 0.1803955184998517, 0.19655213080901124, 0.18674629181679592, 0.17609575084060958, 0.17783791371709212, 0.17672382093797767, 0.09105602596758033, 0.08457170681009851, 0.08002941176224232, 0.0797029872296856, 0.09285866205191884, 0.078816459689797, 0.07852127578337242, 0.08674459523586142, 0.08097848315352674]}, "mutation_prompt": null}
{"id": "654a567a-a4c8-4928-b56e-64708387e628", "solution": "import numpy as np\n\nclass GradientOrientedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 7 + int(self.dim * np.log(self.dim)))  # Adjusted population size\n        self.mutation_factor = 0.55 + np.random.rand(self.population_size) * 0.25  # Refined mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.2  # Refined range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Strategy refinement probability\n                    gradient = np.random.randn(self.dim) * 0.25 * (x0 - best_solution)  # Enhanced gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "GradientOrientedDifferentialEvolution", "description": "Gradient-Oriented Adaptive Differential Evolution with Dynamic Feedback and Strategy Refinement.", "configspace": "", "generation": 58, "fitness": 0.4553405409828148, "feedback": "The algorithm GradientOrientedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.8956117740786144, 0.922724985404996, 0.9291939674836853, 0.899968589113964, 0.9162437347172495, 0.9202474967285873, 0.914404068679366, 0.921955545551483, 0.903177487359105, 0.8528616212620642, 0.8693930269267666, 0.8686939069619957, 0.8499144896622389, 0.8656512660102752, 0.07004635825246752, 0.8473811782356693, 0.8670177212756067, 0.8559748505426696, 0.17028191106482882, 0.15834618482621932, 0.6155513190804236, 0.14779934016990648, 0.1647794855795175, 0.7003541872204084, 0.5836239924957988, 0.16315614773430154, 0.5766778913598432, 0.11729273282017205, 0.41410082833430883, 0.14772141310286457, 0.1677221516000864, 0.5113343985179193, 0.1782854730247595, 0.16254161940074696, 0.16596324781979033, 0.13974218162082175, 0.9682854467917528, 0.9539558949107275, 0.9693448800156251, 0.9739121612103324, 0.9658039418894242, 0.9734571284761558, 0.9880392752428481, 0.966706968084154, 0.9669968259073558, 0.7287123532857895, 0.7320767507895589, 0.7555467502403355, 0.7737803756139774, 0.7835963488675023, 0.7818699511156708, 0.7521125242989923, 0.7048203848247, 0.7919269721408296, 0.8346638971352712, 0.8623205526112531, 0.886074837917641, 0.8852807382180382, 0.8867286242249366, 0.8889403068543433, 0.8736889344949836, 0.8776416510734655, 0.8607646289119557, 0.5197873556629123, 0.5609599591513997, 0.22140011766708634, 0.1336821246312624, 0.15701848942171603, 0.2533631555034074, 0.415987069793764, 0.542606718699684, 0.19969305853714836, 0.5477820386034588, 0.22345126342620247, 0.4659954243229183, 0.13157855345138725, 0.1949943719899857, 0.2164344178638543, 0.5349911889763234, 0.6642341701059498, 0.5633186946563763, 0.4650098367300437, 0.36970131630593395, 0.33894959125149193, 0.5664045278389136, 0.33236555100414955, 0.2216900206967619, 0.32587712348044584, 0.4894426682230515, 0.5818919064853049, 0.359977728925998, 0.4243836608699707, 0.43804540135853665, 0.23475969511695283, 0.1975323465116614, 0.42118598439724697, 0.5131491019893633, 0.18404206912247756, 0.23960492454955518, 0.1873368904023357, 0.2856323356972206, 0.21916035171339432, 0.20275480065074492, 0.26543899282643646, 0.28268302860344763, 0.21376259046919044, 0.19153607963650388, 0.3377816983871479, 0.4025053874848712, 0.37459646171857996, 0.43958273126411895, 0.5003271888266416, 0.4626546033215696, 0.38144735510971794, 0.41137200353754966, 0.3287672905152198, 0.3303412949121952, 0.7452256206555108, 0.6190219675659996, 0.7690968533931433, 0.8230851990633911, 0.67839458811603, 0.6855963885935565, 0.823894299653361, 0.6646325482794746, 0.6968670791297291, 0.09184579883951205, 0.3282878010476784, 0.09320946179403322, 0.10666277503091037, 0.1331894468011796, 0.09313160439635848, 0.12654044009225074, 0.10410428695634222, 0.11470792210586389, 0.14128502135948817, 0.14750443166134342, 0.14600638038745128, 0.5236428474277788, 0.17021325729194492, 0.23848917518985524, 0.2769812242416452, 0.13748849389471984, 0.2603564644543127, 0.593163708189347, 0.541120717815516, 0.6542736641686853, 0.5779515295497654, 0.6680415803074812, 0.6672983271415664, 0.6124374656614828, 0.6330359853127041, 0.656916073162289, 0.40440158164733464, 0.46088432972480964, 0.37567235267766674, 0.3526124941131361, 0.4812685058288336, 0.4093481748235831, 0.529489036089429, 0.5740676503159535, 0.36772770375279373, 0.19434988893628702, 0.21277291802114828, 0.18253214727626133, 0.16835658170213486, 0.21445156824679468, 0.2147806040893604, 0.20802412243176627, 0.20166928054402555, 0.18287495616039784, 0.6716552597421137, 0.24645151825991218, 0.6410021456499512, 0.5276230229733165, 0.7172024499171541, 0.43708721803551875, 0.8086997755678771, 0.21078081700378104, 0.6050861629509594, 0.8748017920260804, 0.7808689150083157, 0.1828686062337539, 0.16356087317291423, 0.19755047999173891, 0.16435839184096224, 0.1498700811404442, 0.9176114417526896, 0.8324579721703061, 0.7601136803220551, 0.5389205594050125, 0.2013098653009805, 0.20977011005091362, 0.16496771457071058, 0.2080079488661204, 0.18569007942211746, 0.36206501390529877, 0.2124907909816608, 0.1812308050353132, 0.19438327519652754, 0.18330401938325702, 0.18442809405082072, 0.188307408587425, 0.18211733666647678, 0.1810786219533076, 0.1753212939222507, 0.17110023168711141, 0.0941531065429766, 0.08680936045326848, 0.09681855481344914, 0.07122255095506191, 0.08202344158067632, 0.0754614913704712, 0.0789943355775069, 0.08132377633731025, 0.08186374523198048]}, "mutation_prompt": null}
{"id": "94631e17-7915-4613-8fed-9a702f964a1f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "e7b3df33-c2e6-4357-998c-70e23a7856f6", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "a338aa82-8023-4e0a-ad7f-ff1b37424523", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "4d7ae1fb-dfdc-43a1-941f-67123001d8f8", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "e0003dad-6296-4aa2-9eb0-d87106dde4e7", "solution": "import numpy as np\n\nclass StochasticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Adapted population size\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Dynamic mutation factor range\n        self.crossover_rate = 0.6 + np.random.rand(self.population_size) * 0.4  # Wider range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for dynamic gradient exploration\n                    gradient = np.random.randn(self.dim) * 0.3 * (x0 - best_solution)  # Enhanced gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n                    # Fitness-directed self-adjustment for mutation factor and crossover rate\n                    self.mutation_factor[i] = min(1.0, self.mutation_factor[i] * 1.1)\n                    self.crossover_rate[i] = max(0.4, self.crossover_rate[i] * 0.9)\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "StochasticAdaptiveDE", "description": "Stochastic Adaptive Differential Evolution with Dynamic Gradient Exploration and Fitness-Directed Self-Adjustment.", "configspace": "", "generation": 63, "fitness": 0.31617743695751227, "feedback": "The algorithm StochasticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.8370125547275881, 0.8617589541300272, 0.8525095245238109, 0.8637463071699379, 0.84005314283736, 0.8354361307655991, 0.8512237330603879, 0.8591232835977716, 0.867914409086243, 0.7209070632328892, 0.7498712444909261, 0.7601007993676284, 0.7682110888906057, 0.7467000902865724, 0.7318628308344535, 0.751440596172571, 0.7551187968132331, 0.7825771643526624, 0.7073207812748201, 0.6839777134753968, 0.7255783557498408, 0.697787646124004, 0.7374319204797462, 0.7556090059793982, 0.6909155062371526, 0.6976986189225283, 0.6980341006404254, 0.6780417222431419, 0.6565631881019005, 0.6636561932606463, 0.6529873110603257, 0.17578421469290684, 0.6512392258344604, 0.677141820000341, 0.6743429871039507, 0.5982444626576982, 0.9915125232443395, 0.9743605554915832, 0.9853325529327719, 0.9868461972498973, 0.9831367501421046, 0.983091255297095, 0.9844373119301151, 0.9808159034347025, 0.985370630406687, 0.38806458522227627, 0.3537228212777884, 0.3990395115652827, 0.3081708813622791, 0.33648179626178176, 0.3673487044331516, 0.30417923293150584, 0.33557774722886113, 0.3519765307702378, 0.2857870917721004, 0.277211966360116, 0.26541461173763836, 0.20349825770168795, 0.27146766206401296, 0.2787184871396907, 0.30497279392205645, 0.24536663519067592, 0.2567745823787627, 0.17566301311202237, 0.15807477100212786, 0.1796028413045031, 0.21808209826901914, 0.12729558832141263, 0.1801734037614331, 0.1618881548288268, 0.1723785047396479, 0.18755370985181852, 0.12484940920912924, 0.17107384388509994, 0.12314285348757092, 0.16714782276412354, 0.18363998550378802, 0.16116764238304826, 0.1394115971074854, 0.149935646791448, 0.1500285353682118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003490131335893709, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.057011601758565456, 0.06297830953550654, 0.1078069403484393, 0.07731875380461939, 0.08064350003026899, 0.06072538074976619, 0.04006618707141063, 0.055754161392712054, 0.07432960462838367, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002654726315121092, 9.999999999998899e-05, 0.0953433017985279, 0.08809890879769133, 0.11108144516059615, 0.11114301075679445, 0.15002564198885615, 0.13881287197079362, 0.04629026177180773, 0.09985890890612648, 0.0852101196295938, 0.45136943707589017, 0.4887951354744542, 0.49402288826418184, 0.48138992796134694, 0.49051767192758366, 0.4548472526658205, 0.5126853991736319, 0.49512254857618077, 0.5077428884822685, 0.10322994457080781, 0.11109993175471022, 0.10125867946271994, 0.0876431929309569, 0.08770174855880886, 0.08822387179095237, 0.08079363273074214, 0.1037578031708084, 0.09349650565485468, 0.13967169169109073, 0.15229541133400437, 0.13186190337399872, 0.1960644321314624, 0.23103485649467392, 0.14257421841268514, 0.14901138140742587, 0.14594197497731642, 0.13978610798705782, 0.2473200351967887, 0.23708327516602234, 0.2618548614238684, 0.2897031143355334, 0.3008651026283655, 0.313442430351614, 0.35563742114798425, 0.311858009321924, 0.296000666047347, 0.20640100098002923, 0.19202335197850717, 0.19856197809144094, 0.17660669195029133, 0.18845139493222296, 0.20038786647182183, 0.19728698727859983, 0.2149966846158331, 0.22349250361882222, 0.2028306878602234, 0.16817238470087847, 0.19729266558889968, 0.17872239403199142, 0.18523367246967803, 0.19606108175252368, 0.18401681041570317, 0.19653158310572116, 0.21763553574484773, 0.20526192279383193, 0.23667559893852963, 0.23930771247503801, 0.2625788251924449, 0.28416102597565607, 0.4467103723930569, 0.21879839759300734, 0.21970332691555683, 0.2289099348935869, 0.1725366670238636, 0.17455500887278763, 0.22177059433374124, 0.4387364501557729, 0.6602684357266473, 0.645615762908359, 0.5555483018173737, 0.16822851460647814, 0.5424563165225884, 0.20095370934312007, 0.22484920311336654, 0.2403206723421618, 0.1845617988430457, 0.3242859891239831, 0.20789830323523062, 0.20913809678096595, 0.35724436035842355, 0.19298743495271542, 0.17490483324435713, 0.18024419689543336, 0.17782192040065292, 0.18815411179685693, 0.1873025709414956, 0.17189516387610237, 0.19163512270736038, 0.17963419936314018, 0.18137314924564862, 0.07378632628066384, 0.07964636996204777, 0.07347720052468254, 0.07811832260975848, 0.07202194302359732, 0.07529900207397, 0.07269994433876914, 0.07137886259574167, 0.07803689128268942]}, "mutation_prompt": null}
{"id": "d472b7e4-afee-46e9-970c-b38cee67ff78", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))  # Slightly adjusted population size\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.2  # Tightened mutation factor range\n        self.crossover_rate = 0.65 + np.random.rand(self.population_size) * 0.3  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for gradient boosting\n                    gradient = np.random.randn(self.dim) * 0.2 * (x0 - best_solution)  # Increased gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Probabilistic Gradient Boosting and Budget-Aware Convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9065098052707716, 0.9031542286094784, 0.9129633573960805, 0.9136285749540218, 0.9096677954903494, 0.9035964125318467, 0.9073667176166039, 0.9238787720111661, 0.9248608393683516, 0.8195483952626041, 0.8662493417497461, 0.841862115390378, 0.8488787544523527, 0.8599094905697706, 0.8377067766148902, 0.8514756631091448, 0.8454088932081302, 0.8646704487776102, 0.5585726500386865, 0.1772810058122246, 0.5858636068528813, 0.5503056453025192, 0.46491522091640136, 0.6731350255532883, 0.16768986283061893, 0.5609900046646268, 0.5871385875803534, 0.1476332508027457, 0.16294199896232053, 0.17313943435276702, 0.14243463966378545, 0.13075241978124263, 0.1390543535471761, 0.5554520386613515, 0.1516138974284411, 0.17170149312856398, 0.9804371251882187, 0.9803170876603575, 0.9792277924922418, 0.9835388864720928, 0.9753525978351504, 0.9721795239582554, 0.978544821097004, 0.9828061912178135, 0.9825678187515012, 0.7055863753459486, 0.7473901934252112, 0.7337931971847877, 0.6696646375368962, 0.7485911564659726, 0.7188060183491634, 0.7411407959003373, 0.7245005352384594, 0.7505403421536725, 0.8865770935791953, 0.8175971385424463, 0.8083763154813383, 0.8600204847362054, 0.8079695213115348, 0.8293275504389094, 0.8531022557780082, 0.8440286024935032, 0.7916647193908414, 0.6206015854809656, 0.13263974800999112, 0.49825107690490966, 0.5315560430044068, 0.526030383288054, 0.507985030192756, 0.5557081825209764, 0.5363701664636149, 0.43625186955664463, 0.5979740054555327, 0.12313722633515611, 0.2342677334848433, 0.6177970110779714, 0.5470536884859271, 0.5260555882840754, 0.6061520879585123, 0.5345037430972135, 0.5406405809179482, 0.19646009356800942, 0.4724318521777142, 0.08602007744772422, 0.5715194817045224, 0.4990962144346047, 0.09617999957101386, 0.5113403232122693, 0.5610212606015327, 0.12091854459445273, 0.576592493943034, 0.23335571911761033, 0.5572104479753948, 0.2828492657107291, 0.5138098316876334, 0.3285666213458206, 0.724262545949502, 0.6242147991310076, 0.5931278609293044, 0.16542611762147663, 0.09602512718392897, 0.11498515689420952, 0.2799970457319997, 0.3696582517472896, 0.1979720492244148, 0.16465161511209936, 0.27240910036234467, 0.20330886054184805, 0.42898458772817805, 0.44822218145723947, 0.31676567594523297, 0.4736190035736544, 0.41671175805782235, 0.4002253766722853, 0.41561741323305257, 0.46002886736160886, 0.4038039197650308, 0.8187916238144505, 0.8210607539998982, 0.830994720525107, 0.8031047243499337, 0.7514079459716385, 0.6939202624065623, 0.7199373148898198, 0.8037520374617755, 0.7476256732511994, 0.105271149905656, 0.09871997813266786, 0.11004685371621126, 0.09178751902913851, 0.1501658590892857, 0.12645280317403595, 0.11822657280080817, 0.1453144139143191, 0.12444537779899345, 0.1671193597396874, 0.1428584667642735, 0.1482908003852208, 0.22624830692622877, 0.17942972119002898, 0.19212540271771872, 0.19137994525717417, 0.18101568361917342, 0.15774146341464912, 0.6282387344663316, 0.511152208523991, 0.5008193816530506, 0.5073122034787227, 0.5459947653163483, 0.5419717526994955, 0.536634792169925, 0.6152051654024815, 0.6837939982418932, 0.40776475386794897, 0.41630560227688207, 0.40550737505899703, 0.361426890441225, 0.3891077838941679, 0.32388408338772057, 0.44806257659713233, 0.44514792198297615, 0.3830054110851997, 0.19343595425166682, 0.19562030941778175, 0.194864524254453, 0.19987559125408028, 0.1973154287472606, 0.1933516580456851, 0.21505965725380072, 0.19406086176514648, 0.18599177485800067, 0.2192097425290256, 0.22459289951420114, 0.605548164485507, 0.45443123421922194, 0.2422874060432929, 0.47590016805483915, 0.6052687250404909, 0.3853450626220548, 0.22714023338314304, 0.16504453137946729, 0.36171094508605184, 0.8938066273306351, 0.1628635148590567, 0.791335293757577, 0.8107881452463872, 0.8694978466348485, 0.16842575108182134, 0.1830546770475504, 0.20978772325727246, 0.3881833625869403, 0.20383248553674327, 0.20615362470311815, 0.7560223056896735, 0.2083668669570603, 0.21275729991548797, 0.21215441032134208, 0.15474574349711656, 0.19343451350084884, 0.17611663002142797, 0.17475705491287374, 0.18383279962820565, 0.17832146081041012, 0.17807494009091063, 0.19668342354461843, 0.1843217395612492, 0.17829501481993315, 0.08057589452235736, 0.08220949305957659, 0.08595305561295297, 0.08034619550549738, 0.08984650990748011, 0.07931768730904021, 0.07741852574929231, 0.07795704847704221, 0.08541850076794344]}, "mutation_prompt": null}
{"id": "05c4a8cc-8f1f-4b45-bad7-bdc103eba671", "solution": "import numpy as np\n\nclass ProbabilisticallyEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.7 + np.random.rand(self.population_size) * 0.15  # Adjusted mutation factor range\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25  # Adjusted range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n\n                if np.random.rand() < 0.05:  # Probability for adaptive mutation adjustment\n                    adaptive_factor = 1.5  # Additional mutation factor\n                else:\n                    adaptive_factor = 1.0\n\n                mutant_vector = x0 + adaptive_factor * self.mutation_factor[i] * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "ProbabilisticallyEnhancedDifferentialEvolution", "description": "Probabilistically Enhanced Differential Evolution with Adaptive Mutation and Dynamic Crossover.", "configspace": "", "generation": 65, "fitness": 0.4474630768868932, "feedback": "The algorithm ProbabilisticallyEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.900678638555922, 0.8848220201004909, 0.8853977244053522, 0.8746148662483892, 0.8998857920592999, 0.8946184042941993, 0.887864216295797, 0.8890132852442199, 0.8862156076968019, 0.8198502685374326, 0.8103623040110044, 0.8220492358107387, 0.79150871425738, 0.8129398898763054, 0.8360913660764568, 0.7836816110520656, 0.8076500456301282, 0.832397486879237, 0.1373358281206185, 0.32952008428418644, 0.1669892175368357, 0.3853946097697465, 0.29023288870601405, 0.5932069311435255, 0.12259336843397617, 0.5621452228533872, 0.14197403223850213, 0.15058044048791508, 0.14457521087184144, 0.15253097395565451, 0.30957899344433093, 0.4563516542759277, 0.5091654881562637, 0.1500766739196333, 0.15437549292420483, 0.1476476838686167, 0.9834112612317616, 0.9744174632186013, 0.9777446056771184, 0.9964766066706768, 0.9804735298978684, 0.9814967253086209, 0.9909855312572967, 0.9771196025616988, 0.9759294194161129, 0.693848693380399, 0.683518358141715, 0.7177392489348661, 0.690922937601989, 0.6700513068501526, 0.6586197568938493, 0.6821039498450566, 0.6678079064285916, 0.6963427410670264, 0.8394047749636657, 0.7893483847165691, 0.8316141415854605, 0.8270600177229743, 0.8837035155066948, 0.8424410057213659, 0.8363660284469546, 0.8258483610025258, 0.8134390181581789, 0.6532123741856483, 0.5229610865651706, 0.5215521615557827, 0.4854563328106487, 0.5240849527630963, 0.5024221251791896, 0.518587683496985, 0.5567994849116351, 0.4432414392387066, 0.009975824823417634, 0.009954328580871197, 0.1188616399931921, 0.5489938314714446, 0.6023292640191346, 0.5575671580187727, 0.5472658586972547, 0.5353433311989287, 0.5349253504070344, 0.45973856151357184, 0.49317013504016627, 0.34158565331556456, 0.3635503022513552, 0.43725977117491954, 0.2923453604878208, 0.5600841018140521, 0.46224861721427724, 0.3989641844854973, 0.5998570944420482, 0.6014755723354742, 0.5227389463811029, 0.6478209237957948, 0.6113985412180425, 0.5071140358783032, 0.6639239365379794, 0.6296103261799644, 0.5405511461064658, 0.18162647045440106, 0.09817773167029664, 0.06504471221264907, 0.18516741025446048, 0.3118303385970911, 0.23930818910199347, 0.16706706729297494, 0.17051905544265988, 0.25956680343065996, 0.35563721860143793, 0.3722716753000356, 0.32623585402169386, 0.4630869554394583, 0.4544708876612241, 0.34242049334648605, 0.3918257465968582, 0.36678552444435286, 0.30881059854160653, 0.7847225934776649, 0.7844520702334213, 0.7524535921182995, 0.7593449128085399, 0.7574302791875602, 0.7638624711364119, 0.7837612621651491, 0.7759040802038615, 0.7854728141384671, 0.08841861558378439, 0.10488171875561547, 0.10556544380365851, 0.14498206336896946, 0.10350031496068568, 0.10934715335307155, 0.10592311482333794, 0.10015962934059375, 0.09352606387325446, 0.191079166604035, 0.14843164983084045, 0.20486399254805376, 0.18538836005455572, 0.17933551828351413, 0.13741031431050765, 0.13922972582533766, 0.17080335143191694, 0.19660787347561404, 0.48301429930635076, 0.48365872297770307, 0.47003398903044336, 0.5187915904756125, 0.45561300872825194, 0.481553054720695, 0.5667082841782232, 0.5936352119330621, 0.5491139211645881, 0.3710189016749319, 0.3539302727383792, 0.35577835375217326, 0.3478699557184278, 0.3441523983955279, 0.31666834344302286, 0.34881910095269886, 0.37225373313881094, 0.3042580620089246, 0.21380227048354994, 0.17213049471026065, 0.21000839024684526, 0.18047791901858856, 0.18253869068243334, 0.19318358407372593, 0.17240294118636235, 0.20594415376915431, 0.1952611860967659, 0.2324724794909504, 0.21431737658768202, 0.6634462389899997, 0.48880196036959245, 0.48660650921532156, 0.38282581813594885, 0.4687003289895467, 0.23565356830453843, 0.562920392803588, 0.18543234605733283, 0.17290950158673335, 0.7654793738374239, 0.1905017609100419, 0.8433275806608609, 0.1976077791996258, 0.1861334701247589, 0.19629095240929495, 0.1877190480328964, 0.16632579504982947, 0.16741324048666395, 0.8231622529631113, 0.8055479197147688, 0.20039900756962126, 0.21086836446077872, 0.198079894383548, 0.21097586068856855, 0.8863965313685033, 0.18550276166005664, 0.1889571527076087, 0.17831555948165478, 0.17967238278233655, 0.17446368769486031, 0.17506436717557206, 0.1752038900171199, 0.16538799918655656, 0.194038042180392, 0.08373511528421296, 0.08295455356795389, 0.0698029003879832, 0.07435771912406586, 0.0755668685959725, 0.08633807313460928, 0.07048194157938703, 0.08726465352314805, 0.07614727206181693]}, "mutation_prompt": null}
{"id": "d591f7cb-0908-4870-8720-f15aa1427b91", "solution": "import numpy as np\n\nclass StochasticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Wider range for mutation\n        self.crossover_rate = 0.6 + np.random.rand(self.population_size) * 0.25  # Slightly adjusted range\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.adaptive_learning_rate = 0.1\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:\n                    gradient = np.random.randn(self.dim) * 0.1 * (x0 - best_solution)  # Adjusted gradient influence\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                adaptive_mutation_factor = self.mutation_factor[i] * (1 - self.eval_count / self.budget)  # Adaptive factor\n                mutant_vector = x0 + adaptive_mutation_factor * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "StochasticAdaptiveDE", "description": "Stochastic Adaptive Differential Evolution with Self-Tuning Parameters for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 66, "fitness": 0.40695975121865946, "feedback": "The algorithm StochasticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.9202684229511474, 0.9281591004608438, 0.9211637116006456, 0.9228311486709707, 0.9149389966351591, 0.9170025255080883, 0.9210057292964638, 0.9218138491779468, 0.9234581033319714, 0.8550179469590915, 0.8779269424051886, 0.8720802300262227, 0.8568280183693784, 0.868192270159694, 0.8678686693545623, 0.8608451419841454, 0.8639462127299576, 0.8689241759543127, 0.17105432171932589, 0.6794700306512722, 0.17755693937488526, 0.33877721496695334, 0.7596045492730336, 0.6965654139653008, 0.15960275089813225, 0.7596593697946823, 0.30450804649376473, 0.1486717637665793, 0.6762979825508179, 0.15364463198825584, 0.17558107404196166, 0.15358611738890227, 0.15220890394650344, 0.16591643871564354, 0.6889490861706549, 0.3864870415956201, 0.984457708194234, 0.9660188931077156, 0.9671031759878685, 0.9873502916782703, 0.9600022277859396, 0.9791526024448215, 0.9897880651344003, 0.9743952220948805, 0.9763424910642675, 0.32250023369063274, 0.4945938386455402, 0.368861346446803, 0.5615582349302988, 0.37928260544001247, 0.49466877300743595, 0.5083275993854588, 0.7055415119282324, 0.5304421404686193, 0.8619207921206211, 0.827973403568114, 0.8257845265326702, 0.8477902181289971, 0.827513672787485, 0.8606375082625428, 0.8355834577695755, 0.8293110121078189, 0.39441757651837517, 0.14347068077164982, 0.35467818130318995, 0.21887937629368803, 0.13249644092297563, 0.17273693545908952, 0.1671669317838771, 0.19677709276783273, 0.17653379918652157, 0.1663389149436555, 0.05372760413150157, 0.16205161966308967, 0.1851115310823519, 0.1827879308449758, 0.2272819128111503, 0.17859482536736482, 0.16685943568790718, 0.16081522857738073, 0.19486546205321453, 0.24486878067138573, 0.12432760091843098, 0.0516874131990942, 0.177374023618325, 0.2507719160824057, 0.08323007669531313, 0.34118985897372456, 0.07944736123107354, 0.13216725896430348, 0.33020221577665954, 0.197913057557211, 0.30941345342696924, 0.20600618808739013, 0.1883132483677048, 0.2695524007332569, 0.29624641156112264, 0.3166920920959463, 0.12412282250543483, 0.16080101559070703, 0.05301914335289215, 0.09431103489641246, 0.11367348862963278, 0.0911149759227996, 0.16738209749095223, 0.1906269195809056, 0.1699828977396739, 0.20025733348890828, 0.24400929481594213, 0.3012899602490663, 0.32851646274413304, 0.48013986662982966, 0.32315807001251307, 0.2865885715433144, 0.311080951667552, 0.21596395503480348, 0.3516327095459387, 0.7476356098121828, 0.6418739970098666, 0.6339151596240656, 0.6465333713934559, 0.7086400518481375, 0.6342917261710501, 0.6633719217892989, 0.6746709539284508, 0.5792261098286171, 0.11734000730576577, 0.21432659156689726, 0.11820304733647213, 0.10891435926690118, 0.13169682230185376, 0.10798420600198022, 0.10676747636850703, 0.12587439623778862, 0.15286622422756768, 0.14695205431455982, 0.16363632602005307, 0.15270929349766393, 0.16130416955524274, 0.15552551874456622, 0.16249674956525817, 0.20291514450730497, 0.2116650829655249, 0.1636338228019355, 0.6343444613695495, 0.5782588744435327, 0.5698529766783298, 0.6628065653166298, 0.6035462345502282, 0.6514454417147246, 0.7079906499430109, 0.7272777779172068, 0.5413259017827668, 0.3938704928684186, 0.30533991629166213, 0.35969530608138534, 0.3799039872323342, 0.42374890509445895, 0.423234311322669, 0.426586101186221, 0.4324067429065913, 0.4221729677358119, 0.18985605430585173, 0.19929733869557476, 0.1936024394335384, 0.19700155031673983, 0.20309638498248594, 0.22459779883043263, 0.2400665196558972, 0.19116746032023058, 0.20486165058932515, 0.7065503360654111, 0.23048680256538223, 0.44325851028454943, 0.7403773527864439, 0.558980256312016, 0.23881378568749922, 0.4567339916484109, 0.2402942840740474, 0.21189212515276135, 0.8260743759928509, 0.16849327647575407, 0.2048287270869058, 0.8735649160697996, 0.7307744636362596, 0.657521017628464, 0.8835944251312019, 0.17270668044145165, 0.7818387590939391, 0.20859718901132362, 0.18452671738858983, 0.17654129009000985, 0.16527641950748784, 0.20637764546403792, 0.20815545050681816, 0.7000630371525567, 0.2065489606064882, 0.4023156433064673, 0.1899421178626195, 0.18606083819114516, 0.1901707333918654, 0.19564595085523462, 0.1905789753835928, 0.18052935316364382, 0.19284951667300398, 0.19273065225456343, 0.17837152327132777, 0.08772409232764533, 0.09037166885903447, 0.08610417473756604, 0.07790785617081253, 0.0811359188590528, 0.08199134062325175, 0.08351340767786264, 0.08404314629309251, 0.08614271674877105]}, "mutation_prompt": null}
{"id": "3ca17c33-8a9c-4583-ad50-66c17dbe0286", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 10 + int(self.dim * np.log(self.dim)))  # Adjusted population size to enhance exploration\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.3  # Broadened mutation factor range for diversity\n        self.crossover_rate = 0.6 + np.random.rand(self.population_size) * 0.35  # Expanded range for crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()  # Added memory to store additional promising solutions\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.05:  # Probability for adaptive memory utilization\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - best_solution)  # Adaptive memory influence\n                else:\n                    gradient = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()  # Store in memory for potential future use\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Dynamic Selection and Adaptive Memory to Enhance Convergence and Diversity.", "configspace": "", "generation": 67, "fitness": 0.46092167650283083, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "3855f6f4-4293-4f39-82f6-bca95754c77f", "metadata": {"aucs": [0.905344044188379, 0.9058163331239815, 0.9001686790938368, 0.9041767811200491, 0.9093426579900244, 0.9092962035390804, 0.9119758018067494, 0.9069161125966284, 0.9078941678745824, 0.8183637542977845, 0.8397275415266445, 0.8248733867814417, 0.8242906079246414, 0.8266792494937933, 0.8464427692943906, 0.8248288311136007, 0.8408937345403196, 0.8424973982006463, 0.5241738566584068, 0.6058584142225918, 0.6306701977774565, 0.16196615050237229, 0.4190977022604673, 0.6121613904229535, 0.4940155240458577, 0.5628976941545691, 0.45848026537207365, 0.16650120345914166, 0.39498408219556647, 0.17428626965993166, 0.42785686727084293, 0.15787942353973716, 0.1448814361637062, 0.43847553503259606, 0.5773484267684872, 0.1625828322968117, 0.9625465802047928, 0.9814356359705644, 0.9771592972176565, 0.9766014891976608, 0.9707830052870243, 0.9663676584319907, 0.9796304911987124, 0.9655515104886028, 0.9689354856122693, 0.6867692730747976, 0.7413300550774795, 0.6785127696430944, 0.7103388482342441, 0.7350284041736573, 0.7073546226253609, 0.6814217645540962, 0.7275287983977208, 0.7069267880671088, 0.7803049359788725, 0.8403743696371507, 0.785017671772522, 0.8739950253591031, 0.8355673315488872, 0.8356228217960546, 0.8398274727975195, 0.8840578739420561, 0.22706804235356037, 0.39585255326493685, 0.49420931685352476, 0.3288378716615622, 0.43806626146438354, 0.1300445381479196, 0.48365818616460676, 0.4659994317788314, 0.5440136143385217, 0.40584449073922013, 0.44331655687902427, 0.5447455634793348, 0.32840963727059835, 0.5039362367487714, 0.42940786589116664, 0.3694284920603157, 0.41324071473910895, 0.22256398043861236, 0.1842497838754803, 0.4790178267015742, 0.4884116025422137, 0.3131327107770733, 0.36458394115598236, 0.4173830319942098, 0.14250937628678295, 0.36443466598087415, 0.4223782438614808, 0.2878218256388324, 0.5511293209853547, 0.5125822041326189, 0.4401325806710139, 0.554168335330544, 0.5675950528639143, 0.42653472671937687, 0.5768407162588243, 0.6077344633572694, 0.358473289558605, 0.16332283891013977, 0.15114305959717622, 0.18968345331167902, 0.27957065547366067, 0.3442394812549767, 0.3010649610335896, 0.14272245991323818, 0.17874536006105135, 0.09405282402587745, 0.3581475058781759, 0.3300418704865742, 0.2979821629298752, 0.42748094526751235, 0.4748225137748727, 0.35524681444009665, 0.3359382526456135, 0.37088562068008624, 0.2791958733922244, 0.7940135394174506, 0.830446000478179, 0.7564422238480382, 0.7617857091678305, 0.7959025330542909, 0.7388154619330307, 0.7536891860420004, 0.7663256609585185, 0.7664692690587082, 0.15556649067953754, 0.10192648699109541, 0.12174405683757672, 0.11462955247645601, 0.10437150451728816, 0.10370309315586035, 0.09565781495776626, 0.10947836320039239, 0.11486941920667537, 0.3007619606332075, 0.18087164035413705, 0.1665566581250103, 0.14479801101699818, 0.14067781306848826, 0.22442105844323612, 0.15510344186495006, 0.17997066942421314, 0.18631783214998077, 0.49300543764016846, 0.5583840757668475, 0.5150376533924126, 0.46314109239726087, 0.6089318523793141, 0.6042349010588874, 0.55262857314206, 0.6282107918325368, 0.5841584792498649, 0.3554234094287262, 0.43608074200220603, 0.32055879343243354, 0.36675962031269416, 0.372870826139297, 0.3192536390149143, 0.35460648721478716, 0.4284273256930624, 0.36401868143206695, 0.19738880446060048, 0.1924445219216162, 0.1896882180044146, 0.1925739439026284, 0.19630816377976112, 0.1914854119035143, 0.1991603735226144, 0.19509979207731354, 0.20039749661229522, 0.4728928359774852, 0.3588590919691378, 0.627664257016755, 0.23139400004294852, 0.7539987900240742, 0.42819060517898755, 0.5077105933289208, 0.5422791398732294, 0.4045930387738015, 0.1617628359504346, 0.1662034659223749, 0.8802584983056161, 0.7562611967117291, 0.1852058677608137, 0.8632756232184607, 0.7348440409817028, 0.8687340871465623, 0.714281372004579, 0.2053189827512999, 0.16833548775320817, 0.8270363688586254, 0.16608408282118237, 0.2029185443608329, 0.16697479513306657, 0.15517711579720384, 0.830689862447769, 0.20983536995125174, 0.1771515668722986, 0.18458218562888906, 0.17973280337397168, 0.18020196403881128, 0.18099573872287755, 0.17782470887053226, 0.17861642220998442, 0.1747872275951149, 0.20376770746371842, 0.07350485256105477, 0.09450791969260097, 0.08428987356112172, 0.07702176436889063, 0.07559448831833471, 0.07610631871443807, 0.07749920211994721, 0.08460845319885046, 0.07723540582116273]}, "mutation_prompt": null}
{"id": "9ff6925b-ec1e-47cd-95e8-908e8cac472e", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 15 + int(self.dim * np.log(self.dim)))  # Increased population size for more diversity\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4  # Further widened mutation factor range\n        self.crossover_rate = 0.5 + np.random.rand(self.population_size) * 0.4  # Adjusted crossover rate for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.quantum_operator = 0.1  # Quantum influence parameter\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        best_fitness = self.fitness[best_index]\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                if np.random.rand() < 0.07:  # Increased probability for adaptive memory utilization\n                    memory_idx = np.random.choice(self.population_size)\n                    quantum_effect = self.quantum_operator * (np.random.rand(self.dim) - 0.5) * (self.memory[memory_idx] - best_solution)\n                else:\n                    quantum_effect = np.zeros(self.dim)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + quantum_effect\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return best_solution\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution leveraging adaptive quantum operators to enhance exploration and convergence in high-dimensional spaces.", "configspace": "", "generation": 68, "fitness": 0.3720840985543877, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "3ca17c33-8a9c-4583-ad50-66c17dbe0286", "metadata": {"aucs": [0.8480269720117244, 0.8795460259937804, 0.8638539992582623, 0.8665668577976504, 0.8808079194102588, 0.8762473075517094, 0.8505336871198643, 0.8620074866625196, 0.8696736262741689, 0.7466554608353906, 0.766137768000563, 0.77878262799117, 0.7450048633519885, 0.7657953525315941, 0.7817232221457746, 0.7590328918363913, 0.777691329957886, 0.7758535324531917, 0.5065739422156266, 0.3458546209845407, 0.4930844048265738, 0.4431396589506975, 0.4871940552232289, 0.5129972832970706, 0.43825974478348917, 0.16597214265601856, 0.5633455286769333, 0.16487767321497782, 0.36216188227420687, 0.5056277804375648, 0.2744448942590966, 0.4484910265037644, 0.4671492438095908, 0.39914798792623696, 0.1788151499852123, 0.35878106825473555, 0.9869298847745924, 0.9797319075834885, 0.9664717605252602, 0.9660744625033484, 0.957394549720703, 0.9700769143475174, 0.9681226890486757, 0.9796137954961048, 0.9645282263049038, 0.5211730488821286, 0.5198299993010495, 0.5300976502630979, 0.5063735932960569, 0.5942853547167236, 0.5602966734738368, 0.5531613230428407, 0.5971429053155703, 0.5398201901835845, 0.6014239360994387, 0.6625964384994032, 0.6295537267686271, 0.6675674891035794, 0.7170410748681934, 0.6633671661338542, 0.6277444869276141, 0.7008794574404769, 0.6869855429000116, 0.3073418414308813, 0.31403253956130583, 0.29143802171037436, 0.2534716925816315, 0.31053883452475384, 0.25137308312165363, 0.20110986768550188, 0.41769473363329923, 0.2597735215786465, 0.27422611056708457, 0.23765738815075554, 0.2461606652922146, 0.29095293825542723, 0.31140932286365963, 0.24356341739700305, 0.29057710847055174, 0.3002470780302985, 0.29822687778720525, 0.11565172323418993, 0.12974253672346403, 0.08031965823082887, 0.030674708790171645, 0.13175482085068868, 0.09511311159028302, 0.10019428574121425, 0.16842279547000139, 0.06265873858941917, 0.21520280143585002, 0.25647465288706295, 0.24435256993911514, 0.1672598327343594, 0.18430652688607474, 0.23378496486019107, 0.2517295753994564, 0.2689312605878098, 0.2811280905506114, 0.0335955214246495, 0.03773130206199693, 0.027789050934474813, 0.0727114468554606, 0.09901827794781781, 0.032681133004051066, 0.07650232774672894, 0.08481674551977791, 0.08565619893849419, 0.18247788331061188, 0.2137331218741153, 0.21584091775672076, 0.21197181848631852, 0.26360610861350364, 0.24511106751757128, 0.1977325789923542, 0.19926233253999448, 0.19460510654465146, 0.5752767354004684, 0.6234676869361577, 0.621479338670206, 0.5996207137717037, 0.6544231827265705, 0.593538715640332, 0.5745772890117138, 0.6011392358624935, 0.6415345375503789, 0.0917519286310382, 0.10421743753514368, 0.09343294221774157, 0.11309774760128932, 0.13457046067608647, 0.09377046927777011, 0.1016104602715483, 0.08391028911336873, 0.08340979437954266, 0.1442540705505544, 0.1462247243084015, 0.20097138977036688, 0.14860879510808078, 0.13421266989269864, 0.13402909123741125, 0.148051982856933, 0.13764316045328395, 0.14090013656828249, 0.3866911687513138, 0.38361615087936607, 0.38853613633273976, 0.369508150793589, 0.3651874967473334, 0.3864790613664685, 0.3756605365126965, 0.47103265312953946, 0.45356187972827144, 0.2445541900071464, 0.23304865893769877, 0.26115456399381143, 0.2297490710989175, 0.23971720752136183, 0.27722454854963063, 0.22909357674040243, 0.29948895413786125, 0.2703201408846406, 0.2130989638824926, 0.19507401443712324, 0.18488311580583605, 0.17586891641649816, 0.18422580003757327, 0.1885933951891684, 0.1920540236632161, 0.19941979573500135, 0.21483700554805352, 0.4337658590740906, 0.2287046791563263, 0.195252483639215, 0.2967374121177363, 0.4157729087154034, 0.2800971969787469, 0.18985365250621156, 0.23579560951526013, 0.23714730389074223, 0.6874394430733628, 0.5044492227324517, 0.775180199627497, 0.5645064140800455, 0.1679623435482256, 0.19295398592696533, 0.6954745163218343, 0.7853373251682324, 0.6614781712741411, 0.20485475204116332, 0.1646886520260219, 0.5875141592232048, 0.6230166695997246, 0.18800335790015454, 0.20238310490972522, 0.210255049169649, 0.6508316632154609, 0.21031790458041033, 0.19292175805926193, 0.18753096254215684, 0.17792535276643828, 0.18195966443979072, 0.18888345831425823, 0.18511686416540674, 0.18758787832531576, 0.18822184698260547, 0.1937653938176117, 0.08757293663977506, 0.07908490531492984, 0.08913414982821866, 0.07619380256743202, 0.08473113555189538, 0.08082901464668846, 0.07825912279463265, 0.0948437239754587, 0.07294120996007913]}, "mutation_prompt": null}
{"id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.10 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.05 * (self.global_best - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Dynamic Memory and Environmental Feedback for Enhanced Performance.", "configspace": "", "generation": 69, "fitness": 0.47378571707481826, "feedback": "The algorithm CoevolutionaryAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "3ca17c33-8a9c-4583-ad50-66c17dbe0286", "metadata": {"aucs": [0.8832480531004583, 0.9012854033056067, 0.8893669832894031, 0.8842678099238231, 0.9107642238630185, 0.8889469686247702, 0.8767106341925663, 0.9038875766221016, 0.8982911210225977, 0.7993113933517382, 0.8260399092609195, 0.8293160342754251, 0.8031333884243577, 0.8260388215268221, 0.8295100304242982, 0.8128705864555161, 0.8243065203251259, 0.8170820476985798, 0.15262362785627215, 0.49953165185587567, 0.48200569065006404, 0.38907186981566877, 0.37844365996784135, 0.36549290932715084, 0.2984936379653461, 0.48354289278400286, 0.6049744098597905, 0.152614209798971, 0.1482637437928086, 0.12331373153443115, 0.12829162605341282, 0.1357935838284553, 0.15189937070219806, 0.1421710082209463, 0.14589245025024788, 0.2684152898834623, 0.9624295408089681, 0.9721577057871323, 0.967021227925701, 0.9610408621758085, 0.9607929746931004, 0.9685749822740649, 0.9587695929101322, 0.9664029513383446, 0.9614886701989819, 0.6709264752341464, 0.7212008304289295, 0.6819423583510144, 0.6576327158960855, 0.7177881083168871, 0.719294920865211, 0.7456357291571116, 0.7115790224614064, 0.7121148768314851, 0.8431360773544776, 0.8264087179225938, 0.7973765397268878, 0.8371386923776496, 0.8587898847824069, 0.7895298960144495, 0.8020730400328077, 0.8625192557225608, 0.8398172483623452, 0.49740072939962887, 0.5891422978062271, 0.46599243431192316, 0.5843002874688832, 0.5850680303102024, 0.5030109010317705, 0.453146042305435, 0.5733571059469802, 0.45025920018936416, 0.4515028518879024, 0.5958879500457573, 0.13780774133977447, 0.6224899782048517, 0.5460094195826923, 0.5111991075736719, 0.5572849717377505, 0.567548400708636, 0.3577556902332585, 0.559354280799037, 0.6078134981606036, 0.47221932826658275, 0.5232677340657435, 0.46733874788013496, 0.4805076167592529, 0.5290867276228715, 0.13035697262221768, 0.3467394566498987, 0.6356745646873156, 0.6538228469432386, 0.5104924922339464, 0.6479635506699861, 0.5572476037053423, 0.4581312416416501, 0.7203206880737302, 0.7059538276040949, 0.6002712117107953, 0.3489311501989417, 0.25909326424712176, 0.11829770185877264, 0.4119108875504298, 0.1728861041545139, 0.33095387552194977, 0.1714153651463104, 0.28700466144735626, 0.16396823220300472, 0.3844695370775677, 0.48937676709197153, 0.3341764965976589, 0.4473793478418826, 0.5797188132540296, 0.39746717893416694, 0.41186940637398994, 0.4359197020667185, 0.4267731669749054, 0.8272266606512402, 0.8202207297981494, 0.808309743557406, 0.7730053846747338, 0.8164556189994325, 0.7767305823074896, 0.7941995910273928, 0.8597337710015523, 0.7801791518828451, 0.15584366245526393, 0.12094474032802804, 0.10915323928917675, 0.10181767971607314, 0.09313060949345509, 0.11462667221513456, 0.1006935175976107, 0.11899561719516427, 0.1148067024735634, 0.13768282633486384, 0.15641497261497883, 0.14689861369312662, 0.1845264040837168, 0.15560427491783357, 0.15143175278168142, 0.2738417621769913, 0.4354887851847782, 0.1400893832692498, 0.4549926287818695, 0.5522605225728163, 0.5305534373149651, 0.455102117420246, 0.5528540554853114, 0.529775133050101, 0.5173942324873932, 0.6604874272685358, 0.6121768878004681, 0.36402891615461075, 0.34768153503507127, 0.32699239296664373, 0.34966765671779176, 0.40963829742385116, 0.40659805095964496, 0.35522858728757456, 0.5303257621886682, 0.47598060677182685, 0.19760167820415353, 0.20764099609097153, 0.20422646731924476, 0.19525032225565597, 0.20194717898611725, 0.20475959440085256, 0.2155533016948361, 0.20453753498779081, 0.22365484818085357, 0.22515079112971215, 0.5406086332144506, 0.28979834528370285, 0.67627401747485, 0.6294171791365555, 0.5591677699346009, 0.2145613775229923, 0.6219048064025586, 0.23215963920069038, 0.8904058246381871, 0.8708510025815474, 0.1528692927472124, 0.1926059752968502, 0.20578102692972178, 0.8279546814619482, 0.7505806216349138, 0.21008203282929783, 0.7301410641550174, 0.8656915031532526, 0.16834872903552311, 0.1691252225751767, 0.8138198207187264, 0.2097953196775959, 0.20757707111185442, 0.21072816915329462, 0.11243023172583577, 0.21150197283002659, 0.18776094221549233, 0.19113074653492979, 0.18163344352559974, 0.19642338338721999, 0.1768560225124194, 0.20552185533213396, 0.17398209263480857, 0.18235394061188925, 0.16967451573631664, 0.08122122978256319, 0.08364319478242399, 0.09410818990431757, 0.08322527838662486, 0.0943094564023238, 0.09649556812753812, 0.0771173876920549, 0.08279972787951151, 0.07903021512047004]}, "mutation_prompt": null}
{"id": "fa742986-9666-4052-9b1c-2ca291e7c7fe", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.1 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.05 * (self.global_best - x0)\n                reshaping = 0.1 * np.sin(self.eval_count / self.budget * np.pi)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback + reshaping\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Strategies and Population Reshaping for Improved Convergence.", "configspace": "", "generation": 70, "fitness": 0.22953595694010998, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.48124880758144295, 0.43517992992034504, 0.45108853622313816, 0.5030725881399596, 0.5103585962022189, 0.408363783018752, 0.4662698117897852, 0.449917100558451, 0.4478977558484981, 0.05055295832091722, 0.05193455418036885, 0.10421116251654128, 0.04964287208792306, 0.08160125340835533, 0.09016405319461795, 0.1289094052066383, 0.08248022865013538, 0.07156513230134098, 0.10733292695514463, 0.138464921691553, 0.11570475715456141, 0.11812795503197815, 0.11862277516941577, 0.12517129359440227, 0.12195344416539466, 0.12942955798503408, 0.13231350085794003, 0.11749293122963467, 0.10902901878530646, 0.10414601258220868, 0.1100675875173367, 0.1251215321290431, 0.132465476976526, 0.13660521322683672, 0.12921503351169517, 0.12362584079696903, 0.9786657948588456, 0.9491173910412811, 0.9518443880523386, 0.9673830096113664, 0.9554911680052495, 0.3144387361713439, 0.2806588196875287, 0.96870917987578, 0.3607887777047061, 0.33805000490381276, 0.34249803529075684, 0.3140235924568793, 0.32012175888405814, 0.31277210845758585, 0.2933473637772438, 0.243144128767377, 0.24009744604965522, 0.25983361607208233, 0.34399838137033834, 0.4154635772787111, 0.3731176750134728, 0.36822499139500586, 0.39486564234784205, 0.3759097272026526, 0.3930229539734008, 0.3994772234145325, 0.36027273128997306, 0.22207217962345238, 0.22083357945659265, 0.2287828366331519, 0.22718721954139798, 0.2314749246081893, 0.22298214224871626, 0.2277695173153108, 0.23141366557789234, 0.2230880838861946, 0.15578737679263555, 0.18022101662737877, 0.11473489063526832, 0.15200230786531688, 0.14358934333075468, 0.13124756909709245, 0.13856945270973697, 0.15327447299901464, 0.14146386096062546, 0.027971738842266114, 0.011016123919495802, 0.0006003606287057206, 0.024680939022182935, 0.008927399171601458, 0.01049945468480673, 0.004868776422648824, 0.00897980691437772, 0.041561627451288, 0.08295239404642052, 0.07482670688357962, 0.0639473063678977, 0.09241860872460272, 0.10274007038544408, 0.09321277744311052, 0.12752253294212224, 0.10431949944564478, 0.13248139976962192, 0.0003874905546487062, 0.00022521621025550775, 0.00010029084230478436, 9.999999999998899e-05, 0.002319146342812717, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001007233631140636, 0.00013129986849347297, 0.1246073430352379, 0.1024740916305209, 0.10799597531669392, 0.1160075195572674, 0.16788490890729812, 0.10421603702753013, 0.12772128548789774, 0.12527099699947608, 0.09498330079424155, 0.43344041261437294, 0.46815389367533355, 0.45000524073451476, 0.46273778914315034, 0.43653096799483915, 0.4170365926210401, 0.4317280921149269, 0.41373532973966654, 0.41477080819590884, 0.09186266059057457, 0.11407517182861282, 0.08950398670228898, 0.12035269093690726, 0.10547814642193465, 0.09254305909837257, 0.11383082705064085, 0.09708097136171268, 0.09778971037690876, 0.13922165104061246, 0.15877134961287298, 0.15309326964006997, 0.13328192570073438, 0.14083267604491811, 0.13878108393868538, 0.18532699588663226, 0.1535864284679468, 0.1465015748497479, 0.2826701265333923, 0.32319620315043807, 0.2824890886512559, 0.29647097065120365, 0.29531320287617946, 0.27755435670515594, 0.3104904599587457, 0.3044160428410596, 0.3109024838837525, 0.226800734422263, 0.2158540391097109, 0.23990495000288736, 0.21448794797983695, 0.23873394908233658, 0.21496103435977798, 0.2298358590548375, 0.2385966766993498, 0.25246670098497803, 0.19714835882770965, 0.20229069467209781, 0.19705430914157074, 0.19626235392178504, 0.1935554680103413, 0.20061278576540587, 0.19212136946885294, 0.18943003247682688, 0.1917370203199903, 0.20299554687080756, 0.2249277757760232, 0.2228952196665951, 0.24723079584738716, 0.22091602263536347, 0.20697021208285227, 0.245663702782847, 0.22008448832575644, 0.22738494825968225, 0.6641940905369544, 0.6619960626027994, 0.15419705859800137, 0.4697262048727052, 0.18475955220219653, 0.6589653053512029, 0.5699584092285122, 0.6011571196012359, 0.17037882886967104, 0.5676479689500631, 0.20663513372230602, 0.16908363992813358, 0.5758089896043752, 0.20952485928542597, 0.6679485286401174, 0.20125625864288055, 0.12604567562682334, 0.21217789806948917, 0.1892765066724037, 0.18226910205217173, 0.19349398618866775, 0.18978407926390406, 0.19676755013429947, 0.1933055447323183, 0.1868554651580454, 0.1877055631263903, 0.18924740700606457, 0.0798269604063293, 0.09047488204480159, 0.08028277788688187, 0.08501606339356316, 0.089382312939845, 0.08928709703939763, 0.0865050967460369, 0.07402990201176796, 0.08088145936842761]}, "mutation_prompt": null}
{"id": "dbbb48f9-6a68-4259-9313-ce4bd49b620d", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n        self.adaptive_rate = 0.1  # new adaptive rate for parameter adjustment\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)  # slightly increased coefficient\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.05 * (self.global_best - x0)\n                mutated_difference = (x1 - x2) * (1 + 0.1 * np.random.randn(self.dim))  # new random scaling\n                mutant_vector = x0 + self.mutation_factor[i] * mutated_difference + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n                        self.adaptive_rate = max(0.05, self.adaptive_rate * 0.95)  # decrease adaptive rate for stability\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Modified Coevolutionary Adaptive Differential Evolution with improved mutation strategies and adaptive parameters for enhanced convergence.", "configspace": "", "generation": 71, "fitness": 0.41787008557864475, "feedback": "The algorithm CoevolutionaryAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.8739371359831005, 0.8868421236240885, 0.8851055805966956, 0.8891011529483981, 0.8997497989214845, 0.8968124191758251, 0.8906926289761394, 0.9114382625757605, 0.9058100511373388, 0.8075905233158126, 0.8196126631831154, 0.8109211546448114, 0.784518397613392, 0.8158070533489015, 0.8109199110969955, 0.8046696443069059, 0.824359340781978, 0.8117804636467879, 0.5781249275798834, 0.16949450085474493, 0.1564473601410442, 0.4099415756850917, 0.41403271700439515, 0.23987262910901186, 0.5164980758195462, 0.27011358736808566, 0.3128644780690293, 0.15319812358951113, 0.12887664700788537, 0.1380746097786767, 0.22454554201518606, 0.15560150026295327, 0.15840643437380053, 0.14545205977451292, 0.1430282598882635, 0.17587285058244562, 0.9582781424660155, 0.9566717570032052, 0.9741479798100674, 0.9630643257522886, 0.9631343538887068, 0.977246007361913, 0.9709165467686984, 0.9406004079205794, 0.9624073871518974, 0.6881788205967689, 0.6920618030838865, 0.6724353739719726, 0.67752433303399, 0.7101631053226349, 0.7215149830945554, 0.6801070837299412, 0.7197104316508685, 0.7205221346816973, 0.7897596652915168, 0.8457155739553319, 0.7814972685291938, 0.8415119342377023, 0.8546818805281893, 0.852932876771058, 0.7620580076756376, 0.8694609155201504, 0.8955734181793176, 0.5093641193663364, 0.12636055948406177, 0.3438737408749083, 0.42299157070569493, 0.5976104104781943, 0.2960359187983327, 0.4884279148904723, 0.4444300884687987, 0.5198783836291306, 0.5236626033711833, 0.4116181847797852, 0.5678732700671174, 0.5986934444356286, 0.6022728392631526, 0.47115686585269345, 0.5073449716879819, 0.5491273300942776, 0.4265885810583899, 0.0988891383831293, 0.12515526751671568, 0.11815997006588808, 0.08427594549933093, 0.08233246850802678, 0.12027630262182687, 0.17845916616014257, 0.15655727176527467, 0.05393643888688182, 0.13210975361935984, 0.10700545962349295, 0.07973194968402042, 0.1211957984528571, 0.10751035867462178, 0.07240570685857328, 0.10901257629443839, 0.11623221973328324, 0.0818363800190336, 0.11187451913448498, 0.09173848266638962, 0.14472336030679767, 0.21262244334121727, 0.08814040218855046, 0.18374508422896807, 0.13825526717918435, 0.10961131675605629, 0.11103033317446276, 0.23848615236612525, 0.285753404466471, 0.251658108930622, 0.2752819102224424, 0.3157193878696549, 0.25606190712157795, 0.24720351116979455, 0.2804394508362482, 0.24644494422599306, 0.608191854408502, 0.6538965842170283, 0.6240038012452827, 0.640871111858702, 0.6166686499207386, 0.6300070059071075, 0.6287318549267937, 0.6652145345686127, 0.626432041518865, 0.12050781018724943, 0.10448680076626338, 0.11916590930876769, 0.10945733116540124, 0.13174069100169417, 0.10215664549246117, 0.10909599833030947, 0.10165366997340575, 0.09972302498398544, 0.3651402030710291, 0.158849571414431, 0.15425068207360548, 0.15048112062739416, 0.14111575832939816, 0.22382090411002054, 0.18461933936804886, 0.13525816088360776, 0.15095491116482063, 0.4829749673059277, 0.5824123566515516, 0.4660534973374355, 0.48671404436218835, 0.6658353790230809, 0.5511948010025909, 0.5601374662647128, 0.6801020709570087, 0.551537891452208, 0.34148431848407224, 0.43398738452646257, 0.3243588190971888, 0.3526959705468534, 0.39317168127826396, 0.3433206275294546, 0.38983506138812307, 0.41912604467089154, 0.4085444081416787, 0.18919234755640235, 0.21776588759523152, 0.21858206076602404, 0.18583724612942598, 0.1780248818528617, 0.19913091067885114, 0.1906093736632145, 0.20363599845391012, 0.1904710952562747, 0.5258081245822495, 0.6268950345277864, 0.2152311365516414, 0.36864332041446146, 0.2295945999942013, 0.4619287492760319, 0.22984049243746862, 0.5334274135298314, 0.5844361802751041, 0.1970717568242717, 0.8388541572803394, 0.8777352259548242, 0.6809014828133846, 0.18238183125522744, 0.7704960209246297, 0.729689083680392, 0.7271547164345613, 0.8478077582891625, 0.8162749533143088, 0.7714946893513978, 0.20433528132550238, 0.19977285230883945, 0.2102776796029452, 0.16423202850690377, 0.8061561590596545, 0.1542308086030716, 0.15164536953321273, 0.18158414906879228, 0.18469396116273917, 0.17535273126919582, 0.18159720266386448, 0.18305815805391157, 0.17734351795424141, 0.18424263997072943, 0.18251515640530747, 0.1793333557230662, 0.07732854697473335, 0.08466466416088847, 0.0943852614621612, 0.07916279094928869, 0.0913184032553006, 0.0841719802874783, 0.08313188454741194, 0.08290427890264018, 0.08042667411122129]}, "mutation_prompt": null}
{"id": "5be74926-ee84-417b-839a-3ac8af286636", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.10 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                if np.random.rand() < 0.1:\n                    perturbation = 0.1 * np.random.normal(0, 1, self.dim)\n                else:\n                    perturbation = np.zeros(self.dim)\n\n                feedback = 0.05 * (self.global_best - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback + perturbation\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Stochastic Perturbation and Memory Reinforcement for Improved Convergence.", "configspace": "", "generation": 72, "fitness": 0.4706581453476584, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.8558086559207696, 0.8944291632261122, 0.8828600066083814, 0.8730910906723288, 0.8882762971265127, 0.8963434276888032, 0.8722531377495448, 0.8963752501141925, 0.907286021236079, 0.7803737997183063, 0.7988179794143317, 0.8054592062672561, 0.7794681746354628, 0.8088636572836908, 0.8093474449504374, 0.7712044676713044, 0.8250737996573954, 0.7999485018211591, 0.42690467978979363, 0.13173796724863918, 0.16688933577005172, 0.29410436969686826, 0.5810303414165788, 0.224680051291814, 0.5616692007982544, 0.1615425810015758, 0.45417403697253633, 0.1461132957148613, 0.1667378837770127, 0.14910826044471537, 0.13433000381262084, 0.14455404597886068, 0.14206464675141284, 0.15533367429362477, 0.4507047877926852, 0.1224793222186894, 0.9666825017193994, 0.9889600493535929, 0.956175773287399, 0.9695690147829571, 0.9656456274306209, 0.95110524281491, 0.957983620965156, 0.9463247788889305, 0.9664378043056504, 0.6572552094268886, 0.7470533518217486, 0.6719406855851895, 0.6401076173906797, 0.7075965325084779, 0.7100794582490352, 0.6560522297125938, 0.7076012122946072, 0.6831183792824316, 0.7810853983598454, 0.8435996666504937, 0.7457635933390614, 0.8135233099393788, 0.8368346556530732, 0.823568933397766, 0.8259687576565096, 0.8163575748973854, 0.8081158517351509, 0.6587712105851683, 0.5194132240407192, 0.5266580361694886, 0.13167509954298673, 0.5736623442110491, 0.5164888306966274, 0.5573750332785199, 0.48413854586068095, 0.5013829115705613, 0.5272221699908922, 0.2785099598019124, 0.4964316701348124, 0.5847205836243239, 0.5204987305690989, 0.46005254669294904, 0.5250385010100971, 0.6924121385447664, 0.11307756803924585, 0.48799658664755075, 0.5822324260182484, 0.4693131799469936, 0.5093644847526626, 0.5143859639179102, 0.48458630945356695, 0.42105798231117175, 0.5480803285568048, 0.4379984932244806, 0.5498974750791787, 0.6514893073900836, 0.492685323134079, 0.5608492748293883, 0.6719510445966399, 0.44556107394154165, 0.5734369033991173, 0.700190223724878, 0.5954016283985665, 0.12556130937460153, 0.33384114104044915, 0.2208912589138483, 0.3482019864084763, 0.2233264606467189, 0.32509668217885024, 0.21577133909800172, 0.16700098782203132, 0.2701493800719116, 0.3636895528958519, 0.4445610696922825, 0.3293795591794918, 0.42064215898391544, 0.48396466203420563, 0.40356458576241516, 0.33698215093309325, 0.4065687685686086, 0.3659822668598858, 0.7530968965695237, 0.8066391504619577, 0.7785485117639601, 0.7921349367989596, 0.7957405364278882, 0.773715813825302, 0.7619097763366385, 0.8106611306877932, 0.7654587424848862, 0.0966264077888831, 0.11046524004024882, 0.11719810922622309, 0.09653454311151932, 0.1154979506584739, 0.11683400434476954, 0.10288167443341012, 0.10099472258609987, 0.09568387847308135, 0.12858736634455614, 0.1551291111619646, 0.1453009385243229, 0.14131097602020182, 0.1520621734131502, 0.16758250754868043, 0.2099103444394188, 0.1628707263772523, 0.1569491915059833, 0.45268451457240744, 0.5256918637571064, 0.5317862641274889, 0.47075543148731835, 0.5392012475143997, 0.49709441604475546, 0.5032069427746041, 0.6433981426334798, 0.5277259363847329, 0.2996635002583883, 0.42832590635800916, 0.34661062009475385, 0.3322768356501744, 0.4439960796035358, 0.36454725471310134, 0.3662804329737779, 0.41371005072411504, 0.3840291296459746, 0.20374479175330595, 0.21315337973641035, 0.1873134606858704, 0.1790412653436606, 0.17940210424953218, 0.20655755670772724, 0.18804710815702175, 0.2090674252421031, 0.22791827053776514, 0.40643021407109803, 0.6685322185083364, 0.22313021332472227, 0.393181304637532, 0.21396843003390453, 0.6201352454794247, 0.5406970926723318, 0.2155600682627148, 0.23624193395904813, 0.7946328777374954, 0.8360648458446798, 0.8782351129411738, 0.8449280209363154, 0.8680125057997079, 0.19621671680721553, 0.1648289129225321, 0.1999522167992588, 0.8526956745014718, 0.8303497889019074, 0.8285442873884938, 0.8218714864814481, 0.7684992506863608, 0.20973829252943443, 0.6728612138387284, 0.2099580815372779, 0.21149277946248513, 0.21253526932563882, 0.17858104119433205, 0.18352766849866664, 0.18464563737483197, 0.21268184525262923, 0.18022554413628755, 0.17835835220663854, 0.1827172624839083, 0.18075849000807998, 0.18232432789819575, 0.07768659878515483, 0.0834700495113464, 0.07993553489334737, 0.07857679167644238, 0.08578300781800385, 0.08589073446471174, 0.09281543226971023, 0.08457361544759956, 0.08163028056391264]}, "mutation_prompt": null}
{"id": "dfa373f3-a0a3-41ec-809a-b7670cf8983c", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.10 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.05 * (self.global_best - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Dynamic Memory and Environmental Feedback for Enhanced Performance.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.8832480531004583, 0.9012854033056067, 0.8893669832894031, 0.8842678099238231, 0.9107642238630185, 0.8889469686247702, 0.8767106341925663, 0.9038875766221016, 0.8982911210225977, 0.7993113933517382, 0.8260399092609195, 0.8293160342754251, 0.8031333884243577, 0.8260388215268221, 0.8295100304242982, 0.8128705864555161, 0.8243065203251259, 0.8170820476985798, 0.15262362785627215, 0.49953165185587567, 0.48200569065006404, 0.38907186981566877, 0.37844365996784135, 0.36549290932715084, 0.2984936379653461, 0.48354289278400286, 0.6049744098597905, 0.152614209798971, 0.1482637437928086, 0.12331373153443115, 0.12829162605341282, 0.1357935838284553, 0.15189937070219806, 0.1421710082209463, 0.14589245025024788, 0.2684152898834623, 0.9624295408089681, 0.9721577057871323, 0.967021227925701, 0.9610408621758085, 0.9607929746931004, 0.9685749822740649, 0.9587695929101322, 0.9664029513383446, 0.9614886701989819, 0.6709264752341464, 0.7212008304289295, 0.6819423583510144, 0.6576327158960855, 0.7177881083168871, 0.719294920865211, 0.7456357291571116, 0.7115790224614064, 0.7121148768314851, 0.8431360773544776, 0.8264087179225938, 0.7973765397268878, 0.8371386923776496, 0.8587898847824069, 0.7895298960144495, 0.8020730400328077, 0.8625192557225608, 0.8398172483623452, 0.49740072939962887, 0.5891422978062271, 0.46599243431192316, 0.5843002874688832, 0.5850680303102024, 0.5030109010317705, 0.453146042305435, 0.5733571059469802, 0.45025920018936416, 0.4515028518879024, 0.5958879500457573, 0.13780774133977447, 0.6224899782048517, 0.5460094195826923, 0.5111991075736719, 0.5572849717377505, 0.567548400708636, 0.3577556902332585, 0.559354280799037, 0.6078134981606036, 0.47221932826658275, 0.5232677340657435, 0.46733874788013496, 0.4805076167592529, 0.5290867276228715, 0.13035697262221768, 0.3467394566498987, 0.6356745646873156, 0.6538228469432386, 0.5104924922339464, 0.6479635506699861, 0.5572476037053423, 0.4581312416416501, 0.7203206880737302, 0.7059538276040949, 0.6002712117107953, 0.3489311501989417, 0.25909326424712176, 0.11829770185877264, 0.4119108875504298, 0.1728861041545139, 0.33095387552194977, 0.1714153651463104, 0.28700466144735626, 0.16396823220300472, 0.3844695370775677, 0.48937676709197153, 0.3341764965976589, 0.4473793478418826, 0.5797188132540296, 0.39746717893416694, 0.41186940637398994, 0.4359197020667185, 0.4267731669749054, 0.8272266606512402, 0.8202207297981494, 0.808309743557406, 0.7730053846747338, 0.8164556189994325, 0.7767305823074896, 0.7941995910273928, 0.8597337710015523, 0.7801791518828451, 0.15584366245526393, 0.12094474032802804, 0.10915323928917675, 0.10181767971607314, 0.09313060949345509, 0.11462667221513456, 0.1006935175976107, 0.11899561719516427, 0.1148067024735634, 0.13768282633486384, 0.15641497261497883, 0.14689861369312662, 0.1845264040837168, 0.15560427491783357, 0.15143175278168142, 0.2738417621769913, 0.4354887851847782, 0.1400893832692498, 0.4549926287818695, 0.5522605225728163, 0.5305534373149651, 0.455102117420246, 0.5528540554853114, 0.529775133050101, 0.5173942324873932, 0.6604874272685358, 0.6121768878004681, 0.36402891615461075, 0.34768153503507127, 0.32699239296664373, 0.34966765671779176, 0.40963829742385116, 0.40659805095964496, 0.35522858728757456, 0.5303257621886682, 0.47598060677182685, 0.19760167820415353, 0.20764099609097153, 0.20422646731924476, 0.19525032225565597, 0.20194717898611725, 0.20475959440085256, 0.2155533016948361, 0.20453753498779081, 0.22365484818085357, 0.22515079112971215, 0.5406086332144506, 0.28979834528370285, 0.67627401747485, 0.6294171791365555, 0.5591677699346009, 0.2145613775229923, 0.6219048064025586, 0.23215963920069038, 0.8904058246381871, 0.8708510025815474, 0.1528692927472124, 0.1926059752968502, 0.20578102692972178, 0.8279546814619482, 0.7505806216349138, 0.21008203282929783, 0.7301410641550174, 0.8656915031532526, 0.16834872903552311, 0.1691252225751767, 0.8138198207187264, 0.2097953196775959, 0.20757707111185442, 0.21072816915329462, 0.11243023172583577, 0.21150197283002659, 0.18776094221549233, 0.19113074653492979, 0.18163344352559974, 0.19642338338721999, 0.1768560225124194, 0.20552185533213396, 0.17398209263480857, 0.18235394061188925, 0.16967451573631664, 0.08122122978256319, 0.08364319478242399, 0.09410818990431757, 0.08322527838662486, 0.0943094564023238, 0.09649556812753812, 0.0771173876920549, 0.08279972787951151, 0.07903021512047004]}, "mutation_prompt": null}
{"id": "0562ad43-62ca-4c15-82a4-bb2d680fc7dd", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.5 + np.random.rand(self.population_size) * 0.4\n        self.crossover_rate = 0.7 + np.random.rand(self.population_size) * 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.10 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.05 * (self.global_best - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Dynamic Memory and Environmental Feedback for Enhanced Performance.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.8832480531004583, 0.9012854033056067, 0.8893669832894031, 0.8842678099238231, 0.9107642238630185, 0.8889469686247702, 0.8767106341925663, 0.9038875766221016, 0.8982911210225977, 0.7993113933517382, 0.8260399092609195, 0.8293160342754251, 0.8031333884243577, 0.8260388215268221, 0.8295100304242982, 0.8128705864555161, 0.8243065203251259, 0.8170820476985798, 0.15262362785627215, 0.49953165185587567, 0.48200569065006404, 0.38907186981566877, 0.37844365996784135, 0.36549290932715084, 0.2984936379653461, 0.48354289278400286, 0.6049744098597905, 0.152614209798971, 0.1482637437928086, 0.12331373153443115, 0.12829162605341282, 0.1357935838284553, 0.15189937070219806, 0.1421710082209463, 0.14589245025024788, 0.2684152898834623, 0.9624295408089681, 0.9721577057871323, 0.967021227925701, 0.9610408621758085, 0.9607929746931004, 0.9685749822740649, 0.9587695929101322, 0.9664029513383446, 0.9614886701989819, 0.6709264752341464, 0.7212008304289295, 0.6819423583510144, 0.6576327158960855, 0.7177881083168871, 0.719294920865211, 0.7456357291571116, 0.7115790224614064, 0.7121148768314851, 0.8431360773544776, 0.8264087179225938, 0.7973765397268878, 0.8371386923776496, 0.8587898847824069, 0.7895298960144495, 0.8020730400328077, 0.8625192557225608, 0.8398172483623452, 0.49740072939962887, 0.5891422978062271, 0.46599243431192316, 0.5843002874688832, 0.5850680303102024, 0.5030109010317705, 0.453146042305435, 0.5733571059469802, 0.45025920018936416, 0.4515028518879024, 0.5958879500457573, 0.13780774133977447, 0.6224899782048517, 0.5460094195826923, 0.5111991075736719, 0.5572849717377505, 0.567548400708636, 0.3577556902332585, 0.559354280799037, 0.6078134981606036, 0.47221932826658275, 0.5232677340657435, 0.46733874788013496, 0.4805076167592529, 0.5290867276228715, 0.13035697262221768, 0.3467394566498987, 0.6356745646873156, 0.6538228469432386, 0.5104924922339464, 0.6479635506699861, 0.5572476037053423, 0.4581312416416501, 0.7203206880737302, 0.7059538276040949, 0.6002712117107953, 0.3489311501989417, 0.25909326424712176, 0.11829770185877264, 0.4119108875504298, 0.1728861041545139, 0.33095387552194977, 0.1714153651463104, 0.28700466144735626, 0.16396823220300472, 0.3844695370775677, 0.48937676709197153, 0.3341764965976589, 0.4473793478418826, 0.5797188132540296, 0.39746717893416694, 0.41186940637398994, 0.4359197020667185, 0.4267731669749054, 0.8272266606512402, 0.8202207297981494, 0.808309743557406, 0.7730053846747338, 0.8164556189994325, 0.7767305823074896, 0.7941995910273928, 0.8597337710015523, 0.7801791518828451, 0.15584366245526393, 0.12094474032802804, 0.10915323928917675, 0.10181767971607314, 0.09313060949345509, 0.11462667221513456, 0.1006935175976107, 0.11899561719516427, 0.1148067024735634, 0.13768282633486384, 0.15641497261497883, 0.14689861369312662, 0.1845264040837168, 0.15560427491783357, 0.15143175278168142, 0.2738417621769913, 0.4354887851847782, 0.1400893832692498, 0.4549926287818695, 0.5522605225728163, 0.5305534373149651, 0.455102117420246, 0.5528540554853114, 0.529775133050101, 0.5173942324873932, 0.6604874272685358, 0.6121768878004681, 0.36402891615461075, 0.34768153503507127, 0.32699239296664373, 0.34966765671779176, 0.40963829742385116, 0.40659805095964496, 0.35522858728757456, 0.5303257621886682, 0.47598060677182685, 0.19760167820415353, 0.20764099609097153, 0.20422646731924476, 0.19525032225565597, 0.20194717898611725, 0.20475959440085256, 0.2155533016948361, 0.20453753498779081, 0.22365484818085357, 0.22515079112971215, 0.5406086332144506, 0.28979834528370285, 0.67627401747485, 0.6294171791365555, 0.5591677699346009, 0.2145613775229923, 0.6219048064025586, 0.23215963920069038, 0.8904058246381871, 0.8708510025815474, 0.1528692927472124, 0.1926059752968502, 0.20578102692972178, 0.8279546814619482, 0.7505806216349138, 0.21008203282929783, 0.7301410641550174, 0.8656915031532526, 0.16834872903552311, 0.1691252225751767, 0.8138198207187264, 0.2097953196775959, 0.20757707111185442, 0.21072816915329462, 0.11243023172583577, 0.21150197283002659, 0.18776094221549233, 0.19113074653492979, 0.18163344352559974, 0.19642338338721999, 0.1768560225124194, 0.20552185533213396, 0.17398209263480857, 0.18235394061188925, 0.16967451573631664, 0.08122122978256319, 0.08364319478242399, 0.09410818990431757, 0.08322527838662486, 0.0943094564023238, 0.09649556812753812, 0.0771173876920549, 0.08279972787951151, 0.07903021512047004]}, "mutation_prompt": null}
{"id": "d5625fa6-f3ca-41e8-86f5-1107d918fdbb", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)  # Self-adaptive mutation range\n        self.crossover_rate = np.random.uniform(0.7, 0.95, self.population_size)  # Hybrid crossover range\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.10 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.05 * (self.global_best - x0)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate[i]\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution enhanced with a self-adaptive mutation rate and hybrid crossover strategy.", "configspace": "", "generation": 75, "fitness": 0.47334694716437403, "feedback": "The algorithm CoevolutionaryAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.8852735386007557, 0.9049734019198314, 0.9143678441109336, 0.886523072215502, 0.916458014391713, 0.9120733220071395, 0.8885765695268304, 0.9185013316012792, 0.9075727877054155, 0.8167579164607552, 0.8563533832168464, 0.8382148624239327, 0.8094834175259085, 0.8566840389859836, 0.8467300986922099, 0.8233775066757005, 0.8548726516380356, 0.8280266114365866, 0.5633194483525086, 0.5603637624306966, 0.6128077691716616, 0.41310245805891377, 0.17353127288247194, 0.432410522408995, 0.2778433248784533, 0.16031629771814782, 0.45993831872516033, 0.16426950864225853, 0.14521434961351476, 0.3683332242281786, 0.13907148244992218, 0.1379732230984546, 0.5225974865309089, 0.15587159752202773, 0.14642932176474877, 0.15939944920654725, 0.963221485953911, 0.967830136753046, 0.9444120459194191, 0.979184848626439, 0.9605747841776999, 0.9651077948985216, 0.969724478511763, 0.9565550937186864, 0.9539401122093343, 0.6761810565245403, 0.7742535669713891, 0.7002131950676759, 0.7055036014992173, 0.7501349226926135, 0.7091726428194955, 0.7028155935672253, 0.5264622443137668, 0.7347574893695943, 0.822898267582847, 0.22484292778652148, 0.8470303104835414, 0.8705233074344504, 0.8608157423688344, 0.8972260661459754, 0.8331973401770981, 0.86835767573373, 0.8088419197618877, 0.6472815726142718, 0.6010674706308545, 0.5276898994875702, 0.47120335322013296, 0.1697295097248438, 0.49160506248574676, 0.5354614296797551, 0.4407495942979608, 0.2817244679139268, 0.43818177107302103, 0.14883517525011525, 0.09756995440596872, 0.5652924162959876, 0.21660547220785165, 0.20606023085186698, 0.6040869385985634, 0.6379567566099466, 0.5008827909592046, 0.6295219727431447, 0.3785793460281749, 0.24819366383062502, 0.5678408631313735, 0.2650459201558074, 0.1691617265414368, 0.4969148150206779, 0.48667274100838676, 0.31879971856276357, 0.6423958196662418, 0.7329526070022925, 0.6366364720869713, 0.664743634771811, 0.18612420308316924, 0.318527623275508, 0.7087969564492187, 0.38934609493193484, 0.6992417299814955, 0.15179442386197384, 0.11152589530884338, 0.2317408905593813, 0.4094892880946821, 0.4588282563502527, 0.3745661962432675, 0.18274341233327995, 0.13971951585791742, 0.2677682234753188, 0.4303965158601325, 0.4416164731669663, 0.35264902462551695, 0.48906753063590735, 0.4971318987437918, 0.3207325870473111, 0.41361727954527705, 0.5671426825672641, 0.3845992885776828, 0.8490505080657305, 0.8602424873732096, 0.8099760137629366, 0.7713207239935047, 0.6235923849508058, 0.8234212234674358, 0.8224775198560818, 0.6972880910489359, 0.7923731801159192, 0.09704689205895844, 0.11983146501538844, 0.13817683523347135, 0.10307143662396268, 0.10139108934863417, 0.11128655035756241, 0.19404400165180402, 0.10680606222681943, 0.13509826433235417, 0.18965504979297043, 0.1521292959739854, 0.14412329453776096, 0.19525746393430599, 0.2572596588278575, 0.14380676678485438, 0.23264270557153477, 0.1692410196340809, 0.16656633486598116, 0.4689957673563099, 0.6785099900301876, 0.5161371597223836, 0.5426701420325746, 0.6720198576924103, 0.6079156677184075, 0.5588754845676766, 0.710786680053616, 0.6786862855731325, 0.3884465778908476, 0.510152440589225, 0.3741713854689609, 0.40432855206250673, 0.4459706005634506, 0.3383600805115632, 0.43012622024126457, 0.52020291223564, 0.4903372625768132, 0.18576919328869756, 0.19297855703912326, 0.20961399743304943, 0.20005405433798973, 0.21810679067136474, 0.1875098824473349, 0.19130822910516676, 0.2251818161381115, 0.21787321716835428, 0.687383359620771, 0.7683840381891398, 0.5555744883316824, 0.6121505075275184, 0.6293978252528436, 0.2228569543112211, 0.5818902418526277, 0.22409327573989535, 0.24552497777170568, 0.8975392585799314, 0.8906586326480694, 0.18569720929229627, 0.8430459143442777, 0.2090665666234447, 0.8568680441086977, 0.18311998706888288, 0.8571509289238808, 0.8228319500492363, 0.872205915576613, 0.20692375650200912, 0.16677799040037966, 0.8070046795021681, 0.20995359109692946, 0.2106975765271366, 0.21293071423036725, 0.11133826909359923, 0.2097048980240238, 0.18340643123285538, 0.19346632012438048, 0.1908126058663815, 0.17326871218694284, 0.19085941715794297, 0.1813313585497318, 0.1879755820945741, 0.18322764674165282, 0.18841533170491387, 0.07094472695088838, 0.09181441245270305, 0.07780859560209796, 0.08534989943226523, 0.07706109599658961, 0.08866256855819843, 0.07890658453597987, 0.08741092015444318, 0.08118070772834163]}, "mutation_prompt": null}
{"id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 76, "fitness": 0.47416031727034696, "feedback": "The algorithm CoevolutionaryAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "4b494a1f-73cc-4cef-b5bc-44897a82f490", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "07096dc2-15f0-4409-a422-f340c242c594", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "f9d936eb-82b5-4f0c-9e2b-e47fc235c737", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "8fd894de-60fb-4ffc-ae27-8d2b5a9d2fdd", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "1f5c84dc-a7ed-41a3-a005-d5ffab615b1b", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "75157644-7aa9-4191-a7ad-ebc4d7b30db2", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "c73dd941-3b7e-4049-9a4c-ac55a6704a06", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "fc6c993e-c8bc-4fdd-b992-47f9f4bf6d58", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "85ad3c9a-3dfa-4cbc-a009-bb7bf307af2a", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "f8f987ec-9575-4ef1-9b3e-8518856e483f", "solution": "import numpy as np\n\nclass CoevolutionaryAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.15 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = np.zeros(self.dim)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "CoevolutionaryAdaptiveDifferentialEvolution", "description": "Coevolutionary Adaptive Differential Evolution with Memory-informed and Stochastic Feedback for Enhanced Global and Local Search Capabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8778170324607908, 0.8908513546400273, 0.9012631705960839, 0.8783017336808422, 0.8970984143098368, 0.8979461003580473, 0.8759703635844248, 0.8765979285353618, 0.8898197199482317, 0.7881198344104194, 0.8247202670905107, 0.804505966100639, 0.7593355107797786, 0.8255862336453057, 0.8136086389557158, 0.8109911662567637, 0.8188996492489612, 0.8211637764965058, 0.26183003887043266, 0.4457842141966274, 0.33862539055543617, 0.12713304162473726, 0.14875163056263463, 0.16643938028552785, 0.2356952906746036, 0.35174373116438185, 0.21644743060845673, 0.1559975472611832, 0.15608683733533635, 0.23051904435041093, 0.13189378080987169, 0.14492255879428662, 0.12424514299361311, 0.132939880390184, 0.35775288206219413, 0.12902993938360918, 0.9337244369358753, 0.9707658586452396, 0.9720974397510145, 0.9628222789926694, 0.961777291995387, 0.9738498713808496, 0.9705632831507355, 0.9355737972647702, 0.9921824222488976, 0.669107022450535, 0.7209201870167856, 0.6726798329434445, 0.6839128407782429, 0.7169145173236553, 0.6857703816397571, 0.6803007255786405, 0.7028655824860438, 0.7198010445197758, 0.8264114699543982, 0.851896288381836, 0.8515520671329078, 0.836913878612167, 0.8934350620695546, 0.8608403475641098, 0.8493823767564721, 0.8587414822028042, 0.8143083696815957, 0.5990947387436059, 0.561474200117912, 0.5682527064516393, 0.6085544234617875, 0.616557415562833, 0.49605354231868637, 0.5927542908581378, 0.646017623297169, 0.596844108166392, 0.6295592859643647, 0.5760407009363062, 0.010064458386748854, 0.6426188029067099, 0.6334976620561483, 0.5406010603925684, 0.5649798627971269, 0.6419893021097756, 0.601044224142721, 0.559560386823247, 0.6136333374261805, 0.4966598804461967, 0.5508360474283671, 0.5433836615042731, 0.49087616730597516, 0.5357722291845648, 0.5700239540381853, 0.49910631809580974, 0.5969746138698057, 0.6875003144643217, 0.6333331566880877, 0.42433801538299853, 0.5021850477472547, 0.6221634085240116, 0.7115519827796309, 0.7216589214059258, 0.6212935393209034, 0.26093430293795583, 0.1200257697818774, 0.19519764514345805, 0.31496747188903373, 0.5524198053808808, 0.29557656730437154, 0.2561988051741356, 0.1930493306337615, 0.22538882710904573, 0.4691870371204072, 0.4606127147612208, 0.3888634768358762, 0.47673702590126776, 0.5157874819913596, 0.4293118921290502, 0.4659293372598392, 0.44049870621301934, 0.3506898617450154, 0.7836080327978906, 0.8187044856006696, 0.7827958597156092, 0.7717301445488197, 0.8013403868020107, 0.7794454397284372, 0.7670753432537328, 0.8192119548753283, 0.7815462238529055, 0.1097736275041521, 0.10010194258806837, 0.1105091611015927, 0.10285434564157936, 0.10837694607232173, 0.09516507688243614, 0.0983912730930182, 0.11625590113139628, 0.08159300670188929, 0.15002026624117204, 0.13972517166212106, 0.13129198737085135, 0.1352775086511685, 0.22563761250340308, 0.16055977560551526, 0.18853118344476716, 0.2543177291892579, 0.18988494011878776, 0.46465204393270787, 0.5790226422229185, 0.44335380085037557, 0.48053484068827457, 0.5181488676818138, 0.46847875297477926, 0.5387264328357512, 0.5931921074012834, 0.5409477465647471, 0.37679200969870386, 0.41500936460989124, 0.342870515891153, 0.346358365684598, 0.39724214125545454, 0.37385887596851775, 0.420608405367194, 0.49963276872417484, 0.33375437903519956, 0.1844854482628524, 0.1998466589985013, 0.178941966341025, 0.23646978740970448, 0.20627728256401046, 0.19806346423366428, 0.1982401668418402, 0.1892982309242911, 0.19469446721777384, 0.2792789747080875, 0.5801236537655499, 0.590576828785434, 0.456998564146886, 0.2139682692601399, 0.3286058839955074, 0.21739561177468036, 0.36074225433268026, 0.23191357563425685, 0.18318086502464026, 0.8654955242942152, 0.8921171384796662, 0.836737428535032, 0.20730708906128525, 0.8327429054445884, 0.18575379946551973, 0.7972851662599961, 0.19290340159472896, 0.8779502175198105, 0.2101618877401723, 0.8002908501826067, 0.20773894697413686, 0.8833988011276582, 0.20724400995625825, 0.15367710373872956, 0.21049139900587732, 0.1273479680052073, 0.17561030656577747, 0.19223971350491653, 0.18199947138976347, 0.18394899542697019, 0.18107338487391733, 0.19206118445188158, 0.19474404309612947, 0.17858161369001557, 0.17630184808286287, 0.07236139129020924, 0.08004141212021809, 0.08097571423971972, 0.08207503681788186, 0.07591558193850578, 0.08373226650939358, 0.08426402316371329, 0.07188306457578042, 0.08039426808593964]}, "mutation_prompt": null}
{"id": "5c4a4dee-9c53-4191-81f9-389c3b1b3ee4", "solution": "import numpy as np\n\nclass StochasticGradientInformedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.2 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = 0.01 * (self.global_best - x0)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "StochasticGradientInformedDE", "description": "Stochastic Gradient-informed Differential Evolution with Enhanced Memory Feedback for Robust Global Exploration and Local Exploitation.", "configspace": "", "generation": 86, "fitness": 0.48263994415709077, "feedback": "The algorithm StochasticGradientInformedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "950ecbdd-bd8f-43a0-ad60-82e0981b7434", "metadata": {"aucs": [0.8735239233501073, 0.8942354912644135, 0.8915700635640378, 0.8806854568367604, 0.9009920479319925, 0.9032776281695907, 0.8711504739260669, 0.8931157030387059, 0.8830061265515181, 0.7870586884770095, 0.8172769296091583, 0.8207904241761407, 0.7998597903110303, 0.798311472726786, 0.8311841962902998, 0.7908272116009969, 0.8279479280085361, 0.8260023563979921, 0.39852216394033835, 0.49488676181323465, 0.1272175027409146, 0.4412939276666843, 0.1353536233244118, 0.35048177131133273, 0.526362985328332, 0.10915980227427446, 0.15132388196750746, 0.11210709106443084, 0.15076590105091925, 0.13389029845508227, 0.15227263092743293, 0.12789280907232492, 0.14705949155352394, 0.13586899109896788, 0.35220620451941165, 0.23445057963416271, 0.9489714701268068, 0.9317975940379077, 0.9830607921654994, 0.9741520514546244, 0.9616432998365629, 0.9720693800778393, 0.9616272114693847, 0.9716685086432009, 0.9921819750260585, 0.6872682619354804, 0.7390737618185775, 0.6885730408453519, 0.716713643352596, 0.6802726963392236, 0.6659918660535672, 0.695331791356383, 0.6984648014080255, 0.6802882115106008, 0.8073036549493682, 0.8311704272144207, 0.8086715551520125, 0.846376290333556, 0.8584669980729998, 0.8217117034910374, 0.825338709076616, 0.849242280276426, 0.8596552151888305, 0.5894195702142068, 0.6069526748045402, 0.5298409145455764, 0.6801196354881787, 0.6656559022035011, 0.5895908384659208, 0.5104061309471327, 0.623904298409575, 0.13222047146332594, 0.6770814797868301, 0.5634231504846933, 0.4424423032663102, 0.5264161581505951, 0.4691127221711504, 0.5632436779583123, 0.5446856018666849, 0.5081760583447192, 0.5470602091206497, 0.5109211477866605, 0.5752160745181694, 0.48155580734274295, 0.6023035128578937, 0.5959825381511155, 0.4978655872259272, 0.5724728471048874, 0.6089802495058199, 0.4467530544069319, 0.651951276175492, 0.6523806522298596, 0.5903661565779159, 0.6307020281889774, 0.690707632911646, 0.5694193794616427, 0.7227103033534625, 0.7278523461554508, 0.6803914241587885, 0.2142520224839204, 0.11283486580399527, 0.24470729307615224, 0.3789495040752715, 0.5234587119589762, 0.1699469374208693, 0.21071223501685443, 0.2549409176019731, 0.23579291009860015, 0.4314548753499021, 0.5367029141344292, 0.406390370802305, 0.42573374267094943, 0.5580012159141404, 0.40641159609182054, 0.43712516683739944, 0.5104100298872746, 0.35073171518492496, 0.8185504056119259, 0.8170039937110447, 0.7954029882338166, 0.8053364130717564, 0.8271027454663304, 0.7983479839500452, 0.7686155674072186, 0.8116259377553942, 0.7727629859734794, 0.10900433180960334, 0.1135219445203477, 0.10861136490170753, 0.09826250001073877, 0.10872790183261805, 0.10257598089828446, 0.11238547934545873, 0.13634860714079644, 0.09697919843127545, 0.6235802887856812, 0.21093396624581096, 0.1582022058610344, 0.1589230097963007, 0.1652069676406248, 0.15070338633053015, 0.13189457933934412, 0.1195033878131535, 0.12941068116503662, 0.5191355100345789, 0.5444209369804391, 0.4976499537194454, 0.5184900521894793, 0.5545298198703443, 0.5468129512149623, 0.5256721290426116, 0.5851941078641179, 0.601817641525181, 0.3328011145603672, 0.4372984646990833, 0.34523137405702564, 0.3261749461936517, 0.4775801735881888, 0.4232380828649047, 0.3487642084495508, 0.45907623107353535, 0.3552253118062785, 0.1838248371733765, 0.20067306455855383, 0.1950603892742775, 0.19228656638330244, 0.1968493104154454, 0.198771690304132, 0.19462641567047523, 0.21466033837068732, 0.18466209031221226, 0.4452962936780579, 0.28464634738878547, 0.5213602338207115, 0.3918127414801499, 0.2331337506438811, 0.2016287711265783, 0.2350935254906148, 0.37166591062501064, 0.6131127204940494, 0.18449287751245125, 0.8850055016745405, 0.8863707691165361, 0.8424905313391271, 0.2079578662244207, 0.7153673058701349, 0.1618488745417983, 0.6362089931969481, 0.7355436716542874, 0.8045974388639233, 0.16890422751576084, 0.20563545013463613, 0.7297919596649319, 0.8257282513479812, 0.210125993542279, 0.20605273397980794, 0.12732649670595653, 0.8397500305629816, 0.18522862920158234, 0.18058442551561038, 0.1873477913108228, 0.18332968246155534, 0.17868970076030732, 0.1788042777173363, 0.19337434598873082, 0.18705942745417847, 0.17933490675672525, 0.07691922348907154, 0.07390117067502977, 0.08624914969583242, 0.07714924573685678, 0.07771941066620514, 0.07506985672378319, 0.07930675782469332, 0.07689630933697722, 0.07640148177197481]}, "mutation_prompt": null}
{"id": "e256ddfb-87b9-4fb4-a203-fab68d646627", "solution": "import numpy as np\n\nclass StochasticGradientInformedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = 0.6 + np.random.rand(self.population_size) * 0.3\n        self.crossover_rate = 0.75 + np.random.rand(self.population_size) * 0.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(current_population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    memory_idx = np.random.choice(self.population_size)\n                    gradient = 0.2 * (self.memory[memory_idx] - self.global_best)\n                else:\n                    gradient = 0.01 * (self.global_best - x0)\n                \n                feedback = 0.1 * (self.global_best - x0) + 0.05 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "StochasticGradientInformedDE", "description": "Stochastic Gradient-informed Differential Evolution with Enhanced Memory Feedback for Robust Global Exploration and Local Exploitation.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5c4a4dee-9c53-4191-81f9-389c3b1b3ee4", "metadata": {"aucs": [0.8735239233501073, 0.8942354912644135, 0.8915700635640378, 0.8806854568367604, 0.9009920479319925, 0.9032776281695907, 0.8711504739260669, 0.8931157030387059, 0.8830061265515181, 0.7870586884770095, 0.8172769296091583, 0.8207904241761407, 0.7998597903110303, 0.798311472726786, 0.8311841962902998, 0.7908272116009969, 0.8279479280085361, 0.8260023563979921, 0.39852216394033835, 0.49488676181323465, 0.1272175027409146, 0.4412939276666843, 0.1353536233244118, 0.35048177131133273, 0.526362985328332, 0.10915980227427446, 0.15132388196750746, 0.11210709106443084, 0.15076590105091925, 0.13389029845508227, 0.15227263092743293, 0.12789280907232492, 0.14705949155352394, 0.13586899109896788, 0.35220620451941165, 0.23445057963416271, 0.9489714701268068, 0.9317975940379077, 0.9830607921654994, 0.9741520514546244, 0.9616432998365629, 0.9720693800778393, 0.9616272114693847, 0.9716685086432009, 0.9921819750260585, 0.6872682619354804, 0.7390737618185775, 0.6885730408453519, 0.716713643352596, 0.6802726963392236, 0.6659918660535672, 0.695331791356383, 0.6984648014080255, 0.6802882115106008, 0.8073036549493682, 0.8311704272144207, 0.8086715551520125, 0.846376290333556, 0.8584669980729998, 0.8217117034910374, 0.825338709076616, 0.849242280276426, 0.8596552151888305, 0.5894195702142068, 0.6069526748045402, 0.5298409145455764, 0.6801196354881787, 0.6656559022035011, 0.5895908384659208, 0.5104061309471327, 0.623904298409575, 0.13222047146332594, 0.6770814797868301, 0.5634231504846933, 0.4424423032663102, 0.5264161581505951, 0.4691127221711504, 0.5632436779583123, 0.5446856018666849, 0.5081760583447192, 0.5470602091206497, 0.5109211477866605, 0.5752160745181694, 0.48155580734274295, 0.6023035128578937, 0.5959825381511155, 0.4978655872259272, 0.5724728471048874, 0.6089802495058199, 0.4467530544069319, 0.651951276175492, 0.6523806522298596, 0.5903661565779159, 0.6307020281889774, 0.690707632911646, 0.5694193794616427, 0.7227103033534625, 0.7278523461554508, 0.6803914241587885, 0.2142520224839204, 0.11283486580399527, 0.24470729307615224, 0.3789495040752715, 0.5234587119589762, 0.1699469374208693, 0.21071223501685443, 0.2549409176019731, 0.23579291009860015, 0.4314548753499021, 0.5367029141344292, 0.406390370802305, 0.42573374267094943, 0.5580012159141404, 0.40641159609182054, 0.43712516683739944, 0.5104100298872746, 0.35073171518492496, 0.8185504056119259, 0.8170039937110447, 0.7954029882338166, 0.8053364130717564, 0.8271027454663304, 0.7983479839500452, 0.7686155674072186, 0.8116259377553942, 0.7727629859734794, 0.10900433180960334, 0.1135219445203477, 0.10861136490170753, 0.09826250001073877, 0.10872790183261805, 0.10257598089828446, 0.11238547934545873, 0.13634860714079644, 0.09697919843127545, 0.6235802887856812, 0.21093396624581096, 0.1582022058610344, 0.1589230097963007, 0.1652069676406248, 0.15070338633053015, 0.13189457933934412, 0.1195033878131535, 0.12941068116503662, 0.5191355100345789, 0.5444209369804391, 0.4976499537194454, 0.5184900521894793, 0.5545298198703443, 0.5468129512149623, 0.5256721290426116, 0.5851941078641179, 0.601817641525181, 0.3328011145603672, 0.4372984646990833, 0.34523137405702564, 0.3261749461936517, 0.4775801735881888, 0.4232380828649047, 0.3487642084495508, 0.45907623107353535, 0.3552253118062785, 0.1838248371733765, 0.20067306455855383, 0.1950603892742775, 0.19228656638330244, 0.1968493104154454, 0.198771690304132, 0.19462641567047523, 0.21466033837068732, 0.18466209031221226, 0.4452962936780579, 0.28464634738878547, 0.5213602338207115, 0.3918127414801499, 0.2331337506438811, 0.2016287711265783, 0.2350935254906148, 0.37166591062501064, 0.6131127204940494, 0.18449287751245125, 0.8850055016745405, 0.8863707691165361, 0.8424905313391271, 0.2079578662244207, 0.7153673058701349, 0.1618488745417983, 0.6362089931969481, 0.7355436716542874, 0.8045974388639233, 0.16890422751576084, 0.20563545013463613, 0.7297919596649319, 0.8257282513479812, 0.210125993542279, 0.20605273397980794, 0.12732649670595653, 0.8397500305629816, 0.18522862920158234, 0.18058442551561038, 0.1873477913108228, 0.18332968246155534, 0.17868970076030732, 0.1788042777173363, 0.19337434598873082, 0.18705942745417847, 0.17933490675672525, 0.07691922348907154, 0.07390117067502977, 0.08624914969583242, 0.07714924573685678, 0.07771941066620514, 0.07506985672378319, 0.07930675782469332, 0.07689630933697722, 0.07640148177197481]}, "mutation_prompt": null}
{"id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 88, "fitness": 0.4828943713501558, "feedback": "The algorithm AdaptiveMutationDiversityDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "5c4a4dee-9c53-4191-81f9-389c3b1b3ee4", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
{"id": "fee19197-9621-4ed7-b07b-73847e89e404", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
{"id": "c8f60df0-7c7d-452c-a4ad-8328a4bf30a0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.5, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.6, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.25 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.03 * (self.global_best - x0)\n                \n                feedback = 0.2 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "EnhancedAdaptiveMutationDiversityDE", "description": "Enhanced Adaptive Mutation and Diversity Injection DE with Feedback Control for Robust Optimization.", "configspace": "", "generation": 90, "fitness": 0.470960403895137, "feedback": "The algorithm EnhancedAdaptiveMutationDiversityDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9085541439026968, 0.9101893814786355, 0.9021364928850517, 0.9150198550655083, 0.9250063907082007, 0.9168450063754288, 0.913748378472885, 0.9103201061228295, 0.9146195214788634, 0.8261341628314229, 0.8635734191207567, 0.8399496363934974, 0.8320011688878474, 0.8465727084833314, 0.825881647989289, 0.8214248398791744, 0.854770633652032, 0.8373506349705986, 0.6745316111052213, 0.43899531938200187, 0.6450723655659902, 0.15213761609309417, 0.5067268860134282, 0.5906543057655156, 0.4788025554839873, 0.636712272781804, 0.37385823286362396, 0.13777239136904607, 0.1671785957619848, 0.14628993294897885, 0.16030970272003175, 0.3827040197798842, 0.16917588434406006, 0.1347574224068434, 0.16394907605097364, 0.15598056654645553, 0.9797839862659263, 0.9873908175724722, 0.9636846373013968, 0.9636385332324439, 0.949993914450582, 0.9692385022761073, 0.9542444271603745, 0.9756714849561399, 0.9602550779916297, 0.7296611746358427, 0.738226773653132, 0.717529990420567, 0.7529475573410048, 0.7958351284909787, 0.7327657142988009, 0.7058432579345137, 0.7590681648586357, 0.6919508401730474, 0.8055398492598088, 0.8371021275565615, 0.8059175171051793, 0.8485824494690306, 0.8969220986672622, 0.7937547809381161, 0.7732313564817203, 0.8634850128611035, 0.8417726103534205, 0.5210158780915792, 0.3068244003214008, 0.46809661888484755, 0.5748809652537975, 0.6254410171977292, 0.47721467614997104, 0.6196734632490177, 0.5338526502454517, 0.41740875345403705, 0.5319145382314613, 0.6010834966331908, 0.35045629545070556, 0.5499287209594422, 0.5633103119590932, 0.5302186485624141, 0.5655713562077893, 0.3241863869236874, 0.5116812222881331, 0.40010162486994627, 0.13220358043062463, 0.32717693720234364, 0.4319877086381749, 0.511982042022914, 0.16954224312536204, 0.3717926639726947, 0.5536943267664145, 0.13085894375537277, 0.5432245147298608, 0.6176493146439963, 0.3108190538651072, 0.45406767308091556, 0.3674035193944045, 0.43173997042692414, 0.5809136074064714, 0.6886584562048934, 0.49726757117143927, 0.0922387591363647, 0.29141624525117604, 0.13660072156519365, 0.28197070210478226, 0.2957668529295262, 0.16025093759873288, 0.2787259939785688, 0.20163915985647063, 0.1373288425304472, 0.3682105221191947, 0.37236372336176027, 0.28388836038690857, 0.4200142432507209, 0.48027521492949177, 0.3848455860157284, 0.3576807490996845, 0.38217468595877524, 0.35207685612150885, 0.7602223550839965, 0.7782809745250509, 0.7459254955887065, 0.753827704053452, 0.8065799829344689, 0.7133471190342466, 0.7619036792559053, 0.7129596615444811, 0.6696344019190821, 0.09843484061589403, 0.17340093846269578, 0.11267295243316477, 0.13510082545263646, 0.10806509592804103, 0.10705237747157281, 0.12206786094807631, 0.11889237035271527, 0.10187266238278314, 0.1663960882941825, 0.14940288191306084, 0.1366097238102586, 0.13080051896140887, 0.2211137537024983, 0.15584825644714329, 0.15496385229937026, 0.17787892135407912, 0.17170649220292855, 0.504066886529051, 0.6402509026490109, 0.5649287865337638, 0.5080850300469335, 0.5712823136671431, 0.5701990030606041, 0.5837355350412166, 0.717769759489164, 0.6384938595733902, 0.34347415247044766, 0.4394438375146167, 0.3408956885425757, 0.36681802421254506, 0.43076392877160496, 0.38297301778556103, 0.4253876511615001, 0.5290263718846504, 0.38494178214548236, 0.20869112553466873, 0.18834493976622402, 0.19467461828713917, 0.22161324598708754, 0.20411620762323235, 0.19424153373089692, 0.18736653440862772, 0.19799977009460856, 0.18388267451549622, 0.5363329443209978, 0.6151301137027537, 0.23352307207324063, 0.5481144661775303, 0.5798065433177637, 0.5148559706668293, 0.19227156790716848, 0.7508445530251451, 0.4617931188816362, 0.8508544887419799, 0.16573246806771114, 0.1501672659204829, 0.7809660696851896, 0.19665205858485058, 0.8759769744550134, 0.1601224854261547, 0.8370318791154912, 0.18211437639221595, 0.886501937651999, 0.20194230908989697, 0.766983225227378, 0.20830678067810715, 0.7291153213699582, 0.20407947196963716, 0.2120126070353051, 0.12716105390623356, 0.771693961856213, 0.18309143513388348, 0.18435138908427728, 0.2025837019350023, 0.22195872233838687, 0.18544337700686497, 0.17831368485785082, 0.19939895444983524, 0.1785489341890487, 0.18691934292649937, 0.07626556877688584, 0.09017094812001092, 0.07453117548596089, 0.08839276596570056, 0.0813826398501345, 0.0913361133401055, 0.08209752520666191, 0.08651090256832072, 0.08257802751472387]}, "mutation_prompt": null}
{"id": "8aa57db4-9b6c-4818-8a64-d87a102ee5e5", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
{"id": "89db3c2b-48aa-45fb-8ca5-e281b50e3bd4", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
{"id": "1369bc56-ac08-460f-bb07-c406a4b9e24c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.35 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.025 * (self.global_best - x0)\n                \n                feedback = 0.12 * (self.global_best - x0) + 0.08 * (x0 - x1)\n                stochastic_factor = np.random.uniform(0.1, 0.3)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback * stochastic_factor\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "EnhancedAdaptiveMutationDiversityDE", "description": "Enhanced Adaptive Mutation and Diversity Injection DE with Stochastic Gradient and Feedback Mechanism for Balanced Exploration.", "configspace": "", "generation": 93, "fitness": 0.4571972380593738, "feedback": "The algorithm EnhancedAdaptiveMutationDiversityDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.8806045301570091, 0.9199503701674064, 0.902156235401939, 0.8926143622450401, 0.9122570100058756, 0.9065815479432677, 0.8833834747343546, 0.8976836689464208, 0.904788716293467, 0.8168734219517745, 0.8371122966055285, 0.8259949821384676, 0.7974683552462303, 0.8277646752943029, 0.8352736355278871, 0.8053002127114891, 0.8583200701058491, 0.8114268595577175, 0.13188159768694474, 0.16100794322681722, 0.5388227149378717, 0.36484912060189356, 0.45341194262817397, 0.5681257691831465, 0.27304864320684297, 0.6392217393310298, 0.4577652502842099, 0.3269737021479724, 0.1659060943044648, 0.14776723166089667, 0.14360744645571977, 0.17288913787046334, 0.46515806349266364, 0.1265367087683189, 0.1531158161281152, 0.15637096170880327, 0.9695604887880217, 0.9585509320086236, 0.9511355135900833, 0.9821903255305328, 0.9477293131416432, 0.98575868075144, 0.989751619750175, 0.9696908604966168, 0.9628678826429037, 0.693848509343412, 0.7411487433995179, 0.7391414639386125, 0.6928907333153346, 0.7052975449474372, 0.7069237842386551, 0.7034124511492066, 0.764458813690474, 0.7404405179187512, 0.8127458167312097, 0.8586741488800569, 0.2272894928067175, 0.8693911977170303, 0.8961274651662802, 0.8530751576050326, 0.8505611280465974, 0.8503283130518013, 0.8783056842225216, 0.5051074965553437, 0.25992156452659465, 0.4999198986781104, 0.49054231663867276, 0.1799723355712496, 0.5964411439823054, 0.5440390291627056, 0.4909823080733121, 0.3567953793641957, 0.39841427088128045, 0.12890066140080603, 0.3127498890231786, 0.6119940659307381, 0.6880421418520004, 0.5352762496187136, 0.4875269815442924, 0.20511299080153678, 0.21660027227210854, 0.4568722041322153, 0.33058171471977116, 0.3131734204626617, 0.40591332115982937, 0.5714012392833991, 0.3013571544236985, 0.3935526599091007, 0.4096805031219537, 0.19884988108435764, 0.5779557038207179, 0.25749228995432083, 0.5612511535936835, 0.5118165097429894, 0.09460236160812585, 0.5280038475957163, 0.6487352791531515, 0.3683854793054344, 0.6475750484988148, 0.15309627137313642, 0.137043794531867, 0.16207820824504837, 0.2828566315853679, 0.25706081072278153, 0.18367449882264986, 0.20625702720529715, 0.1669966401507731, 0.10122127628367439, 0.38251808840402823, 0.37525699921003597, 0.30969615195161015, 0.4034333884079858, 0.4008022409203601, 0.4391408753410684, 0.38683010988237143, 0.43247474737713887, 0.34620410205941965, 0.7554947232974355, 0.6762341234102962, 0.7871083495751825, 0.811320830835341, 0.7301213645722783, 0.7778837148428095, 0.7385661071841974, 0.8292637271242704, 0.7457480983323059, 0.1297238390669283, 0.10641102299678784, 0.13329378672145265, 0.09639102096419394, 0.11613143244792667, 0.1217090473880853, 0.10430229900712751, 0.09367096379747386, 0.12303411361646521, 0.16977172512033178, 0.2977147707084973, 0.14992807090561344, 0.1457142209069312, 0.5190840770232827, 0.1504789429455312, 0.17459513108052072, 0.2208432285801527, 0.13814656762808097, 0.5317583329488154, 0.5784397760144184, 0.5520559849905868, 0.5365453557297633, 0.6234262175687713, 0.5665365385430048, 0.5933828060484341, 0.5742811318157393, 0.5824773900707491, 0.3108557649259417, 0.3894988150814789, 0.40247009002118506, 0.38515281027182846, 0.45235254299280914, 0.3147111048445178, 0.36045988231120796, 0.5918119563297093, 0.38539187384124984, 0.21809713753426585, 0.18361025746501158, 0.18756746896675947, 0.2015801741505996, 0.21763939901487228, 0.18545354778051126, 0.2111927932730845, 0.18090409216779502, 0.20911801129833474, 0.2232852833166703, 0.2338984488722302, 0.522877814688159, 0.24275498944038676, 0.5810333181493254, 0.4183442455251991, 0.5684955338027793, 0.21402705785507448, 0.27546901079380137, 0.20666138896808517, 0.16400267609707786, 0.15166555338796972, 0.7557949343201003, 0.7543933051928501, 0.8345598164601987, 0.165382739876622, 0.889734334061645, 0.7328522096645903, 0.8649347175233942, 0.7923274145089505, 0.8007563427263276, 0.7524156152493531, 0.698992393945423, 0.20937274471851375, 0.12560212137578564, 0.20761936194825403, 0.1282949921856209, 0.1888030527012171, 0.17387024211744428, 0.19065649454913614, 0.18238131896196752, 0.18444499408394233, 0.17623166093235232, 0.18089789343472318, 0.18292801149635773, 0.19429543699575713, 0.08104313405393004, 0.08117218314326713, 0.08449338290985775, 0.0717956223262809, 0.08889919957020342, 0.07636659619379538, 0.08165575873384223, 0.08974690133620844, 0.08442509510034746]}, "mutation_prompt": null}
{"id": "d740883b-e99b-4259-8604-d4733493b222", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
{"id": "e0390c35-f5e8-4a75-8dad-c53a3bed7928", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.memory_fitness = np.full(self.population_size, np.inf)\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n\n                if trial_fitness < self.memory_fitness[i]:\n                    self.memory[i] = trial_vector.copy()\n                    self.memory_fitness[i] = trial_fitness\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE with Memory-based Selection for Enhanced Convergence.", "configspace": "", "generation": 95, "fitness": 0.47326733532946835, "feedback": "The algorithm AdaptiveMutationDiversityDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.899041185816506, 0.9226882897537513, 0.9089327710588144, 0.9070207369171852, 0.9328496674739154, 0.9125561990026432, 0.8963781506247378, 0.9205951739086325, 0.9102339125679838, 0.8306803859542968, 0.8308003649954864, 0.8577134214098545, 0.8231270534428292, 0.860242752145278, 0.852750710784382, 0.8399766066129474, 0.8091505783063405, 0.8461466694069942, 0.15914548703110032, 0.4032187824974991, 0.44749517570163566, 0.1301155254173093, 0.49838214680717474, 0.45520802518442005, 0.1422584314122438, 0.5053321363399956, 0.399909209880709, 0.15133802339478675, 0.16541530563441553, 0.13580286082176296, 0.12946302554770173, 0.15310011957984393, 0.13845968771974326, 0.1400767060327638, 0.1344230246018442, 0.12679433358151582, 0.9734103074463027, 0.9810837567615028, 0.9513901336365619, 0.9714118385396776, 0.9456226429466306, 0.9477123429822434, 0.9816778495794487, 0.9841677674957806, 0.9911089859160599, 0.7478770547307081, 0.7993596470170492, 0.7621261183578141, 0.7325084612620293, 0.7542534543627692, 0.7508595017556405, 0.7407771757050662, 0.7814523994932424, 0.7553841654802934, 0.8036715082073617, 0.8628292722189801, 0.8663184771927441, 0.8692664923414805, 0.8907057314854794, 0.8403476822604851, 0.863996940629031, 0.9130733514976721, 0.8417641242798424, 0.5826499535464428, 0.1960412868188468, 0.5186788574773347, 0.5930931536048948, 0.17478724391676714, 0.44618923081880246, 0.6330581941224127, 0.6376541147408875, 0.47344008103312907, 0.3688990258807092, 0.17045731260412644, 0.13160181524998604, 0.6194824072446355, 0.46464737781126575, 0.517880061452878, 0.5102843413644477, 0.2550871142031791, 0.6273305866269878, 0.5127896360496444, 0.41387385010096966, 0.4358681634354141, 0.6158955122960503, 0.27760610600263547, 0.30436283655538665, 0.542877901271503, 0.5782655440963906, 0.18396195018083616, 0.6492125792022774, 0.6857455440285536, 0.5188239294203721, 0.5735194450582564, 0.7322285627851306, 0.44399187436624654, 0.6445906396939094, 0.6206017322587978, 0.6309308977742911, 0.2158193175328761, 0.17276605934346212, 0.1925470059523111, 0.37090768843137434, 0.2820970981361134, 0.5056477711540122, 0.1624768692811458, 0.12357247357267442, 0.3211229203287942, 0.3974721673050725, 0.4413594750103227, 0.3771019528408409, 0.5069129997753605, 0.37148707925012636, 0.4216575655707424, 0.4552609891736831, 0.47465340367652376, 0.35168823061389143, 0.8049318428614985, 0.8644800316936604, 0.7948038262775745, 0.8104955631712248, 0.818775397359617, 0.8008987969535728, 0.8102265283462953, 0.7522374657780109, 0.7227923756604335, 0.10708976779439305, 0.11337192947296337, 0.12645773725618636, 0.10320192226114344, 0.09924257747559495, 0.11080320312527525, 0.11792730588737466, 0.15081640372605487, 0.1189746728800164, 0.1995770704629668, 0.13082785056615753, 0.13713445777848388, 0.15350192353691605, 0.1647036360350248, 0.1346277687983891, 0.141244962729679, 0.13224237499843072, 0.13991811673760313, 0.5370164254521657, 0.5792373171115148, 0.5899996278317827, 0.581717397401095, 0.7161677725861313, 0.6173452567403696, 0.6201380627952133, 0.7642732562583264, 0.6867264452907011, 0.41033516201745013, 0.4491943703252136, 0.38149974435768363, 0.40612478929141294, 0.3832402121402019, 0.39574751156224053, 0.42861937893346436, 0.41785673934631606, 0.48272649675331425, 0.20424936255451687, 0.20890600457411979, 0.20244634122362382, 0.1925452098787216, 0.20484575872211297, 0.21078935971562396, 0.19224948139613984, 0.21362600332178816, 0.22311469801573436, 0.24438392494866268, 0.5043177150427305, 0.5488335625540416, 0.22170963771470076, 0.8332853738391881, 0.24012013655504194, 0.5846839312861285, 0.3890099673677203, 0.20450401230724125, 0.8607998906672301, 0.862129821938882, 0.1531443949755028, 0.8676310285622296, 0.15621902029019907, 0.890972784642466, 0.182333709375204, 0.17487256122161632, 0.8969552574374051, 0.9055744283747283, 0.16809589133492897, 0.8470920363940068, 0.20725611291668633, 0.20507013591374867, 0.16466967520098008, 0.2120776229953225, 0.28711497080973813, 0.2123717028890948, 0.18267923228556526, 0.18098543560204183, 0.18018913486345123, 0.17741909976278325, 0.18164598095911677, 0.18514026678472706, 0.19857690763231184, 0.17661595019694565, 0.1792807790981229, 0.0874956553163938, 0.09296231747659567, 0.0815488441469181, 0.08481973333662807, 0.08764842164344833, 0.09244979650853169, 0.08157067792993222, 0.09534176409562478, 0.08016167975441824]}, "mutation_prompt": null}
{"id": "87543d59-677e-41b0-bc8e-36a2d1fa9f3d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 15 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.5, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.6, 0.95, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n\n                if np.random.rand() < 0.05:\n                    memory_candidate = self.memory[np.random.choice(self.population_size)]\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (memory_candidate - x0) + diversity_boost\n                else:\n                    gradient = self.learning_rate * (self.global_best - x0)\n\n                feedback = 0.2 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[np.random.choice(self.population_size)] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "EnhancedAdaptiveMutationDiversityDE", "description": "Enhanced Adaptive Mutation and Diversity DE with Memory-Based Learning for Dynamic Exploration.", "configspace": "", "generation": 96, "fitness": 0.4771251970016283, "feedback": "The algorithm EnhancedAdaptiveMutationDiversityDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.8952779389700888, 0.9002849344956113, 0.9145108169743752, 0.899952884899932, 0.9164335167514046, 0.9121196038310049, 0.892576089652675, 0.9122482862175013, 0.9117974007197094, 0.8199221860876329, 0.8407728739192017, 0.8416343675646052, 0.8112799549879841, 0.837965997212474, 0.8407248800487427, 0.8038188956459393, 0.8292965271385404, 0.8526813941633822, 0.3961257396358817, 0.5261259674756984, 0.6334491709886001, 0.1495446357958914, 0.4147139701083671, 0.17234700086452448, 0.130735705200407, 0.4337260478507031, 0.3358839603889109, 0.12517809057991547, 0.16270364886696476, 0.1514458022565235, 0.2351453492280774, 0.3225950837924806, 0.14869367160650415, 0.3845683619363217, 0.15937588342960118, 0.13926686474018057, 0.9753439380323856, 0.9738894415464842, 0.9792140449637342, 0.9680619295686734, 0.9496081524122942, 0.9693668358685682, 0.9812664598175597, 0.9697191241008879, 0.9646171904142224, 0.7176635630769552, 0.7827105447324576, 0.7380381563568521, 0.6957803299452645, 0.7666681584503494, 0.7536622724155052, 0.7121360504222475, 0.7605764385259397, 0.7718071469454691, 0.8277931890181507, 0.2127841867107667, 0.8432267091747643, 0.37343810980554637, 0.8508401342166978, 0.8522588165532451, 0.8507404463683356, 0.8692947254905581, 0.8608619877183395, 0.4947290473797188, 0.6287048009601827, 0.5753290723314548, 0.4831872324805262, 0.5433795419531253, 0.47726141594667537, 0.6441161002941167, 0.6456699942189476, 0.5526458144159991, 0.42003762100470476, 0.6402965143003028, 0.5351358580465857, 0.6021502567384882, 0.6367275619998392, 0.5174828414337986, 0.5071259850579007, 0.5215826479433507, 0.5747384463708323, 0.4793312711314368, 0.4505157074787962, 0.42612403187334436, 0.4260710312981807, 0.49418260093555844, 0.4004183209670428, 0.37242242670390246, 0.554490082716588, 0.4096269152763654, 0.608539142706721, 0.5750861438575843, 0.49740763355342665, 0.4800130523124251, 0.6841212192256672, 0.5146610662866278, 0.5630199128432944, 0.6855602753207475, 0.603253412049779, 0.2624031396852192, 0.19604959317675308, 0.10552566527185792, 0.17783421082415174, 0.41046766833730075, 0.21195044606909907, 0.13564809459277982, 0.28630307648878506, 0.1512972129302027, 0.33169552586073625, 0.4189984882565134, 0.3962509228802771, 0.37270879029822157, 0.4897072962526893, 0.4780393117299476, 0.3769828528053889, 0.4551121066647281, 0.3604213871003422, 0.7626260288136394, 0.8300945439446924, 0.8172742886482135, 0.7890627578193726, 0.8292569980957376, 0.8028120005772723, 0.7685579733756185, 0.8268737418126255, 0.8153878066573819, 0.10756015844740197, 0.11573046918509522, 0.11366741404256586, 0.09849760238201599, 0.09656503185101772, 0.1021943199999078, 0.10558735431814859, 0.13494897241080106, 0.10413496005383183, 0.1305695388223599, 0.17376643801469271, 0.1427486062439962, 0.1872254174901643, 0.15075496219774853, 0.13361263668086398, 0.1270555393099958, 0.14067448034406393, 0.15611289511107584, 0.48195063835501095, 0.6499400888249, 0.5837031449290435, 0.4536741390162863, 0.6105263178787758, 0.590273527958159, 0.6394118445004082, 0.6932161701694486, 0.6837433969853403, 0.34640849925261896, 0.4066503071111862, 0.39616622221688214, 0.36477788958554846, 0.4035621988304099, 0.4502160275204339, 0.38099985281134796, 0.5030249190598189, 0.5006809862676656, 0.18933252685837598, 0.20575207675815876, 0.20648339971257668, 0.19912909511149968, 0.19094858699462536, 0.21277815830451385, 0.194724609836173, 0.21727531043516102, 0.22080294370924747, 0.2048366310856532, 0.2266311412748241, 0.2396706949609836, 0.5443286264165595, 0.23990720611231342, 0.6878694648870587, 0.47376254574613963, 0.6015012189728555, 0.5575905253932399, 0.21008663898030522, 0.8948711181229068, 0.16421420739779602, 0.1932730351072982, 0.8634311510338779, 0.7399848519178263, 0.7259285084990492, 0.7900524784991259, 0.7788887991063829, 0.12794312891876836, 0.787541415676515, 0.20461219973794909, 0.7987426043209876, 0.2062316358985985, 0.8547020547236814, 0.20781559617683065, 0.12758205253002164, 0.21295639659658117, 0.17994916373262626, 0.1739647147320711, 0.17478316520297665, 0.1935635176306234, 0.18043924660212574, 0.1710647533493569, 0.2010045888375095, 0.17769273755855064, 0.18493985913260536, 0.08428646555185038, 0.07896872028193103, 0.08388642879953445, 0.08403399780221021, 0.09278140887410757, 0.07734889999833028, 0.0781908057245877, 0.08191886615015842, 0.08693109333485594]}, "mutation_prompt": null}
{"id": "14be928d-e37f-4dab-95e6-be144a2d195a", "solution": "import numpy as np\n\nclass EvolutionaryDifferentialDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n        \n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "EvolutionaryDifferentialDE", "description": "Evolutionary Differential Evolution with Adaptive Parameters and Memory for Diverse Exploration and Exploitation.", "configspace": "", "generation": 97, "fitness": 0.4796298015805079, "feedback": "The algorithm EvolutionaryDifferentialDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9029977187421779, 0.9218947043060086, 0.9236819634438819, 0.912242268342974, 0.926677921871539, 0.9239981191296627, 0.8951566082007345, 0.9251239175539839, 0.920498196066114, 0.8309522927563405, 0.8474708994227584, 0.8459531816316809, 0.8223549365230396, 0.8533495012643681, 0.8564756245044288, 0.8372862279215245, 0.8534398751312224, 0.860672263566791, 0.43173374576097867, 0.17885202214501283, 0.5334722034808574, 0.27284274136753073, 0.5728680942654911, 0.36137039231579093, 0.4237729215205762, 0.1745379369885317, 0.16857377613499647, 0.14423857083588776, 0.1563236526006656, 0.12574745695714795, 0.15089657851945992, 0.137100562546135, 0.15267777661071869, 0.12528025172233115, 0.15564208884699782, 0.39116528340563517, 0.9711447609524496, 0.9575076142932604, 0.9631849386392978, 0.9718623983387354, 0.9706360984366035, 0.97798360836061, 0.9842967491269792, 0.9662009620454162, 0.9816012778047303, 0.7317912000932781, 0.7707905421807002, 0.7510823219697489, 0.7719055312324417, 0.7805980658232518, 0.7837582803220615, 0.7465254501181153, 0.6941030914098258, 0.7252077965398571, 0.8153353931013095, 0.861089721397456, 0.8616511100692857, 0.8742349865667868, 0.8849339277364111, 0.8463375161635499, 0.8553110828722887, 0.8817798092415647, 0.44238410558812546, 0.5522227193633235, 0.643285234379378, 0.12974824420821585, 0.6917115810224845, 0.728195907797045, 0.7413892167599718, 0.6098888909519061, 0.21463600999241006, 0.6661128242658465, 0.43869280969282687, 0.5403487856142393, 0.6632834112912127, 0.6279468614064749, 0.7188048401796876, 0.20479542097933534, 0.6269431615949286, 0.2278643992073246, 0.31007350804851463, 0.42443037892284907, 0.4828251448542423, 0.4430303346502107, 0.5149408081727777, 0.5118487503680662, 0.2297065340295149, 0.46307669312145094, 0.15881797772593798, 0.15175386607739505, 0.6758656292586641, 0.4554473394175895, 0.6225697501909007, 0.6127758732273214, 0.7224023206317487, 0.19515786339160424, 0.6994301815071252, 0.7571070509629176, 0.5130983550343235, 0.3209716962925149, 0.1777340674587733, 0.11508032634643717, 0.3901676111096205, 0.40797083533612954, 0.25795540065336486, 0.3429758895448404, 0.13064917533351328, 0.10750325039934994, 0.4792163561721319, 0.30633032870789456, 0.40219570259978277, 0.44661963106328106, 0.5001596626574634, 0.47434827176967964, 0.3947581017912558, 0.3834680781413149, 0.446948755098757, 0.8080521664937581, 0.8543432509625615, 0.8128663391678109, 0.7636382663360721, 0.6532737920680949, 0.7832054229170776, 0.8211442728994577, 0.8306444025712822, 0.7250080490302622, 0.11797405442678721, 0.11473640723871559, 0.12162859341781096, 0.100378438396863, 0.10308403119087484, 0.09226672618704812, 0.10569642483615171, 0.11335743000938037, 0.10267249431224135, 0.13611443032035753, 0.17940669961247602, 0.15232013741929729, 0.1256251540185611, 0.14380557229811797, 0.13297099674438395, 0.11150372923829088, 0.1460416627700475, 0.13844603275298217, 0.5509960136640798, 0.6921596354523187, 0.6764503172973877, 0.5916661499222791, 0.5908559728221685, 0.6873210664871028, 0.6271958490732598, 0.718186318092072, 0.6720075593321144, 0.38760343761149274, 0.4797620777983217, 0.4377846876677526, 0.40218875972326473, 0.44460639091609566, 0.4592133452358136, 0.4699164121234385, 0.5377227022829008, 0.4758437202416158, 0.25037543835798914, 0.21114136142152418, 0.18509012054915197, 0.20060201253210241, 0.20572992370422105, 0.20546938556850447, 0.19661339460624894, 0.21394875370641786, 0.20613002843994976, 0.5371438730622589, 0.6743978693850459, 0.7862124902435026, 0.4592726393628792, 0.5055262382555106, 0.5404060975286678, 0.7085505679279065, 0.685914416300391, 0.519018012067898, 0.16539774416612507, 0.16452386703788213, 0.19937862027175945, 0.8741518632096474, 0.16230942330624076, 0.8716445101101442, 0.16755841900835367, 0.14214911424173915, 0.8599544834255107, 0.8421634433168638, 0.16789245388226104, 0.16662997417166825, 0.1955328877695165, 0.2017541175406674, 0.8172638152550205, 0.8708371451903552, 0.21397749472791172, 0.15496484568161517, 0.20927405165944424, 0.18326210788045671, 0.18975229789981762, 0.18234927136909196, 0.18474247557407286, 0.197914866201925, 0.19203198097659258, 0.2218995477906116, 0.1794402006452681, 0.08130414143485032, 0.07839357513023093, 0.07886863985835879, 0.08452100605657908, 0.08834625388710704, 0.08042077699534877, 0.08198169073810879, 0.07416244921432247, 0.0942171337598382]}, "mutation_prompt": null}
{"id": "4965c5fb-1daf-4bd1-b860-31ef56db1d36", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
{"id": "246f44f7-df97-4781-b687-d7a174ba6184", "solution": "import numpy as np\n\nclass AdaptiveMutationDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 12 + int(self.dim * np.log(self.dim)))\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.population_size)\n        self.crossover_rate = np.random.uniform(0.7, 0.9, self.population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory = self.population.copy()\n        self.global_best = self.population[0].copy()\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n\n        while self.eval_count < self.budget:\n            current_population_size = min(self.population_size, self.budget - self.eval_count)\n            \n            for i in range(current_population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[indices]\n                \n                if np.random.rand() < 0.05:\n                    diversity_boost = np.random.uniform(-1, 1, self.dim)\n                    gradient = 0.3 * (self.memory[np.random.choice(self.population_size)] - x0) + diversity_boost\n                else:\n                    gradient = 0.02 * (self.global_best - x0)\n                \n                feedback = 0.15 * (self.global_best - x0) + 0.1 * (x0 - x1)\n                mutant_vector = x0 + self.mutation_factor[i] * (x1 - x2) + gradient + feedback\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate[i], mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.global_best_fitness:\n                        self.global_best_fitness = trial_fitness\n                        self.global_best = trial_vector.copy()\n                        self.memory[i] = trial_vector.copy()\n\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best = self.population[i].copy()", "name": "AdaptiveMutationDiversityDE", "description": "Adaptive Mutation and Diversity Injection DE for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f48b3939-8dfe-4220-87aa-a414477c4bf1", "metadata": {"aucs": [0.9037908546628757, 0.9253494617090506, 0.9159343052827991, 0.9001917984654065, 0.9195674777830352, 0.9173072485675701, 0.9005629076478402, 0.9219663660558749, 0.926581793903383, 0.8372876790664918, 0.8530297621590346, 0.8509871258936555, 0.81860875039732, 0.8702343252671382, 0.8502315130173017, 0.8358532779110672, 0.855425848517753, 0.844489373623418, 0.3711471230200635, 0.15656816019175346, 0.17124434242747644, 0.2908628527324165, 0.16461154734237093, 0.4722525925193173, 0.25210835222567884, 0.17529769825666264, 0.36187314807878546, 0.1263112164670085, 0.1637113225674406, 0.13136567652511044, 0.16452109913002766, 0.12962031901248505, 0.13095476025409536, 0.14900148894920895, 0.10851665328128202, 0.15295609009378153, 0.9734795438334294, 0.9742191603537328, 0.9582320761138953, 0.9769785252157183, 0.9599085988629469, 0.9580150365270427, 0.9547370758676548, 0.9841677674957806, 0.991103118360972, 0.7169922532361144, 0.7906170293410306, 0.7313749114230487, 0.6806096177877422, 0.7942570895667582, 0.7541277179988579, 0.7278199676418583, 0.7951936164980234, 0.7545531575177917, 0.8326615872850723, 0.9070457641298865, 0.8205547756127138, 0.842203874009333, 0.8981039915627607, 0.8697542259891231, 0.8389325059242457, 0.8672767005162186, 0.8817965551771859, 0.6476307519288025, 0.5585066267254561, 0.39281091380960953, 0.623995244658712, 0.5089655327310498, 0.4866562264704096, 0.6993039253867512, 0.6073547124590087, 0.78337084852909, 0.45021820377114774, 0.48579155211488045, 0.5299343692432712, 0.5840840121276238, 0.22274392973575308, 0.20904454889898139, 0.5263003979822755, 0.2220980743450819, 0.5654696912676345, 0.5065344199108279, 0.6048716281797197, 0.2904695165858733, 0.5714252245235925, 0.631502009569499, 0.4810790408979104, 0.5963675793017469, 0.5218128934620895, 0.4165834773623547, 0.6524933021776974, 0.6663519578147055, 0.4192517727105497, 0.626630368568984, 0.7429256996737312, 0.6281016593635701, 0.6225869921171825, 0.7359488649555872, 0.6391558252823968, 0.2613814844417708, 0.1272466757749927, 0.17648473197107706, 0.3196655844948819, 0.3397159135732635, 0.21585723356148845, 0.2563827661051913, 0.10434147132888139, 0.29867879482234516, 0.4297232468087584, 0.42906410012649343, 0.3999685550561787, 0.5186970664191062, 0.5283072059026088, 0.46049785115760655, 0.42623040582614635, 0.34620759668065704, 0.5025286268330518, 0.8131738492261716, 0.8345293012318804, 0.8250202499035894, 0.8237078334936451, 0.7301974279203898, 0.8226877944534524, 0.6653395463452374, 0.8438295923454393, 0.8284902593630519, 0.12528617715486, 0.15196216686253938, 0.13229097005335422, 0.10475177772044841, 0.10788183704599119, 0.10743160800735951, 0.09082596112449648, 0.11543868014249548, 0.1168473923605865, 0.14656260972524593, 0.1442938228206796, 0.13817579456941453, 0.15617908681119874, 0.16868171550773225, 0.13521675576211456, 0.15811796523149568, 0.14682719400244026, 0.1394741991274253, 0.5931674227918535, 0.7148512531775828, 0.6563250106076495, 0.5808591548529041, 0.6864701243986583, 0.5854951112186639, 0.6555737920056113, 0.6128204451114814, 0.6713034248017911, 0.42879951083882983, 0.4863227034073093, 0.39453659460658463, 0.4116805432471953, 0.5557282833848278, 0.32863384839838883, 0.42511398877648165, 0.6343921137492509, 0.4937521071230141, 0.21830795149682036, 0.20421306529306926, 0.2229418495663158, 0.18257774422205653, 0.21559023735766714, 0.22424446405247633, 0.22966935773481223, 0.21582756964353988, 0.2197781798884414, 0.31819501686480023, 0.2390501271358555, 0.6874404541585138, 0.4908185311736215, 0.685884906860147, 0.21925865896909513, 0.2000278435841777, 0.24646006116960884, 0.21879769086076117, 0.87556233759745, 0.8452766709483248, 0.8442806876384868, 0.16778492570692638, 0.1688319429206302, 0.8971147828564792, 0.16662623028116574, 0.17060182422397396, 0.8353779507403899, 0.9131940308332456, 0.167516650206884, 0.8559302197849643, 0.2074628425219145, 0.2090020747173914, 0.16367995535109459, 0.21208259415928332, 0.8678942821170186, 0.21197825210443455, 0.18936725137859212, 0.18115243032641737, 0.19055992935699428, 0.1860163828285808, 0.17810311787854094, 0.1919874782889055, 0.20042380056099796, 0.18399797560331266, 0.17301396351580656, 0.08494172677509282, 0.08640391912762824, 0.07918374671989081, 0.08080270772097409, 0.08665992245907816, 0.09212194660828643, 0.0792904217543875, 0.0887793575422613, 0.0896575052522729]}, "mutation_prompt": null}
